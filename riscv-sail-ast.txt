val internal_pick = monadic {_: "internal_pick"}: forall ('a : Type).
  list('a) -> 'a

val undefined_bool = monadic {_: "undefined_bool"}: unit -> bool

val undefined_bit = monadic {_: "undefined_bit"}: unit -> bit

val undefined_int = monadic {_: "undefined_int"}: unit -> int

val undefined_nat = monadic {_: "undefined_nat"}: unit -> nat

val undefined_real = monadic {_: "undefined_real"}: unit -> real

val undefined_string = monadic {_: "undefined_string"}: unit -> string

val undefined_list = monadic {_: "undefined_list"}: forall ('a : Type).
  'a -> list('a)

val undefined_range = monadic {_: "undefined_range"}: forall ('n : Int) ('m : Int).
  (int('n), int('m)) -> range('n, 'm)

val undefined_vector = monadic {_: "undefined_vector"}: forall ('n : Int) ('a : Type).
  (int('n), 'a) -> vector('n, 'a)

val undefined_bitvector = monadic {_: "undefined_bitvector"}: forall ('n : Int).
  int('n) -> bitvector('n)

val undefined_unit = monadic {_: "undefined_unit"}: unit -> unit

default Order dec

$include_start /home/pauln/.opam/default/share/sail/lib/smt.sail

/*! Euclidean division */
val ediv_int = pure {ocaml: "quotient", interpreter: "quotient", lem: "integerDiv", coq: "ZEuclid.div", lean: "Int.ediv", _: "ediv_int"}: forall ('n : Int) ('m : Int).
  (int('n), int('m)) -> int(div('n, 'm))

val emod_int = pure {ocaml: "modulus", interpreter: "modulus", lem: "integerMod", coq: "ZEuclid.modulo", lean: "Int.emod", _: "emod_int"}: forall ('n : Int) ('m : Int).
  (int('n), int('m)) -> int(mod('n, 'm))

val abs_int_atom = pure {ocaml: "abs_int", interpreter: "abs_int", lem: "integerAbs", coq: "Z.abs", lean: "Int.natAbs", _: "abs_int"}: forall ('n : Int).
  int('n) -> int(abs('n))

overload abs_int = {abs_int_atom}

$include_end /home/pauln/.opam/default/share/sail/lib/smt.sail

$include_start /home/pauln/.opam/default/share/sail/lib/option.sail

$sail_internal 

union option ('a: Type) = {Some : 'a, None : unit}

val is_none : forall ('a : Type). option('a) -> bool

$[complete]
function is_none opt = $[complete] match opt {
  Some(_) => false,
  None(()) => true
}

val is_some : forall ('a : Type). option('a) -> bool

$[complete]
function is_some opt = $[complete] match opt {
  Some(_) => true,
  None(()) => false
}

$include_end /home/pauln/.opam/default/share/sail/lib/option.sail

$include_start /home/pauln/.opam/default/share/sail/lib/arith.sail

$include_start /home/pauln/.opam/default/share/sail/lib/flow.sail

val eq_unit = pure {lean: "_lean_beq", _: "eq_unit"}: (unit, unit) -> bool(true)

$[complete]
function eq_unit (_, _) = true

val eq_bit = pure {lem: "eq", lean: "_lean_beq", _: "eq_bit"}: (bit, bit) -> bool

val not_bool = pure {coq: "negb", lean: "_lean_not", _: "not"}: forall ('p : Bool).
  bool('p) -> bool(not('p))

val and_bool = pure {coq: "andb", lean: "_lean_and", _: "and_bool"}: forall ('p : Bool) ('q : Bool).
  (bool('p), bool('q)) -> bool(('p & 'q))

val and_bool_no_flow = pure {coq: "andb", lean: "_lean_and", _: "and_bool"}: (bool, bool) -> bool

val or_bool = pure {coq: "orb", lean: "_lean_or", _: "or_bool"}: forall ('p : Bool) ('q : Bool).
  (bool('p), bool('q)) -> bool(('p | 'q))

val eq_int = pure {ocaml: "eq_int", interpreter: "eq_int", lem: "eq", coq: "Z.eqb", lean: "_lean_beq", _: "eq_int"}: forall ('n : Int) ('m : Int).
  (int('n), int('m)) -> bool('n == 'm)

val eq_bool = pure {ocaml: "eq_bool", interpreter: "eq_bool", lem: "eq", coq: "Bool.eqb", lean: "_lean_beq", _: "eq_bool"}: (bool, bool) -> bool

val neq_int = pure {lem: "neq", lean: "_lean_bne"}: forall ('n : Int) ('m : Int).
  (int('n), int('m)) -> bool('n != 'm)

$[complete]
function neq_int (x, y) = not_bool(eq_int(x, y))

val neq_bool : (bool, bool) -> bool

$[complete]
function neq_bool (x, y) = not_bool(eq_bool(x, y))

val lteq_int = pure {coq: "Z.leb", lean: "_lean_le", _: "lteq"}: forall ('n : Int) ('m : Int).
  (int('n), int('m)) -> bool('n <= 'm)

val gteq_int = pure {coq: "Z.geb", lean: "_lean_ge", _: "gteq"}: forall ('n : Int) ('m : Int).
  (int('n), int('m)) -> bool('n >= 'm)

val lt_int = pure {coq: "Z.ltb", lean: "_lean_lt", _: "lt"}: forall ('n : Int) ('m : Int).
  (int('n), int('m)) -> bool('n < 'm)

val gt_int = pure {coq: "Z.gtb", lean: "_lean_gt", _: "gt"}: forall ('n : Int) ('m : Int).
  (int('n), int('m)) -> bool('n > 'm)

overload operator == = {eq_int, eq_bit, eq_bool, eq_unit}

overload operator != = {neq_int, neq_bool}

overload operator | = {or_bool}

overload operator & = {and_bool}

overload operator <= = {lteq_int}

overload operator < = {lt_int}

overload operator >= = {gteq_int}

overload operator > = {gt_int}

val __id = pure {systemverilog: "id"}: forall ('n : Int). int('n) -> int('n)

$[complete]
function __id x = x

overload __size = {__id}

val __deref = monadic {_: "reg_deref"}: forall ('a : Type). register('a) -> 'a

$include_end /home/pauln/.opam/default/share/sail/lib/flow.sail

val add_atom = pure {ocaml: "add_int", interpreter: "add_int", lem: "integerAdd", coq: "Z.add", lean: "_lean_addi", _: "add_int"}: forall ('n : Int) ('m : Int).
  (int('n), int('m)) -> int('n + 'm)

val add_int = pure {ocaml: "add_int", interpreter: "add_int", lem: "integerAdd", coq: "Z.add", lean: "_lean_addi", _: "add_int"}: (int, int) -> int

overload operator + = {add_atom, add_int}

val sub_atom = pure {ocaml: "sub_int", interpreter: "sub_int", lem: "integerMinus", coq: "Z.sub", lean: "_lean_subi", _: "sub_int"}: forall ('n : Int) ('m : Int).
  (int('n), int('m)) -> int('n - 'm)

val sub_int = pure {ocaml: "sub_int", interpreter: "sub_int", lem: "integerMinus", coq: "Z.sub", lean: "_lean_subi", _: "sub_int"}: (int, int) -> int

overload operator - = {sub_atom, sub_int}

val sub_nat = pure {ocaml: "(fun (x,y) -> let n = sub_int (x,y) in if Big_int.less_equal n Big_int.zero then Big_int.zero else n)", lem: "integerMinus", coq: "Z.sub", lean: "_lean_subi", _: "sub_nat"}: (nat, nat) -> nat

val negate_atom = pure {ocaml: "negate", interpreter: "negate", lem: "integerNegate", coq: "Z.opp", lean: "Neg.neg", _: "neg_int"}: forall ('n : Int).
  int('n) -> int(- 'n)

val negate_int = pure {ocaml: "negate", interpreter: "negate", lem: "integerNegate", coq: "Z.opp", lean: "Neg.neg", _: "neg_int"}: int -> int

overload negate = {negate_atom, negate_int}

val mult_atom = pure {ocaml: "mult", interpreter: "mult", lem: "integerMult", coq: "Z.mul", lean: "_lean_muli", _: "mult_int"}: forall ('n : Int) ('m : Int).
  (int('n), int('m)) -> int('n * 'm)

val mult_int = pure {ocaml: "mult", interpreter: "mult", lem: "integerMult", coq: "Z.mul", lean: "_lean_muli", _: "mult_int"}: (int, int) -> int

overload operator * = {mult_atom, mult_int}

$[sv_module { "stdout" = true }]
val print_int = pure {_: "print_int"}: (string, int) -> unit

$[sv_module { "stderr" = true }]
val prerr_int = pure {_: "prerr_int"}: (string, int) -> unit

/*!
We have special support for raising values to the power of two. Any Sail expression `2 ^ x` will be compiled to this builtin.
*/
val pow2 = pure {lean: "_lean_pow2i", _: "pow2"}: forall ('n : Int).
  int('n) -> int(2 ^ 'n)

/*!
A common idiom in asl is to take two bits of an opcode and convert in into a variable like
```
let elsize = shl_int(8, UInt(size))
```
THIS ensures that in this case the typechecker knows that the end result will be a value in the set `{8, 16, 32, 64}`

Similarly, we define shifts of 32 and 1 (i.e., powers of two).

The most general shift operations also allow negative shifts which go in the opposite direction, for compatibility with ASL.
*/
val _shl8 = pure {c: "shl_mach_int", lean: "Int.shiftl", _: "shl_int"}: forall ('n : Int), (0 <= 'n & 'n <= 3).
  (int(8), int('n)) -> {8, 16, 32, 64}

val _shl32 = pure {c: "shl_mach_int", lean: "Int.shiftl", _: "shl_int"}: forall ('n : Int), 'n in {0, 1}.
  (int(32), int('n)) -> {32, 64}

val _shl1 = pure {c: "shl_mach_int", lean: "Int.shiftl", _: "shl_int"}: forall ('n : Int), (0 <= 'n & 'n <= 3).
  (int(1), int('n)) -> {1, 2, 4, 8}

val _shl_int = pure {lean: "Int.shiftl", _: "shl_int"}: forall ('n : Int), 0 <= 'n.
  (int, int('n)) -> int

val _shr32 = pure {c: "shr_mach_int", lean: "Int.shiftl", _: "shr_int"}: forall ('n : Int), (0 <= 'n & 'n <= 31).
  (int('n), int(1)) -> {('m : Int), (0 <= 'm & 'm <= 15). int('m)}

val _shr_int = pure {lean: "Int.shiftr", _: "shr_int"}: forall ('n : Int), 0 <= 'n.
  (int, int('n)) -> int

val _shl_int_general : (int, int) -> int

$[complete]
function _shl_int_general (m : int, n : int) = if $[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(n, 0) then
  _shl_int(m, n)
else
  _shr_int(m, $[overloaded { "name" = "negate", "is_infix" = false }] negate_atom(n))

val _shr_int_general : (int, int) -> int

$[complete]
function _shr_int_general (m : int, n : int) = if $[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(n, 0) then
  _shr_int(m, n)
else
  _shl_int(m, $[overloaded { "name" = "negate", "is_infix" = false }] negate_atom(n))

overload shl_int = {_shl1, _shl8, _shl32, _shl_int, _shl_int_general}

overload shr_int = {_shr32, _shr_int, _shr_int_general}

/*! Truncating division (rounds towards zero) */
val tdiv_int = pure {coq: "Z.quot", lean: "Int.tdiv", _: "tdiv_int"}: (int, int) -> int

/*! Remainder for truncating division (has sign of dividend) */
val _tmod_int = pure {coq: "Z.rem", lean: "Int.tmod", _: "tmod_int"}: (int, int) -> int

/*! If we know the second argument is positive, we know the result is positive */
val _tmod_int_positive = pure {ocaml: "tmod_int", interpreter: "tmod_int", lem: "tmod_int", coq: "Z.rem", lean: "Int.tmod", _: "tmod_int"}: forall ('n : Int), 'n >= 1.
  (int, int('n)) -> nat

overload tmod_int = {_tmod_int_positive, _tmod_int}

$c_reserved fdiv_int

val fdiv_int : (int, int) -> int

$[complete]
function fdiv_int (n : int, m : int) = {
    if $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "<", "is_infix" = true }] lt_int(n, 0), $[overloaded { "name" = ">", "is_infix" = true }] gt_int(m, 0)) then {
        $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(tdiv_int($[overloaded { "name" = "+", "is_infix" = true }] add_atom(n, 1), m), 1)
    } else if $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = ">", "is_infix" = true }] gt_int(n, 0), $[overloaded { "name" = "<", "is_infix" = true }] lt_int(m, 0)) then {
        $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(tdiv_int($[overloaded { "name" = "-", "is_infix" = true }] sub_atom(n, 1), m), 1)
    } else {
        tdiv_int(n, m)
    }
}

$c_reserved fmod_int

val fmod_int : (int, int) -> int

$[complete]
function fmod_int (n : int, m : int) = {
    $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(n, $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(m, fdiv_int(n, m)))
}

val abs_int_plain = pure {smt: "abs", ocaml: "abs_int", interpreter: "abs_int", lem: "integerAbs", coq: "Z.abs", lean: "Sail.Int.intAbs", _: "abs_int"}: int -> int

overload abs_int = {abs_int_plain}

val max_int = pure {lem: "integerMax", coq: "Z.max", lean: "Max.max", _: "max_int"}: forall ('x : Int) ('y : Int).
  (int('x), int('y)) -> {('z : Int), ('x >= 'y & 'z == 'x | 'x < 'y & 'z == 'y). int('z)}

val min_int = pure {lem: "integerMin", coq: "Z.min", lean: "Min.min", _: "min_int"}: forall ('x : Int) ('y : Int).
  (int('x), int('y)) -> {('z : Int), ('x < 'y & 'z == 'x | 'x >= 'y & 'z == 'y). int('z)}

$include_end /home/pauln/.opam/default/share/sail/lib/arith.sail

$include_start /home/pauln/.opam/default/share/sail/lib/string.sail

val eq_string = pure {lem: "eq", coq: "generic_eq", lean: "_lean_beq", _: "eq_string"}: (string, string) -> bool

overload operator == = {eq_string}

val concat_str = pure {coq: "String.append", lem: "stringAppend", lean: "HAppend.hAppend", _: "concat_str"}: (string, string) -> string

val dec_str = pure {lean: "Int.repr", _: "dec_str"}: int -> string

val hex_str = pure {lean: "Int.toHex", _: "hex_str"}: int -> string

val hex_str_upper = pure {lean: "Int.toHexUpper", _: "hex_str_upper"}: int -> string

val bits_str = pure {lean: "BitVec.toFormatted", _: "string_of_bits"}: forall ('n : Int).
  bitvector('n) -> string

val concat_str_bits : forall ('n : Int). (string, bitvector('n)) -> string

$[complete]
function concat_str_bits (str, x) = concat_str(str, bits_str(x))

val concat_str_dec : (string, int) -> string

$[complete]
function concat_str_dec (str, x) = concat_str(str, dec_str(x))

$[sv_module { "stdout" = true }]
val print_endline = pure {_: "print_endline"}: string -> unit

$[sv_module { "stderr" = true }]
val prerr_endline = pure {_: "prerr_endline"}: string -> unit

$[sv_module { "stdout" = true }]
val print = pure {_: "print"}: string -> unit

$[sv_module { "stderr" = true }]
val prerr = pure {_: "prerr"}: string -> unit

$include_end /home/pauln/.opam/default/share/sail/lib/string.sail

$include_start /home/pauln/.opam/default/share/sail/lib/mapping.sail

$[sv_function { "types" = "int #1" }]
val string_take = pure {lean: "String.take", _: "string_take"}: (string, nat) -> string

$[sv_function { "types" = "int #1" }]
val string_drop = pure {lean: "String.drop", _: "string_drop"}: (string, nat) -> string

$[sv_function { "return_type" = "int" }]
val string_length = pure {lean: "String.length", _: "string_length"}: string -> nat

val string_append = pure {coq: "String.append", lean: "String.append", c: "concat_str", _: "string_append"}: (string, string) -> string

val string_startswith = pure {lean: "String.startsWith", _: "string_startswith"}: (string, string) -> bool

val n_leading_spaces = pure {coq: "n_leading_spaces_Z", lean: "String.leadingSpaces"}: string -> nat

$[complete]
function n_leading_spaces s = $[complete] match s {
  "" => 0,
  _ => $[complete] match string_take(s, 1) {
    " " => $[overloaded { "name" = "+", "is_infix" = true }] add_atom(1, n_leading_spaces(string_drop(s, 1))),
    _ => 0
  }
}

/*!
In a string mapping this is treated as `[ ]+`, i.e one or more space
characters. It is printed as a single space `" "`.
*/
val spc : unit <-> string

$[complete]
function spc_forwards () = " "

$[complete]
function spc_forwards_matches () = true

$[complete]
function spc_backwards _ = ()

$[complete]
function spc_backwards_matches s = {
    let len = string_length(s);
    $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_int(n_leading_spaces(s), len), $[overloaded { "name" = ">", "is_infix" = true }] gt_int(len, 0))
}

/*!
In a string mapping this is treated as `[ ]*`, i.e. zero or more space
characters. It is printed as the empty string.
*/
val opt_spc : unit <-> string

$[complete]
function opt_spc_forwards () = ""

$[complete]
function opt_spc_forwards_matches () = true

$[complete]
function opt_spc_backwards _ = ()

$[complete]
function opt_spc_backwards_matches s = $[overloaded { "name" = "==", "is_infix" = true }] eq_int(n_leading_spaces(s), string_length(s))

/*!
Like `opt_spc`, in a string mapping this is treated as `[ ]*`, i.e. zero or more space
characters. It differs however in that it is printed as a single space `" "`.
*/
val def_spc : unit <-> string

$[complete]
function def_spc_forwards () = " "

$[complete]
function def_spc_forwards_matches () = true

$[complete]
function def_spc_backwards _ = ()

$[complete]
function def_spc_backwards_matches s = $[overloaded { "name" = "==", "is_infix" = true }] eq_int(n_leading_spaces(s), string_length(s))

val sep : unit <-> string

mapping sep = {() <-> opt_spc(()) ^ "," ^ def_spc(())}

$include_end /home/pauln/.opam/default/share/sail/lib/mapping.sail

$include_start /home/pauln/.opam/default/share/sail/lib/vector_dec.sail

$include_start /home/pauln/.opam/default/share/sail/lib/vector.sail

type bits('n: Int) = bitvector('n)

val eq_bits = pure {ocaml: "eq_list", interpreter: "eq_list", lem: "eq_vec", coq: "eq_vec", lean: "_lean_beq", _: "eq_bits"}: forall ('n : Int).
  (bitvector('n), bitvector('n)) -> bool

overload operator == = {eq_bit, eq_bits}

val neq_bits = pure {lem: "neq_vec", coq: "neq_vec", c: "neq_bits", lean: "_lean_bne"}: forall ('n : Int).
  (bitvector('n), bitvector('n)) -> bool

$[complete]
function neq_bits (x, y) = not_bool(eq_bits(x, y))

overload operator != = {neq_bits}

val bitvector_length = pure {coq: "length_mword", lean: "Sail.BitVec.length", _: "length"}: forall ('n : Int).
  bitvector('n) -> int('n)

val vector_length = pure {ocaml: "length", interpreter: "length", lem: "length_list", coq: "vec_length", lean: "Vector.length", _: "length"}: forall ('n : Int) ('a : Type).
  vector('n, 'a) -> int('n)

val vector_init = pure {lean: "vectorInit", _: "vector_init"}: forall ('n : Int) ('a : Type), 'n >= 0.
  (implicit('n), 'a) -> vector('n, 'a)

overload length = {bitvector_length, vector_length}

val count_leading_zeros = pure {lean: "BitVec.countLeadingZeros", _: "count_leading_zeros"}: forall ('N : Int), 'N >= 1.
  bitvector('N) -> {('n : Int), (0 <= 'n & 'n <= 'N). int('n)}

val count_trailing_zeros = pure {lean: "BitVec.countTrailingZeros", _: "count_trailing_zeros"}: forall ('N : Int), 'N >= 1.
  bitvector('N) -> {('n : Int), (0 <= 'n & 'n <= 'N). int('n)}

$[sv_module { "stdout" = true }]
val print_bits = pure {_: "print_bits"}: forall ('n : Int).
  (string, bitvector('n)) -> unit

$[sv_module { "stderr" = true }]
val prerr_bits = pure {_: "prerr_bits"}: forall ('n : Int).
  (string, bitvector('n)) -> unit

val sail_sign_extend = pure {lean: "Sail.BitVec.signExtend", _: "sign_extend"}: forall ('n : Int) ('m : Int), 'm >= 'n.
  (bitvector('n), int('m)) -> bitvector('m)

val sail_zero_extend = pure {lean: "Sail.BitVec.zeroExtend", _: "zero_extend"}: forall ('n : Int) ('m : Int), 'm >= 'n.
  (bitvector('n), int('m)) -> bitvector('m)

/*!
THIS`(v, n)` truncates `v`, keeping only the _least_ significant `n` bits.
 */
val truncate = pure {ocaml: "vector_truncate", interpreter: "vector_truncate", lem: "vector_truncate", coq: "vector_truncate", lean: "Sail.BitVec.truncate", _: "sail_truncate"}: forall ('m : Int) ('n : Int), ('m >= 0 & 'm <= 'n).
  (bitvector('n), int('m)) -> bitvector('m)

/*!
THIS`(v, n)` truncates `v`, keeping only the _most_ significant `n` bits.
 */
val truncateLSB = pure {ocaml: "vector_truncateLSB", interpreter: "vector_truncateLSB", lem: "vector_truncateLSB", coq: "vector_truncateLSB", lean: "Sail.BitVec.truncateLsb", _: "sail_truncateLSB"}: forall ('m : Int) ('n : Int), ('m >= 0 & 'm <= 'n).
  (bitvector('n), int('m)) -> bitvector('m)

val sail_mask : forall ('len : Int) ('v : Int), ('len >= 0 & 'v >= 0).
  (int('len), bitvector('v)) -> bitvector('len)

$[complete]
function sail_mask (len, v) = if $[overloaded { "name" = "<=", "is_infix" = true }] lteq_int(len, $[overloaded { "name" = "length", "is_infix" = false }] bitvector_length(v)) then
  truncate(v, len)
else
  sail_zero_extend(v, len)

overload operator ^ = {sail_mask}

val bitvector_concat = pure {ocaml: "append", interpreter: "append", lem: "concat_vec", coq: "concat_vec", lean: "_lean_app", _: "append"}: forall ('n : Int) ('m : Int).
  (bitvector('n), bitvector('m)) -> bitvector('n + 'm)

overload append = {bitvector_concat}

val append_64 = pure {_: "append_64"}: forall ('n : Int).
  (bitvector('n), bitvector(64)) -> bitvector('n + 64)

val bitvector_access = pure {ocaml: "access", interpreter: "access", lem: "access_vec_dec", coq: "access_vec_dec", lean: "BitVec.access", _: "vector_access"}: forall ('n : Int) ('m : Int), (0 <= 'm & 'm < 'n).
  (bitvector('n), int('m)) -> bit

val plain_vector_access = pure {ocaml: "access", interpreter: "access", lem: "access_list_dec", coq: "vec_access_dec", lean: "GetElem?.getElem!", _: "vector_access"}: forall ('n : Int) ('m : Int) ('a : Type), (0 <= 'm & 'm < 'n).
  (vector('n, 'a), int('m)) -> 'a

overload vector_access = {bitvector_access, plain_vector_access}

val bitvector_update = pure {ocaml: "update", interpreter: "update", lem: "update_vec_dec", coq: "update_vec_dec", lean: "BitVec.update", _: "vector_update"}: forall ('n : Int) ('m : Int), (0 <= 'm & 'm < 'n).
  (bitvector('n), int('m), bit) -> bitvector('n)

val plain_vector_update = pure {ocaml: "update", interpreter: "update", lem: "update_list_dec", coq: "vec_update_dec", lean: "vectorUpdate", _: "vector_update"}: forall ('n : Int) ('m : Int) ('a : Type), (0 <= 'm & 'm < 'n).
  (vector('n, 'a), int('m), 'a) -> vector('n, 'a)

overload vector_update = {bitvector_update, plain_vector_update}

val add_bits = pure {ocaml: "add_vec", interpreter: "add_vec", lem: "add_vec", coq: "add_vec", lean: "_lean_add", _: "add_bits"}: forall ('n : Int).
  (bitvector('n), bitvector('n)) -> bitvector('n)

val add_bits_int = pure {ocaml: "add_vec_int", interpreter: "add_vec_int", lem: "add_vec_int", coq: "add_vec_int", lean: "BitVec.addInt", _: "add_bits_int"}: forall ('n : Int).
  (bitvector('n), int) -> bitvector('n)

overload operator + = {add_bits, add_bits_int}

val sub_bits = pure {ocaml: "sub_vec", interpreter: "sub_vec", lem: "sub_vec", coq: "sub_vec", lean: "_lean_sub", _: "sub_bits"}: forall ('n : Int).
  (bitvector('n), bitvector('n)) -> bitvector('n)

val not_vec = pure {ocaml: "not_vec", lem: "not_vec", coq: "not_vec", interpreter: "not_vec", lean: "Complement.complement", _: "not_bits"}: forall ('n : Int).
  bitvector('n) -> bitvector('n)

val and_vec = pure {lem: "and_vec", coq: "and_vec", ocaml: "and_vec", interpreter: "and_vec", lean: "_lean_bvand", _: "and_bits"}: forall ('n : Int).
  (bitvector('n), bitvector('n)) -> bitvector('n)

overload operator & = {and_vec}

val or_vec = pure {lem: "or_vec", coq: "or_vec", ocaml: "or_vec", interpreter: "or_vec", lean: "_lean_bvor", _: "or_bits"}: forall ('n : Int).
  (bitvector('n), bitvector('n)) -> bitvector('n)

overload operator | = {or_vec}

val xor_vec = pure {lem: "xor_vec", coq: "xor_vec", ocaml: "xor_vec", interpreter: "xor_vec", lean: "_lean_bvxor", _: "xor_bits"}: forall ('n : Int).
  (bitvector('n), bitvector('n)) -> bitvector('n)

val subrange_bits = pure {ocaml: "subrange", interpreter: "subrange", lem: "subrange_vec_dec", coq: "subrange_vec_dec", lean: "Sail.BitVec.extractLsb", _: "vector_subrange"}: forall ('n : Int) ('m : Int) ('o : Int), (0 <= 'o & 'o <= 'm & 'm < 'n).
  (bitvector('n), int('m), int('o)) -> bitvector('m - 'o + 1)

overload vector_subrange = {subrange_bits}

val update_subrange_bits = pure {ocaml: "update_subrange", interpreter: "update_subrange", lem: "update_subrange_vec_dec", coq: "update_subrange_vec_dec", lean: "Sail.BitVec.updateSubrange", _: "vector_update_subrange"}: forall ('n : Int) ('m : Int) ('o : Int), (0 <= 'o & 'o <= 'm & 'm < 'n).
  (bitvector('n), int('m), int('o), bitvector('m - ('o - 1))) -> bitvector('n)

overload vector_update_subrange = {update_subrange_bits}

val sail_shiftleft = pure {lean: "_lean_shiftl", _: "shiftl"}: forall ('n : Int).
  (bitvector('n), int) -> bitvector('n)

val sail_shiftright = pure {lean: "_lean_shiftr", _: "shiftr"}: forall ('n : Int).
  (bitvector('n), int) -> bitvector('n)

val sail_arith_shiftright = pure {lean: "BitVec.rotateRight", _: "arith_shiftr"}: forall ('n : Int).
  (bitvector('n), int) -> bitvector('n)

val sail_zeros = pure {lean: "BitVec.zero", _: "zeros"}: forall ('n : Int), 'n >= 0.
  int('n) -> bitvector('n)

val sail_ones : forall ('n : Int), 'n >= 0. int('n) -> bitvector('n)

$[complete]
function sail_ones n = not_vec(sail_zeros(n))

val slice = pure {lean: "BitVec.slice", _: "slice"}: forall ('n : Int) ('m : Int) ('o : Int), (0 <= 'm & 0 <= 'n).
  (bitvector('m), int('o), int('n)) -> bitvector('n)

val replicate_bits = pure {lean: "BitVec.replicateBits", _: "replicate_bits"}: forall ('n : Int) ('m : Int), 'm >= 0.
  (bitvector('n), int('m)) -> bitvector('n * 'm)

val slice_mask : forall ('n : Int), 'n >= 0.
  (implicit('n), int, int) -> bitvector('n)

$[complete]
function slice_mask (n, i, l) = if $[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(l, n) then {
    sail_shiftleft(sail_ones(n), i)
} else {
    let one : bits('n) = sail_mask(n, [bitone] : bits(1));
    sail_shiftleft(sub_bits(sail_shiftleft(one, l), one), i)
}

val get_slice_int = pure {_: "get_slice_int"}: forall ('w : Int).
  (int('w), int, int) -> bitvector('w)

val set_slice_int = pure {_: "set_slice_int"}: forall ('w : Int).
  (int('w), int, int, bitvector('w)) -> int

val set_slice_bits = pure {_: "set_slice"}: forall ('n : Int) ('m : Int).
  (implicit('n), int('m), bitvector('n), int, bitvector('m)) -> bitvector('n)

/*!
converts a bit vector of length $n$ to an integer in the range $0$ to $2^n - 1$.
 */
val unsigned = pure {ocaml: "uint", lem: "uint", interpreter: "uint", coq: "uint", lean: "BitVec.toNat", _: "sail_unsigned"}: forall ('n : Int).
  bitvector('n) -> range(0, 2 ^ 'n - 1)

/*!
converts a bit vector of length $n$ to an integer in the range $-2^{n-1}$ to $2^{n-1} - 1$ using twos-complement.
 */
val signed = pure {ocaml: "sint", lem: "sint", interpreter: "sint", coq: "sint", lean: "BitVec.toInt", _: "sail_signed"}: forall ('n : Int), 'n > 0.
  bitvector('n) -> range(- (2 ^ ('n - 1)), 2 ^ ('n - 1) - 1)

overload __size = {__id, bitvector_length, vector_length}

val to_bytes_le : forall ('n : Int), 'n > 0.
  (implicit('n), bitvector(8 * 'n)) -> vector('n, bitvector(8))

$[complete]
function to_bytes_le (n, b) = {
    var res = vector_init(n, sail_zeros(8));
    foreach (i from 0 to sub_atom(n, 1) by 1 in inc) {
        res[i] = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(b, $[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(8, i), 7), $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(8, i))
    };
    res
}

val from_bytes_le : forall ('n : Int), 'n > 0.
  (implicit('n), vector('n, bitvector(8))) -> bitvector(8 * 'n)

$[complete]
function from_bytes_le (n, v) = {
    var res = sail_zeros($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(8, n));
    foreach (i from 0 to sub_atom(n, 1) by 1 in inc) {
        res[$[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(8, i), 7) .. $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(8, i)] = $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(v, i)
    };
    res
}

$include_end /home/pauln/.opam/default/share/sail/lib/vector.sail

$include_end /home/pauln/.opam/default/share/sail/lib/vector_dec.sail

$include_start /home/pauln/.opam/default/share/sail/lib/generic_equality.sail

val eq_anything = pure {ocaml: "(fun (x, y) -> x = y)", lem: "eq", coq: "generic_eq", lean: "_lean_beq", _: "eq_anything"}: forall ('a : Type).
  ('a, 'a) -> bool

overload operator == = {eq_anything}

val neq_anything = pure {lem: "neq", lean: "bne", coq: "generic_neq"}: forall ('a : Type).
  ('a, 'a) -> bool

$[complete]
function neq_anything (x, y) = not_bool(eq_anything(y, x))

overload operator != = {neq_anything}

$include_end /home/pauln/.opam/default/share/sail/lib/generic_equality.sail

$include_start /home/pauln/.opam/default/share/sail/lib/hex_bits.sail

$[sv_function { "types" = "int #0" }]
val parse_hex_bits = pure {_: "parse_hex_bits"}: forall ('n : Int), 'n > 0.
  (int('n), string) -> bitvector('n)

$[sv_function { "types" = "int #0" }]
val valid_hex_bits = pure {_: "valid_hex_bits"}: forall ('n : Int), 'n > 0.
  (int('n), string) -> bool

val hex_bits : forall ('n : Int), 'n > 0. bitvector('n) <-> (int('n), string)

$[complete]
function hex_bits_forwards bv = ($[overloaded { "name" = "length", "is_infix" = false }] bitvector_length(bv), hex_str(unsigned(bv)))

$[complete]
function hex_bits_forwards_matches bv = true

$[complete]
function hex_bits_backwards (n, str) = parse_hex_bits(n, str)

$[complete]
function hex_bits_backwards_matches (n, str) = valid_hex_bits(n, str)

val hex_bits_1 : bitvector(1) <-> string

mapping hex_bits_1 = {hex_bits((1, s)) <-> s}

val hex_bits_2 : bitvector(2) <-> string

mapping hex_bits_2 = {hex_bits((2, s)) <-> s}

val hex_bits_3 : bitvector(3) <-> string

mapping hex_bits_3 = {hex_bits((3, s)) <-> s}

val hex_bits_4 : bitvector(4) <-> string

mapping hex_bits_4 = {hex_bits((4, s)) <-> s}

val hex_bits_5 : bitvector(5) <-> string

mapping hex_bits_5 = {hex_bits((5, s)) <-> s}

val hex_bits_6 : bitvector(6) <-> string

mapping hex_bits_6 = {hex_bits((6, s)) <-> s}

val hex_bits_7 : bitvector(7) <-> string

mapping hex_bits_7 = {hex_bits((7, s)) <-> s}

val hex_bits_8 : bitvector(8) <-> string

mapping hex_bits_8 = {hex_bits((8, s)) <-> s}

val hex_bits_9 : bitvector(9) <-> string

mapping hex_bits_9 = {hex_bits((9, s)) <-> s}

val hex_bits_10 : bitvector(10) <-> string

mapping hex_bits_10 = {hex_bits((10, s)) <-> s}

val hex_bits_11 : bitvector(11) <-> string

mapping hex_bits_11 = {hex_bits((11, s)) <-> s}

val hex_bits_12 : bitvector(12) <-> string

mapping hex_bits_12 = {hex_bits((12, s)) <-> s}

val hex_bits_13 : bitvector(13) <-> string

mapping hex_bits_13 = {hex_bits((13, s)) <-> s}

val hex_bits_14 : bitvector(14) <-> string

mapping hex_bits_14 = {hex_bits((14, s)) <-> s}

val hex_bits_15 : bitvector(15) <-> string

mapping hex_bits_15 = {hex_bits((15, s)) <-> s}

val hex_bits_16 : bitvector(16) <-> string

mapping hex_bits_16 = {hex_bits((16, s)) <-> s}

val hex_bits_17 : bitvector(17) <-> string

mapping hex_bits_17 = {hex_bits((17, s)) <-> s}

val hex_bits_18 : bitvector(18) <-> string

mapping hex_bits_18 = {hex_bits((18, s)) <-> s}

val hex_bits_19 : bitvector(19) <-> string

mapping hex_bits_19 = {hex_bits((19, s)) <-> s}

val hex_bits_20 : bitvector(20) <-> string

mapping hex_bits_20 = {hex_bits((20, s)) <-> s}

val hex_bits_21 : bitvector(21) <-> string

mapping hex_bits_21 = {hex_bits((21, s)) <-> s}

val hex_bits_22 : bitvector(22) <-> string

mapping hex_bits_22 = {hex_bits((22, s)) <-> s}

val hex_bits_23 : bitvector(23) <-> string

mapping hex_bits_23 = {hex_bits((23, s)) <-> s}

val hex_bits_24 : bitvector(24) <-> string

mapping hex_bits_24 = {hex_bits((24, s)) <-> s}

val hex_bits_25 : bitvector(25) <-> string

mapping hex_bits_25 = {hex_bits((25, s)) <-> s}

val hex_bits_26 : bitvector(26) <-> string

mapping hex_bits_26 = {hex_bits((26, s)) <-> s}

val hex_bits_27 : bitvector(27) <-> string

mapping hex_bits_27 = {hex_bits((27, s)) <-> s}

val hex_bits_28 : bitvector(28) <-> string

mapping hex_bits_28 = {hex_bits((28, s)) <-> s}

val hex_bits_29 : bitvector(29) <-> string

mapping hex_bits_29 = {hex_bits((29, s)) <-> s}

val hex_bits_30 : bitvector(30) <-> string

mapping hex_bits_30 = {hex_bits((30, s)) <-> s}

val hex_bits_31 : bitvector(31) <-> string

mapping hex_bits_31 = {hex_bits((31, s)) <-> s}

val hex_bits_32 : bitvector(32) <-> string

mapping hex_bits_32 = {hex_bits((32, s)) <-> s}

val hex_bits_33 : bitvector(33) <-> string

mapping hex_bits_33 = {hex_bits((33, s)) <-> s}

val hex_bits_34 : bitvector(34) <-> string

mapping hex_bits_34 = {hex_bits((34, s)) <-> s}

val hex_bits_35 : bitvector(35) <-> string

mapping hex_bits_35 = {hex_bits((35, s)) <-> s}

val hex_bits_36 : bitvector(36) <-> string

mapping hex_bits_36 = {hex_bits((36, s)) <-> s}

val hex_bits_37 : bitvector(37) <-> string

mapping hex_bits_37 = {hex_bits((37, s)) <-> s}

val hex_bits_38 : bitvector(38) <-> string

mapping hex_bits_38 = {hex_bits((38, s)) <-> s}

val hex_bits_39 : bitvector(39) <-> string

mapping hex_bits_39 = {hex_bits((39, s)) <-> s}

val hex_bits_40 : bitvector(40) <-> string

mapping hex_bits_40 = {hex_bits((40, s)) <-> s}

val hex_bits_41 : bitvector(41) <-> string

mapping hex_bits_41 = {hex_bits((41, s)) <-> s}

val hex_bits_42 : bitvector(42) <-> string

mapping hex_bits_42 = {hex_bits((42, s)) <-> s}

val hex_bits_43 : bitvector(43) <-> string

mapping hex_bits_43 = {hex_bits((43, s)) <-> s}

val hex_bits_44 : bitvector(44) <-> string

mapping hex_bits_44 = {hex_bits((44, s)) <-> s}

val hex_bits_45 : bitvector(45) <-> string

mapping hex_bits_45 = {hex_bits((45, s)) <-> s}

val hex_bits_46 : bitvector(46) <-> string

mapping hex_bits_46 = {hex_bits((46, s)) <-> s}

val hex_bits_47 : bitvector(47) <-> string

mapping hex_bits_47 = {hex_bits((47, s)) <-> s}

val hex_bits_48 : bitvector(48) <-> string

mapping hex_bits_48 = {hex_bits((48, s)) <-> s}

val hex_bits_49 : bitvector(49) <-> string

mapping hex_bits_49 = {hex_bits((49, s)) <-> s}

val hex_bits_50 : bitvector(50) <-> string

mapping hex_bits_50 = {hex_bits((50, s)) <-> s}

val hex_bits_51 : bitvector(51) <-> string

mapping hex_bits_51 = {hex_bits((51, s)) <-> s}

val hex_bits_52 : bitvector(52) <-> string

mapping hex_bits_52 = {hex_bits((52, s)) <-> s}

val hex_bits_53 : bitvector(53) <-> string

mapping hex_bits_53 = {hex_bits((53, s)) <-> s}

val hex_bits_54 : bitvector(54) <-> string

mapping hex_bits_54 = {hex_bits((54, s)) <-> s}

val hex_bits_55 : bitvector(55) <-> string

mapping hex_bits_55 = {hex_bits((55, s)) <-> s}

val hex_bits_56 : bitvector(56) <-> string

mapping hex_bits_56 = {hex_bits((56, s)) <-> s}

val hex_bits_57 : bitvector(57) <-> string

mapping hex_bits_57 = {hex_bits((57, s)) <-> s}

val hex_bits_58 : bitvector(58) <-> string

mapping hex_bits_58 = {hex_bits((58, s)) <-> s}

val hex_bits_59 : bitvector(59) <-> string

mapping hex_bits_59 = {hex_bits((59, s)) <-> s}

val hex_bits_60 : bitvector(60) <-> string

mapping hex_bits_60 = {hex_bits((60, s)) <-> s}

val hex_bits_61 : bitvector(61) <-> string

mapping hex_bits_61 = {hex_bits((61, s)) <-> s}

val hex_bits_62 : bitvector(62) <-> string

mapping hex_bits_62 = {hex_bits((62, s)) <-> s}

val hex_bits_63 : bitvector(63) <-> string

mapping hex_bits_63 = {hex_bits((63, s)) <-> s}

val hex_bits_64 : bitvector(64) <-> string

mapping hex_bits_64 = {hex_bits((64, s)) <-> s}

$include_end /home/pauln/.opam/default/share/sail/lib/hex_bits.sail

$include_start /home/pauln/.opam/default/share/sail/lib/hex_bits_signed.sail

val hex_bits_signed : forall ('n : Int), 'n > 0.
  bitvector('n) <-> (int('n), string)

$[complete]
function hex_bits_signed_forwards bv = {
    let len = $[overloaded { "name" = "length", "is_infix" = false }] bitvector_length(bv);
    let s = if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(bv, $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(len, 1)), bitone) then {
        concat_str("-", hex_str($[overloaded { "name" = "+", "is_infix" = true }] add_atom(unsigned(not_vec(bv)), 1)))
    } else {
        hex_str(unsigned(bv))
    };
    ($[overloaded { "name" = "length", "is_infix" = false }] bitvector_length(bv), s)
}

$[complete]
function hex_bits_signed_forwards_matches bv = true

$[complete]
function hex_bits_signed_backwards (n, str) = {
    if $[overloaded { "name" = "==", "is_infix" = true }] eq_string(string_take(str, 1), "-") then {
        sub_bits(sail_zeros(n), parse_hex_bits(n, string_drop(str, 1)))
    } else {
        let parsed = parse_hex_bits(n, str);
        if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(parsed, $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(n, 1)), bitzero) then {
            parsed
        } else {
            sail_zeros(n)
        }
    }
}

$[complete]
function hex_bits_signed_backwards_matches (n, str) = {
    if $[overloaded { "name" = "==", "is_infix" = true }] eq_string(string_take(str, 1), "-") then {
        valid_hex_bits(n, string_drop(str, 1))
    } else if valid_hex_bits(n, str) then {
        let parsed = parse_hex_bits(n, str);
        $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(parsed, $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(n, 1)), bitzero)
    } else {
        false
    }
}

val hex_bits_signed_1 : bitvector(1) <-> string

mapping hex_bits_signed_1 = {hex_bits_signed((1, s)) <-> s}

val hex_bits_signed_2 : bitvector(2) <-> string

mapping hex_bits_signed_2 = {hex_bits_signed((2, s)) <-> s}

val hex_bits_signed_3 : bitvector(3) <-> string

mapping hex_bits_signed_3 = {hex_bits_signed((3, s)) <-> s}

val hex_bits_signed_4 : bitvector(4) <-> string

mapping hex_bits_signed_4 = {hex_bits_signed((4, s)) <-> s}

val hex_bits_signed_5 : bitvector(5) <-> string

mapping hex_bits_signed_5 = {hex_bits_signed((5, s)) <-> s}

val hex_bits_signed_6 : bitvector(6) <-> string

mapping hex_bits_signed_6 = {hex_bits_signed((6, s)) <-> s}

val hex_bits_signed_7 : bitvector(7) <-> string

mapping hex_bits_signed_7 = {hex_bits_signed((7, s)) <-> s}

val hex_bits_signed_8 : bitvector(8) <-> string

mapping hex_bits_signed_8 = {hex_bits_signed((8, s)) <-> s}

val hex_bits_signed_9 : bitvector(9) <-> string

mapping hex_bits_signed_9 = {hex_bits_signed((9, s)) <-> s}

val hex_bits_signed_10 : bitvector(10) <-> string

mapping hex_bits_signed_10 = {hex_bits_signed((10, s)) <-> s}

val hex_bits_signed_11 : bitvector(11) <-> string

mapping hex_bits_signed_11 = {hex_bits_signed((11, s)) <-> s}

val hex_bits_signed_12 : bitvector(12) <-> string

mapping hex_bits_signed_12 = {hex_bits_signed((12, s)) <-> s}

val hex_bits_signed_13 : bitvector(13) <-> string

mapping hex_bits_signed_13 = {hex_bits_signed((13, s)) <-> s}

val hex_bits_signed_14 : bitvector(14) <-> string

mapping hex_bits_signed_14 = {hex_bits_signed((14, s)) <-> s}

val hex_bits_signed_15 : bitvector(15) <-> string

mapping hex_bits_signed_15 = {hex_bits_signed((15, s)) <-> s}

val hex_bits_signed_16 : bitvector(16) <-> string

mapping hex_bits_signed_16 = {hex_bits_signed((16, s)) <-> s}

val hex_bits_signed_17 : bitvector(17) <-> string

mapping hex_bits_signed_17 = {hex_bits_signed((17, s)) <-> s}

val hex_bits_signed_18 : bitvector(18) <-> string

mapping hex_bits_signed_18 = {hex_bits_signed((18, s)) <-> s}

val hex_bits_signed_19 : bitvector(19) <-> string

mapping hex_bits_signed_19 = {hex_bits_signed((19, s)) <-> s}

val hex_bits_signed_20 : bitvector(20) <-> string

mapping hex_bits_signed_20 = {hex_bits_signed((20, s)) <-> s}

val hex_bits_signed_21 : bitvector(21) <-> string

mapping hex_bits_signed_21 = {hex_bits_signed((21, s)) <-> s}

val hex_bits_signed_22 : bitvector(22) <-> string

mapping hex_bits_signed_22 = {hex_bits_signed((22, s)) <-> s}

val hex_bits_signed_23 : bitvector(23) <-> string

mapping hex_bits_signed_23 = {hex_bits_signed((23, s)) <-> s}

val hex_bits_signed_24 : bitvector(24) <-> string

mapping hex_bits_signed_24 = {hex_bits_signed((24, s)) <-> s}

val hex_bits_signed_25 : bitvector(25) <-> string

mapping hex_bits_signed_25 = {hex_bits_signed((25, s)) <-> s}

val hex_bits_signed_26 : bitvector(26) <-> string

mapping hex_bits_signed_26 = {hex_bits_signed((26, s)) <-> s}

val hex_bits_signed_27 : bitvector(27) <-> string

mapping hex_bits_signed_27 = {hex_bits_signed((27, s)) <-> s}

val hex_bits_signed_28 : bitvector(28) <-> string

mapping hex_bits_signed_28 = {hex_bits_signed((28, s)) <-> s}

val hex_bits_signed_29 : bitvector(29) <-> string

mapping hex_bits_signed_29 = {hex_bits_signed((29, s)) <-> s}

val hex_bits_signed_30 : bitvector(30) <-> string

mapping hex_bits_signed_30 = {hex_bits_signed((30, s)) <-> s}

val hex_bits_signed_31 : bitvector(31) <-> string

mapping hex_bits_signed_31 = {hex_bits_signed((31, s)) <-> s}

val hex_bits_signed_32 : bitvector(32) <-> string

mapping hex_bits_signed_32 = {hex_bits_signed((32, s)) <-> s}

val hex_bits_signed_33 : bitvector(33) <-> string

mapping hex_bits_signed_33 = {hex_bits_signed((33, s)) <-> s}

val hex_bits_signed_34 : bitvector(34) <-> string

mapping hex_bits_signed_34 = {hex_bits_signed((34, s)) <-> s}

val hex_bits_signed_35 : bitvector(35) <-> string

mapping hex_bits_signed_35 = {hex_bits_signed((35, s)) <-> s}

val hex_bits_signed_36 : bitvector(36) <-> string

mapping hex_bits_signed_36 = {hex_bits_signed((36, s)) <-> s}

val hex_bits_signed_37 : bitvector(37) <-> string

mapping hex_bits_signed_37 = {hex_bits_signed((37, s)) <-> s}

val hex_bits_signed_38 : bitvector(38) <-> string

mapping hex_bits_signed_38 = {hex_bits_signed((38, s)) <-> s}

val hex_bits_signed_39 : bitvector(39) <-> string

mapping hex_bits_signed_39 = {hex_bits_signed((39, s)) <-> s}

val hex_bits_signed_40 : bitvector(40) <-> string

mapping hex_bits_signed_40 = {hex_bits_signed((40, s)) <-> s}

val hex_bits_signed_41 : bitvector(41) <-> string

mapping hex_bits_signed_41 = {hex_bits_signed((41, s)) <-> s}

val hex_bits_signed_42 : bitvector(42) <-> string

mapping hex_bits_signed_42 = {hex_bits_signed((42, s)) <-> s}

val hex_bits_signed_43 : bitvector(43) <-> string

mapping hex_bits_signed_43 = {hex_bits_signed((43, s)) <-> s}

val hex_bits_signed_44 : bitvector(44) <-> string

mapping hex_bits_signed_44 = {hex_bits_signed((44, s)) <-> s}

val hex_bits_signed_45 : bitvector(45) <-> string

mapping hex_bits_signed_45 = {hex_bits_signed((45, s)) <-> s}

val hex_bits_signed_46 : bitvector(46) <-> string

mapping hex_bits_signed_46 = {hex_bits_signed((46, s)) <-> s}

val hex_bits_signed_47 : bitvector(47) <-> string

mapping hex_bits_signed_47 = {hex_bits_signed((47, s)) <-> s}

val hex_bits_signed_48 : bitvector(48) <-> string

mapping hex_bits_signed_48 = {hex_bits_signed((48, s)) <-> s}

val hex_bits_signed_49 : bitvector(49) <-> string

mapping hex_bits_signed_49 = {hex_bits_signed((49, s)) <-> s}

val hex_bits_signed_50 : bitvector(50) <-> string

mapping hex_bits_signed_50 = {hex_bits_signed((50, s)) <-> s}

val hex_bits_signed_51 : bitvector(51) <-> string

mapping hex_bits_signed_51 = {hex_bits_signed((51, s)) <-> s}

val hex_bits_signed_52 : bitvector(52) <-> string

mapping hex_bits_signed_52 = {hex_bits_signed((52, s)) <-> s}

val hex_bits_signed_53 : bitvector(53) <-> string

mapping hex_bits_signed_53 = {hex_bits_signed((53, s)) <-> s}

val hex_bits_signed_54 : bitvector(54) <-> string

mapping hex_bits_signed_54 = {hex_bits_signed((54, s)) <-> s}

val hex_bits_signed_55 : bitvector(55) <-> string

mapping hex_bits_signed_55 = {hex_bits_signed((55, s)) <-> s}

val hex_bits_signed_56 : bitvector(56) <-> string

mapping hex_bits_signed_56 = {hex_bits_signed((56, s)) <-> s}

val hex_bits_signed_57 : bitvector(57) <-> string

mapping hex_bits_signed_57 = {hex_bits_signed((57, s)) <-> s}

val hex_bits_signed_58 : bitvector(58) <-> string

mapping hex_bits_signed_58 = {hex_bits_signed((58, s)) <-> s}

val hex_bits_signed_59 : bitvector(59) <-> string

mapping hex_bits_signed_59 = {hex_bits_signed((59, s)) <-> s}

val hex_bits_signed_60 : bitvector(60) <-> string

mapping hex_bits_signed_60 = {hex_bits_signed((60, s)) <-> s}

val hex_bits_signed_61 : bitvector(61) <-> string

mapping hex_bits_signed_61 = {hex_bits_signed((61, s)) <-> s}

val hex_bits_signed_62 : bitvector(62) <-> string

mapping hex_bits_signed_62 = {hex_bits_signed((62, s)) <-> s}

val hex_bits_signed_63 : bitvector(63) <-> string

mapping hex_bits_signed_63 = {hex_bits_signed((63, s)) <-> s}

val hex_bits_signed_64 : bitvector(64) <-> string

mapping hex_bits_signed_64 = {hex_bits_signed((64, s)) <-> s}

$include_end /home/pauln/.opam/default/share/sail/lib/hex_bits_signed.sail

$include_start /home/pauln/.opam/default/share/sail/lib/dec_bits.sail

val parse_dec_bits = pure {_: "parse_dec_bits"}: forall ('n : Int), 'n > 0.
  (int('n), string) -> bitvector('n)

val valid_dec_bits = pure {_: "valid_dec_bits"}: forall ('n : Int), 'n > 0.
  (int('n), string) -> bool

val dec_bits : forall ('n : Int), 'n > 0. bitvector('n) <-> (int('n), string)

$[complete]
function dec_bits_forwards bv = ($[overloaded { "name" = "length", "is_infix" = false }] bitvector_length(bv), dec_str(unsigned(bv)))

$[complete]
function dec_bits_forwards_matches bv = true

$[complete]
function dec_bits_backwards (n, str) = parse_dec_bits(n, str)

$[complete]
function dec_bits_backwards_matches (n, str) = valid_dec_bits(n, str)

val dec_bits_1 : bitvector(1) <-> string

mapping dec_bits_1 = {dec_bits((1, s)) <-> s}

val dec_bits_2 : bitvector(2) <-> string

mapping dec_bits_2 = {dec_bits((2, s)) <-> s}

val dec_bits_3 : bitvector(3) <-> string

mapping dec_bits_3 = {dec_bits((3, s)) <-> s}

val dec_bits_4 : bitvector(4) <-> string

mapping dec_bits_4 = {dec_bits((4, s)) <-> s}

val dec_bits_5 : bitvector(5) <-> string

mapping dec_bits_5 = {dec_bits((5, s)) <-> s}

val dec_bits_6 : bitvector(6) <-> string

mapping dec_bits_6 = {dec_bits((6, s)) <-> s}

val dec_bits_7 : bitvector(7) <-> string

mapping dec_bits_7 = {dec_bits((7, s)) <-> s}

val dec_bits_8 : bitvector(8) <-> string

mapping dec_bits_8 = {dec_bits((8, s)) <-> s}

val dec_bits_9 : bitvector(9) <-> string

mapping dec_bits_9 = {dec_bits((9, s)) <-> s}

val dec_bits_10 : bitvector(10) <-> string

mapping dec_bits_10 = {dec_bits((10, s)) <-> s}

val dec_bits_32 : bitvector(32) <-> string

mapping dec_bits_32 = {dec_bits((32, s)) <-> s}

$include_end /home/pauln/.opam/default/share/sail/lib/dec_bits.sail

val not_bit : bit -> bit

$[complete]
function not_bit b = if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit(b, bitone) then
  bitzero
else
  bitone

overload ~ = {not_bool, not_vec, not_bit}

val not : forall ('p : Bool). bool('p) -> bool(not('p))

$[complete]
function not b = not_bool(b)

overload operator & = {and_vec}

overload operator | = {or_vec}

overload operator ^ = {xor_vec, concat_str}

val sub_vec = pure {c: "sub_bits", lean: "_lean_sub", _: "sub_vec"}: forall ('n : Int).
  (bitvector('n), bitvector('n)) -> bitvector('n)

val sub_vec_int = pure {c: "sub_bits_int", lean: "BitVec.subInt", _: "sub_vec_int"}: forall ('n : Int).
  (bitvector('n), int) -> bitvector('n)

overload operator - = {sub_vec, sub_vec_int}

val quot_positive_round_zero = pure {interpreter: "quot_round_zero", lem: "hardware_quot", lean: "Int.tdiv", c: "tdiv_int", coq: "Z.quot"}: forall ('n : Int) ('m : Int), ('n >= 0 & 'm > 0).
  (int('n), int('m)) -> int(div('n, 'm))

val quot_round_zero = pure {interpreter: "quot_round_zero", lem: "hardware_quot", c: "tdiv_int", coq: "Z.quot", lean: "Int.tdiv"}: forall ('m : Int), 'm != 0.
  (int, int('m)) -> int

val rem_positive_round_zero = pure {interpreter: "rem_round_zero", lem: "hardware_mod", c: "tmod_int", coq: "Z.rem", lean: "Int.tmod"}: forall ('n : Int) ('m : Int), ('n >= 0 & 'm > 0).
  (int('n), int('m)) -> int(mod('n, 'm))

val rem_round_zero = pure {interpreter: "rem_round_zero", lem: "hardware_mod", c: "tmod_int", coq: "Z.rem", lean: "Int.tmod"}: forall ('m : Int), 'm != 0.
  (int, int('m)) -> int

type nat1 = {('n : Int), 'n > 0. int('n)}

overload min = {min_int}

overload max = {max_int}

val print_string = pure {_: "print_string"}: (string, string) -> unit

val print_log = pure {interpreter: "print_endline", c: "print_log", lem: "print_dbg", _: "print_endline"}: string -> unit

val print_log_instr = pure {c: "print_log_instr"}: (string, bitvector(64)) -> unit

$[complete]
function print_log_instr (message, pc) = print_log(message)

val print_step = pure {c: "print_step"}: unit -> unit

$[complete]
function print_step () = ()

val get_config_print_instr = pure {c: "get_config_print_instr"}: unit -> bool

val get_config_print_platform = pure {c: "get_config_print_platform"}: unit -> bool

val get_config_rvfi = pure {c: "get_config_rvfi"}: unit -> bool

val get_config_use_abi_names = pure {c: "get_config_use_abi_names"}: unit -> bool

$[complete]
function get_config_print_instr () = false

$[complete]
function get_config_print_platform () = false

$[complete]
function get_config_rvfi () = false

$[complete]
function get_config_use_abi_names () = false

val sign_extend : forall ('n : Int) ('m : Int), 'm >= 'n.
  (implicit('m), bitvector('n)) -> bitvector('m)

val zero_extend : forall ('n : Int) ('m : Int), 'm >= 'n.
  (implicit('m), bitvector('n)) -> bitvector('m)

$[complete]
function sign_extend (m, v) = sail_sign_extend(v, m)

$[complete]
function zero_extend (m, v) = sail_zero_extend(v, m)

val zeros : forall ('n : Int), 'n >= 0. implicit('n) -> bitvector('n)

$[complete]
function zeros n = sail_zeros(n)

val ones : forall ('n : Int), 'n >= 0. implicit('n) -> bitvector('n)

$[complete]
function ones n = sail_ones(n)

val trunc : forall ('m : Int) ('n : Int), ('m >= 0 & 'm <= 'n).
  (implicit('m), bitvector('n)) -> bitvector('m)

$[complete]
function trunc (m, v) = truncate(v, m)

val bool_bit : bool <-> bit

mapping bool_bit = {
  true <-> bitone,
  false <-> bitzero
}

val bool_bits : bool <-> bitvector(1)

mapping bool_bits = {
  true <-> 0b1,
  false <-> 0b0
}

val bool_to_bit : bool -> bit

$[complete]
function bool_to_bit x : bool = bool_bit_forwards(x)

val bit_to_bool : bit -> bool

$[complete]
function bit_to_bool x : bit = bool_bit_backwards(x)

val bool_to_bits : bool -> bitvector(1)

$[complete]
function bool_to_bits x : bool = bool_bits_forwards(x)

val bits_to_bool : bitvector(1) -> bool

$[complete]
function bits_to_bool x : bits(1) = bool_bits_backwards(x)

val bit_to_bits : bit -> bitvector(1)

$[complete]
function bit_to_bits x : bit = bool_bits_forwards(bit_to_bool(x))

val bits_to_bit : bitvector(1) -> bit

$[complete]
function bits_to_bit x : bits(1) = bool_to_bit(bits_to_bool(x))

val to_bits : forall ('l : Int) ('x : Int), ('l >= 0 & 0 <= 'x & 'x < 2 ^ 'l).
  (implicit('l), int('x)) -> bitvector('l)

$[complete]
function to_bits (l, n) = get_slice_int(l, n, 0)

val to_bits_checked : forall ('l : Int), 'l >= 0.
  (implicit('l), int) -> bitvector('l)

$[complete]
function to_bits_checked (l, n) = {
    let bv = get_slice_int(l, n, 0);
    assert($[overloaded { "name" = "==", "is_infix" = true }] eq_int(unsigned(bv), n), $[overloaded { "name" = "^", "is_infix" = true }] concat_str("Couldn't convert integer ", $[overloaded { "name" = "^", "is_infix" = true }] concat_str(dec_str(n), $[overloaded { "name" = "^", "is_infix" = true }] concat_str(" to ", $[overloaded { "name" = "^", "is_infix" = true }] concat_str(dec_str(l), " bits without overflow.")))));
    bv
}

val to_bits_truncate : forall ('l : Int), 'l >= 0.
  (implicit('l), int) -> bitvector('l)

$[complete]
function to_bits_truncate (l, n) = get_slice_int(l, n, 0)

val to_bits_unsafe : forall ('l : Int), 'l >= 0.
  (implicit('l), int) -> bitvector('l)

$[complete]
function to_bits_unsafe (l, n) = get_slice_int(l, n, 0)

infix 4 <_s

infix 4 >_s

infix 4 <=_s

infix 4 >=_s

infix 4 <_u

infix 4 >_u

infix 4 <=_u

infix 4 >=_u

val operator <_s : forall ('n : Int), 'n > 0.
  (bitvector('n), bitvector('n)) -> bool

val operator >_s : forall ('n : Int), 'n > 0.
  (bitvector('n), bitvector('n)) -> bool

val operator <=_s : forall ('n : Int), 'n > 0.
  (bitvector('n), bitvector('n)) -> bool

val operator >=_s : forall ('n : Int), 'n > 0.
  (bitvector('n), bitvector('n)) -> bool

val operator <_u : forall ('n : Int). (bitvector('n), bitvector('n)) -> bool

val operator >_u : forall ('n : Int). (bitvector('n), bitvector('n)) -> bool

val operator <=_u : forall ('n : Int). (bitvector('n), bitvector('n)) -> bool

val operator >=_u : forall ('n : Int). (bitvector('n), bitvector('n)) -> bool

$[complete]
function operator <_s (x, y) = $[overloaded { "name" = "<", "is_infix" = true }] lt_int(signed(x), signed(y))

$[complete]
function operator >_s (x, y) = $[overloaded { "name" = ">", "is_infix" = true }] gt_int(signed(x), signed(y))

$[complete]
function operator <=_s (x, y) = $[overloaded { "name" = "<=", "is_infix" = true }] lteq_int(signed(x), signed(y))

$[complete]
function operator >=_s (x, y) = $[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(signed(x), signed(y))

$[complete]
function operator <_u (x, y) = $[overloaded { "name" = "<", "is_infix" = true }] lt_int(unsigned(x), unsigned(y))

$[complete]
function operator >_u (x, y) = $[overloaded { "name" = ">", "is_infix" = true }] gt_int(unsigned(x), unsigned(y))

$[complete]
function operator <=_u (x, y) = $[overloaded { "name" = "<=", "is_infix" = true }] lteq_int(unsigned(x), unsigned(y))

$[complete]
function operator >=_u (x, y) = $[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(unsigned(x), unsigned(y))

infix 7 >>

infix 7 <<

val shift_bits_right = pure {_: "shift_bits_right"}: forall ('n : Int) ('m : Int).
  (bitvector('n), bitvector('m)) -> bitvector('n)

val shift_bits_left = pure {_: "shift_bits_left"}: forall ('n : Int) ('m : Int).
  (bitvector('n), bitvector('m)) -> bitvector('n)

val shiftl = pure {_: "shiftl"}: forall ('m : Int) ('n : Int), 'n >= 0.
  (bitvector('m), int('n)) -> bitvector('m)

val shiftr = pure {_: "shiftr"}: forall ('m : Int) ('n : Int), 'n >= 0.
  (bitvector('m), int('n)) -> bitvector('m)

overload operator >> = {shift_bits_right, shiftr}

overload operator << = {shift_bits_left, shiftl}

val shift_right_arith : forall ('m : Int) ('n : Int), ('n >= 1 & 'm >= 0).
  (bitvector('n), int('m)) -> bitvector('n)

$[complete]
function shift_right_arith (value, shift) = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(sign_extend($[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "__size", "is_infix" = false }] bitvector_length(value), shift), value), $[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "-", "is_infix" = true }] sub_atom($[overloaded { "name" = "__size", "is_infix" = false }] bitvector_length(value), 1), shift), shift)

val shift_bits_right_arith : forall ('m : Int) ('n : Int), 'n >= 1.
  (bitvector('n), bitvector('m)) -> bitvector('n)

$[complete]
function shift_bits_right_arith (value, shift) = shift_right_arith(value, unsigned(shift))

infix 7 >>>

infix 7 <<<

val rotater : forall ('m : Int) ('n : Int), ('m >= 'n & 'n >= 0).
  (bitvector('m), int('n)) -> bitvector('m)

$[complete]
function rotater (value, shift) = $[overloaded { "name" = "|", "is_infix" = true }] or_vec($[overloaded { "name" = ">>", "is_infix" = true }] shiftr(value, shift), $[overloaded { "name" = "<<", "is_infix" = true }] shiftl(value, $[overloaded { "name" = "-", "is_infix" = true }] sub_atom($[overloaded { "name" = "__size", "is_infix" = false }] bitvector_length(value), shift)))

val rotatel : forall ('m : Int) ('n : Int), ('m >= 'n & 'n >= 0).
  (bitvector('m), int('n)) -> bitvector('m)

$[complete]
function rotatel (value, shift) = $[overloaded { "name" = "|", "is_infix" = true }] or_vec($[overloaded { "name" = "<<", "is_infix" = true }] shiftl(value, shift), $[overloaded { "name" = ">>", "is_infix" = true }] shiftr(value, $[overloaded { "name" = "-", "is_infix" = true }] sub_atom($[overloaded { "name" = "__size", "is_infix" = false }] bitvector_length(value), shift)))

val rotate_bits_right : forall ('m : Int) ('n : Int), ('n >= 0 & 'm >= 2 ^ 'n).
  (bitvector('m), bitvector('n)) -> bitvector('m)

$[complete]
function rotate_bits_right (value, shift) = rotater(value, unsigned(shift))

val rotate_bits_left : forall ('m : Int) ('n : Int), ('n >= 0 & 'm >= 2 ^ 'n).
  (bitvector('m), bitvector('n)) -> bitvector('m)

$[complete]
function rotate_bits_left (value, shift) = rotatel(value, unsigned(shift))

overload operator >>> = {rotate_bits_right, rotater}

overload operator <<< = {rotate_bits_left, rotatel}

val reverse_bits : forall ('n : Int), 'n > 0. bitvector('n) -> bitvector('n)

$[complete]
function reverse_bits xs = {
    var ys : bits('n) = zeros($[overloaded { "name" = "__size", "is_infix" = false }] bitvector_length(xs));
    foreach (i
    from 0
    to sub_atom($[overloaded { "name" = "__size", "is_infix" = false }] bitvector_length(ys), 1)
    by 1
    in inc) ys[i] = $[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(xs, $[overloaded { "name" = "-", "is_infix" = true }] sub_atom($[overloaded { "name" = "-", "is_infix" = true }] sub_atom($[overloaded { "name" = "__size", "is_infix" = false }] bitvector_length(ys), 1), i));
    ys
}

overload operator * = {mult_atom, mult_int}

overload operator / = {quot_positive_round_zero}

overload operator % = {rem_positive_round_zero}

val log2 : forall ('n : Int), 'n in {1, 2, 4, 8, 16, 32, 64}. int('n) -> int

$[complete]
function log2 n = {
    let result : int = $[complete] match n {
      1 => 0,
      2 => 1,
      4 => 2,
      8 => 3,
      16 => 4,
      32 => 5,
      ($[int_wildcard 64] _) => 6
    };
    result
}

type max_mem_access : Int = 4096

type mem_access_width = range(1, max_mem_access)

val sys_enable_experimental_extensions = pure {_: "sys_enable_experimental_extensions"}: unit -> bool

val hex_bits_str : forall ('n : Int), 'n >= 0. bitvector('n) -> string

$[complete]
function hex_bits_str x : bits('n) = bits_str(zero_extend($[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "-", "is_infix" = true }] sub_atom(3, $[overloaded { "name" = "%", "is_infix" = true }] rem_positive_round_zero($[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "__size", "is_infix" = false }] bitvector_length(x), 3), 4)), $[overloaded { "name" = "__size", "is_infix" = false }] bitvector_length(x)), x))

union exception = {Error_not_implemented : string, Error_internal_error : unit}

val not_implemented : forall ('a : Type). string -> 'a

$[complete]
function not_implemented message = throw(Error_not_implemented(message))

val internal_error : forall ('a : Type). (string, int, string) -> 'a

$[complete]
function internal_error (file, line, s) = {
    assert(false, $[overloaded { "name" = "^", "is_infix" = true }] concat_str(file, $[overloaded { "name" = "^", "is_infix" = true }] concat_str(":", $[overloaded { "name" = "^", "is_infix" = true }] concat_str(dec_str(line), $[overloaded { "name" = "^", "is_infix" = true }] concat_str(": ", s)))));
    exit(())
}

type xlen : Int = config base.xlen

constraint xlen in {32, 64}

type log2_xlen : Int = if xlen == 32 then 5 else 6

type xlen_bytes : Int = if xlen == 32 then 4 else 8

type physaddrbits_len : Int = if xlen == 32 then 34 else 64

type asidlen : Int = if xlen == 32 then 9 else 16

let log2_xlen = if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(sizeof(xlen), 32) then
  5
else
  6

let xlen_bytes = if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(sizeof(xlen), 32) then
  4
else
  8

let xlen = sizeof(xlen)

let asidlen = if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(sizeof(xlen), 32) then
  9
else
  16

type xlenbits = bits(xlen)

type asidbits = bits(asidlen)

type ext_d_supported : Bool = config extensions.D.supported

type flen_bytes : Int = if ext_d_supported then 8 else 4

type flen : Int = flen_bytes * 8

type flenbits = bits(flen)

let flen_bytes = if constraint(ext_d_supported) then 8 else 4

let flen = mult_atom(if constraint(ext_d_supported) then 8 else 4, 8)

type vlen_exp : Int = config extensions.V.vlen_exp

constraint (3 <= vlen_exp & vlen_exp <= 16)

type elen_exp : Int = config extensions.V.elen_exp

constraint (3 <= elen_exp & elen_exp <= 16 & elen_exp <= vlen_exp)

let vlen_exp = sizeof(vlen_exp)

let elen_exp = sizeof(elen_exp)

type vlen : Int = 2 ^ vlen_exp

type elen : Int = 2 ^ elen_exp

let vlen = 2 ^ sizeof(vlen_exp)

let elen = 2 ^ sizeof(elen_exp)

type physaddrbits = bits(physaddrbits_len)

let physaddrbits_len = if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(sizeof(xlen), 32) then
  34
else
  64

newtype physaddr = Physaddr : physaddrbits

newtype virtaddr = Virtaddr : xlenbits

val bits_of_physaddr : physaddr -> bitvector(if xlen == 32 then 34 else 64)

$[complete]
function bits_of_physaddr Physaddr(paddr) : physaddr = paddr

val bits_of_virtaddr : virtaddr -> bitvector(xlen)

$[complete]
function bits_of_virtaddr Virtaddr(vaddr) : virtaddr = vaddr

val sub_virtaddr_xlenbits : (virtaddr, bitvector(xlen)) -> virtaddr

$[complete]
function sub_virtaddr_xlenbits (Virtaddr(addr) : virtaddr, offset : xlenbits) = Virtaddr($[overloaded { "name" = "-", "is_infix" = true }] sub_vec(addr, offset))

overload operator - = {sub_virtaddr_xlenbits}

overload bits_of = {bits_of_physaddr, bits_of_virtaddr}

type mem_meta = unit

let default_meta : mem_meta = ()

val __WriteRAM_Meta : (bitvector(if xlen == 32 then 34 else 64), range(1, 4096), unit) -> unit

$[complete]
function __WriteRAM_Meta (addr : physaddrbits, width : mem_access_width, meta : mem_meta) = ()

val __ReadRAM_Meta : (bitvector(if xlen == 32 then 34 else 64), range(1, 4096)) -> unit

$[complete]
function __ReadRAM_Meta (addr : physaddrbits, width : mem_access_width) = default_meta

$include_start /home/pauln/.opam/default/share/sail/lib/concurrency_interface.sail

$include_start /home/pauln/.opam/default/share/sail/lib/concurrency_interface/read_write.sail

$sail_internal 

$include_start /home/pauln/.opam/default/share/sail/lib/concurrency_interface/read_write_v1.sail

$sail_internal 

$include_start /home/pauln/.opam/default/share/sail/lib/concurrency_interface/common.sail

$sail_internal 

$target_set emulator_or_isla isla c ocaml interpreter systemverilog

$target_set emulator c ocaml interpreter systemverilog

$target_set prover lem coq lean

$include_start /home/pauln/.opam/default/share/sail/lib/result.sail

$sail_internal 

$option -lem_extern_type result

$option -coq_extern_type result

$option -lean_extern_type result

union result ('a: Type, 'b: Type) = {Ok : 'a, Err : 'b}

val is_ok : forall ('a : Type) ('b : Type). result('a, 'b) -> bool

$[complete]
function is_ok r = $[complete] match r {
  Ok(_) => true,
  Err(_) => false
}

val is_err : forall ('a : Type) ('b : Type). result('a, 'b) -> bool

$[complete]
function is_err r = $[complete] match r {
  Ok(_) => false,
  Err(_) => true
}

val ok_option : forall ('a : Type) ('b : Type). result('a, 'b) -> option('a)

$[complete]
function ok_option r = $[complete] match r {
  Ok(x) => Some(x),
  Err(_) => None()
}

val err_option : forall ('a : Type) ('b : Type). result('a, 'b) -> option('b)

$[complete]
function err_option r = $[complete] match r {
  Ok(_) => None(),
  Err(err) => Some(err)
}

val unwrap_or : forall ('a : Type) ('b : Type). (result('a, 'b), 'a) -> 'a

$[complete]
function unwrap_or (r, y) = $[complete] match r {
  Ok(x) => x,
  Err(_) => y
}

$include_end /home/pauln/.opam/default/share/sail/lib/result.sail

$include_start /home/pauln/.opam/default/share/sail/lib/concurrency_interface/emulator_memory.sail

$sail_internal 

val read_mem# : forall ('a : Type) ('n : Int) ('addrsize : Int), ('n >= 0 & 'addrsize in {32, 64}).
  ('a, int('addrsize), bitvector('addrsize), int('n)) -> bitvector(8 * 'n)

val read_mem_ifetch# : forall ('a : Type) ('n : Int) ('addrsize : Int), ('n >= 0 & 'addrsize in {32, 64}).
  ('a, int('addrsize), bitvector('addrsize), int('n)) -> bitvector(8 * 'n)

val read_mem_exclusive# : forall ('a : Type) ('n : Int) ('addrsize : Int), ('n >= 0 & 'addrsize in {32, 64}).
  ('a, int('addrsize), bitvector('addrsize), int('n)) -> bitvector(8 * 'n)

val write_mem# : forall ('a : Type) ('n : Int) ('addrsize : Int), ('n > 0 & 'addrsize in {32, 64}).
  ('a, int('addrsize), bitvector('addrsize), int('n), bitvector(8 * 'n)) -> bool

val write_mem_exclusive# : forall ('a : Type) ('n : Int) ('addrsize : Int), ('n > 0 & 'addrsize in {32, 64}).
  ('a, int('addrsize), bitvector('addrsize), int('n), bitvector(8 * 'n)) -> bool

$[sv_function]
val read_tag# = monadic {_: "emulator_read_tag"}: forall ('addrsize : Int), 'addrsize in {32, 64}.
  (int('addrsize), bitvector('addrsize)) -> bool

$[sv_module { "writes_memory" = true }]
val write_tag# = monadic {_: "emulator_write_tag"}: forall ('addrsize : Int), 'addrsize in {32, 64}.
  (int('addrsize), bitvector('addrsize), bool) -> unit

$include_end /home/pauln/.opam/default/share/sail/lib/concurrency_interface/emulator_memory.sail

/*! Each cycle (see [sail_end_cycle]) the model must announce the
  current opcode being executed. This is so each event within a cycle
  can be associated with an instruction. */
val sail_instr_announce : forall ('n : Int), 'n > 0. bitvector('n) -> unit

$[complete]
function sail_instr_announce _ = ()

/*! For keeping track of control dependencies, when we take a branch
  we announce the address we are branching to. */
val sail_branch_announce : forall ('addrsize : Int), 'addrsize in {32, 64}.
  (int('addrsize), bitvector('addrsize)) -> unit

$[complete]
function sail_branch_announce (_, _) = ()

/*! Each fetch-decode-execute cycle, the Sail model is expected to
  call [sail_end_cycle], to increment the cycle count and indicate the
  end of the current instruction. Cycle 0 is reserved for
  initialisation before executing the first instruction. */
val sail_end_cycle = monadic {_: "cycle_count"}: unit -> unit

/*! Returns the current cycle count */
$[sv_function { "return_type" = "int" }]
val sail_get_cycle_count = monadic {_: "get_cycle_count"}: unit -> int

/*! Isla allows registers to be set on the command line via the
  `-R/--register` flag. This function sets those registers to the
  provided values. It is a no-op for non-Isla targets.

  This enables a startup flow that works something like:
  ```sail
  function main() {
    // registers can be set using -I/--initial here
    initialize_model(); // defined by the architecture
    sail_reset_registers(); // registers can be set using -R/--register here
    ...
  ```

  This allows us to set the values of registers that would otherwise
  be initialised to some sensible default by the `initialize_model`
  function (overwriting a value set by `-I` at the beginning of execution). */
val sail_reset_registers : unit -> unit

$[complete]
function sail_reset_registers () = ()

/*! Isla supports *relaxed* semantics for system registers. This works
  as follows: Writes to these registers are not guaranteed to occur
  immediately. When a value is read from such a register, any previous
  written value can be read. Re-reading the register within the same
  instruction is guaranteed to return the same value ([sail_end_cycle]
  allows a different value to be subsequently read).

  This function removes all but the very last write, so subsequent
  reads must see only that value.

  This function is a no-op for non-Isla targets. */
val sail_synchronize_registers : unit -> unit

$[complete]
function sail_synchronize_registers () = ()

/*! The functions [sail_mark_register] and [sail_mark_register_pair]
  allow some information in the form of a string to be attached to some
  registers in an execution trace.

  These functions are a no-op for non-Isla targets. */
val sail_mark_register : forall ('a : Type). (register('a), string) -> unit

$[complete]
function sail_mark_register (_, _) = ()

val sail_mark_register_pair : forall ('a : Type) ('b : Type).
  (register('a), register('b), string) -> unit

$[complete]
function sail_mark_register_pair (_, _, _) = ()

/*! The function THIS will cause dependency analysis in Isla to ignore
  the write to the given register. */
val sail_ignore_write_to : forall ('a : Type). register('a) -> unit

$[complete]
function sail_ignore_write_to reg = sail_mark_register(reg, "ignore_write")

val sail_pick_dependency : forall ('a : Type). register('a) -> unit

$[complete]
function sail_pick_dependency reg = sail_mark_register(reg, "pick")

val __monomorphize : forall ('n : Int), 'n >= 0. bitvector('n) -> bitvector('n)

$[complete]
function __monomorphize bv = bv

$include_end /home/pauln/.opam/default/share/sail/lib/concurrency_interface/common.sail

$option -lem_extern_type Access_variety

$option -coq_extern_type Access_variety

$option -lean_extern_type Access_variety

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum Access_variety = {AV_plain, AV_exclusive, AV_atomic_rmw}

val undefined_Access_variety : unit -> Access_variety

$[complete]
function undefined_Access_variety () = internal_pick([|AV_plain, AV_exclusive, AV_atomic_rmw|])

val Access_variety_of_num : forall ('e : Int), (0 <= 'e & 'e <= 2).
  int('e) -> Access_variety

$[complete]
function Access_variety_of_num arg# = $[complete] match arg# {
  0 => AV_plain,
  1 => AV_exclusive,
  _ => AV_atomic_rmw
}

val num_of_Access_variety : Access_variety -> {('e : Int), (0 <= 'e & 'e <= 2). int('e)}

$[complete]
function num_of_Access_variety arg# = $[complete] match arg# {
  AV_plain => 0,
  AV_exclusive => 1,
  AV_atomic_rmw => 2
}

$option -lem_extern_type Access_strength

$option -coq_extern_type Access_strength

$option -lean_extern_type Access_strength

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum Access_strength = {AS_normal, AS_rel_or_acq, AS_acq_rcpc}

val undefined_Access_strength : unit -> Access_strength

$[complete]
function undefined_Access_strength () = internal_pick([|AS_normal, AS_rel_or_acq, AS_acq_rcpc|])

val Access_strength_of_num : forall ('e : Int), (0 <= 'e & 'e <= 2).
  int('e) -> Access_strength

$[complete]
function Access_strength_of_num arg# = $[complete] match arg# {
  0 => AS_normal,
  1 => AS_rel_or_acq,
  _ => AS_acq_rcpc
}

val num_of_Access_strength : Access_strength -> {('e : Int), (0 <= 'e & 'e <= 2). int('e)}

$[complete]
function num_of_Access_strength arg# = $[complete] match arg# {
  AS_normal => 0,
  AS_rel_or_acq => 1,
  AS_acq_rcpc => 2
}

$option -lem_extern_type Explicit_access_kind

$option -coq_extern_type Explicit_access_kind

$option -lean_extern_type Explicit_access_kind

$[undefined_gen "skip"]
struct Explicit_access_kind = {
  variety : Access_variety,
  strength : Access_strength
}

val undefined_Explicit_access_kind : unit -> Explicit_access_kind

$[complete]
function undefined_Explicit_access_kind () = struct Explicit_access_kind { variety = undefined, strength = undefined }

$option -lem_extern_type Access_kind

$option -coq_extern_type Access_kind

$option -lean_extern_type Access_kind

union Access_kind ('arch_ak: Type) = {
  AK_explicit : Explicit_access_kind,
  AK_ifetch : unit,
  AK_ttw : unit,
  AK_arch : 'arch_ak
}

$option -lem_extern_type Mem_read_request

$option -coq_extern_type Mem_read_request

$option -lean_extern_type Mem_read_request

$[undefined_gen "forbid"]
struct Mem_read_request ('n: Int, 'vasize: Int, 'pa: Type, 'ts: Type, 'arch_ak: Type) constraint ('n > 0 & 'vasize >= 0) = {
  access_kind : Access_kind('arch_ak),
  va : option(bits('vasize)),
  pa : 'pa,
  translation : 'ts,
  size : int('n),
  tag : bool
}

val mem_read_request_is_exclusive : forall ('n : Int) ('vasize : Int) ('pa : Type) ('translation_summary : Type) ('arch_ak : Type), ('n > 0 & 'vasize > 0).
  Mem_read_request('n, 'vasize, 'pa, 'translation_summary, 'arch_ak) -> bool

$[complete]
function mem_read_request_is_exclusive request = {
    $[complete] match request.access_kind {
      AK_explicit(eak) => $[complete] match eak.variety {
        AV_exclusive => true,
        _ => false
      },
      _ => false
    }
}

val mem_read_request_is_ifetch : forall ('n : Int) ('vasize : Int) ('pa : Type) ('translation_summary : Type) ('arch_ak : Type), ('n > 0 & 'vasize > 0).
  Mem_read_request('n, 'vasize, 'pa, 'translation_summary, 'arch_ak) -> bool

$[complete]
function mem_read_request_is_ifetch request = {
    $[complete] match request.access_kind {
      AK_ifetch(()) => true,
      _ => false
    }
}

let __monomorphize_reads : bool = false

let __monomorphize_writes : bool = false

outcome sail_mem_read : forall ('n : Int) ('vasize : Int), ('n > 0 & 'vasize > 0).
  Mem_read_request('n, 'vasize, 'pa, 'translation_summary, 'arch_ak) -> result((bits(8 * 'n), option(bool)), 'abort)
with 'pa: Type, 'translation_summary: Type, 'arch_ak: Type, 'abort: Type
= {
  val pa_bits : 'pa -> {('pasize : Int), 'pasize in {32, 64}. bitvector('pasize)}

  impl systemverilog request = {
      let pa = pa_bits(request.pa);
      let pa = if $[overloaded { "name" = "|", "is_infix" = true }] or_bool(mem_read_request_is_ifetch(request), __monomorphize_reads) then
        __monomorphize(pa)
      else
        pa;
      let tag : option(bool) = if request.tag then {
          if $[overloaded { "name" = "==", "is_infix" = true }] eq_int($[overloaded { "name" = "length", "is_infix" = false }] bitvector_length(pa), 32) then {
              Some(read_tag#(32, pa))
          } else {
              Some(read_tag#(64, pa))
          }
      } else {
          None()
      };
      if mem_read_request_is_exclusive(request) then {
          if $[overloaded { "name" = "==", "is_infix" = true }] eq_int($[overloaded { "name" = "length", "is_infix" = false }] bitvector_length(pa), 32) then {
              Ok((read_mem_exclusive#(request, 32, pa, request.size), tag))
          } else {
              Ok((read_mem_exclusive#(request, 64, pa, request.size), tag))
          }
      } else if mem_read_request_is_ifetch(request) then {
          if $[overloaded { "name" = "==", "is_infix" = true }] eq_int($[overloaded { "name" = "length", "is_infix" = false }] bitvector_length(pa), 32) then {
              Ok((read_mem_ifetch#(request, 32, pa, request.size), tag))
          } else {
              Ok((read_mem_ifetch#(request, 64, pa, request.size), tag))
          }
      } else {
          if $[overloaded { "name" = "==", "is_infix" = true }] eq_int($[overloaded { "name" = "length", "is_infix" = false }] bitvector_length(pa), 32) then {
              Ok((read_mem#(request, 32, pa, request.size), tag))
          } else {
              Ok((read_mem#(request, 64, pa, request.size), tag))
          }
      }
  }

  impl interpreter request = {
      let pa = pa_bits(request.pa);
      let pa = if $[overloaded { "name" = "|", "is_infix" = true }] or_bool(mem_read_request_is_ifetch(request), __monomorphize_reads) then
        __monomorphize(pa)
      else
        pa;
      let tag : option(bool) = if request.tag then {
          if $[overloaded { "name" = "==", "is_infix" = true }] eq_int($[overloaded { "name" = "length", "is_infix" = false }] bitvector_length(pa), 32) then {
              Some(read_tag#(32, pa))
          } else {
              Some(read_tag#(64, pa))
          }
      } else {
          None()
      };
      if mem_read_request_is_exclusive(request) then {
          if $[overloaded { "name" = "==", "is_infix" = true }] eq_int($[overloaded { "name" = "length", "is_infix" = false }] bitvector_length(pa), 32) then {
              Ok((read_mem_exclusive#(request, 32, pa, request.size), tag))
          } else {
              Ok((read_mem_exclusive#(request, 64, pa, request.size), tag))
          }
      } else if mem_read_request_is_ifetch(request) then {
          if $[overloaded { "name" = "==", "is_infix" = true }] eq_int($[overloaded { "name" = "length", "is_infix" = false }] bitvector_length(pa), 32) then {
              Ok((read_mem_ifetch#(request, 32, pa, request.size), tag))
          } else {
              Ok((read_mem_ifetch#(request, 64, pa, request.size), tag))
          }
      } else {
          if $[overloaded { "name" = "==", "is_infix" = true }] eq_int($[overloaded { "name" = "length", "is_infix" = false }] bitvector_length(pa), 32) then {
              Ok((read_mem#(request, 32, pa, request.size), tag))
          } else {
              Ok((read_mem#(request, 64, pa, request.size), tag))
          }
      }
  }

  impl ocaml request = {
      let pa = pa_bits(request.pa);
      let pa = if $[overloaded { "name" = "|", "is_infix" = true }] or_bool(mem_read_request_is_ifetch(request), __monomorphize_reads) then
        __monomorphize(pa)
      else
        pa;
      let tag : option(bool) = if request.tag then {
          if $[overloaded { "name" = "==", "is_infix" = true }] eq_int($[overloaded { "name" = "length", "is_infix" = false }] bitvector_length(pa), 32) then {
              Some(read_tag#(32, pa))
          } else {
              Some(read_tag#(64, pa))
          }
      } else {
          None()
      };
      if mem_read_request_is_exclusive(request) then {
          if $[overloaded { "name" = "==", "is_infix" = true }] eq_int($[overloaded { "name" = "length", "is_infix" = false }] bitvector_length(pa), 32) then {
              Ok((read_mem_exclusive#(request, 32, pa, request.size), tag))
          } else {
              Ok((read_mem_exclusive#(request, 64, pa, request.size), tag))
          }
      } else if mem_read_request_is_ifetch(request) then {
          if $[overloaded { "name" = "==", "is_infix" = true }] eq_int($[overloaded { "name" = "length", "is_infix" = false }] bitvector_length(pa), 32) then {
              Ok((read_mem_ifetch#(request, 32, pa, request.size), tag))
          } else {
              Ok((read_mem_ifetch#(request, 64, pa, request.size), tag))
          }
      } else {
          if $[overloaded { "name" = "==", "is_infix" = true }] eq_int($[overloaded { "name" = "length", "is_infix" = false }] bitvector_length(pa), 32) then {
              Ok((read_mem#(request, 32, pa, request.size), tag))
          } else {
              Ok((read_mem#(request, 64, pa, request.size), tag))
          }
      }
  }

  impl c request = {
      let pa = pa_bits(request.pa);
      let pa = if $[overloaded { "name" = "|", "is_infix" = true }] or_bool(mem_read_request_is_ifetch(request), __monomorphize_reads) then
        __monomorphize(pa)
      else
        pa;
      let tag : option(bool) = if request.tag then {
          if $[overloaded { "name" = "==", "is_infix" = true }] eq_int($[overloaded { "name" = "length", "is_infix" = false }] bitvector_length(pa), 32) then {
              Some(read_tag#(32, pa))
          } else {
              Some(read_tag#(64, pa))
          }
      } else {
          None()
      };
      if mem_read_request_is_exclusive(request) then {
          if $[overloaded { "name" = "==", "is_infix" = true }] eq_int($[overloaded { "name" = "length", "is_infix" = false }] bitvector_length(pa), 32) then {
              Ok((read_mem_exclusive#(request, 32, pa, request.size), tag))
          } else {
              Ok((read_mem_exclusive#(request, 64, pa, request.size), tag))
          }
      } else if mem_read_request_is_ifetch(request) then {
          if $[overloaded { "name" = "==", "is_infix" = true }] eq_int($[overloaded { "name" = "length", "is_infix" = false }] bitvector_length(pa), 32) then {
              Ok((read_mem_ifetch#(request, 32, pa, request.size), tag))
          } else {
              Ok((read_mem_ifetch#(request, 64, pa, request.size), tag))
          }
      } else {
          if $[overloaded { "name" = "==", "is_infix" = true }] eq_int($[overloaded { "name" = "length", "is_infix" = false }] bitvector_length(pa), 32) then {
              Ok((read_mem#(request, 32, pa, request.size), tag))
          } else {
              Ok((read_mem#(request, 64, pa, request.size), tag))
          }
      }
  }

  impl isla request = {
      let pa = pa_bits(request.pa);
      let pa = if $[overloaded { "name" = "|", "is_infix" = true }] or_bool(mem_read_request_is_ifetch(request), __monomorphize_reads) then
        __monomorphize(pa)
      else
        pa;
      let tag : option(bool) = if request.tag then {
          if $[overloaded { "name" = "==", "is_infix" = true }] eq_int($[overloaded { "name" = "length", "is_infix" = false }] bitvector_length(pa), 32) then {
              Some(read_tag#(32, pa))
          } else {
              Some(read_tag#(64, pa))
          }
      } else {
          None()
      };
      if mem_read_request_is_exclusive(request) then {
          if $[overloaded { "name" = "==", "is_infix" = true }] eq_int($[overloaded { "name" = "length", "is_infix" = false }] bitvector_length(pa), 32) then {
              Ok((read_mem_exclusive#(request, 32, pa, request.size), tag))
          } else {
              Ok((read_mem_exclusive#(request, 64, pa, request.size), tag))
          }
      } else if mem_read_request_is_ifetch(request) then {
          if $[overloaded { "name" = "==", "is_infix" = true }] eq_int($[overloaded { "name" = "length", "is_infix" = false }] bitvector_length(pa), 32) then {
              Ok((read_mem_ifetch#(request, 32, pa, request.size), tag))
          } else {
              Ok((read_mem_ifetch#(request, 64, pa, request.size), tag))
          }
      } else {
          if $[overloaded { "name" = "==", "is_infix" = true }] eq_int($[overloaded { "name" = "length", "is_infix" = false }] bitvector_length(pa), 32) then {
              Ok((read_mem#(request, 32, pa, request.size), tag))
          } else {
              Ok((read_mem#(request, 64, pa, request.size), tag))
          }
      }
  }
}

$option -lem_extern_type Mem_write_request

$option -coq_extern_type Mem_write_request

$option -lean_extern_type Mem_write_request

$[undefined_gen "forbid"]
struct Mem_write_request ('n: Int, 'vasize: Int, 'pa: Type, 'ts: Type, 'arch_ak: Type) constraint ('n > 0 & 'vasize >= 0) = {
  access_kind : Access_kind('arch_ak),
  va : option(bits('vasize)),
  pa : 'pa,
  translation : 'ts,
  size : int('n),
  value : option(bits(8 * 'n)),
  tag : option(bool)
}

val mem_write_request_is_exclusive : forall ('n : Int) ('vasize : Int) ('pa : Type) ('translation_summary : Type) ('arch_ak : Type), ('n > 0 & 'vasize > 0).
  Mem_write_request('n, 'vasize, 'pa, 'translation_summary, 'arch_ak) -> bool

$[complete]
function mem_write_request_is_exclusive request = {
    $[complete] match request.access_kind {
      AK_explicit(eak) => $[complete] match eak.variety {
        AV_exclusive => true,
        _ => false
      },
      _ => false
    }
}

outcome sail_mem_write : forall ('n : Int) ('vasize : Int), ('n > 0 & 'vasize > 0).
  Mem_write_request('n, 'vasize, 'pa, 'translation_summary, 'arch_ak) -> result(option(bool), 'abort)
with 'pa: Type, 'translation_summary: Type, 'arch_ak: Type, 'abort: Type
= {
  val pa_bits : 'pa -> {('pasize : Int), 'pasize in {32, 64}. bitvector('pasize)}

  impl systemverilog request = {
      let pa = pa_bits(request.pa);
      let pa = if __monomorphize_writes then __monomorphize(pa) else pa;
      let b : bool = $[complete] match request.value {
        Some(value) => if mem_write_request_is_exclusive(request) then {
            if $[overloaded { "name" = "==", "is_infix" = true }] eq_int($[overloaded { "name" = "length", "is_infix" = false }] bitvector_length(pa), 32) then {
                write_mem_exclusive#(request, 32, pa, request.size, value)
            } else {
                write_mem_exclusive#(request, 64, pa, request.size, value)
            }
        } else {
            if $[overloaded { "name" = "==", "is_infix" = true }] eq_int($[overloaded { "name" = "length", "is_infix" = false }] bitvector_length(pa), 32) then {
                write_mem#(request, 32, pa, request.size, value)
            } else {
                write_mem#(request, 64, pa, request.size, value)
            }
        },
        None(()) => true
      };
      $[complete] match request.tag {
        Some(tag) => if $[overloaded { "name" = "==", "is_infix" = true }] eq_int($[overloaded { "name" = "length", "is_infix" = false }] bitvector_length(pa), 32) then {
            write_tag#(32, pa, tag)
        } else {
            write_tag#(64, pa, tag)
        },
        None(()) => ()
      };
      Ok(Some(b))
  }

  impl interpreter request = {
      let pa = pa_bits(request.pa);
      let pa = if __monomorphize_writes then __monomorphize(pa) else pa;
      let b : bool = $[complete] match request.value {
        Some(value) => if mem_write_request_is_exclusive(request) then {
            if $[overloaded { "name" = "==", "is_infix" = true }] eq_int($[overloaded { "name" = "length", "is_infix" = false }] bitvector_length(pa), 32) then {
                write_mem_exclusive#(request, 32, pa, request.size, value)
            } else {
                write_mem_exclusive#(request, 64, pa, request.size, value)
            }
        } else {
            if $[overloaded { "name" = "==", "is_infix" = true }] eq_int($[overloaded { "name" = "length", "is_infix" = false }] bitvector_length(pa), 32) then {
                write_mem#(request, 32, pa, request.size, value)
            } else {
                write_mem#(request, 64, pa, request.size, value)
            }
        },
        None(()) => true
      };
      $[complete] match request.tag {
        Some(tag) => if $[overloaded { "name" = "==", "is_infix" = true }] eq_int($[overloaded { "name" = "length", "is_infix" = false }] bitvector_length(pa), 32) then {
            write_tag#(32, pa, tag)
        } else {
            write_tag#(64, pa, tag)
        },
        None(()) => ()
      };
      Ok(Some(b))
  }

  impl ocaml request = {
      let pa = pa_bits(request.pa);
      let pa = if __monomorphize_writes then __monomorphize(pa) else pa;
      let b : bool = $[complete] match request.value {
        Some(value) => if mem_write_request_is_exclusive(request) then {
            if $[overloaded { "name" = "==", "is_infix" = true }] eq_int($[overloaded { "name" = "length", "is_infix" = false }] bitvector_length(pa), 32) then {
                write_mem_exclusive#(request, 32, pa, request.size, value)
            } else {
                write_mem_exclusive#(request, 64, pa, request.size, value)
            }
        } else {
            if $[overloaded { "name" = "==", "is_infix" = true }] eq_int($[overloaded { "name" = "length", "is_infix" = false }] bitvector_length(pa), 32) then {
                write_mem#(request, 32, pa, request.size, value)
            } else {
                write_mem#(request, 64, pa, request.size, value)
            }
        },
        None(()) => true
      };
      $[complete] match request.tag {
        Some(tag) => if $[overloaded { "name" = "==", "is_infix" = true }] eq_int($[overloaded { "name" = "length", "is_infix" = false }] bitvector_length(pa), 32) then {
            write_tag#(32, pa, tag)
        } else {
            write_tag#(64, pa, tag)
        },
        None(()) => ()
      };
      Ok(Some(b))
  }

  impl c request = {
      let pa = pa_bits(request.pa);
      let pa = if __monomorphize_writes then __monomorphize(pa) else pa;
      let b : bool = $[complete] match request.value {
        Some(value) => if mem_write_request_is_exclusive(request) then {
            if $[overloaded { "name" = "==", "is_infix" = true }] eq_int($[overloaded { "name" = "length", "is_infix" = false }] bitvector_length(pa), 32) then {
                write_mem_exclusive#(request, 32, pa, request.size, value)
            } else {
                write_mem_exclusive#(request, 64, pa, request.size, value)
            }
        } else {
            if $[overloaded { "name" = "==", "is_infix" = true }] eq_int($[overloaded { "name" = "length", "is_infix" = false }] bitvector_length(pa), 32) then {
                write_mem#(request, 32, pa, request.size, value)
            } else {
                write_mem#(request, 64, pa, request.size, value)
            }
        },
        None(()) => true
      };
      $[complete] match request.tag {
        Some(tag) => if $[overloaded { "name" = "==", "is_infix" = true }] eq_int($[overloaded { "name" = "length", "is_infix" = false }] bitvector_length(pa), 32) then {
            write_tag#(32, pa, tag)
        } else {
            write_tag#(64, pa, tag)
        },
        None(()) => ()
      };
      Ok(Some(b))
  }

  impl isla request = {
      let pa = pa_bits(request.pa);
      let pa = if __monomorphize_writes then __monomorphize(pa) else pa;
      let b : bool = $[complete] match request.value {
        Some(value) => if mem_write_request_is_exclusive(request) then {
            if $[overloaded { "name" = "==", "is_infix" = true }] eq_int($[overloaded { "name" = "length", "is_infix" = false }] bitvector_length(pa), 32) then {
                write_mem_exclusive#(request, 32, pa, request.size, value)
            } else {
                write_mem_exclusive#(request, 64, pa, request.size, value)
            }
        } else {
            if $[overloaded { "name" = "==", "is_infix" = true }] eq_int($[overloaded { "name" = "length", "is_infix" = false }] bitvector_length(pa), 32) then {
                write_mem#(request, 32, pa, request.size, value)
            } else {
                write_mem#(request, 64, pa, request.size, value)
            }
        },
        None(()) => true
      };
      $[complete] match request.tag {
        Some(tag) => if $[overloaded { "name" = "==", "is_infix" = true }] eq_int($[overloaded { "name" = "length", "is_infix" = false }] bitvector_length(pa), 32) then {
            write_tag#(32, pa, tag)
        } else {
            write_tag#(64, pa, tag)
        },
        None(()) => ()
      };
      Ok(Some(b))
  }
}

val sail_address_announce : forall ('addrsize : Int), 'addrsize in {32, 64}.
  (int('addrsize), bitvector('addrsize)) -> unit

$[complete]
function sail_address_announce (_, _) = ()

$include_end /home/pauln/.opam/default/share/sail/lib/concurrency_interface/read_write_v1.sail

$include_end /home/pauln/.opam/default/share/sail/lib/concurrency_interface/read_write.sail

$include_start /home/pauln/.opam/default/share/sail/lib/concurrency_interface/barrier.sail

$sail_internal 

$include_start /home/pauln/.opam/default/share/sail/lib/concurrency_interface/common.sail

$sail_internal 

$target_set emulator_or_isla isla c ocaml interpreter systemverilog

$target_set emulator c ocaml interpreter systemverilog

$target_set prover lem coq lean

$include_end /home/pauln/.opam/default/share/sail/lib/concurrency_interface/common.sail

outcome sail_barrier : 'barrier -> unit
with 'barrier: Type
= {
  impl systemverilog _ = ()

  impl interpreter _ = ()

  impl ocaml _ = ()

  impl c _ = ()
}

$include_end /home/pauln/.opam/default/share/sail/lib/concurrency_interface/barrier.sail

$include_end /home/pauln/.opam/default/share/sail/lib/concurrency_interface.sail

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum write_kind = {
  Write_plain,
  Write_RISCV_release,
  Write_RISCV_strong_release,
  Write_RISCV_conditional,
  Write_RISCV_conditional_release,
  Write_RISCV_conditional_strong_release
}

val undefined_write_kind : unit -> write_kind

$[complete]
function undefined_write_kind () = internal_pick([|Write_plain, Write_RISCV_release, Write_RISCV_strong_release, Write_RISCV_conditional, Write_RISCV_conditional_release, Write_RISCV_conditional_strong_release|])

val write_kind_of_num : forall ('e : Int), (0 <= 'e & 'e <= 5).
  int('e) -> write_kind

$[complete]
function write_kind_of_num arg# = $[complete] match arg# {
  0 => Write_plain,
  1 => Write_RISCV_release,
  2 => Write_RISCV_strong_release,
  3 => Write_RISCV_conditional,
  4 => Write_RISCV_conditional_release,
  _ => Write_RISCV_conditional_strong_release
}

val num_of_write_kind : write_kind -> {('e : Int), (0 <= 'e & 'e <= 5). int('e)}

$[complete]
function num_of_write_kind arg# = $[complete] match arg# {
  Write_plain => 0,
  Write_RISCV_release => 1,
  Write_RISCV_strong_release => 2,
  Write_RISCV_conditional => 3,
  Write_RISCV_conditional_release => 4,
  Write_RISCV_conditional_strong_release => 5
}

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum read_kind = {
  Read_plain,
  Read_ifetch,
  Read_RISCV_acquire,
  Read_RISCV_strong_acquire,
  Read_RISCV_reserved,
  Read_RISCV_reserved_acquire,
  Read_RISCV_reserved_strong_acquire
}

val undefined_read_kind : unit -> read_kind

$[complete]
function undefined_read_kind () = internal_pick([|Read_plain, Read_ifetch, Read_RISCV_acquire, Read_RISCV_strong_acquire, Read_RISCV_reserved, Read_RISCV_reserved_acquire, Read_RISCV_reserved_strong_acquire|])

val read_kind_of_num : forall ('e : Int), (0 <= 'e & 'e <= 6).
  int('e) -> read_kind

$[complete]
function read_kind_of_num arg# = $[complete] match arg# {
  0 => Read_plain,
  1 => Read_ifetch,
  2 => Read_RISCV_acquire,
  3 => Read_RISCV_strong_acquire,
  4 => Read_RISCV_reserved,
  5 => Read_RISCV_reserved_acquire,
  _ => Read_RISCV_reserved_strong_acquire
}

val num_of_read_kind : read_kind -> {('e : Int), (0 <= 'e & 'e <= 6). int('e)}

$[complete]
function num_of_read_kind arg# = $[complete] match arg# {
  Read_plain => 0,
  Read_ifetch => 1,
  Read_RISCV_acquire => 2,
  Read_RISCV_strong_acquire => 3,
  Read_RISCV_reserved => 4,
  Read_RISCV_reserved_acquire => 5,
  Read_RISCV_reserved_strong_acquire => 6
}

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum barrier_kind = {
  Barrier_RISCV_rw_rw,
  Barrier_RISCV_r_rw,
  Barrier_RISCV_r_r,
  Barrier_RISCV_rw_w,
  Barrier_RISCV_w_w,
  Barrier_RISCV_w_rw,
  Barrier_RISCV_rw_r,
  Barrier_RISCV_r_w,
  Barrier_RISCV_w_r,
  Barrier_RISCV_tso,
  Barrier_RISCV_i
}

val undefined_barrier_kind : unit -> barrier_kind

$[complete]
function undefined_barrier_kind () = internal_pick([|Barrier_RISCV_rw_rw, Barrier_RISCV_r_rw, Barrier_RISCV_r_r, Barrier_RISCV_rw_w, Barrier_RISCV_w_w, Barrier_RISCV_w_rw, Barrier_RISCV_rw_r, Barrier_RISCV_r_w, Barrier_RISCV_w_r, Barrier_RISCV_tso, Barrier_RISCV_i|])

val barrier_kind_of_num : forall ('e : Int), (0 <= 'e & 'e <= 10).
  int('e) -> barrier_kind

$[complete]
function barrier_kind_of_num arg# = $[complete] match arg# {
  0 => Barrier_RISCV_rw_rw,
  1 => Barrier_RISCV_r_rw,
  2 => Barrier_RISCV_r_r,
  3 => Barrier_RISCV_rw_w,
  4 => Barrier_RISCV_w_w,
  5 => Barrier_RISCV_w_rw,
  6 => Barrier_RISCV_rw_r,
  7 => Barrier_RISCV_r_w,
  8 => Barrier_RISCV_w_r,
  9 => Barrier_RISCV_tso,
  _ => Barrier_RISCV_i
}

val num_of_barrier_kind : barrier_kind -> {('e : Int), (0 <= 'e & 'e <= 10). int('e)}

$[complete]
function num_of_barrier_kind arg# = $[complete] match arg# {
  Barrier_RISCV_rw_rw => 0,
  Barrier_RISCV_r_rw => 1,
  Barrier_RISCV_r_r => 2,
  Barrier_RISCV_rw_w => 3,
  Barrier_RISCV_w_w => 4,
  Barrier_RISCV_w_rw => 5,
  Barrier_RISCV_rw_r => 6,
  Barrier_RISCV_r_w => 7,
  Barrier_RISCV_w_r => 8,
  Barrier_RISCV_tso => 9,
  Barrier_RISCV_i => 10
}

$[undefined_gen "skip"]
struct RISCV_strong_access = {variety : Access_variety}

val undefined_RISCV_strong_access : unit -> RISCV_strong_access

$[complete]
function undefined_RISCV_strong_access () = struct RISCV_strong_access { variety = undefined }

val physaddrbits_zero_extend : bitvector(if xlen == 32 then 34 else 64) -> bitvector(64)

$[complete]
function physaddrbits_zero_extend xs = zero_extend(64, xs)

instantiation sail_mem_write with
  'pa = physaddrbits,
  pa_bits = physaddrbits_zero_extend,
  'translation_summary = unit,
  'arch_ak = RISCV_strong_access,
  'abort = unit

val write_ram : forall ('n : Int), (0 < 'n & 'n <= max_mem_access).
  (write_kind, physaddr, int('n), bitvector(8 * 'n), unit) -> bool

$[complete]
function write_ram (wk, Physaddr(addr), width, data, meta) = {
    let request : Mem_write_request('n, 64, physaddrbits, unit, RISCV_strong_access) = struct Mem_write_request { access_kind = $[complete] match wk {
      Write_plain => AK_explicit(struct Explicit_access_kind { variety = AV_plain, strength = AS_normal }),
      Write_RISCV_release => AK_explicit(struct Explicit_access_kind { variety = AV_plain, strength = AS_rel_or_acq }),
      Write_RISCV_strong_release => AK_arch(struct RISCV_strong_access { variety = AV_plain }),
      Write_RISCV_conditional => AK_explicit(struct Explicit_access_kind { variety = AV_exclusive, strength = AS_normal }),
      Write_RISCV_conditional_release => AK_explicit(struct Explicit_access_kind { variety = AV_exclusive, strength = AS_rel_or_acq }),
      Write_RISCV_conditional_strong_release => AK_arch(struct RISCV_strong_access { variety = AV_exclusive })
    }, va = None(), pa = addr, translation = (), size = width, value = Some(data), tag = None() };
    $[complete] match sail_mem_write(request) {
      Ok(_) => {
          __WriteRAM_Meta(addr, width, meta);
          true
      },
      Err(()) => false
    }
}

val write_ram_ea : forall ('n : Int), (0 < 'n & 'n <= max_mem_access).
  (write_kind, physaddr, int('n)) -> unit

$[complete]
function write_ram_ea (wk, Physaddr(addr), width) = ()

instantiation sail_mem_read with pa_bits = physaddrbits_zero_extend

val read_ram : forall ('n : Int), (0 < 'n & 'n <= max_mem_access).
  (read_kind, physaddr, int('n), bool) -> (bitvector(8 * 'n), unit)

$[complete]
function read_ram (rk, Physaddr(addr), width, read_meta) = {
    let meta = if read_meta then __ReadRAM_Meta(addr, width) else default_meta;
    let request : Mem_read_request('n, 64, physaddrbits, unit, RISCV_strong_access) = struct Mem_read_request { access_kind = $[complete] match rk {
      Read_plain => AK_explicit(struct Explicit_access_kind { variety = AV_plain, strength = AS_normal }),
      Read_ifetch => AK_ifetch(),
      Read_RISCV_acquire => AK_explicit(struct Explicit_access_kind { variety = AV_plain, strength = AS_rel_or_acq }),
      Read_RISCV_strong_acquire => AK_arch(struct RISCV_strong_access { variety = AV_plain }),
      Read_RISCV_reserved => AK_explicit(struct Explicit_access_kind { variety = AV_exclusive, strength = AS_normal }),
      Read_RISCV_reserved_acquire => AK_explicit(struct Explicit_access_kind { variety = AV_exclusive, strength = AS_rel_or_acq }),
      Read_RISCV_reserved_strong_acquire => AK_arch(struct RISCV_strong_access { variety = AV_exclusive })
    }, va = None(), pa = addr, translation = (), size = width, tag = false };
    $[complete] match sail_mem_read(request) {
      Ok((value, _)) => (value, meta),
      Err(()) => exit(())
    }
}

instantiation sail_barrier with 'barrier = barrier_kind

val __TraceMemoryWrite : forall ('n : Int) ('m : Int).
  (int('n), bitvector('m), bitvector(8 * 'n)) -> unit

val __TraceMemoryRead : forall ('n : Int) ('m : Int).
  (int('n), bitvector('m), bitvector(8 * 'n)) -> unit

val brev8 : forall ('m : Int), ('m >= 0 & mod('m, 8) == 0).
  bitvector('m) -> bitvector('m)

$[complete]
function brev8 input = {
    var output : bits('m) = zeros($[overloaded { "name" = "__size", "is_infix" = false }] bitvector_length(input));
    foreach (i
    from 0
    to sub_atom($[overloaded { "name" = "__size", "is_infix" = false }] bitvector_length(output), 8)
    by 8
    in inc) output[$[overloaded { "name" = "+", "is_infix" = true }] add_atom(i, 7) .. i] = reverse_bits($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(input, $[overloaded { "name" = "+", "is_infix" = true }] add_atom(i, 7), i));
    output
}

val carryless_mul : forall ('n : Int), 'n > 0.
  (bitvector('n), bitvector('n)) -> bitvector(2 * 'n)

$[complete]
function carryless_mul (a, b) = {
    var result : bits(2 * 'n) = zeros(mult_atom(2, $[overloaded { "name" = "__size", "is_infix" = false }] bitvector_length(b)));
    foreach (i
    from 0
    to sub_atom($[overloaded { "name" = "__size", "is_infix" = false }] bitvector_length(b), 1)
    by 1
    in inc) {
        if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(a, i), bitone) then result = $[overloaded { "name" = "^", "is_infix" = true }] xor_vec(result, $[overloaded { "name" = "<<", "is_infix" = true }] shiftl(zero_extend(mult_atom(2, $[overloaded { "name" = "__size", "is_infix" = false }] bitvector_length(b)), b), i));
        ()
    };
    result
}

val carryless_mulr : forall ('n : Int), 'n > 0.
  (bitvector('n), bitvector('n)) -> bitvector('n)

$[complete]
function carryless_mulr (a, b) = {
    var result : bits('n) = zeros($[overloaded { "name" = "__size", "is_infix" = false }] bitvector_length(b));
    foreach (i
    from 0
    to sub_atom($[overloaded { "name" = "__size", "is_infix" = false }] bitvector_length(result), 1)
    by 1
    in inc) {
        if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(a, i), bitone) then result = $[overloaded { "name" = "^", "is_infix" = true }] xor_vec(result, $[overloaded { "name" = ">>", "is_infix" = true }] shiftr(b, $[overloaded { "name" = "-", "is_infix" = true }] sub_atom($[overloaded { "name" = "-", "is_infix" = true }] sub_atom($[overloaded { "name" = "__size", "is_infix" = false }] bitvector_length(result), i), 1)));
        ()
    };
    result
}

val carryless_mul_reversed : forall ('n : Int), 'n > 0.
  (bitvector('n), bitvector('n)) -> bitvector('n)

$[complete]
function carryless_mul_reversed (a, b) = {
    let prod = carryless_mul(reverse_bits(a), reverse_bits(b));
    reverse_bits($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(prod, $[overloaded { "name" = "-", "is_infix" = true }] sub_atom($[overloaded { "name" = "__size", "is_infix" = false }] bitvector_length(b), 1), 0))
}

$[property]
val cmulr_equivalence : (bitvector(16), bitvector(16)) -> bool

$[complete]
$[property]
function cmulr_equivalence (a : bits(16), b : bits(16)) = {
    $[overloaded { "name" = "==", "is_infix" = true }] eq_bits(carryless_mul_reversed(a, b), carryless_mulr(a, b))
}

val rev8 : forall ('m : Int), ('m >= 0 & mod('m, 8) == 0).
  bitvector('m) -> bitvector('m)

$[complete]
function rev8 input = {
    var output : bits('m) = zeros($[overloaded { "name" = "__size", "is_infix" = false }] bitvector_length(input));
    foreach (i
    from 0
    to sub_atom($[overloaded { "name" = "__size", "is_infix" = false }] bitvector_length(output), 8)
    by 8
    in inc) {
        output[$[overloaded { "name" = "+", "is_infix" = true }] add_atom(i, 7) .. i] = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(input, $[overloaded { "name" = "-", "is_infix" = true }] sub_atom($[overloaded { "name" = "-", "is_infix" = true }] sub_atom($[overloaded { "name" = "__size", "is_infix" = false }] bitvector_length(output), i), 1), $[overloaded { "name" = "-", "is_infix" = true }] sub_atom($[overloaded { "name" = "-", "is_infix" = true }] sub_atom($[overloaded { "name" = "__size", "is_infix" = false }] bitvector_length(output), i), 8))
    };
    output
}

val count_ones : forall ('n : Int), 'n >= 0. bitvector('n) -> range(0, 'n)

$[complete]
function count_ones x = {
    var count : range(0, 'n) = 0;
    foreach (i
    from 0
    to sub_atom($[overloaded { "name" = "__size", "is_infix" = false }] bitvector_length(x), 1)
    by 1
    in inc) {
        if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(x, i), bitone) then {
            let new_count = $[overloaded { "name" = "+", "is_infix" = true }] add_atom(count, 1);
            assert($[overloaded { "name" = "<=", "is_infix" = true }] lteq_int(new_count, $[overloaded { "name" = "__size", "is_infix" = false }] bitvector_length(x)), "./core/arithmetic.sail:67.28-67.29");
            count = new_count
        };
        ()
    };
    count
}

$[undefined_gen "skip"]
$[bitfield]
struct RVFI_DII_Instruction_Packet = {bits : bitvector(64)}

val undefined_RVFI_DII_Instruction_Packet : unit -> RVFI_DII_Instruction_Packet

$[complete]
function undefined_RVFI_DII_Instruction_Packet () = struct RVFI_DII_Instruction_Packet { bits = undefined }

val Mk_RVFI_DII_Instruction_Packet : bitvector(64) -> RVFI_DII_Instruction_Packet

$[complete]
function Mk_RVFI_DII_Instruction_Packet v = struct RVFI_DII_Instruction_Packet { bits = v }

$[fix_location]
val _get_RVFI_DII_Instruction_Packet_bits : RVFI_DII_Instruction_Packet -> bitvector(64)

$[complete]
$[fix_location]
function _get_RVFI_DII_Instruction_Packet_bits v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, sub_atom(64, 1), 0)

$[fix_location]
val _update_RVFI_DII_Instruction_Packet_bits : (RVFI_DII_Instruction_Packet, bitvector(64)) -> RVFI_DII_Instruction_Packet

$[complete]
$[fix_location]
function _update_RVFI_DII_Instruction_Packet_bits (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, sub_atom(64, 1), 0, x) }

$[fix_location]
overload update_bits = {_update_RVFI_DII_Instruction_Packet_bits}

$[fix_location]
val _set_RVFI_DII_Instruction_Packet_bits : (register(RVFI_DII_Instruction_Packet), bitvector(64)) -> unit

$[complete]
$[fix_location]
function _set_RVFI_DII_Instruction_Packet_bits (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_RVFI_DII_Instruction_Packet_bits(r, v)
}

overload _mod_bits = {
  _get_RVFI_DII_Instruction_Packet_bits,
  _set_RVFI_DII_Instruction_Packet_bits
}

$[fix_location]
val _get_RVFI_DII_Instruction_Packet_padding : RVFI_DII_Instruction_Packet -> bitvector(8)

$[complete]
$[fix_location]
function _get_RVFI_DII_Instruction_Packet_padding v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 63, 56)

$[fix_location]
val _update_RVFI_DII_Instruction_Packet_padding : (RVFI_DII_Instruction_Packet, bitvector(8)) -> RVFI_DII_Instruction_Packet

$[complete]
$[fix_location]
function _update_RVFI_DII_Instruction_Packet_padding (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 63, 56, x) }

$[fix_location]
overload update_padding = {_update_RVFI_DII_Instruction_Packet_padding}

$[fix_location]
val _set_RVFI_DII_Instruction_Packet_padding : (register(RVFI_DII_Instruction_Packet), bitvector(8)) -> unit

$[complete]
$[fix_location]
function _set_RVFI_DII_Instruction_Packet_padding (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_RVFI_DII_Instruction_Packet_padding(r, v)
}

overload _mod_padding = {
  _get_RVFI_DII_Instruction_Packet_padding,
  _set_RVFI_DII_Instruction_Packet_padding
}

$[fix_location]
val _get_RVFI_DII_Instruction_Packet_rvfi_cmd : RVFI_DII_Instruction_Packet -> bitvector(8)

$[complete]
$[fix_location]
function _get_RVFI_DII_Instruction_Packet_rvfi_cmd v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 55, 48)

$[fix_location]
val _update_RVFI_DII_Instruction_Packet_rvfi_cmd : (RVFI_DII_Instruction_Packet, bitvector(8)) -> RVFI_DII_Instruction_Packet

$[complete]
$[fix_location]
function _update_RVFI_DII_Instruction_Packet_rvfi_cmd (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 55, 48, x) }

$[fix_location]
overload update_rvfi_cmd = {_update_RVFI_DII_Instruction_Packet_rvfi_cmd}

$[fix_location]
val _set_RVFI_DII_Instruction_Packet_rvfi_cmd : (register(RVFI_DII_Instruction_Packet), bitvector(8)) -> unit

$[complete]
$[fix_location]
function _set_RVFI_DII_Instruction_Packet_rvfi_cmd (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_RVFI_DII_Instruction_Packet_rvfi_cmd(r, v)
}

overload _mod_rvfi_cmd = {
  _get_RVFI_DII_Instruction_Packet_rvfi_cmd,
  _set_RVFI_DII_Instruction_Packet_rvfi_cmd
}

$[fix_location]
val _get_RVFI_DII_Instruction_Packet_rvfi_insn : RVFI_DII_Instruction_Packet -> bitvector(32)

$[complete]
$[fix_location]
function _get_RVFI_DII_Instruction_Packet_rvfi_insn v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 31, 0)

$[fix_location]
val _update_RVFI_DII_Instruction_Packet_rvfi_insn : (RVFI_DII_Instruction_Packet, bitvector(32)) -> RVFI_DII_Instruction_Packet

$[complete]
$[fix_location]
function _update_RVFI_DII_Instruction_Packet_rvfi_insn (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 31, 0, x) }

$[fix_location]
overload update_rvfi_insn = {_update_RVFI_DII_Instruction_Packet_rvfi_insn}

$[fix_location]
val _set_RVFI_DII_Instruction_Packet_rvfi_insn : (register(RVFI_DII_Instruction_Packet), bitvector(32)) -> unit

$[complete]
$[fix_location]
function _set_RVFI_DII_Instruction_Packet_rvfi_insn (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_RVFI_DII_Instruction_Packet_rvfi_insn(r, v)
}

overload _mod_rvfi_insn = {
  _get_RVFI_DII_Instruction_Packet_rvfi_insn,
  _set_RVFI_DII_Instruction_Packet_rvfi_insn
}

$[fix_location]
val _get_RVFI_DII_Instruction_Packet_rvfi_time : RVFI_DII_Instruction_Packet -> bitvector(16)

$[complete]
$[fix_location]
function _get_RVFI_DII_Instruction_Packet_rvfi_time v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 47, 32)

$[fix_location]
val _update_RVFI_DII_Instruction_Packet_rvfi_time : (RVFI_DII_Instruction_Packet, bitvector(16)) -> RVFI_DII_Instruction_Packet

$[complete]
$[fix_location]
function _update_RVFI_DII_Instruction_Packet_rvfi_time (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 47, 32, x) }

$[fix_location]
overload update_rvfi_time = {_update_RVFI_DII_Instruction_Packet_rvfi_time}

$[fix_location]
val _set_RVFI_DII_Instruction_Packet_rvfi_time : (register(RVFI_DII_Instruction_Packet), bitvector(16)) -> unit

$[complete]
$[fix_location]
function _set_RVFI_DII_Instruction_Packet_rvfi_time (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_RVFI_DII_Instruction_Packet_rvfi_time(r, v)
}

overload _mod_rvfi_time = {
  _get_RVFI_DII_Instruction_Packet_rvfi_time,
  _set_RVFI_DII_Instruction_Packet_rvfi_time
}

register rvfi_instruction : RVFI_DII_Instruction_Packet

val rvfi_set_instr_packet : bitvector(64) -> unit

$[complete]
function rvfi_set_instr_packet p = rvfi_instruction = Mk_RVFI_DII_Instruction_Packet(p)

val rvfi_get_cmd : unit -> bitvector(8)

$[complete]
function rvfi_get_cmd () = _get_RVFI_DII_Instruction_Packet_rvfi_cmd(rvfi_instruction)

val rvfi_get_insn : unit -> bitvector(32)

$[complete]
function rvfi_get_insn () = _get_RVFI_DII_Instruction_Packet_rvfi_insn(rvfi_instruction)

val print_instr_packet : bitvector(64) -> unit

$[complete]
function print_instr_packet bs = {
    let p = Mk_RVFI_DII_Instruction_Packet(bs);
    print_bits("command ", _get_RVFI_DII_Instruction_Packet_rvfi_cmd(p));
    print_bits("instruction ", _get_RVFI_DII_Instruction_Packet_rvfi_insn(p))
}

$[undefined_gen "skip"]
$[bitfield]
struct RVFI_DII_Execution_Packet_InstMetaData = {bits : bitvector(192)}

val undefined_RVFI_DII_Execution_Packet_InstMetaData : unit -> RVFI_DII_Execution_Packet_InstMetaData

$[complete]
function undefined_RVFI_DII_Execution_Packet_InstMetaData () = struct RVFI_DII_Execution_Packet_InstMetaData { bits = undefined }

val Mk_RVFI_DII_Execution_Packet_InstMetaData : bitvector(192) -> RVFI_DII_Execution_Packet_InstMetaData

$[complete]
function Mk_RVFI_DII_Execution_Packet_InstMetaData v = struct RVFI_DII_Execution_Packet_InstMetaData { bits = v }

$[fix_location]
val _get_RVFI_DII_Execution_Packet_InstMetaData_bits : RVFI_DII_Execution_Packet_InstMetaData -> bitvector(192)

$[complete]
$[fix_location]
function _get_RVFI_DII_Execution_Packet_InstMetaData_bits v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, sub_atom(192, 1), 0)

$[fix_location]
val _update_RVFI_DII_Execution_Packet_InstMetaData_bits : (RVFI_DII_Execution_Packet_InstMetaData, bitvector(192)) -> RVFI_DII_Execution_Packet_InstMetaData

$[complete]
$[fix_location]
function _update_RVFI_DII_Execution_Packet_InstMetaData_bits (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, sub_atom(192, 1), 0, x) }

$[fix_location]
overload update_bits = {_update_RVFI_DII_Execution_Packet_InstMetaData_bits}

$[fix_location]
val _set_RVFI_DII_Execution_Packet_InstMetaData_bits : (register(RVFI_DII_Execution_Packet_InstMetaData), bitvector(192)) -> unit

$[complete]
$[fix_location]
function _set_RVFI_DII_Execution_Packet_InstMetaData_bits (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_RVFI_DII_Execution_Packet_InstMetaData_bits(r, v)
}

overload _mod_bits = {
  _get_RVFI_DII_Execution_Packet_InstMetaData_bits,
  _set_RVFI_DII_Execution_Packet_InstMetaData_bits
}

$[fix_location]
val _get_RVFI_DII_Execution_Packet_InstMetaData_padding : RVFI_DII_Execution_Packet_InstMetaData -> bitvector(16)

$[complete]
$[fix_location]
function _get_RVFI_DII_Execution_Packet_InstMetaData_padding v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 191, 176)

$[fix_location]
val _update_RVFI_DII_Execution_Packet_InstMetaData_padding : (RVFI_DII_Execution_Packet_InstMetaData, bitvector(16)) -> RVFI_DII_Execution_Packet_InstMetaData

$[complete]
$[fix_location]
function _update_RVFI_DII_Execution_Packet_InstMetaData_padding (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 191, 176, x) }

$[fix_location]
overload update_padding = {
  _update_RVFI_DII_Execution_Packet_InstMetaData_padding
}

$[fix_location]
val _set_RVFI_DII_Execution_Packet_InstMetaData_padding : (register(RVFI_DII_Execution_Packet_InstMetaData), bitvector(16)) -> unit

$[complete]
$[fix_location]
function _set_RVFI_DII_Execution_Packet_InstMetaData_padding (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_RVFI_DII_Execution_Packet_InstMetaData_padding(r, v)
}

overload _mod_padding = {
  _get_RVFI_DII_Execution_Packet_InstMetaData_padding,
  _set_RVFI_DII_Execution_Packet_InstMetaData_padding
}

$[fix_location]
val _get_RVFI_DII_Execution_Packet_InstMetaData_rvfi_halt : RVFI_DII_Execution_Packet_InstMetaData -> bitvector(8)

$[complete]
$[fix_location]
function _get_RVFI_DII_Execution_Packet_InstMetaData_rvfi_halt v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 143, 136)

$[fix_location]
val _update_RVFI_DII_Execution_Packet_InstMetaData_rvfi_halt : (RVFI_DII_Execution_Packet_InstMetaData, bitvector(8)) -> RVFI_DII_Execution_Packet_InstMetaData

$[complete]
$[fix_location]
function _update_RVFI_DII_Execution_Packet_InstMetaData_rvfi_halt (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 143, 136, x) }

$[fix_location]
overload update_rvfi_halt = {
  _update_RVFI_DII_Execution_Packet_InstMetaData_rvfi_halt
}

$[fix_location]
val _set_RVFI_DII_Execution_Packet_InstMetaData_rvfi_halt : (register(RVFI_DII_Execution_Packet_InstMetaData), bitvector(8)) -> unit

$[complete]
$[fix_location]
function _set_RVFI_DII_Execution_Packet_InstMetaData_rvfi_halt (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_RVFI_DII_Execution_Packet_InstMetaData_rvfi_halt(r, v)
}

overload _mod_rvfi_halt = {
  _get_RVFI_DII_Execution_Packet_InstMetaData_rvfi_halt,
  _set_RVFI_DII_Execution_Packet_InstMetaData_rvfi_halt
}

$[fix_location]
val _get_RVFI_DII_Execution_Packet_InstMetaData_rvfi_insn : RVFI_DII_Execution_Packet_InstMetaData -> bitvector(64)

$[complete]
$[fix_location]
function _get_RVFI_DII_Execution_Packet_InstMetaData_rvfi_insn v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 127, 64)

$[fix_location]
val _update_RVFI_DII_Execution_Packet_InstMetaData_rvfi_insn : (RVFI_DII_Execution_Packet_InstMetaData, bitvector(64)) -> RVFI_DII_Execution_Packet_InstMetaData

$[complete]
$[fix_location]
function _update_RVFI_DII_Execution_Packet_InstMetaData_rvfi_insn (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 127, 64, x) }

$[fix_location]
overload update_rvfi_insn = {
  _update_RVFI_DII_Execution_Packet_InstMetaData_rvfi_insn
}

$[fix_location]
val _set_RVFI_DII_Execution_Packet_InstMetaData_rvfi_insn : (register(RVFI_DII_Execution_Packet_InstMetaData), bitvector(64)) -> unit

$[complete]
$[fix_location]
function _set_RVFI_DII_Execution_Packet_InstMetaData_rvfi_insn (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_RVFI_DII_Execution_Packet_InstMetaData_rvfi_insn(r, v)
}

overload _mod_rvfi_insn = {
  _get_RVFI_DII_Execution_Packet_InstMetaData_rvfi_insn,
  _set_RVFI_DII_Execution_Packet_InstMetaData_rvfi_insn
}

$[fix_location]
val _get_RVFI_DII_Execution_Packet_InstMetaData_rvfi_intr : RVFI_DII_Execution_Packet_InstMetaData -> bitvector(8)

$[complete]
$[fix_location]
function _get_RVFI_DII_Execution_Packet_InstMetaData_rvfi_intr v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 151, 144)

$[fix_location]
val _update_RVFI_DII_Execution_Packet_InstMetaData_rvfi_intr : (RVFI_DII_Execution_Packet_InstMetaData, bitvector(8)) -> RVFI_DII_Execution_Packet_InstMetaData

$[complete]
$[fix_location]
function _update_RVFI_DII_Execution_Packet_InstMetaData_rvfi_intr (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 151, 144, x) }

$[fix_location]
overload update_rvfi_intr = {
  _update_RVFI_DII_Execution_Packet_InstMetaData_rvfi_intr
}

$[fix_location]
val _set_RVFI_DII_Execution_Packet_InstMetaData_rvfi_intr : (register(RVFI_DII_Execution_Packet_InstMetaData), bitvector(8)) -> unit

$[complete]
$[fix_location]
function _set_RVFI_DII_Execution_Packet_InstMetaData_rvfi_intr (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_RVFI_DII_Execution_Packet_InstMetaData_rvfi_intr(r, v)
}

overload _mod_rvfi_intr = {
  _get_RVFI_DII_Execution_Packet_InstMetaData_rvfi_intr,
  _set_RVFI_DII_Execution_Packet_InstMetaData_rvfi_intr
}

$[fix_location]
val _get_RVFI_DII_Execution_Packet_InstMetaData_rvfi_ixl : RVFI_DII_Execution_Packet_InstMetaData -> bitvector(8)

$[complete]
$[fix_location]
function _get_RVFI_DII_Execution_Packet_InstMetaData_rvfi_ixl v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 167, 160)

$[fix_location]
val _update_RVFI_DII_Execution_Packet_InstMetaData_rvfi_ixl : (RVFI_DII_Execution_Packet_InstMetaData, bitvector(8)) -> RVFI_DII_Execution_Packet_InstMetaData

$[complete]
$[fix_location]
function _update_RVFI_DII_Execution_Packet_InstMetaData_rvfi_ixl (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 167, 160, x) }

$[fix_location]
overload update_rvfi_ixl = {
  _update_RVFI_DII_Execution_Packet_InstMetaData_rvfi_ixl
}

$[fix_location]
val _set_RVFI_DII_Execution_Packet_InstMetaData_rvfi_ixl : (register(RVFI_DII_Execution_Packet_InstMetaData), bitvector(8)) -> unit

$[complete]
$[fix_location]
function _set_RVFI_DII_Execution_Packet_InstMetaData_rvfi_ixl (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_RVFI_DII_Execution_Packet_InstMetaData_rvfi_ixl(r, v)
}

overload _mod_rvfi_ixl = {
  _get_RVFI_DII_Execution_Packet_InstMetaData_rvfi_ixl,
  _set_RVFI_DII_Execution_Packet_InstMetaData_rvfi_ixl
}

$[fix_location]
val _get_RVFI_DII_Execution_Packet_InstMetaData_rvfi_mode : RVFI_DII_Execution_Packet_InstMetaData -> bitvector(8)

$[complete]
$[fix_location]
function _get_RVFI_DII_Execution_Packet_InstMetaData_rvfi_mode v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 159, 152)

$[fix_location]
val _update_RVFI_DII_Execution_Packet_InstMetaData_rvfi_mode : (RVFI_DII_Execution_Packet_InstMetaData, bitvector(8)) -> RVFI_DII_Execution_Packet_InstMetaData

$[complete]
$[fix_location]
function _update_RVFI_DII_Execution_Packet_InstMetaData_rvfi_mode (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 159, 152, x) }

$[fix_location]
overload update_rvfi_mode = {
  _update_RVFI_DII_Execution_Packet_InstMetaData_rvfi_mode
}

$[fix_location]
val _set_RVFI_DII_Execution_Packet_InstMetaData_rvfi_mode : (register(RVFI_DII_Execution_Packet_InstMetaData), bitvector(8)) -> unit

$[complete]
$[fix_location]
function _set_RVFI_DII_Execution_Packet_InstMetaData_rvfi_mode (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_RVFI_DII_Execution_Packet_InstMetaData_rvfi_mode(r, v)
}

overload _mod_rvfi_mode = {
  _get_RVFI_DII_Execution_Packet_InstMetaData_rvfi_mode,
  _set_RVFI_DII_Execution_Packet_InstMetaData_rvfi_mode
}

$[fix_location]
val _get_RVFI_DII_Execution_Packet_InstMetaData_rvfi_order : RVFI_DII_Execution_Packet_InstMetaData -> bitvector(64)

$[complete]
$[fix_location]
function _get_RVFI_DII_Execution_Packet_InstMetaData_rvfi_order v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 63, 0)

$[fix_location]
val _update_RVFI_DII_Execution_Packet_InstMetaData_rvfi_order : (RVFI_DII_Execution_Packet_InstMetaData, bitvector(64)) -> RVFI_DII_Execution_Packet_InstMetaData

$[complete]
$[fix_location]
function _update_RVFI_DII_Execution_Packet_InstMetaData_rvfi_order (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 63, 0, x) }

$[fix_location]
overload update_rvfi_order = {
  _update_RVFI_DII_Execution_Packet_InstMetaData_rvfi_order
}

$[fix_location]
val _set_RVFI_DII_Execution_Packet_InstMetaData_rvfi_order : (register(RVFI_DII_Execution_Packet_InstMetaData), bitvector(64)) -> unit

$[complete]
$[fix_location]
function _set_RVFI_DII_Execution_Packet_InstMetaData_rvfi_order (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_RVFI_DII_Execution_Packet_InstMetaData_rvfi_order(r, v)
}

overload _mod_rvfi_order = {
  _get_RVFI_DII_Execution_Packet_InstMetaData_rvfi_order,
  _set_RVFI_DII_Execution_Packet_InstMetaData_rvfi_order
}

$[fix_location]
val _get_RVFI_DII_Execution_Packet_InstMetaData_rvfi_trap : RVFI_DII_Execution_Packet_InstMetaData -> bitvector(8)

$[complete]
$[fix_location]
function _get_RVFI_DII_Execution_Packet_InstMetaData_rvfi_trap v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 135, 128)

$[fix_location]
val _update_RVFI_DII_Execution_Packet_InstMetaData_rvfi_trap : (RVFI_DII_Execution_Packet_InstMetaData, bitvector(8)) -> RVFI_DII_Execution_Packet_InstMetaData

$[complete]
$[fix_location]
function _update_RVFI_DII_Execution_Packet_InstMetaData_rvfi_trap (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 135, 128, x) }

$[fix_location]
overload update_rvfi_trap = {
  _update_RVFI_DII_Execution_Packet_InstMetaData_rvfi_trap
}

$[fix_location]
val _set_RVFI_DII_Execution_Packet_InstMetaData_rvfi_trap : (register(RVFI_DII_Execution_Packet_InstMetaData), bitvector(8)) -> unit

$[complete]
$[fix_location]
function _set_RVFI_DII_Execution_Packet_InstMetaData_rvfi_trap (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_RVFI_DII_Execution_Packet_InstMetaData_rvfi_trap(r, v)
}

overload _mod_rvfi_trap = {
  _get_RVFI_DII_Execution_Packet_InstMetaData_rvfi_trap,
  _set_RVFI_DII_Execution_Packet_InstMetaData_rvfi_trap
}

$[fix_location]
val _get_RVFI_DII_Execution_Packet_InstMetaData_rvfi_valid : RVFI_DII_Execution_Packet_InstMetaData -> bitvector(8)

$[complete]
$[fix_location]
function _get_RVFI_DII_Execution_Packet_InstMetaData_rvfi_valid v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 175, 168)

$[fix_location]
val _update_RVFI_DII_Execution_Packet_InstMetaData_rvfi_valid : (RVFI_DII_Execution_Packet_InstMetaData, bitvector(8)) -> RVFI_DII_Execution_Packet_InstMetaData

$[complete]
$[fix_location]
function _update_RVFI_DII_Execution_Packet_InstMetaData_rvfi_valid (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 175, 168, x) }

$[fix_location]
overload update_rvfi_valid = {
  _update_RVFI_DII_Execution_Packet_InstMetaData_rvfi_valid
}

$[fix_location]
val _set_RVFI_DII_Execution_Packet_InstMetaData_rvfi_valid : (register(RVFI_DII_Execution_Packet_InstMetaData), bitvector(8)) -> unit

$[complete]
$[fix_location]
function _set_RVFI_DII_Execution_Packet_InstMetaData_rvfi_valid (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_RVFI_DII_Execution_Packet_InstMetaData_rvfi_valid(r, v)
}

overload _mod_rvfi_valid = {
  _get_RVFI_DII_Execution_Packet_InstMetaData_rvfi_valid,
  _set_RVFI_DII_Execution_Packet_InstMetaData_rvfi_valid
}

$[undefined_gen "skip"]
$[bitfield]
struct RVFI_DII_Execution_Packet_PC = {bits : bitvector(128)}

val undefined_RVFI_DII_Execution_Packet_PC : unit -> RVFI_DII_Execution_Packet_PC

$[complete]
function undefined_RVFI_DII_Execution_Packet_PC () = struct RVFI_DII_Execution_Packet_PC { bits = undefined }

val Mk_RVFI_DII_Execution_Packet_PC : bitvector(128) -> RVFI_DII_Execution_Packet_PC

$[complete]
function Mk_RVFI_DII_Execution_Packet_PC v = struct RVFI_DII_Execution_Packet_PC { bits = v }

$[fix_location]
val _get_RVFI_DII_Execution_Packet_PC_bits : RVFI_DII_Execution_Packet_PC -> bitvector(128)

$[complete]
$[fix_location]
function _get_RVFI_DII_Execution_Packet_PC_bits v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, sub_atom(128, 1), 0)

$[fix_location]
val _update_RVFI_DII_Execution_Packet_PC_bits : (RVFI_DII_Execution_Packet_PC, bitvector(128)) -> RVFI_DII_Execution_Packet_PC

$[complete]
$[fix_location]
function _update_RVFI_DII_Execution_Packet_PC_bits (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, sub_atom(128, 1), 0, x) }

$[fix_location]
overload update_bits = {_update_RVFI_DII_Execution_Packet_PC_bits}

$[fix_location]
val _set_RVFI_DII_Execution_Packet_PC_bits : (register(RVFI_DII_Execution_Packet_PC), bitvector(128)) -> unit

$[complete]
$[fix_location]
function _set_RVFI_DII_Execution_Packet_PC_bits (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_RVFI_DII_Execution_Packet_PC_bits(r, v)
}

overload _mod_bits = {
  _get_RVFI_DII_Execution_Packet_PC_bits,
  _set_RVFI_DII_Execution_Packet_PC_bits
}

$[fix_location]
val _get_RVFI_DII_Execution_Packet_PC_rvfi_pc_rdata : RVFI_DII_Execution_Packet_PC -> bitvector(64)

$[complete]
$[fix_location]
function _get_RVFI_DII_Execution_Packet_PC_rvfi_pc_rdata v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 63, 0)

$[fix_location]
val _update_RVFI_DII_Execution_Packet_PC_rvfi_pc_rdata : (RVFI_DII_Execution_Packet_PC, bitvector(64)) -> RVFI_DII_Execution_Packet_PC

$[complete]
$[fix_location]
function _update_RVFI_DII_Execution_Packet_PC_rvfi_pc_rdata (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 63, 0, x) }

$[fix_location]
overload update_rvfi_pc_rdata = {
  _update_RVFI_DII_Execution_Packet_PC_rvfi_pc_rdata
}

$[fix_location]
val _set_RVFI_DII_Execution_Packet_PC_rvfi_pc_rdata : (register(RVFI_DII_Execution_Packet_PC), bitvector(64)) -> unit

$[complete]
$[fix_location]
function _set_RVFI_DII_Execution_Packet_PC_rvfi_pc_rdata (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_RVFI_DII_Execution_Packet_PC_rvfi_pc_rdata(r, v)
}

overload _mod_rvfi_pc_rdata = {
  _get_RVFI_DII_Execution_Packet_PC_rvfi_pc_rdata,
  _set_RVFI_DII_Execution_Packet_PC_rvfi_pc_rdata
}

$[fix_location]
val _get_RVFI_DII_Execution_Packet_PC_rvfi_pc_wdata : RVFI_DII_Execution_Packet_PC -> bitvector(64)

$[complete]
$[fix_location]
function _get_RVFI_DII_Execution_Packet_PC_rvfi_pc_wdata v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 127, 64)

$[fix_location]
val _update_RVFI_DII_Execution_Packet_PC_rvfi_pc_wdata : (RVFI_DII_Execution_Packet_PC, bitvector(64)) -> RVFI_DII_Execution_Packet_PC

$[complete]
$[fix_location]
function _update_RVFI_DII_Execution_Packet_PC_rvfi_pc_wdata (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 127, 64, x) }

$[fix_location]
overload update_rvfi_pc_wdata = {
  _update_RVFI_DII_Execution_Packet_PC_rvfi_pc_wdata
}

$[fix_location]
val _set_RVFI_DII_Execution_Packet_PC_rvfi_pc_wdata : (register(RVFI_DII_Execution_Packet_PC), bitvector(64)) -> unit

$[complete]
$[fix_location]
function _set_RVFI_DII_Execution_Packet_PC_rvfi_pc_wdata (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_RVFI_DII_Execution_Packet_PC_rvfi_pc_wdata(r, v)
}

overload _mod_rvfi_pc_wdata = {
  _get_RVFI_DII_Execution_Packet_PC_rvfi_pc_wdata,
  _set_RVFI_DII_Execution_Packet_PC_rvfi_pc_wdata
}

$[undefined_gen "skip"]
$[bitfield]
struct RVFI_DII_Execution_Packet_Ext_Integer = {bits : bitvector(320)}

val undefined_RVFI_DII_Execution_Packet_Ext_Integer : unit -> RVFI_DII_Execution_Packet_Ext_Integer

$[complete]
function undefined_RVFI_DII_Execution_Packet_Ext_Integer () = struct RVFI_DII_Execution_Packet_Ext_Integer { bits = undefined }

val Mk_RVFI_DII_Execution_Packet_Ext_Integer : bitvector(320) -> RVFI_DII_Execution_Packet_Ext_Integer

$[complete]
function Mk_RVFI_DII_Execution_Packet_Ext_Integer v = struct RVFI_DII_Execution_Packet_Ext_Integer { bits = v }

$[fix_location]
val _get_RVFI_DII_Execution_Packet_Ext_Integer_bits : RVFI_DII_Execution_Packet_Ext_Integer -> bitvector(320)

$[complete]
$[fix_location]
function _get_RVFI_DII_Execution_Packet_Ext_Integer_bits v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, sub_atom(320, 1), 0)

$[fix_location]
val _update_RVFI_DII_Execution_Packet_Ext_Integer_bits : (RVFI_DII_Execution_Packet_Ext_Integer, bitvector(320)) -> RVFI_DII_Execution_Packet_Ext_Integer

$[complete]
$[fix_location]
function _update_RVFI_DII_Execution_Packet_Ext_Integer_bits (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, sub_atom(320, 1), 0, x) }

$[fix_location]
overload update_bits = {_update_RVFI_DII_Execution_Packet_Ext_Integer_bits}

$[fix_location]
val _set_RVFI_DII_Execution_Packet_Ext_Integer_bits : (register(RVFI_DII_Execution_Packet_Ext_Integer), bitvector(320)) -> unit

$[complete]
$[fix_location]
function _set_RVFI_DII_Execution_Packet_Ext_Integer_bits (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_RVFI_DII_Execution_Packet_Ext_Integer_bits(r, v)
}

overload _mod_bits = {
  _get_RVFI_DII_Execution_Packet_Ext_Integer_bits,
  _set_RVFI_DII_Execution_Packet_Ext_Integer_bits
}

$[fix_location]
val _get_RVFI_DII_Execution_Packet_Ext_Integer_magic : RVFI_DII_Execution_Packet_Ext_Integer -> bitvector(64)

$[complete]
$[fix_location]
function _get_RVFI_DII_Execution_Packet_Ext_Integer_magic v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 63, 0)

$[fix_location]
val _update_RVFI_DII_Execution_Packet_Ext_Integer_magic : (RVFI_DII_Execution_Packet_Ext_Integer, bitvector(64)) -> RVFI_DII_Execution_Packet_Ext_Integer

$[complete]
$[fix_location]
function _update_RVFI_DII_Execution_Packet_Ext_Integer_magic (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 63, 0, x) }

$[fix_location]
overload update_magic = {_update_RVFI_DII_Execution_Packet_Ext_Integer_magic}

$[fix_location]
val _set_RVFI_DII_Execution_Packet_Ext_Integer_magic : (register(RVFI_DII_Execution_Packet_Ext_Integer), bitvector(64)) -> unit

$[complete]
$[fix_location]
function _set_RVFI_DII_Execution_Packet_Ext_Integer_magic (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_RVFI_DII_Execution_Packet_Ext_Integer_magic(r, v)
}

overload _mod_magic = {
  _get_RVFI_DII_Execution_Packet_Ext_Integer_magic,
  _set_RVFI_DII_Execution_Packet_Ext_Integer_magic
}

$[fix_location]
val _get_RVFI_DII_Execution_Packet_Ext_Integer_padding : RVFI_DII_Execution_Packet_Ext_Integer -> bitvector(40)

$[complete]
$[fix_location]
function _get_RVFI_DII_Execution_Packet_Ext_Integer_padding v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 319, 280)

$[fix_location]
val _update_RVFI_DII_Execution_Packet_Ext_Integer_padding : (RVFI_DII_Execution_Packet_Ext_Integer, bitvector(40)) -> RVFI_DII_Execution_Packet_Ext_Integer

$[complete]
$[fix_location]
function _update_RVFI_DII_Execution_Packet_Ext_Integer_padding (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 319, 280, x) }

$[fix_location]
overload update_padding = {
  _update_RVFI_DII_Execution_Packet_Ext_Integer_padding
}

$[fix_location]
val _set_RVFI_DII_Execution_Packet_Ext_Integer_padding : (register(RVFI_DII_Execution_Packet_Ext_Integer), bitvector(40)) -> unit

$[complete]
$[fix_location]
function _set_RVFI_DII_Execution_Packet_Ext_Integer_padding (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_RVFI_DII_Execution_Packet_Ext_Integer_padding(r, v)
}

overload _mod_padding = {
  _get_RVFI_DII_Execution_Packet_Ext_Integer_padding,
  _set_RVFI_DII_Execution_Packet_Ext_Integer_padding
}

$[fix_location]
val _get_RVFI_DII_Execution_Packet_Ext_Integer_rvfi_rd_addr : RVFI_DII_Execution_Packet_Ext_Integer -> bitvector(8)

$[complete]
$[fix_location]
function _get_RVFI_DII_Execution_Packet_Ext_Integer_rvfi_rd_addr v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 263, 256)

$[fix_location]
val _update_RVFI_DII_Execution_Packet_Ext_Integer_rvfi_rd_addr : (RVFI_DII_Execution_Packet_Ext_Integer, bitvector(8)) -> RVFI_DII_Execution_Packet_Ext_Integer

$[complete]
$[fix_location]
function _update_RVFI_DII_Execution_Packet_Ext_Integer_rvfi_rd_addr (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 263, 256, x) }

$[fix_location]
overload update_rvfi_rd_addr = {
  _update_RVFI_DII_Execution_Packet_Ext_Integer_rvfi_rd_addr
}

$[fix_location]
val _set_RVFI_DII_Execution_Packet_Ext_Integer_rvfi_rd_addr : (register(RVFI_DII_Execution_Packet_Ext_Integer), bitvector(8)) -> unit

$[complete]
$[fix_location]
function _set_RVFI_DII_Execution_Packet_Ext_Integer_rvfi_rd_addr (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_RVFI_DII_Execution_Packet_Ext_Integer_rvfi_rd_addr(r, v)
}

overload _mod_rvfi_rd_addr = {
  _get_RVFI_DII_Execution_Packet_Ext_Integer_rvfi_rd_addr,
  _set_RVFI_DII_Execution_Packet_Ext_Integer_rvfi_rd_addr
}

$[fix_location]
val _get_RVFI_DII_Execution_Packet_Ext_Integer_rvfi_rd_wdata : RVFI_DII_Execution_Packet_Ext_Integer -> bitvector(64)

$[complete]
$[fix_location]
function _get_RVFI_DII_Execution_Packet_Ext_Integer_rvfi_rd_wdata v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 127, 64)

$[fix_location]
val _update_RVFI_DII_Execution_Packet_Ext_Integer_rvfi_rd_wdata : (RVFI_DII_Execution_Packet_Ext_Integer, bitvector(64)) -> RVFI_DII_Execution_Packet_Ext_Integer

$[complete]
$[fix_location]
function _update_RVFI_DII_Execution_Packet_Ext_Integer_rvfi_rd_wdata (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 127, 64, x) }

$[fix_location]
overload update_rvfi_rd_wdata = {
  _update_RVFI_DII_Execution_Packet_Ext_Integer_rvfi_rd_wdata
}

$[fix_location]
val _set_RVFI_DII_Execution_Packet_Ext_Integer_rvfi_rd_wdata : (register(RVFI_DII_Execution_Packet_Ext_Integer), bitvector(64)) -> unit

$[complete]
$[fix_location]
function _set_RVFI_DII_Execution_Packet_Ext_Integer_rvfi_rd_wdata (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_RVFI_DII_Execution_Packet_Ext_Integer_rvfi_rd_wdata(r, v)
}

overload _mod_rvfi_rd_wdata = {
  _get_RVFI_DII_Execution_Packet_Ext_Integer_rvfi_rd_wdata,
  _set_RVFI_DII_Execution_Packet_Ext_Integer_rvfi_rd_wdata
}

$[fix_location]
val _get_RVFI_DII_Execution_Packet_Ext_Integer_rvfi_rs1_addr : RVFI_DII_Execution_Packet_Ext_Integer -> bitvector(8)

$[complete]
$[fix_location]
function _get_RVFI_DII_Execution_Packet_Ext_Integer_rvfi_rs1_addr v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 271, 264)

$[fix_location]
val _update_RVFI_DII_Execution_Packet_Ext_Integer_rvfi_rs1_addr : (RVFI_DII_Execution_Packet_Ext_Integer, bitvector(8)) -> RVFI_DII_Execution_Packet_Ext_Integer

$[complete]
$[fix_location]
function _update_RVFI_DII_Execution_Packet_Ext_Integer_rvfi_rs1_addr (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 271, 264, x) }

$[fix_location]
overload update_rvfi_rs1_addr = {
  _update_RVFI_DII_Execution_Packet_Ext_Integer_rvfi_rs1_addr
}

$[fix_location]
val _set_RVFI_DII_Execution_Packet_Ext_Integer_rvfi_rs1_addr : (register(RVFI_DII_Execution_Packet_Ext_Integer), bitvector(8)) -> unit

$[complete]
$[fix_location]
function _set_RVFI_DII_Execution_Packet_Ext_Integer_rvfi_rs1_addr (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_RVFI_DII_Execution_Packet_Ext_Integer_rvfi_rs1_addr(r, v)
}

overload _mod_rvfi_rs1_addr = {
  _get_RVFI_DII_Execution_Packet_Ext_Integer_rvfi_rs1_addr,
  _set_RVFI_DII_Execution_Packet_Ext_Integer_rvfi_rs1_addr
}

$[fix_location]
val _get_RVFI_DII_Execution_Packet_Ext_Integer_rvfi_rs1_rdata : RVFI_DII_Execution_Packet_Ext_Integer -> bitvector(64)

$[complete]
$[fix_location]
function _get_RVFI_DII_Execution_Packet_Ext_Integer_rvfi_rs1_rdata v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 191, 128)

$[fix_location]
val _update_RVFI_DII_Execution_Packet_Ext_Integer_rvfi_rs1_rdata : (RVFI_DII_Execution_Packet_Ext_Integer, bitvector(64)) -> RVFI_DII_Execution_Packet_Ext_Integer

$[complete]
$[fix_location]
function _update_RVFI_DII_Execution_Packet_Ext_Integer_rvfi_rs1_rdata (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 191, 128, x) }

$[fix_location]
overload update_rvfi_rs1_rdata = {
  _update_RVFI_DII_Execution_Packet_Ext_Integer_rvfi_rs1_rdata
}

$[fix_location]
val _set_RVFI_DII_Execution_Packet_Ext_Integer_rvfi_rs1_rdata : (register(RVFI_DII_Execution_Packet_Ext_Integer), bitvector(64)) -> unit

$[complete]
$[fix_location]
function _set_RVFI_DII_Execution_Packet_Ext_Integer_rvfi_rs1_rdata (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_RVFI_DII_Execution_Packet_Ext_Integer_rvfi_rs1_rdata(r, v)
}

overload _mod_rvfi_rs1_rdata = {
  _get_RVFI_DII_Execution_Packet_Ext_Integer_rvfi_rs1_rdata,
  _set_RVFI_DII_Execution_Packet_Ext_Integer_rvfi_rs1_rdata
}

$[fix_location]
val _get_RVFI_DII_Execution_Packet_Ext_Integer_rvfi_rs2_addr : RVFI_DII_Execution_Packet_Ext_Integer -> bitvector(8)

$[complete]
$[fix_location]
function _get_RVFI_DII_Execution_Packet_Ext_Integer_rvfi_rs2_addr v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 279, 272)

$[fix_location]
val _update_RVFI_DII_Execution_Packet_Ext_Integer_rvfi_rs2_addr : (RVFI_DII_Execution_Packet_Ext_Integer, bitvector(8)) -> RVFI_DII_Execution_Packet_Ext_Integer

$[complete]
$[fix_location]
function _update_RVFI_DII_Execution_Packet_Ext_Integer_rvfi_rs2_addr (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 279, 272, x) }

$[fix_location]
overload update_rvfi_rs2_addr = {
  _update_RVFI_DII_Execution_Packet_Ext_Integer_rvfi_rs2_addr
}

$[fix_location]
val _set_RVFI_DII_Execution_Packet_Ext_Integer_rvfi_rs2_addr : (register(RVFI_DII_Execution_Packet_Ext_Integer), bitvector(8)) -> unit

$[complete]
$[fix_location]
function _set_RVFI_DII_Execution_Packet_Ext_Integer_rvfi_rs2_addr (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_RVFI_DII_Execution_Packet_Ext_Integer_rvfi_rs2_addr(r, v)
}

overload _mod_rvfi_rs2_addr = {
  _get_RVFI_DII_Execution_Packet_Ext_Integer_rvfi_rs2_addr,
  _set_RVFI_DII_Execution_Packet_Ext_Integer_rvfi_rs2_addr
}

$[fix_location]
val _get_RVFI_DII_Execution_Packet_Ext_Integer_rvfi_rs2_rdata : RVFI_DII_Execution_Packet_Ext_Integer -> bitvector(64)

$[complete]
$[fix_location]
function _get_RVFI_DII_Execution_Packet_Ext_Integer_rvfi_rs2_rdata v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 255, 192)

$[fix_location]
val _update_RVFI_DII_Execution_Packet_Ext_Integer_rvfi_rs2_rdata : (RVFI_DII_Execution_Packet_Ext_Integer, bitvector(64)) -> RVFI_DII_Execution_Packet_Ext_Integer

$[complete]
$[fix_location]
function _update_RVFI_DII_Execution_Packet_Ext_Integer_rvfi_rs2_rdata (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 255, 192, x) }

$[fix_location]
overload update_rvfi_rs2_rdata = {
  _update_RVFI_DII_Execution_Packet_Ext_Integer_rvfi_rs2_rdata
}

$[fix_location]
val _set_RVFI_DII_Execution_Packet_Ext_Integer_rvfi_rs2_rdata : (register(RVFI_DII_Execution_Packet_Ext_Integer), bitvector(64)) -> unit

$[complete]
$[fix_location]
function _set_RVFI_DII_Execution_Packet_Ext_Integer_rvfi_rs2_rdata (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_RVFI_DII_Execution_Packet_Ext_Integer_rvfi_rs2_rdata(r, v)
}

overload _mod_rvfi_rs2_rdata = {
  _get_RVFI_DII_Execution_Packet_Ext_Integer_rvfi_rs2_rdata,
  _set_RVFI_DII_Execution_Packet_Ext_Integer_rvfi_rs2_rdata
}

$[undefined_gen "skip"]
$[bitfield]
struct RVFI_DII_Execution_Packet_Ext_MemAccess = {bits : bitvector(704)}

val undefined_RVFI_DII_Execution_Packet_Ext_MemAccess : unit -> RVFI_DII_Execution_Packet_Ext_MemAccess

$[complete]
function undefined_RVFI_DII_Execution_Packet_Ext_MemAccess () = struct RVFI_DII_Execution_Packet_Ext_MemAccess { bits = undefined }

val Mk_RVFI_DII_Execution_Packet_Ext_MemAccess : bitvector(704) -> RVFI_DII_Execution_Packet_Ext_MemAccess

$[complete]
function Mk_RVFI_DII_Execution_Packet_Ext_MemAccess v = struct RVFI_DII_Execution_Packet_Ext_MemAccess { bits = v }

$[fix_location]
val _get_RVFI_DII_Execution_Packet_Ext_MemAccess_bits : RVFI_DII_Execution_Packet_Ext_MemAccess -> bitvector(704)

$[complete]
$[fix_location]
function _get_RVFI_DII_Execution_Packet_Ext_MemAccess_bits v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, sub_atom(704, 1), 0)

$[fix_location]
val _update_RVFI_DII_Execution_Packet_Ext_MemAccess_bits : (RVFI_DII_Execution_Packet_Ext_MemAccess, bitvector(704)) -> RVFI_DII_Execution_Packet_Ext_MemAccess

$[complete]
$[fix_location]
function _update_RVFI_DII_Execution_Packet_Ext_MemAccess_bits (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, sub_atom(704, 1), 0, x) }

$[fix_location]
overload update_bits = {_update_RVFI_DII_Execution_Packet_Ext_MemAccess_bits}

$[fix_location]
val _set_RVFI_DII_Execution_Packet_Ext_MemAccess_bits : (register(RVFI_DII_Execution_Packet_Ext_MemAccess), bitvector(704)) -> unit

$[complete]
$[fix_location]
function _set_RVFI_DII_Execution_Packet_Ext_MemAccess_bits (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_RVFI_DII_Execution_Packet_Ext_MemAccess_bits(r, v)
}

overload _mod_bits = {
  _get_RVFI_DII_Execution_Packet_Ext_MemAccess_bits,
  _set_RVFI_DII_Execution_Packet_Ext_MemAccess_bits
}

$[fix_location]
val _get_RVFI_DII_Execution_Packet_Ext_MemAccess_magic : RVFI_DII_Execution_Packet_Ext_MemAccess -> bitvector(64)

$[complete]
$[fix_location]
function _get_RVFI_DII_Execution_Packet_Ext_MemAccess_magic v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 63, 0)

$[fix_location]
val _update_RVFI_DII_Execution_Packet_Ext_MemAccess_magic : (RVFI_DII_Execution_Packet_Ext_MemAccess, bitvector(64)) -> RVFI_DII_Execution_Packet_Ext_MemAccess

$[complete]
$[fix_location]
function _update_RVFI_DII_Execution_Packet_Ext_MemAccess_magic (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 63, 0, x) }

$[fix_location]
overload update_magic = {_update_RVFI_DII_Execution_Packet_Ext_MemAccess_magic}

$[fix_location]
val _set_RVFI_DII_Execution_Packet_Ext_MemAccess_magic : (register(RVFI_DII_Execution_Packet_Ext_MemAccess), bitvector(64)) -> unit

$[complete]
$[fix_location]
function _set_RVFI_DII_Execution_Packet_Ext_MemAccess_magic (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_RVFI_DII_Execution_Packet_Ext_MemAccess_magic(r, v)
}

overload _mod_magic = {
  _get_RVFI_DII_Execution_Packet_Ext_MemAccess_magic,
  _set_RVFI_DII_Execution_Packet_Ext_MemAccess_magic
}

$[fix_location]
val _get_RVFI_DII_Execution_Packet_Ext_MemAccess_rvfi_mem_addr : RVFI_DII_Execution_Packet_Ext_MemAccess -> bitvector(64)

$[complete]
$[fix_location]
function _get_RVFI_DII_Execution_Packet_Ext_MemAccess_rvfi_mem_addr v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 703, 640)

$[fix_location]
val _update_RVFI_DII_Execution_Packet_Ext_MemAccess_rvfi_mem_addr : (RVFI_DII_Execution_Packet_Ext_MemAccess, bitvector(64)) -> RVFI_DII_Execution_Packet_Ext_MemAccess

$[complete]
$[fix_location]
function _update_RVFI_DII_Execution_Packet_Ext_MemAccess_rvfi_mem_addr (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 703, 640, x) }

$[fix_location]
overload update_rvfi_mem_addr = {
  _update_RVFI_DII_Execution_Packet_Ext_MemAccess_rvfi_mem_addr
}

$[fix_location]
val _set_RVFI_DII_Execution_Packet_Ext_MemAccess_rvfi_mem_addr : (register(RVFI_DII_Execution_Packet_Ext_MemAccess), bitvector(64)) -> unit

$[complete]
$[fix_location]
function _set_RVFI_DII_Execution_Packet_Ext_MemAccess_rvfi_mem_addr (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_RVFI_DII_Execution_Packet_Ext_MemAccess_rvfi_mem_addr(r, v)
}

overload _mod_rvfi_mem_addr = {
  _get_RVFI_DII_Execution_Packet_Ext_MemAccess_rvfi_mem_addr,
  _set_RVFI_DII_Execution_Packet_Ext_MemAccess_rvfi_mem_addr
}

$[fix_location]
val _get_RVFI_DII_Execution_Packet_Ext_MemAccess_rvfi_mem_rdata : RVFI_DII_Execution_Packet_Ext_MemAccess -> bitvector(256)

$[complete]
$[fix_location]
function _get_RVFI_DII_Execution_Packet_Ext_MemAccess_rvfi_mem_rdata v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 319, 64)

$[fix_location]
val _update_RVFI_DII_Execution_Packet_Ext_MemAccess_rvfi_mem_rdata : (RVFI_DII_Execution_Packet_Ext_MemAccess, bitvector(256)) -> RVFI_DII_Execution_Packet_Ext_MemAccess

$[complete]
$[fix_location]
function _update_RVFI_DII_Execution_Packet_Ext_MemAccess_rvfi_mem_rdata (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 319, 64, x) }

$[fix_location]
overload update_rvfi_mem_rdata = {
  _update_RVFI_DII_Execution_Packet_Ext_MemAccess_rvfi_mem_rdata
}

$[fix_location]
val _set_RVFI_DII_Execution_Packet_Ext_MemAccess_rvfi_mem_rdata : (register(RVFI_DII_Execution_Packet_Ext_MemAccess), bitvector(256)) -> unit

$[complete]
$[fix_location]
function _set_RVFI_DII_Execution_Packet_Ext_MemAccess_rvfi_mem_rdata (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_RVFI_DII_Execution_Packet_Ext_MemAccess_rvfi_mem_rdata(r, v)
}

overload _mod_rvfi_mem_rdata = {
  _get_RVFI_DII_Execution_Packet_Ext_MemAccess_rvfi_mem_rdata,
  _set_RVFI_DII_Execution_Packet_Ext_MemAccess_rvfi_mem_rdata
}

$[fix_location]
val _get_RVFI_DII_Execution_Packet_Ext_MemAccess_rvfi_mem_rmask : RVFI_DII_Execution_Packet_Ext_MemAccess -> bitvector(32)

$[complete]
$[fix_location]
function _get_RVFI_DII_Execution_Packet_Ext_MemAccess_rvfi_mem_rmask v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 607, 576)

$[fix_location]
val _update_RVFI_DII_Execution_Packet_Ext_MemAccess_rvfi_mem_rmask : (RVFI_DII_Execution_Packet_Ext_MemAccess, bitvector(32)) -> RVFI_DII_Execution_Packet_Ext_MemAccess

$[complete]
$[fix_location]
function _update_RVFI_DII_Execution_Packet_Ext_MemAccess_rvfi_mem_rmask (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 607, 576, x) }

$[fix_location]
overload update_rvfi_mem_rmask = {
  _update_RVFI_DII_Execution_Packet_Ext_MemAccess_rvfi_mem_rmask
}

$[fix_location]
val _set_RVFI_DII_Execution_Packet_Ext_MemAccess_rvfi_mem_rmask : (register(RVFI_DII_Execution_Packet_Ext_MemAccess), bitvector(32)) -> unit

$[complete]
$[fix_location]
function _set_RVFI_DII_Execution_Packet_Ext_MemAccess_rvfi_mem_rmask (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_RVFI_DII_Execution_Packet_Ext_MemAccess_rvfi_mem_rmask(r, v)
}

overload _mod_rvfi_mem_rmask = {
  _get_RVFI_DII_Execution_Packet_Ext_MemAccess_rvfi_mem_rmask,
  _set_RVFI_DII_Execution_Packet_Ext_MemAccess_rvfi_mem_rmask
}

$[fix_location]
val _get_RVFI_DII_Execution_Packet_Ext_MemAccess_rvfi_mem_wdata : RVFI_DII_Execution_Packet_Ext_MemAccess -> bitvector(256)

$[complete]
$[fix_location]
function _get_RVFI_DII_Execution_Packet_Ext_MemAccess_rvfi_mem_wdata v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 575, 320)

$[fix_location]
val _update_RVFI_DII_Execution_Packet_Ext_MemAccess_rvfi_mem_wdata : (RVFI_DII_Execution_Packet_Ext_MemAccess, bitvector(256)) -> RVFI_DII_Execution_Packet_Ext_MemAccess

$[complete]
$[fix_location]
function _update_RVFI_DII_Execution_Packet_Ext_MemAccess_rvfi_mem_wdata (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 575, 320, x) }

$[fix_location]
overload update_rvfi_mem_wdata = {
  _update_RVFI_DII_Execution_Packet_Ext_MemAccess_rvfi_mem_wdata
}

$[fix_location]
val _set_RVFI_DII_Execution_Packet_Ext_MemAccess_rvfi_mem_wdata : (register(RVFI_DII_Execution_Packet_Ext_MemAccess), bitvector(256)) -> unit

$[complete]
$[fix_location]
function _set_RVFI_DII_Execution_Packet_Ext_MemAccess_rvfi_mem_wdata (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_RVFI_DII_Execution_Packet_Ext_MemAccess_rvfi_mem_wdata(r, v)
}

overload _mod_rvfi_mem_wdata = {
  _get_RVFI_DII_Execution_Packet_Ext_MemAccess_rvfi_mem_wdata,
  _set_RVFI_DII_Execution_Packet_Ext_MemAccess_rvfi_mem_wdata
}

$[fix_location]
val _get_RVFI_DII_Execution_Packet_Ext_MemAccess_rvfi_mem_wmask : RVFI_DII_Execution_Packet_Ext_MemAccess -> bitvector(32)

$[complete]
$[fix_location]
function _get_RVFI_DII_Execution_Packet_Ext_MemAccess_rvfi_mem_wmask v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 639, 608)

$[fix_location]
val _update_RVFI_DII_Execution_Packet_Ext_MemAccess_rvfi_mem_wmask : (RVFI_DII_Execution_Packet_Ext_MemAccess, bitvector(32)) -> RVFI_DII_Execution_Packet_Ext_MemAccess

$[complete]
$[fix_location]
function _update_RVFI_DII_Execution_Packet_Ext_MemAccess_rvfi_mem_wmask (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 639, 608, x) }

$[fix_location]
overload update_rvfi_mem_wmask = {
  _update_RVFI_DII_Execution_Packet_Ext_MemAccess_rvfi_mem_wmask
}

$[fix_location]
val _set_RVFI_DII_Execution_Packet_Ext_MemAccess_rvfi_mem_wmask : (register(RVFI_DII_Execution_Packet_Ext_MemAccess), bitvector(32)) -> unit

$[complete]
$[fix_location]
function _set_RVFI_DII_Execution_Packet_Ext_MemAccess_rvfi_mem_wmask (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_RVFI_DII_Execution_Packet_Ext_MemAccess_rvfi_mem_wmask(r, v)
}

overload _mod_rvfi_mem_wmask = {
  _get_RVFI_DII_Execution_Packet_Ext_MemAccess_rvfi_mem_wmask,
  _set_RVFI_DII_Execution_Packet_Ext_MemAccess_rvfi_mem_wmask
}

register rvfi_inst_data : RVFI_DII_Execution_Packet_InstMetaData

register rvfi_pc_data : RVFI_DII_Execution_Packet_PC

register rvfi_int_data : RVFI_DII_Execution_Packet_Ext_Integer

register rvfi_int_data_present : bool

register rvfi_mem_data : RVFI_DII_Execution_Packet_Ext_MemAccess

register rvfi_mem_data_present : bool

val rvfi_zero_exec_packet : unit -> unit

$[complete]
function rvfi_zero_exec_packet () = {
    rvfi_inst_data = Mk_RVFI_DII_Execution_Packet_InstMetaData(zeros(192));
    rvfi_pc_data = Mk_RVFI_DII_Execution_Packet_PC(zeros(128));
    rvfi_int_data = Mk_RVFI_DII_Execution_Packet_Ext_Integer(zeros(320));
    rvfi_int_data = $[overloaded { "name" = "update_magic", "is_infix" = false }] _update_RVFI_DII_Execution_Packet_Ext_Integer_magic(rvfi_int_data, 0x617461642d746e69);
    rvfi_int_data_present = false;
    rvfi_mem_data = Mk_RVFI_DII_Execution_Packet_Ext_MemAccess(zeros(704));
    rvfi_mem_data = $[overloaded { "name" = "update_magic", "is_infix" = false }] _update_RVFI_DII_Execution_Packet_Ext_MemAccess_magic(rvfi_mem_data, 0x617461642d6d656d);
    rvfi_mem_data_present = false
}

val rvfi_halt_exec_packet : unit -> unit

$[complete]
function rvfi_halt_exec_packet () = rvfi_inst_data.bits[143 .. 136] = 0x01

val rvfi_get_int_data : unit -> bitvector(320)

$[complete]
function rvfi_get_int_data () = {
    assert(rvfi_int_data_present, "reading uninitialized data");
    return(rvfi_int_data.bits)
}

val rvfi_get_mem_data : unit -> bitvector(704)

$[complete]
function rvfi_get_mem_data () = {
    assert(rvfi_mem_data_present, "reading uninitialized data");
    return(rvfi_mem_data.bits)
}

val rvfi_encode_width_mask : forall ('n : Int), (0 < 'n & 'n <= 32).
  int('n) -> bitvector(32)

$[complete]
function rvfi_encode_width_mask width = $[overloaded { "name" = ">>", "is_infix" = true }] shiftr(0xFFFFFFFF, $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(32, width))

val print_rvfi_exec : unit -> unit

$[complete]
function print_rvfi_exec () = {
    print_bits("rvfi_intr     : ", _get_RVFI_DII_Execution_Packet_InstMetaData_rvfi_intr(rvfi_inst_data));
    print_bits("rvfi_halt     : ", _get_RVFI_DII_Execution_Packet_InstMetaData_rvfi_halt(rvfi_inst_data));
    print_bits("rvfi_trap     : ", _get_RVFI_DII_Execution_Packet_InstMetaData_rvfi_trap(rvfi_inst_data));
    print_bits("rvfi_rd_addr  : ", _get_RVFI_DII_Execution_Packet_Ext_Integer_rvfi_rd_addr(rvfi_int_data));
    print_bits("rvfi_rs2_addr : ", _get_RVFI_DII_Execution_Packet_Ext_Integer_rvfi_rs2_addr(rvfi_int_data));
    print_bits("rvfi_rs1_addr : ", _get_RVFI_DII_Execution_Packet_Ext_Integer_rvfi_rs1_addr(rvfi_int_data));
    print_bits("rvfi_mem_wmask: ", _get_RVFI_DII_Execution_Packet_Ext_MemAccess_rvfi_mem_wmask(rvfi_mem_data));
    print_bits("rvfi_mem_rmask: ", _get_RVFI_DII_Execution_Packet_Ext_MemAccess_rvfi_mem_rmask(rvfi_mem_data));
    print_bits("rvfi_mem_wdata: ", _get_RVFI_DII_Execution_Packet_Ext_MemAccess_rvfi_mem_wdata(rvfi_mem_data));
    print_bits("rvfi_mem_rdata: ", _get_RVFI_DII_Execution_Packet_Ext_MemAccess_rvfi_mem_rdata(rvfi_mem_data));
    print_bits("rvfi_mem_addr : ", _get_RVFI_DII_Execution_Packet_Ext_MemAccess_rvfi_mem_addr(rvfi_mem_data));
    print_bits("rvfi_rd_wdata : ", _get_RVFI_DII_Execution_Packet_Ext_Integer_rvfi_rd_wdata(rvfi_int_data));
    print_bits("rvfi_rs2_data : ", _get_RVFI_DII_Execution_Packet_Ext_Integer_rvfi_rs2_rdata(rvfi_int_data));
    print_bits("rvfi_rs1_data : ", _get_RVFI_DII_Execution_Packet_Ext_Integer_rvfi_rs1_rdata(rvfi_int_data));
    print_bits("rvfi_insn     : ", _get_RVFI_DII_Execution_Packet_InstMetaData_rvfi_insn(rvfi_inst_data));
    print_bits("rvfi_pc_wdata : ", _get_RVFI_DII_Execution_Packet_PC_rvfi_pc_wdata(rvfi_pc_data));
    print_bits("rvfi_pc_rdata : ", _get_RVFI_DII_Execution_Packet_PC_rvfi_pc_rdata(rvfi_pc_data));
    print_bits("rvfi_order    : ", _get_RVFI_DII_Execution_Packet_InstMetaData_rvfi_order(rvfi_inst_data))
}

val rvfi_write : forall ('n : Int), (0 < 'n & 'n <= max_mem_access).
  (bitvector(xlen), int('n), bitvector(8 * 'n)) -> unit

$[complete]
function rvfi_write (paddr, width, value) = {
    rvfi_mem_data.bits[703 .. 640] = zero_extend(64, paddr);
    rvfi_mem_data_present = true;
    if $[overloaded { "name" = "<=", "is_infix" = true }] lteq_int(width, 16) then {
        rvfi_mem_data.bits[575 .. 320] = sail_zero_extend(value, 256);
        rvfi_mem_data.bits[639 .. 608] = rvfi_encode_width_mask(width)
    } else {
        internal_error("./core/rvfi_dii.sail", 232, "Expected at most 16 bytes here!")
    }
}

val rvfi_read : forall ('n : Int), 'n > 0.
  (bitvector(xlen), int('n), bitvector(8 * 'n)) -> unit

$[complete]
function rvfi_read (paddr, width, value) = {
    rvfi_mem_data.bits[703 .. 640] = zero_extend(64, paddr);
    rvfi_mem_data_present = true;
    if $[overloaded { "name" = "<=", "is_infix" = true }] lteq_int(width, 16) then {
        rvfi_mem_data.bits[319 .. 64] = sail_zero_extend(value, 256);
        rvfi_mem_data.bits[607 .. 576] = rvfi_encode_width_mask(width)
    } else {
        internal_error("./core/rvfi_dii.sail", 245, "Expected at most 16 bytes here!")
    }
}

val rvfi_mem_exception : bitvector(xlen) -> unit

$[complete]
function rvfi_mem_exception paddr = {
    rvfi_mem_data.bits[703 .. 640] = zero_extend(64, paddr);
    rvfi_mem_data_present = true
}

val rvfi_wX : forall ('n : Int), (0 <= 'n & 'n < 32).
  (int('n), bitvector(xlen)) -> unit

$[complete]
function rvfi_wX (r, v) = {
    rvfi_int_data.bits[127 .. 64] = zero_extend(64, v);
    rvfi_int_data.bits[263 .. 256] = to_bits(8, r);
    rvfi_int_data_present = true
}

val rvfi_trap : unit -> unit

$[complete]
function rvfi_trap () = rvfi_inst_data.bits[135 .. 128] = 0x01

$[undefined_gen "skip"]
$[bitfield]
struct RVFI_DII_Execution_Packet_V1 = {bits : bitvector(704)}

val undefined_RVFI_DII_Execution_Packet_V1 : unit -> RVFI_DII_Execution_Packet_V1

$[complete]
function undefined_RVFI_DII_Execution_Packet_V1 () = struct RVFI_DII_Execution_Packet_V1 { bits = undefined }

val Mk_RVFI_DII_Execution_Packet_V1 : bitvector(704) -> RVFI_DII_Execution_Packet_V1

$[complete]
function Mk_RVFI_DII_Execution_Packet_V1 v = struct RVFI_DII_Execution_Packet_V1 { bits = v }

$[fix_location]
val _get_RVFI_DII_Execution_Packet_V1_bits : RVFI_DII_Execution_Packet_V1 -> bitvector(704)

$[complete]
$[fix_location]
function _get_RVFI_DII_Execution_Packet_V1_bits v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, sub_atom(704, 1), 0)

$[fix_location]
val _update_RVFI_DII_Execution_Packet_V1_bits : (RVFI_DII_Execution_Packet_V1, bitvector(704)) -> RVFI_DII_Execution_Packet_V1

$[complete]
$[fix_location]
function _update_RVFI_DII_Execution_Packet_V1_bits (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, sub_atom(704, 1), 0, x) }

$[fix_location]
overload update_bits = {_update_RVFI_DII_Execution_Packet_V1_bits}

$[fix_location]
val _set_RVFI_DII_Execution_Packet_V1_bits : (register(RVFI_DII_Execution_Packet_V1), bitvector(704)) -> unit

$[complete]
$[fix_location]
function _set_RVFI_DII_Execution_Packet_V1_bits (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_RVFI_DII_Execution_Packet_V1_bits(r, v)
}

overload _mod_bits = {
  _get_RVFI_DII_Execution_Packet_V1_bits,
  _set_RVFI_DII_Execution_Packet_V1_bits
}

$[fix_location]
val _get_RVFI_DII_Execution_Packet_V1_rvfi_halt : RVFI_DII_Execution_Packet_V1 -> bitvector(8)

$[complete]
$[fix_location]
function _get_RVFI_DII_Execution_Packet_V1_rvfi_halt v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 695, 688)

$[fix_location]
val _update_RVFI_DII_Execution_Packet_V1_rvfi_halt : (RVFI_DII_Execution_Packet_V1, bitvector(8)) -> RVFI_DII_Execution_Packet_V1

$[complete]
$[fix_location]
function _update_RVFI_DII_Execution_Packet_V1_rvfi_halt (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 695, 688, x) }

$[fix_location]
overload update_rvfi_halt = {_update_RVFI_DII_Execution_Packet_V1_rvfi_halt}

$[fix_location]
val _set_RVFI_DII_Execution_Packet_V1_rvfi_halt : (register(RVFI_DII_Execution_Packet_V1), bitvector(8)) -> unit

$[complete]
$[fix_location]
function _set_RVFI_DII_Execution_Packet_V1_rvfi_halt (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_RVFI_DII_Execution_Packet_V1_rvfi_halt(r, v)
}

overload _mod_rvfi_halt = {
  _get_RVFI_DII_Execution_Packet_V1_rvfi_halt,
  _set_RVFI_DII_Execution_Packet_V1_rvfi_halt
}

$[fix_location]
val _get_RVFI_DII_Execution_Packet_V1_rvfi_insn : RVFI_DII_Execution_Packet_V1 -> bitvector(64)

$[complete]
$[fix_location]
function _get_RVFI_DII_Execution_Packet_V1_rvfi_insn v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 255, 192)

$[fix_location]
val _update_RVFI_DII_Execution_Packet_V1_rvfi_insn : (RVFI_DII_Execution_Packet_V1, bitvector(64)) -> RVFI_DII_Execution_Packet_V1

$[complete]
$[fix_location]
function _update_RVFI_DII_Execution_Packet_V1_rvfi_insn (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 255, 192, x) }

$[fix_location]
overload update_rvfi_insn = {_update_RVFI_DII_Execution_Packet_V1_rvfi_insn}

$[fix_location]
val _set_RVFI_DII_Execution_Packet_V1_rvfi_insn : (register(RVFI_DII_Execution_Packet_V1), bitvector(64)) -> unit

$[complete]
$[fix_location]
function _set_RVFI_DII_Execution_Packet_V1_rvfi_insn (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_RVFI_DII_Execution_Packet_V1_rvfi_insn(r, v)
}

overload _mod_rvfi_insn = {
  _get_RVFI_DII_Execution_Packet_V1_rvfi_insn,
  _set_RVFI_DII_Execution_Packet_V1_rvfi_insn
}

$[fix_location]
val _get_RVFI_DII_Execution_Packet_V1_rvfi_intr : RVFI_DII_Execution_Packet_V1 -> bitvector(8)

$[complete]
$[fix_location]
function _get_RVFI_DII_Execution_Packet_V1_rvfi_intr v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 703, 696)

$[fix_location]
val _update_RVFI_DII_Execution_Packet_V1_rvfi_intr : (RVFI_DII_Execution_Packet_V1, bitvector(8)) -> RVFI_DII_Execution_Packet_V1

$[complete]
$[fix_location]
function _update_RVFI_DII_Execution_Packet_V1_rvfi_intr (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 703, 696, x) }

$[fix_location]
overload update_rvfi_intr = {_update_RVFI_DII_Execution_Packet_V1_rvfi_intr}

$[fix_location]
val _set_RVFI_DII_Execution_Packet_V1_rvfi_intr : (register(RVFI_DII_Execution_Packet_V1), bitvector(8)) -> unit

$[complete]
$[fix_location]
function _set_RVFI_DII_Execution_Packet_V1_rvfi_intr (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_RVFI_DII_Execution_Packet_V1_rvfi_intr(r, v)
}

overload _mod_rvfi_intr = {
  _get_RVFI_DII_Execution_Packet_V1_rvfi_intr,
  _set_RVFI_DII_Execution_Packet_V1_rvfi_intr
}

$[fix_location]
val _get_RVFI_DII_Execution_Packet_V1_rvfi_mem_addr : RVFI_DII_Execution_Packet_V1 -> bitvector(64)

$[complete]
$[fix_location]
function _get_RVFI_DII_Execution_Packet_V1_rvfi_mem_addr v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 511, 448)

$[fix_location]
val _update_RVFI_DII_Execution_Packet_V1_rvfi_mem_addr : (RVFI_DII_Execution_Packet_V1, bitvector(64)) -> RVFI_DII_Execution_Packet_V1

$[complete]
$[fix_location]
function _update_RVFI_DII_Execution_Packet_V1_rvfi_mem_addr (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 511, 448, x) }

$[fix_location]
overload update_rvfi_mem_addr = {
  _update_RVFI_DII_Execution_Packet_V1_rvfi_mem_addr
}

$[fix_location]
val _set_RVFI_DII_Execution_Packet_V1_rvfi_mem_addr : (register(RVFI_DII_Execution_Packet_V1), bitvector(64)) -> unit

$[complete]
$[fix_location]
function _set_RVFI_DII_Execution_Packet_V1_rvfi_mem_addr (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_RVFI_DII_Execution_Packet_V1_rvfi_mem_addr(r, v)
}

overload _mod_rvfi_mem_addr = {
  _get_RVFI_DII_Execution_Packet_V1_rvfi_mem_addr,
  _set_RVFI_DII_Execution_Packet_V1_rvfi_mem_addr
}

$[fix_location]
val _get_RVFI_DII_Execution_Packet_V1_rvfi_mem_rdata : RVFI_DII_Execution_Packet_V1 -> bitvector(64)

$[complete]
$[fix_location]
function _get_RVFI_DII_Execution_Packet_V1_rvfi_mem_rdata v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 575, 512)

$[fix_location]
val _update_RVFI_DII_Execution_Packet_V1_rvfi_mem_rdata : (RVFI_DII_Execution_Packet_V1, bitvector(64)) -> RVFI_DII_Execution_Packet_V1

$[complete]
$[fix_location]
function _update_RVFI_DII_Execution_Packet_V1_rvfi_mem_rdata (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 575, 512, x) }

$[fix_location]
overload update_rvfi_mem_rdata = {
  _update_RVFI_DII_Execution_Packet_V1_rvfi_mem_rdata
}

$[fix_location]
val _set_RVFI_DII_Execution_Packet_V1_rvfi_mem_rdata : (register(RVFI_DII_Execution_Packet_V1), bitvector(64)) -> unit

$[complete]
$[fix_location]
function _set_RVFI_DII_Execution_Packet_V1_rvfi_mem_rdata (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_RVFI_DII_Execution_Packet_V1_rvfi_mem_rdata(r, v)
}

overload _mod_rvfi_mem_rdata = {
  _get_RVFI_DII_Execution_Packet_V1_rvfi_mem_rdata,
  _set_RVFI_DII_Execution_Packet_V1_rvfi_mem_rdata
}

$[fix_location]
val _get_RVFI_DII_Execution_Packet_V1_rvfi_mem_rmask : RVFI_DII_Execution_Packet_V1 -> bitvector(8)

$[complete]
$[fix_location]
function _get_RVFI_DII_Execution_Packet_V1_rvfi_mem_rmask v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 647, 640)

$[fix_location]
val _update_RVFI_DII_Execution_Packet_V1_rvfi_mem_rmask : (RVFI_DII_Execution_Packet_V1, bitvector(8)) -> RVFI_DII_Execution_Packet_V1

$[complete]
$[fix_location]
function _update_RVFI_DII_Execution_Packet_V1_rvfi_mem_rmask (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 647, 640, x) }

$[fix_location]
overload update_rvfi_mem_rmask = {
  _update_RVFI_DII_Execution_Packet_V1_rvfi_mem_rmask
}

$[fix_location]
val _set_RVFI_DII_Execution_Packet_V1_rvfi_mem_rmask : (register(RVFI_DII_Execution_Packet_V1), bitvector(8)) -> unit

$[complete]
$[fix_location]
function _set_RVFI_DII_Execution_Packet_V1_rvfi_mem_rmask (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_RVFI_DII_Execution_Packet_V1_rvfi_mem_rmask(r, v)
}

overload _mod_rvfi_mem_rmask = {
  _get_RVFI_DII_Execution_Packet_V1_rvfi_mem_rmask,
  _set_RVFI_DII_Execution_Packet_V1_rvfi_mem_rmask
}

$[fix_location]
val _get_RVFI_DII_Execution_Packet_V1_rvfi_mem_wdata : RVFI_DII_Execution_Packet_V1 -> bitvector(64)

$[complete]
$[fix_location]
function _get_RVFI_DII_Execution_Packet_V1_rvfi_mem_wdata v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 639, 576)

$[fix_location]
val _update_RVFI_DII_Execution_Packet_V1_rvfi_mem_wdata : (RVFI_DII_Execution_Packet_V1, bitvector(64)) -> RVFI_DII_Execution_Packet_V1

$[complete]
$[fix_location]
function _update_RVFI_DII_Execution_Packet_V1_rvfi_mem_wdata (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 639, 576, x) }

$[fix_location]
overload update_rvfi_mem_wdata = {
  _update_RVFI_DII_Execution_Packet_V1_rvfi_mem_wdata
}

$[fix_location]
val _set_RVFI_DII_Execution_Packet_V1_rvfi_mem_wdata : (register(RVFI_DII_Execution_Packet_V1), bitvector(64)) -> unit

$[complete]
$[fix_location]
function _set_RVFI_DII_Execution_Packet_V1_rvfi_mem_wdata (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_RVFI_DII_Execution_Packet_V1_rvfi_mem_wdata(r, v)
}

overload _mod_rvfi_mem_wdata = {
  _get_RVFI_DII_Execution_Packet_V1_rvfi_mem_wdata,
  _set_RVFI_DII_Execution_Packet_V1_rvfi_mem_wdata
}

$[fix_location]
val _get_RVFI_DII_Execution_Packet_V1_rvfi_mem_wmask : RVFI_DII_Execution_Packet_V1 -> bitvector(8)

$[complete]
$[fix_location]
function _get_RVFI_DII_Execution_Packet_V1_rvfi_mem_wmask v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 655, 648)

$[fix_location]
val _update_RVFI_DII_Execution_Packet_V1_rvfi_mem_wmask : (RVFI_DII_Execution_Packet_V1, bitvector(8)) -> RVFI_DII_Execution_Packet_V1

$[complete]
$[fix_location]
function _update_RVFI_DII_Execution_Packet_V1_rvfi_mem_wmask (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 655, 648, x) }

$[fix_location]
overload update_rvfi_mem_wmask = {
  _update_RVFI_DII_Execution_Packet_V1_rvfi_mem_wmask
}

$[fix_location]
val _set_RVFI_DII_Execution_Packet_V1_rvfi_mem_wmask : (register(RVFI_DII_Execution_Packet_V1), bitvector(8)) -> unit

$[complete]
$[fix_location]
function _set_RVFI_DII_Execution_Packet_V1_rvfi_mem_wmask (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_RVFI_DII_Execution_Packet_V1_rvfi_mem_wmask(r, v)
}

overload _mod_rvfi_mem_wmask = {
  _get_RVFI_DII_Execution_Packet_V1_rvfi_mem_wmask,
  _set_RVFI_DII_Execution_Packet_V1_rvfi_mem_wmask
}

$[fix_location]
val _get_RVFI_DII_Execution_Packet_V1_rvfi_order : RVFI_DII_Execution_Packet_V1 -> bitvector(64)

$[complete]
$[fix_location]
function _get_RVFI_DII_Execution_Packet_V1_rvfi_order v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 63, 0)

$[fix_location]
val _update_RVFI_DII_Execution_Packet_V1_rvfi_order : (RVFI_DII_Execution_Packet_V1, bitvector(64)) -> RVFI_DII_Execution_Packet_V1

$[complete]
$[fix_location]
function _update_RVFI_DII_Execution_Packet_V1_rvfi_order (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 63, 0, x) }

$[fix_location]
overload update_rvfi_order = {_update_RVFI_DII_Execution_Packet_V1_rvfi_order}

$[fix_location]
val _set_RVFI_DII_Execution_Packet_V1_rvfi_order : (register(RVFI_DII_Execution_Packet_V1), bitvector(64)) -> unit

$[complete]
$[fix_location]
function _set_RVFI_DII_Execution_Packet_V1_rvfi_order (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_RVFI_DII_Execution_Packet_V1_rvfi_order(r, v)
}

overload _mod_rvfi_order = {
  _get_RVFI_DII_Execution_Packet_V1_rvfi_order,
  _set_RVFI_DII_Execution_Packet_V1_rvfi_order
}

$[fix_location]
val _get_RVFI_DII_Execution_Packet_V1_rvfi_pc_rdata : RVFI_DII_Execution_Packet_V1 -> bitvector(64)

$[complete]
$[fix_location]
function _get_RVFI_DII_Execution_Packet_V1_rvfi_pc_rdata v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 127, 64)

$[fix_location]
val _update_RVFI_DII_Execution_Packet_V1_rvfi_pc_rdata : (RVFI_DII_Execution_Packet_V1, bitvector(64)) -> RVFI_DII_Execution_Packet_V1

$[complete]
$[fix_location]
function _update_RVFI_DII_Execution_Packet_V1_rvfi_pc_rdata (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 127, 64, x) }

$[fix_location]
overload update_rvfi_pc_rdata = {
  _update_RVFI_DII_Execution_Packet_V1_rvfi_pc_rdata
}

$[fix_location]
val _set_RVFI_DII_Execution_Packet_V1_rvfi_pc_rdata : (register(RVFI_DII_Execution_Packet_V1), bitvector(64)) -> unit

$[complete]
$[fix_location]
function _set_RVFI_DII_Execution_Packet_V1_rvfi_pc_rdata (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_RVFI_DII_Execution_Packet_V1_rvfi_pc_rdata(r, v)
}

overload _mod_rvfi_pc_rdata = {
  _get_RVFI_DII_Execution_Packet_V1_rvfi_pc_rdata,
  _set_RVFI_DII_Execution_Packet_V1_rvfi_pc_rdata
}

$[fix_location]
val _get_RVFI_DII_Execution_Packet_V1_rvfi_pc_wdata : RVFI_DII_Execution_Packet_V1 -> bitvector(64)

$[complete]
$[fix_location]
function _get_RVFI_DII_Execution_Packet_V1_rvfi_pc_wdata v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 191, 128)

$[fix_location]
val _update_RVFI_DII_Execution_Packet_V1_rvfi_pc_wdata : (RVFI_DII_Execution_Packet_V1, bitvector(64)) -> RVFI_DII_Execution_Packet_V1

$[complete]
$[fix_location]
function _update_RVFI_DII_Execution_Packet_V1_rvfi_pc_wdata (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 191, 128, x) }

$[fix_location]
overload update_rvfi_pc_wdata = {
  _update_RVFI_DII_Execution_Packet_V1_rvfi_pc_wdata
}

$[fix_location]
val _set_RVFI_DII_Execution_Packet_V1_rvfi_pc_wdata : (register(RVFI_DII_Execution_Packet_V1), bitvector(64)) -> unit

$[complete]
$[fix_location]
function _set_RVFI_DII_Execution_Packet_V1_rvfi_pc_wdata (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_RVFI_DII_Execution_Packet_V1_rvfi_pc_wdata(r, v)
}

overload _mod_rvfi_pc_wdata = {
  _get_RVFI_DII_Execution_Packet_V1_rvfi_pc_wdata,
  _set_RVFI_DII_Execution_Packet_V1_rvfi_pc_wdata
}

$[fix_location]
val _get_RVFI_DII_Execution_Packet_V1_rvfi_rd_addr : RVFI_DII_Execution_Packet_V1 -> bitvector(8)

$[complete]
$[fix_location]
function _get_RVFI_DII_Execution_Packet_V1_rvfi_rd_addr v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 679, 672)

$[fix_location]
val _update_RVFI_DII_Execution_Packet_V1_rvfi_rd_addr : (RVFI_DII_Execution_Packet_V1, bitvector(8)) -> RVFI_DII_Execution_Packet_V1

$[complete]
$[fix_location]
function _update_RVFI_DII_Execution_Packet_V1_rvfi_rd_addr (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 679, 672, x) }

$[fix_location]
overload update_rvfi_rd_addr = {
  _update_RVFI_DII_Execution_Packet_V1_rvfi_rd_addr
}

$[fix_location]
val _set_RVFI_DII_Execution_Packet_V1_rvfi_rd_addr : (register(RVFI_DII_Execution_Packet_V1), bitvector(8)) -> unit

$[complete]
$[fix_location]
function _set_RVFI_DII_Execution_Packet_V1_rvfi_rd_addr (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_RVFI_DII_Execution_Packet_V1_rvfi_rd_addr(r, v)
}

overload _mod_rvfi_rd_addr = {
  _get_RVFI_DII_Execution_Packet_V1_rvfi_rd_addr,
  _set_RVFI_DII_Execution_Packet_V1_rvfi_rd_addr
}

$[fix_location]
val _get_RVFI_DII_Execution_Packet_V1_rvfi_rd_wdata : RVFI_DII_Execution_Packet_V1 -> bitvector(64)

$[complete]
$[fix_location]
function _get_RVFI_DII_Execution_Packet_V1_rvfi_rd_wdata v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 447, 384)

$[fix_location]
val _update_RVFI_DII_Execution_Packet_V1_rvfi_rd_wdata : (RVFI_DII_Execution_Packet_V1, bitvector(64)) -> RVFI_DII_Execution_Packet_V1

$[complete]
$[fix_location]
function _update_RVFI_DII_Execution_Packet_V1_rvfi_rd_wdata (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 447, 384, x) }

$[fix_location]
overload update_rvfi_rd_wdata = {
  _update_RVFI_DII_Execution_Packet_V1_rvfi_rd_wdata
}

$[fix_location]
val _set_RVFI_DII_Execution_Packet_V1_rvfi_rd_wdata : (register(RVFI_DII_Execution_Packet_V1), bitvector(64)) -> unit

$[complete]
$[fix_location]
function _set_RVFI_DII_Execution_Packet_V1_rvfi_rd_wdata (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_RVFI_DII_Execution_Packet_V1_rvfi_rd_wdata(r, v)
}

overload _mod_rvfi_rd_wdata = {
  _get_RVFI_DII_Execution_Packet_V1_rvfi_rd_wdata,
  _set_RVFI_DII_Execution_Packet_V1_rvfi_rd_wdata
}

$[fix_location]
val _get_RVFI_DII_Execution_Packet_V1_rvfi_rs1_addr : RVFI_DII_Execution_Packet_V1 -> bitvector(8)

$[complete]
$[fix_location]
function _get_RVFI_DII_Execution_Packet_V1_rvfi_rs1_addr v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 663, 656)

$[fix_location]
val _update_RVFI_DII_Execution_Packet_V1_rvfi_rs1_addr : (RVFI_DII_Execution_Packet_V1, bitvector(8)) -> RVFI_DII_Execution_Packet_V1

$[complete]
$[fix_location]
function _update_RVFI_DII_Execution_Packet_V1_rvfi_rs1_addr (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 663, 656, x) }

$[fix_location]
overload update_rvfi_rs1_addr = {
  _update_RVFI_DII_Execution_Packet_V1_rvfi_rs1_addr
}

$[fix_location]
val _set_RVFI_DII_Execution_Packet_V1_rvfi_rs1_addr : (register(RVFI_DII_Execution_Packet_V1), bitvector(8)) -> unit

$[complete]
$[fix_location]
function _set_RVFI_DII_Execution_Packet_V1_rvfi_rs1_addr (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_RVFI_DII_Execution_Packet_V1_rvfi_rs1_addr(r, v)
}

overload _mod_rvfi_rs1_addr = {
  _get_RVFI_DII_Execution_Packet_V1_rvfi_rs1_addr,
  _set_RVFI_DII_Execution_Packet_V1_rvfi_rs1_addr
}

$[fix_location]
val _get_RVFI_DII_Execution_Packet_V1_rvfi_rs1_data : RVFI_DII_Execution_Packet_V1 -> bitvector(64)

$[complete]
$[fix_location]
function _get_RVFI_DII_Execution_Packet_V1_rvfi_rs1_data v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 319, 256)

$[fix_location]
val _update_RVFI_DII_Execution_Packet_V1_rvfi_rs1_data : (RVFI_DII_Execution_Packet_V1, bitvector(64)) -> RVFI_DII_Execution_Packet_V1

$[complete]
$[fix_location]
function _update_RVFI_DII_Execution_Packet_V1_rvfi_rs1_data (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 319, 256, x) }

$[fix_location]
overload update_rvfi_rs1_data = {
  _update_RVFI_DII_Execution_Packet_V1_rvfi_rs1_data
}

$[fix_location]
val _set_RVFI_DII_Execution_Packet_V1_rvfi_rs1_data : (register(RVFI_DII_Execution_Packet_V1), bitvector(64)) -> unit

$[complete]
$[fix_location]
function _set_RVFI_DII_Execution_Packet_V1_rvfi_rs1_data (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_RVFI_DII_Execution_Packet_V1_rvfi_rs1_data(r, v)
}

overload _mod_rvfi_rs1_data = {
  _get_RVFI_DII_Execution_Packet_V1_rvfi_rs1_data,
  _set_RVFI_DII_Execution_Packet_V1_rvfi_rs1_data
}

$[fix_location]
val _get_RVFI_DII_Execution_Packet_V1_rvfi_rs2_addr : RVFI_DII_Execution_Packet_V1 -> bitvector(8)

$[complete]
$[fix_location]
function _get_RVFI_DII_Execution_Packet_V1_rvfi_rs2_addr v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 671, 664)

$[fix_location]
val _update_RVFI_DII_Execution_Packet_V1_rvfi_rs2_addr : (RVFI_DII_Execution_Packet_V1, bitvector(8)) -> RVFI_DII_Execution_Packet_V1

$[complete]
$[fix_location]
function _update_RVFI_DII_Execution_Packet_V1_rvfi_rs2_addr (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 671, 664, x) }

$[fix_location]
overload update_rvfi_rs2_addr = {
  _update_RVFI_DII_Execution_Packet_V1_rvfi_rs2_addr
}

$[fix_location]
val _set_RVFI_DII_Execution_Packet_V1_rvfi_rs2_addr : (register(RVFI_DII_Execution_Packet_V1), bitvector(8)) -> unit

$[complete]
$[fix_location]
function _set_RVFI_DII_Execution_Packet_V1_rvfi_rs2_addr (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_RVFI_DII_Execution_Packet_V1_rvfi_rs2_addr(r, v)
}

overload _mod_rvfi_rs2_addr = {
  _get_RVFI_DII_Execution_Packet_V1_rvfi_rs2_addr,
  _set_RVFI_DII_Execution_Packet_V1_rvfi_rs2_addr
}

$[fix_location]
val _get_RVFI_DII_Execution_Packet_V1_rvfi_rs2_data : RVFI_DII_Execution_Packet_V1 -> bitvector(64)

$[complete]
$[fix_location]
function _get_RVFI_DII_Execution_Packet_V1_rvfi_rs2_data v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 383, 320)

$[fix_location]
val _update_RVFI_DII_Execution_Packet_V1_rvfi_rs2_data : (RVFI_DII_Execution_Packet_V1, bitvector(64)) -> RVFI_DII_Execution_Packet_V1

$[complete]
$[fix_location]
function _update_RVFI_DII_Execution_Packet_V1_rvfi_rs2_data (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 383, 320, x) }

$[fix_location]
overload update_rvfi_rs2_data = {
  _update_RVFI_DII_Execution_Packet_V1_rvfi_rs2_data
}

$[fix_location]
val _set_RVFI_DII_Execution_Packet_V1_rvfi_rs2_data : (register(RVFI_DII_Execution_Packet_V1), bitvector(64)) -> unit

$[complete]
$[fix_location]
function _set_RVFI_DII_Execution_Packet_V1_rvfi_rs2_data (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_RVFI_DII_Execution_Packet_V1_rvfi_rs2_data(r, v)
}

overload _mod_rvfi_rs2_data = {
  _get_RVFI_DII_Execution_Packet_V1_rvfi_rs2_data,
  _set_RVFI_DII_Execution_Packet_V1_rvfi_rs2_data
}

$[fix_location]
val _get_RVFI_DII_Execution_Packet_V1_rvfi_trap : RVFI_DII_Execution_Packet_V1 -> bitvector(8)

$[complete]
$[fix_location]
function _get_RVFI_DII_Execution_Packet_V1_rvfi_trap v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 687, 680)

$[fix_location]
val _update_RVFI_DII_Execution_Packet_V1_rvfi_trap : (RVFI_DII_Execution_Packet_V1, bitvector(8)) -> RVFI_DII_Execution_Packet_V1

$[complete]
$[fix_location]
function _update_RVFI_DII_Execution_Packet_V1_rvfi_trap (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 687, 680, x) }

$[fix_location]
overload update_rvfi_trap = {_update_RVFI_DII_Execution_Packet_V1_rvfi_trap}

$[fix_location]
val _set_RVFI_DII_Execution_Packet_V1_rvfi_trap : (register(RVFI_DII_Execution_Packet_V1), bitvector(8)) -> unit

$[complete]
$[fix_location]
function _set_RVFI_DII_Execution_Packet_V1_rvfi_trap (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_RVFI_DII_Execution_Packet_V1_rvfi_trap(r, v)
}

overload _mod_rvfi_trap = {
  _get_RVFI_DII_Execution_Packet_V1_rvfi_trap,
  _set_RVFI_DII_Execution_Packet_V1_rvfi_trap
}

val rvfi_get_exec_packet_v1 : unit -> bitvector(704)

$[complete]
function rvfi_get_exec_packet_v1 () = {
    let v1_packet = Mk_RVFI_DII_Execution_Packet_V1(zeros(704));
    let v1_packet = $[overloaded { "name" = "update_rvfi_intr", "is_infix" = false }] _update_RVFI_DII_Execution_Packet_V1_rvfi_intr(v1_packet, _get_RVFI_DII_Execution_Packet_InstMetaData_rvfi_intr(rvfi_inst_data));
    let v1_packet = $[overloaded { "name" = "update_rvfi_halt", "is_infix" = false }] _update_RVFI_DII_Execution_Packet_V1_rvfi_halt(v1_packet, _get_RVFI_DII_Execution_Packet_InstMetaData_rvfi_halt(rvfi_inst_data));
    let v1_packet = $[overloaded { "name" = "update_rvfi_trap", "is_infix" = false }] _update_RVFI_DII_Execution_Packet_V1_rvfi_trap(v1_packet, _get_RVFI_DII_Execution_Packet_InstMetaData_rvfi_trap(rvfi_inst_data));
    let v1_packet = $[overloaded { "name" = "update_rvfi_insn", "is_infix" = false }] _update_RVFI_DII_Execution_Packet_V1_rvfi_insn(v1_packet, _get_RVFI_DII_Execution_Packet_InstMetaData_rvfi_insn(rvfi_inst_data));
    let v1_packet = $[overloaded { "name" = "update_rvfi_order", "is_infix" = false }] _update_RVFI_DII_Execution_Packet_V1_rvfi_order(v1_packet, _get_RVFI_DII_Execution_Packet_InstMetaData_rvfi_order(rvfi_inst_data));
    let v1_packet = $[overloaded { "name" = "update_rvfi_pc_wdata", "is_infix" = false }] _update_RVFI_DII_Execution_Packet_V1_rvfi_pc_wdata(v1_packet, _get_RVFI_DII_Execution_Packet_PC_rvfi_pc_wdata(rvfi_pc_data));
    let v1_packet = $[overloaded { "name" = "update_rvfi_pc_rdata", "is_infix" = false }] _update_RVFI_DII_Execution_Packet_V1_rvfi_pc_rdata(v1_packet, _get_RVFI_DII_Execution_Packet_PC_rvfi_pc_rdata(rvfi_pc_data));
    let v1_packet = $[overloaded { "name" = "update_rvfi_rd_addr", "is_infix" = false }] _update_RVFI_DII_Execution_Packet_V1_rvfi_rd_addr(v1_packet, _get_RVFI_DII_Execution_Packet_Ext_Integer_rvfi_rd_addr(rvfi_int_data));
    let v1_packet = $[overloaded { "name" = "update_rvfi_rs2_addr", "is_infix" = false }] _update_RVFI_DII_Execution_Packet_V1_rvfi_rs2_addr(v1_packet, _get_RVFI_DII_Execution_Packet_Ext_Integer_rvfi_rs2_addr(rvfi_int_data));
    let v1_packet = $[overloaded { "name" = "update_rvfi_rs1_addr", "is_infix" = false }] _update_RVFI_DII_Execution_Packet_V1_rvfi_rs1_addr(v1_packet, _get_RVFI_DII_Execution_Packet_Ext_Integer_rvfi_rs1_addr(rvfi_int_data));
    let v1_packet = $[overloaded { "name" = "update_rvfi_rd_wdata", "is_infix" = false }] _update_RVFI_DII_Execution_Packet_V1_rvfi_rd_wdata(v1_packet, _get_RVFI_DII_Execution_Packet_Ext_Integer_rvfi_rd_wdata(rvfi_int_data));
    let v1_packet = $[overloaded { "name" = "update_rvfi_rs2_data", "is_infix" = false }] _update_RVFI_DII_Execution_Packet_V1_rvfi_rs2_data(v1_packet, _get_RVFI_DII_Execution_Packet_Ext_Integer_rvfi_rs2_rdata(rvfi_int_data));
    let v1_packet = $[overloaded { "name" = "update_rvfi_rs1_data", "is_infix" = false }] _update_RVFI_DII_Execution_Packet_V1_rvfi_rs1_data(v1_packet, _get_RVFI_DII_Execution_Packet_Ext_Integer_rvfi_rs1_rdata(rvfi_int_data));
    let v1_packet = $[overloaded { "name" = "update_rvfi_mem_wmask", "is_infix" = false }] _update_RVFI_DII_Execution_Packet_V1_rvfi_mem_wmask(v1_packet, truncate(_get_RVFI_DII_Execution_Packet_Ext_MemAccess_rvfi_mem_wmask(rvfi_mem_data), 8));
    let v1_packet = $[overloaded { "name" = "update_rvfi_mem_rmask", "is_infix" = false }] _update_RVFI_DII_Execution_Packet_V1_rvfi_mem_rmask(v1_packet, truncate(_get_RVFI_DII_Execution_Packet_Ext_MemAccess_rvfi_mem_rmask(rvfi_mem_data), 8));
    let v1_packet = $[overloaded { "name" = "update_rvfi_mem_wdata", "is_infix" = false }] _update_RVFI_DII_Execution_Packet_V1_rvfi_mem_wdata(v1_packet, truncate(_get_RVFI_DII_Execution_Packet_Ext_MemAccess_rvfi_mem_wdata(rvfi_mem_data), 64));
    let v1_packet = $[overloaded { "name" = "update_rvfi_mem_rdata", "is_infix" = false }] _update_RVFI_DII_Execution_Packet_V1_rvfi_mem_rdata(v1_packet, truncate(_get_RVFI_DII_Execution_Packet_Ext_MemAccess_rvfi_mem_rdata(rvfi_mem_data), 64));
    let v1_packet = $[overloaded { "name" = "update_rvfi_mem_addr", "is_infix" = false }] _update_RVFI_DII_Execution_Packet_V1_rvfi_mem_addr(v1_packet, _get_RVFI_DII_Execution_Packet_Ext_MemAccess_rvfi_mem_addr(rvfi_mem_data));
    return(v1_packet.bits)
}

$[undefined_gen "skip"]
$[bitfield]
struct RVFI_DII_Execution_PacketV2 = {bits : bitvector(512)}

val undefined_RVFI_DII_Execution_PacketV2 : unit -> RVFI_DII_Execution_PacketV2

$[complete]
function undefined_RVFI_DII_Execution_PacketV2 () = struct RVFI_DII_Execution_PacketV2 { bits = undefined }

val Mk_RVFI_DII_Execution_PacketV2 : bitvector(512) -> RVFI_DII_Execution_PacketV2

$[complete]
function Mk_RVFI_DII_Execution_PacketV2 v = struct RVFI_DII_Execution_PacketV2 { bits = v }

$[fix_location]
val _get_RVFI_DII_Execution_PacketV2_bits : RVFI_DII_Execution_PacketV2 -> bitvector(512)

$[complete]
$[fix_location]
function _get_RVFI_DII_Execution_PacketV2_bits v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, sub_atom(512, 1), 0)

$[fix_location]
val _update_RVFI_DII_Execution_PacketV2_bits : (RVFI_DII_Execution_PacketV2, bitvector(512)) -> RVFI_DII_Execution_PacketV2

$[complete]
$[fix_location]
function _update_RVFI_DII_Execution_PacketV2_bits (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, sub_atom(512, 1), 0, x) }

$[fix_location]
overload update_bits = {_update_RVFI_DII_Execution_PacketV2_bits}

$[fix_location]
val _set_RVFI_DII_Execution_PacketV2_bits : (register(RVFI_DII_Execution_PacketV2), bitvector(512)) -> unit

$[complete]
$[fix_location]
function _set_RVFI_DII_Execution_PacketV2_bits (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_RVFI_DII_Execution_PacketV2_bits(r, v)
}

overload _mod_bits = {
  _get_RVFI_DII_Execution_PacketV2_bits,
  _set_RVFI_DII_Execution_PacketV2_bits
}

$[fix_location]
val _get_RVFI_DII_Execution_PacketV2_basic_data : RVFI_DII_Execution_PacketV2 -> bitvector(192)

$[complete]
$[fix_location]
function _get_RVFI_DII_Execution_PacketV2_basic_data v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 319, 128)

$[fix_location]
val _update_RVFI_DII_Execution_PacketV2_basic_data : (RVFI_DII_Execution_PacketV2, bitvector(192)) -> RVFI_DII_Execution_PacketV2

$[complete]
$[fix_location]
function _update_RVFI_DII_Execution_PacketV2_basic_data (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 319, 128, x) }

$[fix_location]
overload update_basic_data = {_update_RVFI_DII_Execution_PacketV2_basic_data}

$[fix_location]
val _set_RVFI_DII_Execution_PacketV2_basic_data : (register(RVFI_DII_Execution_PacketV2), bitvector(192)) -> unit

$[complete]
$[fix_location]
function _set_RVFI_DII_Execution_PacketV2_basic_data (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_RVFI_DII_Execution_PacketV2_basic_data(r, v)
}

overload _mod_basic_data = {
  _get_RVFI_DII_Execution_PacketV2_basic_data,
  _set_RVFI_DII_Execution_PacketV2_basic_data
}

$[fix_location]
val _get_RVFI_DII_Execution_PacketV2_cheri_data_available : RVFI_DII_Execution_PacketV2 -> bitvector(1)

$[complete]
$[fix_location]
function _get_RVFI_DII_Execution_PacketV2_cheri_data_available v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 452, 452)

$[fix_location]
val _update_RVFI_DII_Execution_PacketV2_cheri_data_available : (RVFI_DII_Execution_PacketV2, bitvector(1)) -> RVFI_DII_Execution_PacketV2

$[complete]
$[fix_location]
function _update_RVFI_DII_Execution_PacketV2_cheri_data_available (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 452, 452, x) }

$[fix_location]
overload update_cheri_data_available = {
  _update_RVFI_DII_Execution_PacketV2_cheri_data_available
}

$[fix_location]
val _set_RVFI_DII_Execution_PacketV2_cheri_data_available : (register(RVFI_DII_Execution_PacketV2), bitvector(1)) -> unit

$[complete]
$[fix_location]
function _set_RVFI_DII_Execution_PacketV2_cheri_data_available (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_RVFI_DII_Execution_PacketV2_cheri_data_available(r, v)
}

overload _mod_cheri_data_available = {
  _get_RVFI_DII_Execution_PacketV2_cheri_data_available,
  _set_RVFI_DII_Execution_PacketV2_cheri_data_available
}

$[fix_location]
val _get_RVFI_DII_Execution_PacketV2_cheri_scr_read_write_data_available : RVFI_DII_Execution_PacketV2 -> bitvector(1)

$[complete]
$[fix_location]
function _get_RVFI_DII_Execution_PacketV2_cheri_scr_read_write_data_available v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 453, 453)

$[fix_location]
val _update_RVFI_DII_Execution_PacketV2_cheri_scr_read_write_data_available : (RVFI_DII_Execution_PacketV2, bitvector(1)) -> RVFI_DII_Execution_PacketV2

$[complete]
$[fix_location]
function _update_RVFI_DII_Execution_PacketV2_cheri_scr_read_write_data_available (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 453, 453, x) }

$[fix_location]
overload update_cheri_scr_read_write_data_available = {
  _update_RVFI_DII_Execution_PacketV2_cheri_scr_read_write_data_available
}

$[fix_location]
val _set_RVFI_DII_Execution_PacketV2_cheri_scr_read_write_data_available : (register(RVFI_DII_Execution_PacketV2), bitvector(1)) -> unit

$[complete]
$[fix_location]
function _set_RVFI_DII_Execution_PacketV2_cheri_scr_read_write_data_available (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_RVFI_DII_Execution_PacketV2_cheri_scr_read_write_data_available(r, v)
}

overload _mod_cheri_scr_read_write_data_available = {
  _get_RVFI_DII_Execution_PacketV2_cheri_scr_read_write_data_available,
  _set_RVFI_DII_Execution_PacketV2_cheri_scr_read_write_data_available
}

$[fix_location]
val _get_RVFI_DII_Execution_PacketV2_csr_read_write_data_available : RVFI_DII_Execution_PacketV2 -> bitvector(1)

$[complete]
$[fix_location]
function _get_RVFI_DII_Execution_PacketV2_csr_read_write_data_available v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 451, 451)

$[fix_location]
val _update_RVFI_DII_Execution_PacketV2_csr_read_write_data_available : (RVFI_DII_Execution_PacketV2, bitvector(1)) -> RVFI_DII_Execution_PacketV2

$[complete]
$[fix_location]
function _update_RVFI_DII_Execution_PacketV2_csr_read_write_data_available (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 451, 451, x) }

$[fix_location]
overload update_csr_read_write_data_available = {
  _update_RVFI_DII_Execution_PacketV2_csr_read_write_data_available
}

$[fix_location]
val _set_RVFI_DII_Execution_PacketV2_csr_read_write_data_available : (register(RVFI_DII_Execution_PacketV2), bitvector(1)) -> unit

$[complete]
$[fix_location]
function _set_RVFI_DII_Execution_PacketV2_csr_read_write_data_available (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_RVFI_DII_Execution_PacketV2_csr_read_write_data_available(r, v)
}

overload _mod_csr_read_write_data_available = {
  _get_RVFI_DII_Execution_PacketV2_csr_read_write_data_available,
  _set_RVFI_DII_Execution_PacketV2_csr_read_write_data_available
}

$[fix_location]
val _get_RVFI_DII_Execution_PacketV2_floating_point_data_available : RVFI_DII_Execution_PacketV2 -> bitvector(1)

$[complete]
$[fix_location]
function _get_RVFI_DII_Execution_PacketV2_floating_point_data_available v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 450, 450)

$[fix_location]
val _update_RVFI_DII_Execution_PacketV2_floating_point_data_available : (RVFI_DII_Execution_PacketV2, bitvector(1)) -> RVFI_DII_Execution_PacketV2

$[complete]
$[fix_location]
function _update_RVFI_DII_Execution_PacketV2_floating_point_data_available (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 450, 450, x) }

$[fix_location]
overload update_floating_point_data_available = {
  _update_RVFI_DII_Execution_PacketV2_floating_point_data_available
}

$[fix_location]
val _set_RVFI_DII_Execution_PacketV2_floating_point_data_available : (register(RVFI_DII_Execution_PacketV2), bitvector(1)) -> unit

$[complete]
$[fix_location]
function _set_RVFI_DII_Execution_PacketV2_floating_point_data_available (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_RVFI_DII_Execution_PacketV2_floating_point_data_available(r, v)
}

overload _mod_floating_point_data_available = {
  _get_RVFI_DII_Execution_PacketV2_floating_point_data_available,
  _set_RVFI_DII_Execution_PacketV2_floating_point_data_available
}

$[fix_location]
val _get_RVFI_DII_Execution_PacketV2_integer_data_available : RVFI_DII_Execution_PacketV2 -> bitvector(1)

$[complete]
$[fix_location]
function _get_RVFI_DII_Execution_PacketV2_integer_data_available v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 448, 448)

$[fix_location]
val _update_RVFI_DII_Execution_PacketV2_integer_data_available : (RVFI_DII_Execution_PacketV2, bitvector(1)) -> RVFI_DII_Execution_PacketV2

$[complete]
$[fix_location]
function _update_RVFI_DII_Execution_PacketV2_integer_data_available (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 448, 448, x) }

$[fix_location]
overload update_integer_data_available = {
  _update_RVFI_DII_Execution_PacketV2_integer_data_available
}

$[fix_location]
val _set_RVFI_DII_Execution_PacketV2_integer_data_available : (register(RVFI_DII_Execution_PacketV2), bitvector(1)) -> unit

$[complete]
$[fix_location]
function _set_RVFI_DII_Execution_PacketV2_integer_data_available (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_RVFI_DII_Execution_PacketV2_integer_data_available(r, v)
}

overload _mod_integer_data_available = {
  _get_RVFI_DII_Execution_PacketV2_integer_data_available,
  _set_RVFI_DII_Execution_PacketV2_integer_data_available
}

$[fix_location]
val _get_RVFI_DII_Execution_PacketV2_magic : RVFI_DII_Execution_PacketV2 -> bitvector(64)

$[complete]
$[fix_location]
function _get_RVFI_DII_Execution_PacketV2_magic v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 63, 0)

$[fix_location]
val _update_RVFI_DII_Execution_PacketV2_magic : (RVFI_DII_Execution_PacketV2, bitvector(64)) -> RVFI_DII_Execution_PacketV2

$[complete]
$[fix_location]
function _update_RVFI_DII_Execution_PacketV2_magic (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 63, 0, x) }

$[fix_location]
overload update_magic = {_update_RVFI_DII_Execution_PacketV2_magic}

$[fix_location]
val _set_RVFI_DII_Execution_PacketV2_magic : (register(RVFI_DII_Execution_PacketV2), bitvector(64)) -> unit

$[complete]
$[fix_location]
function _set_RVFI_DII_Execution_PacketV2_magic (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_RVFI_DII_Execution_PacketV2_magic(r, v)
}

overload _mod_magic = {
  _get_RVFI_DII_Execution_PacketV2_magic,
  _set_RVFI_DII_Execution_PacketV2_magic
}

$[fix_location]
val _get_RVFI_DII_Execution_PacketV2_memory_access_data_available : RVFI_DII_Execution_PacketV2 -> bitvector(1)

$[complete]
$[fix_location]
function _get_RVFI_DII_Execution_PacketV2_memory_access_data_available v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 449, 449)

$[fix_location]
val _update_RVFI_DII_Execution_PacketV2_memory_access_data_available : (RVFI_DII_Execution_PacketV2, bitvector(1)) -> RVFI_DII_Execution_PacketV2

$[complete]
$[fix_location]
function _update_RVFI_DII_Execution_PacketV2_memory_access_data_available (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 449, 449, x) }

$[fix_location]
overload update_memory_access_data_available = {
  _update_RVFI_DII_Execution_PacketV2_memory_access_data_available
}

$[fix_location]
val _set_RVFI_DII_Execution_PacketV2_memory_access_data_available : (register(RVFI_DII_Execution_PacketV2), bitvector(1)) -> unit

$[complete]
$[fix_location]
function _set_RVFI_DII_Execution_PacketV2_memory_access_data_available (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_RVFI_DII_Execution_PacketV2_memory_access_data_available(r, v)
}

overload _mod_memory_access_data_available = {
  _get_RVFI_DII_Execution_PacketV2_memory_access_data_available,
  _set_RVFI_DII_Execution_PacketV2_memory_access_data_available
}

$[fix_location]
val _get_RVFI_DII_Execution_PacketV2_pc_data : RVFI_DII_Execution_PacketV2 -> bitvector(128)

$[complete]
$[fix_location]
function _get_RVFI_DII_Execution_PacketV2_pc_data v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 447, 320)

$[fix_location]
val _update_RVFI_DII_Execution_PacketV2_pc_data : (RVFI_DII_Execution_PacketV2, bitvector(128)) -> RVFI_DII_Execution_PacketV2

$[complete]
$[fix_location]
function _update_RVFI_DII_Execution_PacketV2_pc_data (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 447, 320, x) }

$[fix_location]
overload update_pc_data = {_update_RVFI_DII_Execution_PacketV2_pc_data}

$[fix_location]
val _set_RVFI_DII_Execution_PacketV2_pc_data : (register(RVFI_DII_Execution_PacketV2), bitvector(128)) -> unit

$[complete]
$[fix_location]
function _set_RVFI_DII_Execution_PacketV2_pc_data (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_RVFI_DII_Execution_PacketV2_pc_data(r, v)
}

overload _mod_pc_data = {
  _get_RVFI_DII_Execution_PacketV2_pc_data,
  _set_RVFI_DII_Execution_PacketV2_pc_data
}

$[fix_location]
val _get_RVFI_DII_Execution_PacketV2_trace_size : RVFI_DII_Execution_PacketV2 -> bitvector(64)

$[complete]
$[fix_location]
function _get_RVFI_DII_Execution_PacketV2_trace_size v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 127, 64)

$[fix_location]
val _update_RVFI_DII_Execution_PacketV2_trace_size : (RVFI_DII_Execution_PacketV2, bitvector(64)) -> RVFI_DII_Execution_PacketV2

$[complete]
$[fix_location]
function _update_RVFI_DII_Execution_PacketV2_trace_size (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 127, 64, x) }

$[fix_location]
overload update_trace_size = {_update_RVFI_DII_Execution_PacketV2_trace_size}

$[fix_location]
val _set_RVFI_DII_Execution_PacketV2_trace_size : (register(RVFI_DII_Execution_PacketV2), bitvector(64)) -> unit

$[complete]
$[fix_location]
function _set_RVFI_DII_Execution_PacketV2_trace_size (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_RVFI_DII_Execution_PacketV2_trace_size(r, v)
}

overload _mod_trace_size = {
  _get_RVFI_DII_Execution_PacketV2_trace_size,
  _set_RVFI_DII_Execution_PacketV2_trace_size
}

$[fix_location]
val _get_RVFI_DII_Execution_PacketV2_trap_data_available : RVFI_DII_Execution_PacketV2 -> bitvector(1)

$[complete]
$[fix_location]
function _get_RVFI_DII_Execution_PacketV2_trap_data_available v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 454, 454)

$[fix_location]
val _update_RVFI_DII_Execution_PacketV2_trap_data_available : (RVFI_DII_Execution_PacketV2, bitvector(1)) -> RVFI_DII_Execution_PacketV2

$[complete]
$[fix_location]
function _update_RVFI_DII_Execution_PacketV2_trap_data_available (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 454, 454, x) }

$[fix_location]
overload update_trap_data_available = {
  _update_RVFI_DII_Execution_PacketV2_trap_data_available
}

$[fix_location]
val _set_RVFI_DII_Execution_PacketV2_trap_data_available : (register(RVFI_DII_Execution_PacketV2), bitvector(1)) -> unit

$[complete]
$[fix_location]
function _set_RVFI_DII_Execution_PacketV2_trap_data_available (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_RVFI_DII_Execution_PacketV2_trap_data_available(r, v)
}

overload _mod_trap_data_available = {
  _get_RVFI_DII_Execution_PacketV2_trap_data_available,
  _set_RVFI_DII_Execution_PacketV2_trap_data_available
}

$[fix_location]
val _get_RVFI_DII_Execution_PacketV2_unused_data_available_fields : RVFI_DII_Execution_PacketV2 -> bitvector(57)

$[complete]
$[fix_location]
function _get_RVFI_DII_Execution_PacketV2_unused_data_available_fields v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 511, 455)

$[fix_location]
val _update_RVFI_DII_Execution_PacketV2_unused_data_available_fields : (RVFI_DII_Execution_PacketV2, bitvector(57)) -> RVFI_DII_Execution_PacketV2

$[complete]
$[fix_location]
function _update_RVFI_DII_Execution_PacketV2_unused_data_available_fields (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 511, 455, x) }

$[fix_location]
overload update_unused_data_available_fields = {
  _update_RVFI_DII_Execution_PacketV2_unused_data_available_fields
}

$[fix_location]
val _set_RVFI_DII_Execution_PacketV2_unused_data_available_fields : (register(RVFI_DII_Execution_PacketV2), bitvector(57)) -> unit

$[complete]
$[fix_location]
function _set_RVFI_DII_Execution_PacketV2_unused_data_available_fields (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_RVFI_DII_Execution_PacketV2_unused_data_available_fields(r, v)
}

overload _mod_unused_data_available_fields = {
  _get_RVFI_DII_Execution_PacketV2_unused_data_available_fields,
  _set_RVFI_DII_Execution_PacketV2_unused_data_available_fields
}

val rvfi_get_v2_support_packet : unit -> bitvector(704)

$[complete]
function rvfi_get_v2_support_packet () = {
    let rvfi_exec = Mk_RVFI_DII_Execution_Packet_V1(zeros(704));
    let rvfi_exec = $[overloaded { "name" = "update_rvfi_halt", "is_infix" = false }] _update_RVFI_DII_Execution_Packet_V1_rvfi_halt(rvfi_exec, 0x03);
    return(rvfi_exec.bits)
}

val rvfi_get_v2_trace_size : unit -> bitvector(64)

$[complete]
function rvfi_get_v2_trace_size () = {
    let trace_size : bits(64) = to_bits(64, 512);
    let trace_size = if rvfi_int_data_present then
      $[overloaded { "name" = "+", "is_infix" = true }] add_bits_int(trace_size, 320)
    else
      trace_size;
    let trace_size = if rvfi_mem_data_present then
      $[overloaded { "name" = "+", "is_infix" = true }] add_bits_int(trace_size, 704)
    else
      trace_size;
    return($[overloaded { "name" = ">>", "is_infix" = true }] shiftr(trace_size, 3))
}

val rvfi_get_exec_packet_v2 : unit -> bitvector(512)

$[complete]
function rvfi_get_exec_packet_v2 () = {
    let packet = Mk_RVFI_DII_Execution_PacketV2(zeros(512));
    let packet = $[overloaded { "name" = "update_magic", "is_infix" = false }] _update_RVFI_DII_Execution_PacketV2_magic(packet, 0x32762d6563617274);
    let packet = $[overloaded { "name" = "update_basic_data", "is_infix" = false }] _update_RVFI_DII_Execution_PacketV2_basic_data(packet, rvfi_inst_data.bits);
    let packet = $[overloaded { "name" = "update_pc_data", "is_infix" = false }] _update_RVFI_DII_Execution_PacketV2_pc_data(packet, rvfi_pc_data.bits);
    let packet = $[overloaded { "name" = "update_integer_data_available", "is_infix" = false }] _update_RVFI_DII_Execution_PacketV2_integer_data_available(packet, bool_to_bits(rvfi_int_data_present));
    let packet = $[overloaded { "name" = "update_memory_access_data_available", "is_infix" = false }] _update_RVFI_DII_Execution_PacketV2_memory_access_data_available(packet, bool_to_bits(rvfi_mem_data_present));
    let packet = $[overloaded { "name" = "update_trace_size", "is_infix" = false }] _update_RVFI_DII_Execution_PacketV2_trace_size(packet, rvfi_get_v2_trace_size());
    return(packet.bits)
}

$[undefined_gen "forbid"]
$[no_enum_number_conversions]
enum extension = {
  Ext_M,
  Ext_A,
  Ext_F,
  Ext_D,
  Ext_B,
  Ext_V,
  Ext_S,
  Ext_U,
  Ext_H,
  Ext_Zicbom,
  Ext_Zicbop,
  Ext_Zicboz,
  Ext_Zicntr,
  Ext_Zicond,
  Ext_Zicsr,
  Ext_Zifencei,
  Ext_Zihintntl,
  Ext_Zihintpause,
  Ext_Zihpm,
  Ext_Zimop,
  Ext_Zmmul,
  Ext_Zaamo,
  Ext_Zabha,
  Ext_Zacas,
  Ext_Zalrsc,
  Ext_Zawrs,
  Ext_Zfa,
  Ext_Zfbfmin,
  Ext_Zfh,
  Ext_Zfhmin,
  Ext_Zfinx,
  Ext_Zdinx,
  Ext_Zca,
  Ext_Zcb,
  Ext_Zcd,
  Ext_Zcf,
  Ext_Zcmop,
  Ext_C,
  Ext_Zba,
  Ext_Zbb,
  Ext_Zbc,
  Ext_Zbkb,
  Ext_Zbkc,
  Ext_Zbkx,
  Ext_Zbs,
  Ext_Zknd,
  Ext_Zkne,
  Ext_Zknh,
  Ext_Zkr,
  Ext_Zksed,
  Ext_Zksh,
  Ext_Zkt,
  Ext_Zhinx,
  Ext_Zhinxmin,
  Ext_Zvbb,
  Ext_Zvbc,
  Ext_Zvkb,
  Ext_Zvkg,
  Ext_Zvkned,
  Ext_Zvknha,
  Ext_Zvknhb,
  Ext_Zvksed,
  Ext_Zvksh,
  Ext_Zvkt,
  Ext_Zvkn,
  Ext_Zvknc,
  Ext_Zvkng,
  Ext_Zvks,
  Ext_Zvksc,
  Ext_Zvksg,
  Ext_Sscofpmf,
  Ext_Sstc,
  Ext_Svbare,
  Ext_Sv32,
  Ext_Sv39,
  Ext_Sv48,
  Ext_Sv57,
  Ext_Svinval,
  Ext_Svnapot,
  Ext_Svpbmt,
  Ext_Svrsw60t59b,
  Ext_Smcntrpmf
}

val extensionName : extension <-> string

val hartSupports : extension -> bool

val currentlyEnabled : extension -> bool

mapping extensionName = {
  Ext_M <-> "m",
  Ext_A <-> "a",
  Ext_F <-> "f",
  Ext_D <-> "d",
  Ext_B <-> "b",
  Ext_V <-> "v",
  Ext_S <-> "s",
  Ext_U <-> "u",
  Ext_H <-> "h",
  Ext_Zicbom <-> "zicbom",
  Ext_Zicbop <-> "zicbop",
  Ext_Zicboz <-> "zicboz",
  Ext_Zicntr <-> "zicntr",
  Ext_Zicond <-> "zicond",
  Ext_Zicsr <-> "zicsr",
  Ext_Zifencei <-> "zifencei",
  Ext_Zihintntl <-> "zihintntl",
  Ext_Zihintpause <-> "zihintpause",
  Ext_Zihpm <-> "zihpm",
  Ext_Zimop <-> "zimop",
  Ext_Zmmul <-> "zmmul",
  Ext_Zaamo <-> "zaamo",
  Ext_Zabha <-> "zabha",
  Ext_Zacas <-> "zacas",
  Ext_Zalrsc <-> "zalrsc",
  Ext_Zawrs <-> "zawrs",
  Ext_Zfa <-> "zfa",
  Ext_Zfbfmin <-> "zfbfmin",
  Ext_Zfh <-> "zfh",
  Ext_Zfhmin <-> "zfhmin",
  Ext_Zfinx <-> "zfinx",
  Ext_Zdinx <-> "zdinx",
  Ext_Zca <-> "zca",
  Ext_Zcb <-> "zcb",
  Ext_Zcd <-> "zcd",
  Ext_Zcf <-> "zcf",
  Ext_Zcmop <-> "zcmop",
  Ext_C <-> "c",
  Ext_Zba <-> "zba",
  Ext_Zbb <-> "zbb",
  Ext_Zbc <-> "zbc",
  Ext_Zbkb <-> "zbkb",
  Ext_Zbkc <-> "zbkc",
  Ext_Zbkx <-> "zbkx",
  Ext_Zbs <-> "zbs",
  Ext_Zknd <-> "zknd",
  Ext_Zkne <-> "zkne",
  Ext_Zknh <-> "zknh",
  Ext_Zkr <-> "zkr",
  Ext_Zksed <-> "zksed",
  Ext_Zksh <-> "zksh",
  Ext_Zkt <-> "zkt",
  Ext_Zhinx <-> "zhinx",
  Ext_Zhinxmin <-> "zhinxmin",
  Ext_Zvbb <-> "zvbb",
  Ext_Zvbc <-> "zvbc",
  Ext_Zvkb <-> "zvkb",
  Ext_Zvkg <-> "zvkg",
  Ext_Zvkned <-> "zvkned",
  Ext_Zvknha <-> "zvknha",
  Ext_Zvknhb <-> "zvknhb",
  Ext_Zvksed <-> "zvksed",
  Ext_Zvksh <-> "zvksh",
  Ext_Zvkt <-> "zvkt",
  Ext_Zvkn <-> "zvkn",
  Ext_Zvknc <-> "zvknc",
  Ext_Zvkng <-> "zvkng",
  Ext_Zvks <-> "zvks",
  Ext_Zvksc <-> "zvksc",
  Ext_Zvksg <-> "zvksg",
  Ext_Sscofpmf <-> "sscofpmf",
  Ext_Sstc <-> "sstc",
  Ext_Svbare <-> "svbare",
  Ext_Sv32 <-> "sv32",
  Ext_Sv39 <-> "sv39",
  Ext_Sv48 <-> "sv48",
  Ext_Sv57 <-> "sv57",
  Ext_Svinval <-> "svinval",
  Ext_Svnapot <-> "svnapot",
  Ext_Svpbmt <-> "svpbmt",
  Ext_Svrsw60t59b <-> "svrsw60t59b",
  Ext_Smcntrpmf <-> "smcntrpmf"
}

$[complete]
function hartSupports Ext_M = config extensions.M.supported
and hartSupports Ext_A = config extensions.A.supported
and hartSupports Ext_F = config extensions.F.supported
and hartSupports Ext_D = $[overloaded { "name" = "&", "is_infix" = true }] and_bool(constraint(ext_d_supported), hartSupports(Ext_F))
and hartSupports Ext_B = config extensions.B.supported
and hartSupports Ext_V = config extensions.V.supported
and hartSupports Ext_S = config extensions.S.supported
and hartSupports Ext_U = config extensions.U.supported
and hartSupports Ext_H = false
and hartSupports Ext_Zicbom = config extensions.Zicbom.supported
and hartSupports Ext_Zicbop = config extensions.Zicbop.supported
and hartSupports Ext_Zicboz = config extensions.Zicboz.supported
and hartSupports Ext_Zicntr = config extensions.Zicntr.supported
and hartSupports Ext_Zicond = config extensions.Zicond.supported
and hartSupports Ext_Zicsr = config extensions.Zicsr.supported
and hartSupports Ext_Zifencei = config extensions.Zifencei.supported
and hartSupports Ext_Zihintntl = config extensions.Zihintntl.supported
and hartSupports Ext_Zihintpause = config extensions.Zihintpause.supported
and hartSupports Ext_Zihpm = config extensions.Zihpm.supported
and hartSupports Ext_Zimop = config extensions.Zimop.supported
and hartSupports Ext_Zmmul = config extensions.Zmmul.supported
and hartSupports Ext_Zaamo = config extensions.Zaamo.supported
and hartSupports Ext_Zabha = config extensions.Zabha.supported
and hartSupports Ext_Zacas = config extensions.Zacas.supported
and hartSupports Ext_Zalrsc = config extensions.Zalrsc.supported
and hartSupports Ext_Zawrs = config extensions.Zawrs.supported
and hartSupports Ext_Zfa = config extensions.Zfa.supported
and hartSupports Ext_Zfbfmin = config extensions.Zfbfmin.supported
and hartSupports Ext_Zfh = config extensions.Zfh.supported
and hartSupports Ext_Zfhmin = config extensions.Zfhmin.supported
and hartSupports Ext_Zfinx = config extensions.Zfinx.supported
and hartSupports Ext_Zdinx = config extensions.Zfinx.supported
and hartSupports Ext_Zca = config extensions.Zca.supported
and hartSupports Ext_Zcb = config extensions.Zcb.supported
and hartSupports Ext_Zcd = config extensions.Zcd.supported
and hartSupports Ext_Zcf = $[overloaded { "name" = "&", "is_infix" = true }] and_bool(config extensions.Zcf.supported : bool, $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 32))
and hartSupports Ext_Zcmop = config extensions.Zcmop.supported
and hartSupports Ext_C = $[overloaded { "name" = "&", "is_infix" = true }] and_bool(hartSupports(Ext_Zca), $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "|", "is_infix" = true }] or_bool(hartSupports(Ext_Zcf), $[overloaded { "name" = "|", "is_infix" = true }] or_bool(not(hartSupports(Ext_F)), $[overloaded { "name" = "!=", "is_infix" = true }] neq_int(xlen, 32))), $[overloaded { "name" = "|", "is_infix" = true }] or_bool(hartSupports(Ext_Zcd), not(hartSupports(Ext_D)))))
and hartSupports Ext_Zba = config extensions.Zba.supported
and hartSupports Ext_Zbb = config extensions.Zbb.supported
and hartSupports Ext_Zbc = config extensions.Zbc.supported
and hartSupports Ext_Zbkb = config extensions.Zbkb.supported
and hartSupports Ext_Zbkc = config extensions.Zbkc.supported
and hartSupports Ext_Zbkx = config extensions.Zbkx.supported
and hartSupports Ext_Zbs = config extensions.Zbs.supported
and hartSupports Ext_Zknd = config extensions.Zknd.supported
and hartSupports Ext_Zkne = config extensions.Zkne.supported
and hartSupports Ext_Zknh = config extensions.Zknh.supported
and hartSupports Ext_Zkr = config extensions.Zkr.supported
and hartSupports Ext_Zksed = config extensions.Zksed.supported
and hartSupports Ext_Zksh = config extensions.Zksh.supported
and hartSupports Ext_Zkt = config extensions.Zkt.supported
and hartSupports Ext_Zhinx = config extensions.Zhinx.supported
and hartSupports Ext_Zhinxmin = config extensions.Zhinxmin.supported
and hartSupports Ext_Zvbb = config extensions.Zvbb.supported
and hartSupports Ext_Zvbc = config extensions.Zvbc.supported
and hartSupports Ext_Zvkb = config extensions.Zvkb.supported
and hartSupports Ext_Zvkg = config extensions.Zvkg.supported
and hartSupports Ext_Zvkned = config extensions.Zvkned.supported
and hartSupports Ext_Zvknha = config extensions.Zvknha.supported
and hartSupports Ext_Zvknhb = config extensions.Zvknhb.supported
and hartSupports Ext_Zvksed = config extensions.Zvksed.supported
and hartSupports Ext_Zvksh = config extensions.Zvksh.supported
and hartSupports Ext_Zvkt = config extensions.Zvkt.supported
and hartSupports Ext_Zvkn = $[overloaded { "name" = "&", "is_infix" = true }] and_bool(hartSupports(Ext_Zvkned), $[overloaded { "name" = "&", "is_infix" = true }] and_bool(hartSupports(Ext_Zvknhb), $[overloaded { "name" = "&", "is_infix" = true }] and_bool(hartSupports(Ext_Zvkb), hartSupports(Ext_Zvkt))))
and hartSupports Ext_Zvknc = $[overloaded { "name" = "&", "is_infix" = true }] and_bool(hartSupports(Ext_Zvkn), hartSupports(Ext_Zvbc))
and hartSupports Ext_Zvkng = $[overloaded { "name" = "&", "is_infix" = true }] and_bool(hartSupports(Ext_Zvkn), hartSupports(Ext_Zvkg))
and hartSupports Ext_Zvks = $[overloaded { "name" = "&", "is_infix" = true }] and_bool(hartSupports(Ext_Zvksed), $[overloaded { "name" = "&", "is_infix" = true }] and_bool(hartSupports(Ext_Zvksh), $[overloaded { "name" = "&", "is_infix" = true }] and_bool(hartSupports(Ext_Zvkb), hartSupports(Ext_Zvkt))))
and hartSupports Ext_Zvksc = $[overloaded { "name" = "&", "is_infix" = true }] and_bool(hartSupports(Ext_Zvks), hartSupports(Ext_Zvbc))
and hartSupports Ext_Zvksg = $[overloaded { "name" = "&", "is_infix" = true }] and_bool(hartSupports(Ext_Zvks), hartSupports(Ext_Zvkg))
and hartSupports Ext_Sscofpmf = config extensions.Sscofpmf.supported
and hartSupports Ext_Sstc = config extensions.Sstc.supported
and hartSupports Ext_Svbare = config extensions.Svbare.supported
and hartSupports Ext_Sv32 = $[overloaded { "name" = "&", "is_infix" = true }] and_bool(config extensions.Sv32.supported : bool, $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 32))
and hartSupports Ext_Sv39 = $[overloaded { "name" = "&", "is_infix" = true }] and_bool(config extensions.Sv39.supported : bool, $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64))
and hartSupports Ext_Sv48 = $[overloaded { "name" = "&", "is_infix" = true }] and_bool(config extensions.Sv48.supported : bool, $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64))
and hartSupports Ext_Sv57 = $[overloaded { "name" = "&", "is_infix" = true }] and_bool(config extensions.Sv57.supported : bool, $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64))
and hartSupports Ext_Svinval = config extensions.Svinval.supported
and hartSupports Ext_Svnapot = false
and hartSupports Ext_Svpbmt = false
and hartSupports Ext_Svrsw60t59b = config extensions.Svrsw60t59b.supported
and hartSupports Ext_Smcntrpmf = config extensions.Smcntrpmf.supported

let extensions_ordered_for_isa_string = [Ext_M, Ext_A, Ext_F, Ext_D, Ext_C, Ext_B, Ext_V, Ext_H, Ext_Zicbom, Ext_Zicbop, Ext_Zicboz, Ext_Zicntr, Ext_Zicond, Ext_Zicsr, Ext_Zifencei, Ext_Zihintntl, Ext_Zihintpause, Ext_Zihpm, Ext_Zimop, Ext_Zmmul, Ext_Zaamo, Ext_Zabha, Ext_Zacas, Ext_Zalrsc, Ext_Zawrs, Ext_Zfa, Ext_Zfbfmin, Ext_Zfh, Ext_Zfhmin, Ext_Zfinx, Ext_Zdinx, Ext_Zhinx, Ext_Zhinxmin, Ext_Zca, Ext_Zcb, Ext_Zcd, Ext_Zcf, Ext_Zcmop, Ext_Zba, Ext_Zbb, Ext_Zbc, Ext_Zbkb, Ext_Zbkc, Ext_Zbkx, Ext_Zbs, Ext_Zknd, Ext_Zkne, Ext_Zknh, Ext_Zkr, Ext_Zksed, Ext_Zksh, Ext_Zkt, Ext_Zvbb, Ext_Zvbc, Ext_Zvkb, Ext_Zvkg, Ext_Zvkn, Ext_Zvknc, Ext_Zvkned, Ext_Zvkng, Ext_Zvknha, Ext_Zvknhb, Ext_Zvks, Ext_Zvksc, Ext_Zvksed, Ext_Zvksg, Ext_Zvksh, Ext_Zvkt, Ext_Sscofpmf, Ext_Sstc, Ext_Svinval, Ext_Svnapot, Ext_Svpbmt, Ext_Svrsw60t59b, Ext_Smcntrpmf]

type exc_code = bits(8)

type ext_ptw = unit

let init_ext_ptw : ext_ptw = ()

type ext_ptw_fail = unit

type ext_ptw_error = unit

type ext_exc_type = unit

val ext_translate_exception : unit -> unit

$[complete]
function ext_translate_exception e : ext_ptw_error = e

val ext_exc_type_to_bits : unit -> bitvector(8)

$[complete]
function ext_exc_type_to_bits e = 0x18

val num_of_ext_exc_type : unit -> {('n : Int), (0 <= 'n & 'n < xlen). int('n)}

$[complete]
function num_of_ext_exc_type e = 24

val ext_exc_type_to_str : unit -> string

$[complete]
function ext_exc_type_to_str e = "extension-exception"

type half = bits(16)

type word = bits(32)

type instbits = bits(32)

type pagesize_bits : Int = 12

let pagesize_bits = 12

type base_E_enabled : Bool = config base.E

let base_E_enabled = constraint(base_E_enabled)

type regidx_bit_width : Int = if base_E_enabled then 4 else 5

let regidx_bit_width = if constraint(base_E_enabled) then 4 else 5

newtype regidx = Regidx : bits(regidx_bit_width)

newtype cregidx = Cregidx : bits(3)

type csreg = bits(12)

val regidx_offset : (regidx, bitvector(if base_E_enabled then 4 else 5)) -> regidx

$[complete]
function regidx_offset (Regidx(r) : regidx, o : bits(regidx_bit_width)) = Regidx($[overloaded { "name" = "+", "is_infix" = true }] add_bits(r, o))

val regidx_offset_range : (regidx, range(0, 31)) -> regidx

$[complete]
function regidx_offset_range (Regidx(r) : regidx, o : range(0, 31)) = Regidx($[overloaded { "name" = "+", "is_infix" = true }] add_bits_int(r, o))

val regidx_bits : regidx -> bitvector(if base_E_enabled then 4 else 5)

$[complete]
function regidx_bits Regidx(b) : regidx = b

overload operator + = {regidx_offset, regidx_offset_range}

newtype regno = Regno : range(0, 2 ^ regidx_bit_width - 1)

val creg2reg_idx : cregidx -> regidx

$[complete]
function creg2reg_idx Cregidx(i) : cregidx = Regidx(zero_extend(if constraint(base_E_enabled) then
  4
else
  5, $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(0b1, i)))

let zreg : regidx = Regidx(zero_extend(if constraint(base_E_enabled) then 4 else
  5, 0b00))

let ra : regidx = Regidx(zero_extend(if constraint(base_E_enabled) then 4 else 5, 0b01))

let sp : regidx = Regidx(zero_extend(if constraint(base_E_enabled) then 4 else 5, 0b10))

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum Architecture = {RV32, RV64, RV128}

val undefined_Architecture : unit -> Architecture

$[complete]
function undefined_Architecture () = internal_pick([|RV32, RV64, RV128|])

val Architecture_of_num : forall ('e : Int), (0 <= 'e & 'e <= 2).
  int('e) -> Architecture

$[complete]
function Architecture_of_num arg# = $[complete] match arg# {
  0 => RV32,
  1 => RV64,
  _ => RV128
}

val num_of_Architecture : Architecture -> {('e : Int), (0 <= 'e & 'e <= 2). int('e)}

$[complete]
function num_of_Architecture arg# = $[complete] match arg# {
  RV32 => 0,
  RV64 => 1,
  RV128 => 2
}

type arch_xlen = bits(2)

val architecture : Architecture <-> bitvector(2)

mapping architecture = {
  RV32 <-> 0b01,
  RV64 <-> 0b10,
  RV128 <-> 0b11,
  backwards 0b00 => internal_error("./core/types.sail", 61, "architecture(0b00) is invalid")
}

type nom_priv_bits = bits(2)

type virt_mode_bit = bit

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum Privilege = {User, VirtualUser, Supervisor, VirtualSupervisor, Machine}

val undefined_Privilege : unit -> Privilege

$[complete]
function undefined_Privilege () = internal_pick([|User, VirtualUser, Supervisor, VirtualSupervisor, Machine|])

val Privilege_of_num : forall ('e : Int), (0 <= 'e & 'e <= 4).
  int('e) -> Privilege

$[complete]
function Privilege_of_num arg# = $[complete] match arg# {
  0 => User,
  1 => VirtualUser,
  2 => Supervisor,
  3 => VirtualSupervisor,
  _ => Machine
}

val num_of_Privilege : Privilege -> {('e : Int), (0 <= 'e & 'e <= 4). int('e)}

$[complete]
function num_of_Privilege arg# = $[complete] match arg# {
  User => 0,
  VirtualUser => 1,
  Supervisor => 2,
  VirtualSupervisor => 3,
  Machine => 4
}

val privLevel_bits : (bitvector(2), bit) <-> Privilege

mapping privLevel_bits = {
  (0b00, bitzero) <-> User,
  (0b00, bitone) <-> VirtualUser,
  (0b01, bitzero) <-> Supervisor,
  (0b01, bitone) <-> VirtualSupervisor,
  (0b11, bitzero) <-> Machine,
  forwards _ => internal_error("./core/types.sail", 78, "Invalid privilege level or virtual mode")
}

val privLevel_to_bits : Privilege -> bitvector(2)

$[complete]
function privLevel_to_bits p : Privilege = {
    let (p, _) = privLevel_bits_backwards(p);
    p
}

val privLevel_to_str : Privilege -> string

$[complete]
function privLevel_to_str p : Privilege = $[complete] match p {
  User => "U",
  VirtualUser => "VU",
  Supervisor => if currentlyEnabled(Ext_H) then "HS" else "S",
  VirtualSupervisor => "VS",
  Machine => "M"
}

overload to_str = {privLevel_to_str}

union AccessType ('a: Type) = {
  Read : 'a,
  Write : 'a,
  ReadWrite : ('a, 'a),
  InstructionFetch : unit
}

val is_load_store : forall ('a : Type). AccessType('a) -> bool

$[complete]
function is_load_store ac : AccessType('a) = $[complete] match ac {
  Read(_) => true,
  Write(_) => true,
  ReadWrite(_) => true,
  InstructionFetch(_) => false
}

type is_mem_width('w: Int) -> Bool = 'w in {1, 2, 4, 8}

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum InterruptType = {
  I_U_Software,
  I_S_Software,
  I_M_Software,
  I_U_Timer,
  I_S_Timer,
  I_M_Timer,
  I_U_External,
  I_S_External,
  I_M_External
}

val undefined_InterruptType : unit -> InterruptType

$[complete]
function undefined_InterruptType () = internal_pick([|I_U_Software, I_S_Software, I_M_Software, I_U_Timer, I_S_Timer, I_M_Timer, I_U_External, I_S_External, I_M_External|])

val InterruptType_of_num : forall ('e : Int), (0 <= 'e & 'e <= 8).
  int('e) -> InterruptType

$[complete]
function InterruptType_of_num arg# = $[complete] match arg# {
  0 => I_U_Software,
  1 => I_S_Software,
  2 => I_M_Software,
  3 => I_U_Timer,
  4 => I_S_Timer,
  5 => I_M_Timer,
  6 => I_U_External,
  7 => I_S_External,
  _ => I_M_External
}

val num_of_InterruptType : InterruptType -> {('e : Int), (0 <= 'e & 'e <= 8). int('e)}

$[complete]
function num_of_InterruptType arg# = $[complete] match arg# {
  I_U_Software => 0,
  I_S_Software => 1,
  I_M_Software => 2,
  I_U_Timer => 3,
  I_S_Timer => 4,
  I_M_Timer => 5,
  I_U_External => 6,
  I_S_External => 7,
  I_M_External => 8
}

val interruptType_to_bits : InterruptType -> bitvector(8)

$[complete]
function interruptType_to_bits i = $[complete] match i {
  I_U_Software => 0x00,
  I_S_Software => 0x01,
  I_M_Software => 0x03,
  I_U_Timer => 0x04,
  I_S_Timer => 0x05,
  I_M_Timer => 0x07,
  I_U_External => 0x08,
  I_S_External => 0x09,
  I_M_External => 0x0b
}

union ExceptionType = {
  E_Fetch_Addr_Align : unit,
  E_Fetch_Access_Fault : unit,
  E_Illegal_Instr : unit,
  E_Breakpoint : unit,
  E_Load_Addr_Align : unit,
  E_Load_Access_Fault : unit,
  E_SAMO_Addr_Align : unit,
  E_SAMO_Access_Fault : unit,
  E_U_EnvCall : unit,
  E_S_EnvCall : unit,
  E_Reserved_10 : unit,
  E_M_EnvCall : unit,
  E_Fetch_Page_Fault : unit,
  E_Load_Page_Fault : unit,
  E_Reserved_14 : unit,
  E_SAMO_Page_Fault : unit,
  E_Extension : ext_exc_type
}

val exceptionType_to_bits : ExceptionType -> bitvector(8)

$[complete]
function exceptionType_to_bits e = $[complete] match e {
  E_Fetch_Addr_Align(()) => 0x00,
  E_Fetch_Access_Fault(()) => 0x01,
  E_Illegal_Instr(()) => 0x02,
  E_Breakpoint(()) => 0x03,
  E_Load_Addr_Align(()) => 0x04,
  E_Load_Access_Fault(()) => 0x05,
  E_SAMO_Addr_Align(()) => 0x06,
  E_SAMO_Access_Fault(()) => 0x07,
  E_U_EnvCall(()) => 0x08,
  E_S_EnvCall(()) => 0x09,
  E_Reserved_10(()) => 0x0a,
  E_M_EnvCall(()) => 0x0b,
  E_Fetch_Page_Fault(()) => 0x0c,
  E_Load_Page_Fault(()) => 0x0d,
  E_Reserved_14(()) => 0x0e,
  E_SAMO_Page_Fault(()) => 0x0f,
  E_Extension(e) => ext_exc_type_to_bits(e)
}

val num_of_ExceptionType : ExceptionType -> {('n : Int), (0 <= 'n & 'n < xlen). int('n)}

$[complete]
function num_of_ExceptionType e = $[complete] match e {
  E_Fetch_Addr_Align(()) => 0,
  E_Fetch_Access_Fault(()) => 1,
  E_Illegal_Instr(()) => 2,
  E_Breakpoint(()) => 3,
  E_Load_Addr_Align(()) => 4,
  E_Load_Access_Fault(()) => 5,
  E_SAMO_Addr_Align(()) => 6,
  E_SAMO_Access_Fault(()) => 7,
  E_U_EnvCall(()) => 8,
  E_S_EnvCall(()) => 9,
  E_Reserved_10(()) => 10,
  E_M_EnvCall(()) => 11,
  E_Fetch_Page_Fault(()) => 12,
  E_Load_Page_Fault(()) => 13,
  E_Reserved_14(()) => 14,
  E_SAMO_Page_Fault(()) => 15,
  E_Extension(e) => num_of_ext_exc_type(e)
}

val exceptionType_to_str : ExceptionType -> string

$[complete]
function exceptionType_to_str e = $[complete] match e {
  E_Fetch_Addr_Align(()) => "misaligned-fetch",
  E_Fetch_Access_Fault(()) => "fetch-access-fault",
  E_Illegal_Instr(()) => "illegal-instruction",
  E_Breakpoint(()) => "breakpoint",
  E_Load_Addr_Align(()) => "misaligned-load",
  E_Load_Access_Fault(()) => "load-access-fault",
  E_SAMO_Addr_Align(()) => "misaligned-store/amo",
  E_SAMO_Access_Fault(()) => "store/amo-access-fault",
  E_U_EnvCall(()) => "u-call",
  E_S_EnvCall(()) => "s-call",
  E_Reserved_10(()) => "reserved-0",
  E_M_EnvCall(()) => "m-call",
  E_Fetch_Page_Fault(()) => "fetch-page-fault",
  E_Load_Page_Fault(()) => "load-page-fault",
  E_Reserved_14(()) => "reserved-1",
  E_SAMO_Page_Fault(()) => "store/amo-page-fault",
  E_Extension(e) => ext_exc_type_to_str(e)
}

overload to_str = {exceptionType_to_str}

type tv_mode = bits(2)

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum TrapVectorMode = {TV_Direct, TV_Vector, TV_Reserved}

val undefined_TrapVectorMode : unit -> TrapVectorMode

$[complete]
function undefined_TrapVectorMode () = internal_pick([|TV_Direct, TV_Vector, TV_Reserved|])

val TrapVectorMode_of_num : forall ('e : Int), (0 <= 'e & 'e <= 2).
  int('e) -> TrapVectorMode

$[complete]
function TrapVectorMode_of_num arg# = $[complete] match arg# {
  0 => TV_Direct,
  1 => TV_Vector,
  _ => TV_Reserved
}

val num_of_TrapVectorMode : TrapVectorMode -> {('e : Int), (0 <= 'e & 'e <= 2). int('e)}

$[complete]
function num_of_TrapVectorMode arg# = $[complete] match arg# {
  TV_Direct => 0,
  TV_Vector => 1,
  TV_Reserved => 2
}

val trapVectorMode_of_bits : bitvector(2) -> TrapVectorMode

$[complete]
function trapVectorMode_of_bits m = $[complete] match m {
  0b00 => TV_Direct,
  0b01 => TV_Vector,
  _ => TV_Reserved
}

type ext_status = bits(2)

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum ExtStatus = {Off, Initial, Clean, Dirty}

val undefined_ExtStatus : unit -> ExtStatus

$[complete]
function undefined_ExtStatus () = internal_pick([|Off, Initial, Clean, Dirty|])

val ExtStatus_of_num : forall ('e : Int), (0 <= 'e & 'e <= 3).
  int('e) -> ExtStatus

$[complete]
function ExtStatus_of_num arg# = $[complete] match arg# {
  0 => Off,
  1 => Initial,
  2 => Clean,
  _ => Dirty
}

val num_of_ExtStatus : ExtStatus -> {('e : Int), (0 <= 'e & 'e <= 3). int('e)}

$[complete]
function num_of_ExtStatus arg# = $[complete] match arg# {
  Off => 0,
  Initial => 1,
  Clean => 2,
  Dirty => 3
}

val extStatus_bits : ExtStatus <-> bitvector(2)

mapping extStatus_bits = {
  Off <-> 0b00,
  Initial <-> 0b01,
  Clean <-> 0b10,
  Dirty <-> 0b11
}

val extStatus_to_bits : ExtStatus -> bitvector(2)

$[complete]
function extStatus_to_bits e : ExtStatus = extStatus_bits_forwards(e)

val extStatus_of_bits : bitvector(2) -> ExtStatus

$[complete]
function extStatus_of_bits b : ext_status = extStatus_bits_backwards(b)

type satp_mode = bits(4)

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum SATPMode = {Bare, Sv32, Sv39, Sv48, Sv57}

val undefined_SATPMode : unit -> SATPMode

$[complete]
function undefined_SATPMode () = internal_pick([|Bare, Sv32, Sv39, Sv48, Sv57|])

val SATPMode_of_num : forall ('e : Int), (0 <= 'e & 'e <= 4).
  int('e) -> SATPMode

$[complete]
function SATPMode_of_num arg# = $[complete] match arg# {
  0 => Bare,
  1 => Sv32,
  2 => Sv39,
  3 => Sv48,
  _ => Sv57
}

val num_of_SATPMode : SATPMode -> {('e : Int), (0 <= 'e & 'e <= 4). int('e)}

$[complete]
function num_of_SATPMode arg# = $[complete] match arg# {
  Bare => 0,
  Sv32 => 1,
  Sv39 => 2,
  Sv48 => 3,
  Sv57 => 4
}

val satpMode_of_bits : (Architecture, bitvector(4)) -> option(SATPMode)

$[complete]
function satpMode_of_bits (a : Architecture, m : satp_mode) = $[complete] match (a, m) {
  (_, 0x0) => Some(Bare),
  (RV32, 0x1) => Some(Sv32),
  (RV64, 0x8) => Some(Sv39),
  (RV64, 0x9) => Some(Sv48),
  (RV64, 0xA) => Some(Sv57),
  (_, _) => None()
}

type csrRW = bits(2)

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum WaitReason = {WAIT_WFI, WAIT_WRS_STO, WAIT_WRS_NTO}

val undefined_WaitReason : unit -> WaitReason

$[complete]
function undefined_WaitReason () = internal_pick([|WAIT_WFI, WAIT_WRS_STO, WAIT_WRS_NTO|])

val WaitReason_of_num : forall ('e : Int), (0 <= 'e & 'e <= 2).
  int('e) -> WaitReason

$[complete]
function WaitReason_of_num arg# = $[complete] match arg# {
  0 => WAIT_WFI,
  1 => WAIT_WRS_STO,
  _ => WAIT_WRS_NTO
}

val num_of_WaitReason : WaitReason -> {('e : Int), (0 <= 'e & 'e <= 2). int('e)}

$[complete]
function num_of_WaitReason arg# = $[complete] match arg# {
  WAIT_WFI => 0,
  WAIT_WRS_STO => 1,
  WAIT_WRS_NTO => 2
}

val wait_name : WaitReason <-> string

mapping wait_name = {
  WAIT_WFI <-> "WAIT-WFI",
  WAIT_WRS_STO <-> "WAIT-WRS-STO",
  WAIT_WRS_NTO <-> "WAIT-WRS-NTO"
}

overload to_str = {wait_name}

type word_width = {1, 2, 4, 8}

type word_width_wide = {1, 2, 4, 8, 16}

val width_enc : {1, 2, 4, 8} <-> bitvector(2)

mapping width_enc = {
  1 <-> 0b00,
  2 <-> 0b01,
  4 <-> 0b10,
  8 <-> 0b11
}

val width_mnemonic : {1, 2, 4, 8} <-> string

mapping width_mnemonic = {
  1 <-> "b",
  2 <-> "h",
  4 <-> "w",
  8 <-> "d"
}

val width_enc_wide : {1, 2, 4, 8, 16} <-> bitvector(3)

mapping width_enc_wide = {
  1 <-> 0b000,
  2 <-> 0b001,
  4 <-> 0b010,
  8 <-> 0b011,
  16 <-> 0b100
}

val width_mnemonic_wide : {1, 2, 4, 8, 16} <-> string

mapping width_mnemonic_wide = {
  1 <-> "b",
  2 <-> "h",
  4 <-> "w",
  8 <-> "d",
  16 <-> "q"
}

type is_sv_mode('v: Int) -> Bool = 'v in {32, 39, 48, 57}

type level_range('v: Int) constraint is_sv_mode('v) =
  range(0, if 'v == 32 then 1 else (if 'v == 39 then 2 else (if 'v == 48 then 3 else 4)))

type pte_bits('v: Int) constraint is_sv_mode('v) =
  bits(if 'v == 32 then 32 else 64)

type ppn_bits('v: Int) constraint is_sv_mode('v) =
  bits(if 'v == 32 then 22 else 44)

type vpn_bits('v: Int) constraint is_sv_mode('v) = bits('v - pagesize_bits)

type ext_access_type = unit

let Data : ext_access_type = ()

let default_write_acc : ext_access_type = Data

val accessType_to_str : AccessType(unit) -> string

$[complete]
function accessType_to_str a = $[complete] match a {
  Read(_) => "R",
  Write(_) => "W",
  ReadWrite((_, _)) => "RW",
  InstructionFetch(()) => "X"
}

overload to_str = {accessType_to_str}

type nfields_range('q: Int) -> Bool = ('q > 0 & 'q <= 8)

type nfields_range_pow2('q: Int) -> Bool = 'q in {1, 2, 4, 8}

type nfields = {('q : Int), nfields_range('q). int('q)}

type nfields_pow2 = {('q : Int), nfields_range_pow2('q). int('q)}

val encdec_nfields : bitvector(3) <-> {('q : Int), ('q > 0 & 'q <= 8). int('q)}

mapping encdec_nfields = {
  0b000 <-> 1,
  0b001 <-> 2,
  0b010 <-> 3,
  0b011 <-> 4,
  0b100 <-> 5,
  0b101 <-> 6,
  0b110 <-> 7,
  0b111 <-> 8
}

val nfields_string : {('q : Int), ('q > 0 & 'q <= 8). int('q)} <-> string

mapping nfields_string = {
  1 <-> "",
  2 <-> "seg2",
  3 <-> "seg3",
  4 <-> "seg4",
  5 <-> "seg5",
  6 <-> "seg6",
  7 <-> "seg7",
  8 <-> "seg8"
}

val encdec_nfields_pow2 : bitvector(3) <-> {1, 2, 4, 8}

mapping encdec_nfields_pow2 = {
  0b000 <-> 1,
  0b001 <-> 2,
  0b011 <-> 4,
  0b111 <-> 8
}

val nfields_pow2_string : {1, 2, 4, 8} <-> string

mapping nfields_pow2_string = {
  1 <-> "1",
  2 <-> "2",
  4 <-> "4",
  8 <-> "8"
}

val csr_name_map : bitvector(12) <-> string

val csr_name : bitvector(12) -> string

$[complete]
function csr_name csr = csr_name_map_forwards(csr)

overload to_str = {csr_name}

val is_CSR_accessible : (bitvector(12), Privilege, bool) -> bool

val read_CSR : bitvector(12) -> bitvector(xlen)

val write_CSR : (bitvector(12), bitvector(xlen)) -> result(bitvector(xlen), unit)

val mem_write_callback = pure {c: "mem_write_callback"}: forall ('n : Int), (0 < 'n & 'n <= max_mem_access).
  (string, bitvector(if xlen == 32 then 34 else 64), int('n), bitvector(8 * 'n)) -> unit

$[complete]
function mem_write_callback _ = ()

val mem_read_callback = pure {c: "mem_read_callback"}: forall ('n : Int), (0 < 'n & 'n <= max_mem_access).
  (string, bitvector(if xlen == 32 then 34 else 64), int('n), bitvector(8 * 'n)) -> unit

$[complete]
function mem_read_callback _ = ()

val mem_exception_callback = pure {c: "mem_exception_callback"}: forall ('n : Int), (0 <= 'n & 'n < xlen).
  (bitvector(if xlen == 32 then 34 else 64), int('n)) -> unit

$[complete]
function mem_exception_callback _ = ()

val pc_write_callback = pure {c: "pc_write_callback"}: bitvector(xlen) -> unit

$[complete]
function pc_write_callback _ = ()

val xreg_full_write_callback = pure {c: "xreg_full_write_callback"}: (string, regidx, bitvector(xlen)) -> unit

$[complete]
function xreg_full_write_callback _ = ()

val csr_full_write_callback = pure {c: "csr_full_write_callback"}: (string, bitvector(12), bitvector(xlen)) -> unit

$[complete]
function csr_full_write_callback _ = ()

val csr_full_read_callback = pure {c: "csr_full_read_callback"}: (string, bitvector(12), bitvector(xlen)) -> unit

$[complete]
function csr_full_read_callback _ = ()

val trap_callback = pure {c: "trap_callback"}: unit -> unit

$[complete]
function trap_callback _ = ()

val csr_name_write_callback : (string, bitvector(xlen)) -> unit

$[complete]
function csr_name_write_callback (name : string, value : xlenbits) = {
    let csr = csr_name_map_backwards(name);
    csr_full_write_callback(name, csr, value)
}

val csr_id_write_callback : (bitvector(12), bitvector(xlen)) -> unit

$[complete]
function csr_id_write_callback (csr : csreg, value : xlenbits) = {
    let name = csr_name_map_forwards(csr);
    csr_full_write_callback(name, csr, value)
}

val csr_name_read_callback : (string, bitvector(xlen)) -> unit

$[complete]
function csr_name_read_callback (name : string, value : xlenbits) = {
    let csr = csr_name_map_backwards(name);
    csr_full_read_callback(name, csr, value)
}

val csr_id_read_callback : (bitvector(12), bitvector(xlen)) -> unit

$[complete]
function csr_id_read_callback (csr : csreg, value : xlenbits) = {
    let name = csr_name_map_forwards(csr);
    csr_full_read_callback(name, csr, value)
}

overload csr_write_callback = {
  csr_name_write_callback,
  csr_id_write_callback,
  csr_full_write_callback
}

overload csr_read_callback = {
  csr_name_read_callback,
  csr_id_read_callback,
  csr_full_read_callback
}

val long_csr_write_callback : (string, string, bitvector(64)) -> unit

$[complete]
function long_csr_write_callback (name : string, name_high : string, value : bits(64)) = {
    $[overloaded { "name" = "csr_write_callback", "is_infix" = false }] csr_name_write_callback(name, $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(value, $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(xlen, 1), 0));
    if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 32) then $[overloaded { "name" = "csr_write_callback", "is_infix" = false }] csr_name_write_callback(name_high, $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(value, 63, 32));
    ()
}

type regtype = xlenbits

let zero_reg : regtype = zeros(sizeof(xlen))

val RegStr : bitvector(xlen) -> string

$[complete]
function RegStr r = bits_str(r)

val regval_from_reg : bitvector(xlen) -> bitvector(xlen)

$[complete]
function regval_from_reg r = r

val regval_into_reg : bitvector(xlen) -> bitvector(xlen)

$[complete]
function regval_into_reg v = v

register PC : xlenbits

register nextPC : xlenbits

val encdec_reg : regidx <-> bitvector(5)

mapping encdec_reg = {
  forwards Regidx(r) => zero_extend(5, r),
  backwards r if $[overloaded { "name" = "|", "is_infix" = true }] or_bool(not(base_E_enabled), $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(r, 4), bitzero)) => Regidx($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(r, $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(regidx_bit_width, 1), 0))
}

val encdec_creg : cregidx <-> bitvector(3)

mapping encdec_creg = {Cregidx(r) <-> r}

val reg_abi_name_raw : bitvector(5) <-> string

mapping reg_abi_name_raw = {
  0b00000 <-> "zero",
  0b00001 <-> "ra",
  0b00010 <-> "sp",
  0b00011 <-> "gp",
  0b00100 <-> "tp",
  0b00101 <-> "t0",
  0b00110 <-> "t1",
  0b00111 <-> "t2",
  0b01000 <-> "s0",
  0b01000 <-> "fp",
  0b01001 <-> "s1",
  0b01010 <-> "a0",
  0b01011 <-> "a1",
  0b01100 <-> "a2",
  0b01101 <-> "a3",
  0b01110 <-> "a4",
  0b01111 <-> "a5",
  0b10000 <-> "a6",
  0b10001 <-> "a7",
  0b10010 <-> "s2",
  0b10011 <-> "s3",
  0b10100 <-> "s4",
  0b10101 <-> "s5",
  0b10110 <-> "s6",
  0b10111 <-> "s7",
  0b11000 <-> "s8",
  0b11001 <-> "s9",
  0b11010 <-> "s10",
  0b11011 <-> "s11",
  0b11100 <-> "t3",
  0b11101 <-> "t4",
  0b11110 <-> "t5",
  0b11111 <-> "t6"
}

val reg_arch_name_raw : bitvector(5) <-> string

mapping reg_arch_name_raw = {
  0b00000 <-> "x0",
  0b00001 <-> "x1",
  0b00010 <-> "x2",
  0b00011 <-> "x3",
  0b00100 <-> "x4",
  0b00101 <-> "x5",
  0b00110 <-> "x6",
  0b00111 <-> "x7",
  0b01000 <-> "x8",
  0b01001 <-> "x9",
  0b01010 <-> "x10",
  0b01011 <-> "x11",
  0b01100 <-> "x12",
  0b01101 <-> "x13",
  0b01110 <-> "x14",
  0b01111 <-> "x15",
  0b10000 <-> "x16",
  0b10001 <-> "x17",
  0b10010 <-> "x18",
  0b10011 <-> "x19",
  0b10100 <-> "x20",
  0b10101 <-> "x21",
  0b10110 <-> "x22",
  0b10111 <-> "x23",
  0b11000 <-> "x24",
  0b11001 <-> "x25",
  0b11010 <-> "x26",
  0b11011 <-> "x27",
  0b11100 <-> "x28",
  0b11101 <-> "x29",
  0b11110 <-> "x30",
  0b11111 <-> "x31"
}

val reg_name : regidx <-> string

mapping reg_name = {
  encdec_reg(i) if get_config_use_abi_names() <-> reg_abi_name_raw(i),
  encdec_reg(i) if not(get_config_use_abi_names()) <-> reg_arch_name_raw(i)
}

val sp_reg_name : unit <-> string

mapping sp_reg_name = {
  () if get_config_use_abi_names() <-> "sp",
  () if not(get_config_use_abi_names()) <-> "x2"
}

val creg_name : cregidx <-> string

mapping creg_name = {
  Cregidx(i) <-> reg_name(encdec_reg(0b01 @ (i : bitvector(3))))
}

val xreg_write_callback : (regidx, bitvector(xlen)) -> unit

$[complete]
function xreg_write_callback (reg : regidx, value : xlenbits) = {
    let name = reg_name_forwards(reg);
    xreg_full_write_callback(name, reg, value)
}

register x1 : regtype

register x2 : regtype

register x3 : regtype

register x4 : regtype

register x5 : regtype

register x6 : regtype

register x7 : regtype

register x8 : regtype

register x9 : regtype

register x10 : regtype

register x11 : regtype

register x12 : regtype

register x13 : regtype

register x14 : regtype

register x15 : regtype

register x16 : regtype

register x17 : regtype

register x18 : regtype

register x19 : regtype

register x20 : regtype

register x21 : regtype

register x22 : regtype

register x23 : regtype

register x24 : regtype

register x25 : regtype

register x26 : regtype

register x27 : regtype

register x28 : regtype

register x29 : regtype

register x30 : regtype

register x31 : regtype

val rX : regno -> bitvector(xlen)

$[complete]
function rX Regno(r) : regno = {
    let v : regtype = $[complete] match r {
      0 => zero_reg,
      1 => x1,
      2 => x2,
      3 => x3,
      4 => x4,
      5 => x5,
      6 => x6,
      7 => x7,
      8 => x8,
      9 => x9,
      10 => x10,
      11 => x11,
      12 => x12,
      13 => x13,
      14 => x14,
      15 => x15,
      16 => x16,
      17 => x17,
      18 => x18,
      19 => x19,
      20 => x20,
      21 => x21,
      22 => x22,
      23 => x23,
      24 => x24,
      25 => x25,
      26 => x26,
      27 => x27,
      28 => x28,
      29 => x29,
      30 => x30,
      ($[int_wildcard 31] _) => x31
    };
    regval_from_reg(v)
}

val wX : (regno, bitvector(xlen)) -> unit

$[complete]
function wX (Regno(r) : regno, in_v : xlenbits) = {
    let v = regval_into_reg(in_v);
    $[complete] match r {
      0 => (),
      1 => x1 = v,
      2 => x2 = v,
      3 => x3 = v,
      4 => x4 = v,
      5 => x5 = v,
      6 => x6 = v,
      7 => x7 = v,
      8 => x8 = v,
      9 => x9 = v,
      10 => x10 = v,
      11 => x11 = v,
      12 => x12 = v,
      13 => x13 = v,
      14 => x14 = v,
      15 => x15 = v,
      16 => x16 = v,
      17 => x17 = v,
      18 => x18 = v,
      19 => x19 = v,
      20 => x20 = v,
      21 => x21 = v,
      22 => x22 = v,
      23 => x23 = v,
      24 => x24 = v,
      25 => x25 = v,
      26 => x26 = v,
      27 => x27 = v,
      28 => x28 = v,
      29 => x29 = v,
      30 => x30 = v,
      ($[int_wildcard 31] _) => x31 = v
    };
    if $[overloaded { "name" = "!=", "is_infix" = true }] neq_int(r, 0) then xreg_write_callback(Regidx(to_bits(if constraint(base_E_enabled) then
      4
    else
      5, r)), in_v);
    ()
}

val rX_bits : regidx -> bitvector(xlen)

$[complete]
function rX_bits Regidx(i) : regidx = rX(Regno(unsigned(i)))

val wX_bits : (regidx, bitvector(xlen)) -> unit

$[complete]
function wX_bits (Regidx(i) : regidx, data : xlenbits) = {
    $[setter] wX(Regno(unsigned(i)), data)
}

overload X = {rX_bits, wX_bits, rX, wX}

val rX_pair_bits : regidx -> bitvector(xlen * 2)

$[complete]
function rX_pair_bits i : regidx = if $[overloaded { "name" = "!=", "is_infix" = true }] neq_anything(i, zreg) then
  $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat($[overloaded { "name" = "X", "is_infix" = false }] rX_bits($[overloaded { "name" = "+", "is_infix" = true }] regidx_offset_range(i, 1)), $[overloaded { "name" = "X", "is_infix" = false }] rX_bits(i))
else
  zeros(mult_atom(sizeof(xlen), 2))

val wX_pair_bits : (regidx, bitvector(xlen * 2)) -> unit

$[complete]
function wX_pair_bits (i : regidx, data : bits(xlen * 2)) = if $[overloaded { "name" = "!=", "is_infix" = true }] neq_anything(i, zreg) then {
    $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(i, $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(data, $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(xlen, 1), 0));
    $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits($[overloaded { "name" = "+", "is_infix" = true }] regidx_offset_range(i, 1), $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(data, $[overloaded { "name" = "-", "is_infix" = true }] sub_atom($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(xlen, 2), 1), xlen))
} else ()

overload X_pair = {rX_pair_bits, wX_pair_bits}

/*!
  Retrieves the architectural PC value. This is not necessarily the value
  found in the PC register as extensions may choose to override this function.
  The value in the PC register is the absolute virtual address of the instruction
  to fetch.
 */
val get_arch_pc : unit -> bitvector(xlen)

$[complete]
function get_arch_pc () = PC

val get_next_pc : unit -> bitvector(xlen)

$[complete]
function get_next_pc () = nextPC

val set_next_pc : bitvector(xlen) -> unit

$[complete]
function set_next_pc pc = {
    sail_branch_announce(xlen, pc);
    nextPC = pc
}

val tick_pc : unit -> unit

$[complete]
function tick_pc () = {
    PC = nextPC;
    pc_write_callback(PC)
}

register cur_privilege : Privilege

register cur_inst : xlenbits

$[undefined_gen "skip"]
$[bitfield]
struct Misa = {bits : bitvector(xlen)}

val undefined_Misa : unit -> Misa

$[complete]
function undefined_Misa () = struct Misa { bits = undefined }

val Mk_Misa : bitvector(xlen) -> Misa

$[complete]
function Mk_Misa v = struct Misa { bits = v }

$[fix_location]
val _get_Misa_bits : Misa -> bitvector(xlen)

$[complete]
$[fix_location]
function _get_Misa_bits v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, sub_atom(sizeof(xlen), 1), 0)

$[fix_location]
val _update_Misa_bits : (Misa, bitvector(xlen)) -> Misa

$[complete]
$[fix_location]
function _update_Misa_bits (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, sub_atom(sizeof(xlen), 1), 0, x) }

$[fix_location]
overload update_bits = {_update_Misa_bits}

$[fix_location]
val _set_Misa_bits : (register(Misa), bitvector(xlen)) -> unit

$[complete]
$[fix_location]
function _set_Misa_bits (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Misa_bits(r, v)
}

overload _mod_bits = {_get_Misa_bits, _set_Misa_bits}

$[fix_location]
val _get_Misa_A : Misa -> bitvector(1)

$[complete]
$[fix_location]
function _get_Misa_A v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 0, 0)

$[fix_location]
val _update_Misa_A : (Misa, bitvector(1)) -> Misa

$[complete]
$[fix_location]
function _update_Misa_A (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 0, 0, x) }

$[fix_location]
overload update_A = {_update_Misa_A}

$[fix_location]
val _set_Misa_A : (register(Misa), bitvector(1)) -> unit

$[complete]
$[fix_location]
function _set_Misa_A (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Misa_A(r, v)
}

overload _mod_A = {_get_Misa_A, _set_Misa_A}

$[fix_location]
val _get_Misa_B : Misa -> bitvector(1)

$[complete]
$[fix_location]
function _get_Misa_B v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 1, 1)

$[fix_location]
val _update_Misa_B : (Misa, bitvector(1)) -> Misa

$[complete]
$[fix_location]
function _update_Misa_B (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 1, 1, x) }

$[fix_location]
overload update_B = {_update_Misa_B}

$[fix_location]
val _set_Misa_B : (register(Misa), bitvector(1)) -> unit

$[complete]
$[fix_location]
function _set_Misa_B (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Misa_B(r, v)
}

overload _mod_B = {_get_Misa_B, _set_Misa_B}

$[fix_location]
val _get_Misa_C : Misa -> bitvector(1)

$[complete]
$[fix_location]
function _get_Misa_C v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 2, 2)

$[fix_location]
val _update_Misa_C : (Misa, bitvector(1)) -> Misa

$[complete]
$[fix_location]
function _update_Misa_C (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 2, 2, x) }

$[fix_location]
overload update_C = {_update_Misa_C}

$[fix_location]
val _set_Misa_C : (register(Misa), bitvector(1)) -> unit

$[complete]
$[fix_location]
function _set_Misa_C (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Misa_C(r, v)
}

overload _mod_C = {_get_Misa_C, _set_Misa_C}

$[fix_location]
val _get_Misa_D : Misa -> bitvector(1)

$[complete]
$[fix_location]
function _get_Misa_D v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 3, 3)

$[fix_location]
val _update_Misa_D : (Misa, bitvector(1)) -> Misa

$[complete]
$[fix_location]
function _update_Misa_D (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 3, 3, x) }

$[fix_location]
overload update_D = {_update_Misa_D}

$[fix_location]
val _set_Misa_D : (register(Misa), bitvector(1)) -> unit

$[complete]
$[fix_location]
function _set_Misa_D (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Misa_D(r, v)
}

overload _mod_D = {_get_Misa_D, _set_Misa_D}

$[fix_location]
val _get_Misa_E : Misa -> bitvector(1)

$[complete]
$[fix_location]
function _get_Misa_E v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 4, 4)

$[fix_location]
val _update_Misa_E : (Misa, bitvector(1)) -> Misa

$[complete]
$[fix_location]
function _update_Misa_E (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 4, 4, x) }

$[fix_location]
overload update_E = {_update_Misa_E}

$[fix_location]
val _set_Misa_E : (register(Misa), bitvector(1)) -> unit

$[complete]
$[fix_location]
function _set_Misa_E (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Misa_E(r, v)
}

overload _mod_E = {_get_Misa_E, _set_Misa_E}

$[fix_location]
val _get_Misa_F : Misa -> bitvector(1)

$[complete]
$[fix_location]
function _get_Misa_F v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 5, 5)

$[fix_location]
val _update_Misa_F : (Misa, bitvector(1)) -> Misa

$[complete]
$[fix_location]
function _update_Misa_F (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 5, 5, x) }

$[fix_location]
overload update_F = {_update_Misa_F}

$[fix_location]
val _set_Misa_F : (register(Misa), bitvector(1)) -> unit

$[complete]
$[fix_location]
function _set_Misa_F (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Misa_F(r, v)
}

overload _mod_F = {_get_Misa_F, _set_Misa_F}

$[fix_location]
val _get_Misa_G : Misa -> bitvector(1)

$[complete]
$[fix_location]
function _get_Misa_G v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 6, 6)

$[fix_location]
val _update_Misa_G : (Misa, bitvector(1)) -> Misa

$[complete]
$[fix_location]
function _update_Misa_G (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 6, 6, x) }

$[fix_location]
overload update_G = {_update_Misa_G}

$[fix_location]
val _set_Misa_G : (register(Misa), bitvector(1)) -> unit

$[complete]
$[fix_location]
function _set_Misa_G (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Misa_G(r, v)
}

overload _mod_G = {_get_Misa_G, _set_Misa_G}

$[fix_location]
val _get_Misa_H : Misa -> bitvector(1)

$[complete]
$[fix_location]
function _get_Misa_H v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 7, 7)

$[fix_location]
val _update_Misa_H : (Misa, bitvector(1)) -> Misa

$[complete]
$[fix_location]
function _update_Misa_H (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 7, 7, x) }

$[fix_location]
overload update_H = {_update_Misa_H}

$[fix_location]
val _set_Misa_H : (register(Misa), bitvector(1)) -> unit

$[complete]
$[fix_location]
function _set_Misa_H (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Misa_H(r, v)
}

overload _mod_H = {_get_Misa_H, _set_Misa_H}

$[fix_location]
val _get_Misa_I : Misa -> bitvector(1)

$[complete]
$[fix_location]
function _get_Misa_I v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 8, 8)

$[fix_location]
val _update_Misa_I : (Misa, bitvector(1)) -> Misa

$[complete]
$[fix_location]
function _update_Misa_I (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 8, 8, x) }

$[fix_location]
overload update_I = {_update_Misa_I}

$[fix_location]
val _set_Misa_I : (register(Misa), bitvector(1)) -> unit

$[complete]
$[fix_location]
function _set_Misa_I (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Misa_I(r, v)
}

overload _mod_I = {_get_Misa_I, _set_Misa_I}

$[fix_location]
val _get_Misa_J : Misa -> bitvector(1)

$[complete]
$[fix_location]
function _get_Misa_J v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 9, 9)

$[fix_location]
val _update_Misa_J : (Misa, bitvector(1)) -> Misa

$[complete]
$[fix_location]
function _update_Misa_J (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 9, 9, x) }

$[fix_location]
overload update_J = {_update_Misa_J}

$[fix_location]
val _set_Misa_J : (register(Misa), bitvector(1)) -> unit

$[complete]
$[fix_location]
function _set_Misa_J (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Misa_J(r, v)
}

overload _mod_J = {_get_Misa_J, _set_Misa_J}

$[fix_location]
val _get_Misa_K : Misa -> bitvector(1)

$[complete]
$[fix_location]
function _get_Misa_K v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 10, 10)

$[fix_location]
val _update_Misa_K : (Misa, bitvector(1)) -> Misa

$[complete]
$[fix_location]
function _update_Misa_K (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 10, 10, x) }

$[fix_location]
overload update_K = {_update_Misa_K}

$[fix_location]
val _set_Misa_K : (register(Misa), bitvector(1)) -> unit

$[complete]
$[fix_location]
function _set_Misa_K (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Misa_K(r, v)
}

overload _mod_K = {_get_Misa_K, _set_Misa_K}

$[fix_location]
val _get_Misa_L : Misa -> bitvector(1)

$[complete]
$[fix_location]
function _get_Misa_L v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 11, 11)

$[fix_location]
val _update_Misa_L : (Misa, bitvector(1)) -> Misa

$[complete]
$[fix_location]
function _update_Misa_L (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 11, 11, x) }

$[fix_location]
overload update_L = {_update_Misa_L}

$[fix_location]
val _set_Misa_L : (register(Misa), bitvector(1)) -> unit

$[complete]
$[fix_location]
function _set_Misa_L (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Misa_L(r, v)
}

overload _mod_L = {_get_Misa_L, _set_Misa_L}

$[fix_location]
val _get_Misa_M : Misa -> bitvector(1)

$[complete]
$[fix_location]
function _get_Misa_M v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 12, 12)

$[fix_location]
val _update_Misa_M : (Misa, bitvector(1)) -> Misa

$[complete]
$[fix_location]
function _update_Misa_M (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 12, 12, x) }

$[fix_location]
overload update_M = {_update_Misa_M}

$[fix_location]
val _set_Misa_M : (register(Misa), bitvector(1)) -> unit

$[complete]
$[fix_location]
function _set_Misa_M (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Misa_M(r, v)
}

overload _mod_M = {_get_Misa_M, _set_Misa_M}

$[fix_location]
val _get_Misa_MXL : Misa -> bitvector(xlen - 1 - (xlen - 2) + 1)

$[complete]
$[fix_location]
function _get_Misa_MXL v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, sub_atom(sizeof(xlen), 1), sub_atom(sizeof(xlen), 2))

$[fix_location]
val _update_Misa_MXL : (Misa, bitvector(xlen - 1 - (xlen - 2) + 1)) -> Misa

$[complete]
$[fix_location]
function _update_Misa_MXL (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, sub_atom(sizeof(xlen), 1), sub_atom(sizeof(xlen), 2), x) }

$[fix_location]
overload update_MXL = {_update_Misa_MXL}

$[fix_location]
val _set_Misa_MXL : (register(Misa), bitvector(xlen - 1 - (xlen - 2) + 1)) -> unit

$[complete]
$[fix_location]
function _set_Misa_MXL (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Misa_MXL(r, v)
}

overload _mod_MXL = {_get_Misa_MXL, _set_Misa_MXL}

$[fix_location]
val _get_Misa_N : Misa -> bitvector(1)

$[complete]
$[fix_location]
function _get_Misa_N v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 13, 13)

$[fix_location]
val _update_Misa_N : (Misa, bitvector(1)) -> Misa

$[complete]
$[fix_location]
function _update_Misa_N (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 13, 13, x) }

$[fix_location]
overload update_N = {_update_Misa_N}

$[fix_location]
val _set_Misa_N : (register(Misa), bitvector(1)) -> unit

$[complete]
$[fix_location]
function _set_Misa_N (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Misa_N(r, v)
}

overload _mod_N = {_get_Misa_N, _set_Misa_N}

$[fix_location]
val _get_Misa_O : Misa -> bitvector(1)

$[complete]
$[fix_location]
function _get_Misa_O v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 14, 14)

$[fix_location]
val _update_Misa_O : (Misa, bitvector(1)) -> Misa

$[complete]
$[fix_location]
function _update_Misa_O (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 14, 14, x) }

$[fix_location]
overload update_O = {_update_Misa_O}

$[fix_location]
val _set_Misa_O : (register(Misa), bitvector(1)) -> unit

$[complete]
$[fix_location]
function _set_Misa_O (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Misa_O(r, v)
}

overload _mod_O = {_get_Misa_O, _set_Misa_O}

$[fix_location]
val _get_Misa_P : Misa -> bitvector(1)

$[complete]
$[fix_location]
function _get_Misa_P v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 15, 15)

$[fix_location]
val _update_Misa_P : (Misa, bitvector(1)) -> Misa

$[complete]
$[fix_location]
function _update_Misa_P (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 15, 15, x) }

$[fix_location]
overload update_P = {_update_Misa_P}

$[fix_location]
val _set_Misa_P : (register(Misa), bitvector(1)) -> unit

$[complete]
$[fix_location]
function _set_Misa_P (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Misa_P(r, v)
}

overload _mod_P = {_get_Misa_P, _set_Misa_P}

$[fix_location]
val _get_Misa_Q : Misa -> bitvector(1)

$[complete]
$[fix_location]
function _get_Misa_Q v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 16, 16)

$[fix_location]
val _update_Misa_Q : (Misa, bitvector(1)) -> Misa

$[complete]
$[fix_location]
function _update_Misa_Q (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 16, 16, x) }

$[fix_location]
overload update_Q = {_update_Misa_Q}

$[fix_location]
val _set_Misa_Q : (register(Misa), bitvector(1)) -> unit

$[complete]
$[fix_location]
function _set_Misa_Q (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Misa_Q(r, v)
}

overload _mod_Q = {_get_Misa_Q, _set_Misa_Q}

$[fix_location]
val _get_Misa_R : Misa -> bitvector(1)

$[complete]
$[fix_location]
function _get_Misa_R v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 17, 17)

$[fix_location]
val _update_Misa_R : (Misa, bitvector(1)) -> Misa

$[complete]
$[fix_location]
function _update_Misa_R (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 17, 17, x) }

$[fix_location]
overload update_R = {_update_Misa_R}

$[fix_location]
val _set_Misa_R : (register(Misa), bitvector(1)) -> unit

$[complete]
$[fix_location]
function _set_Misa_R (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Misa_R(r, v)
}

overload _mod_R = {_get_Misa_R, _set_Misa_R}

$[fix_location]
val _get_Misa_S : Misa -> bitvector(1)

$[complete]
$[fix_location]
function _get_Misa_S v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 18, 18)

$[fix_location]
val _update_Misa_S : (Misa, bitvector(1)) -> Misa

$[complete]
$[fix_location]
function _update_Misa_S (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 18, 18, x) }

$[fix_location]
overload update_S = {_update_Misa_S}

$[fix_location]
val _set_Misa_S : (register(Misa), bitvector(1)) -> unit

$[complete]
$[fix_location]
function _set_Misa_S (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Misa_S(r, v)
}

overload _mod_S = {_get_Misa_S, _set_Misa_S}

$[fix_location]
val _get_Misa_T : Misa -> bitvector(1)

$[complete]
$[fix_location]
function _get_Misa_T v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 19, 19)

$[fix_location]
val _update_Misa_T : (Misa, bitvector(1)) -> Misa

$[complete]
$[fix_location]
function _update_Misa_T (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 19, 19, x) }

$[fix_location]
overload update_T = {_update_Misa_T}

$[fix_location]
val _set_Misa_T : (register(Misa), bitvector(1)) -> unit

$[complete]
$[fix_location]
function _set_Misa_T (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Misa_T(r, v)
}

overload _mod_T = {_get_Misa_T, _set_Misa_T}

$[fix_location]
val _get_Misa_U : Misa -> bitvector(1)

$[complete]
$[fix_location]
function _get_Misa_U v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 20, 20)

$[fix_location]
val _update_Misa_U : (Misa, bitvector(1)) -> Misa

$[complete]
$[fix_location]
function _update_Misa_U (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 20, 20, x) }

$[fix_location]
overload update_U = {_update_Misa_U}

$[fix_location]
val _set_Misa_U : (register(Misa), bitvector(1)) -> unit

$[complete]
$[fix_location]
function _set_Misa_U (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Misa_U(r, v)
}

overload _mod_U = {_get_Misa_U, _set_Misa_U}

$[fix_location]
val _get_Misa_V : Misa -> bitvector(1)

$[complete]
$[fix_location]
function _get_Misa_V v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 21, 21)

$[fix_location]
val _update_Misa_V : (Misa, bitvector(1)) -> Misa

$[complete]
$[fix_location]
function _update_Misa_V (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 21, 21, x) }

$[fix_location]
overload update_V = {_update_Misa_V}

$[fix_location]
val _set_Misa_V : (register(Misa), bitvector(1)) -> unit

$[complete]
$[fix_location]
function _set_Misa_V (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Misa_V(r, v)
}

overload _mod_V = {_get_Misa_V, _set_Misa_V}

$[fix_location]
val _get_Misa_W : Misa -> bitvector(1)

$[complete]
$[fix_location]
function _get_Misa_W v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 22, 22)

$[fix_location]
val _update_Misa_W : (Misa, bitvector(1)) -> Misa

$[complete]
$[fix_location]
function _update_Misa_W (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 22, 22, x) }

$[fix_location]
overload update_W = {_update_Misa_W}

$[fix_location]
val _set_Misa_W : (register(Misa), bitvector(1)) -> unit

$[complete]
$[fix_location]
function _set_Misa_W (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Misa_W(r, v)
}

overload _mod_W = {_get_Misa_W, _set_Misa_W}

$[fix_location]
val _get_Misa_X : Misa -> bitvector(1)

$[complete]
$[fix_location]
function _get_Misa_X v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 23, 23)

$[fix_location]
val _update_Misa_X : (Misa, bitvector(1)) -> Misa

$[complete]
$[fix_location]
function _update_Misa_X (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 23, 23, x) }

$[fix_location]
overload update_X = {_update_Misa_X}

$[fix_location]
val _set_Misa_X : (register(Misa), bitvector(1)) -> unit

$[complete]
$[fix_location]
function _set_Misa_X (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Misa_X(r, v)
}

overload _mod_X = {_get_Misa_X, _set_Misa_X}

$[fix_location]
val _get_Misa_Y : Misa -> bitvector(1)

$[complete]
$[fix_location]
function _get_Misa_Y v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 24, 24)

$[fix_location]
val _update_Misa_Y : (Misa, bitvector(1)) -> Misa

$[complete]
$[fix_location]
function _update_Misa_Y (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 24, 24, x) }

$[fix_location]
overload update_Y = {_update_Misa_Y}

$[fix_location]
val _set_Misa_Y : (register(Misa), bitvector(1)) -> unit

$[complete]
$[fix_location]
function _set_Misa_Y (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Misa_Y(r, v)
}

overload _mod_Y = {_get_Misa_Y, _set_Misa_Y}

$[fix_location]
val _get_Misa_Z : Misa -> bitvector(1)

$[complete]
$[fix_location]
function _get_Misa_Z v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 25, 25)

$[fix_location]
val _update_Misa_Z : (Misa, bitvector(1)) -> Misa

$[complete]
$[fix_location]
function _update_Misa_Z (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 25, 25, x) }

$[fix_location]
overload update_Z = {_update_Misa_Z}

$[fix_location]
val _set_Misa_Z : (register(Misa), bitvector(1)) -> unit

$[complete]
$[fix_location]
function _set_Misa_Z (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Misa_Z(r, v)
}

overload _mod_Z = {_get_Misa_Z, _set_Misa_Z}

register misa : Misa = _update_Misa_MXL(Mk_Misa(zeros(sizeof(xlen))), architecture_forwards(if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 32) then
  RV32
else
  RV64))

let sys_enable_writable_misa : bool = config base.writable_misa

let sys_enable_writable_fiom : bool = config base.writable_fiom

let sys_writable_hpm_counters : bits(32) = config base.writable_hpm_counters

val ext_veto_disable_C : unit -> bool

val legalize_misa : (Misa, bitvector(xlen)) -> Misa

$[complete]
function legalize_misa (m : Misa, v : xlenbits) = {
    let v = Mk_Misa(v);
    if $[overloaded { "name" = "|", "is_infix" = true }] or_bool(not(sys_enable_writable_misa), $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_bits(_get_Misa_C(v), 0b0), $[overloaded { "name" = "|", "is_infix" = true }] or_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(nextPC, 1), bitone), ext_veto_disable_C()))) then
      m
    else
      _update_Misa_V(_update_Misa_U(_update_Misa_S(_update_Misa_M(_update_Misa_E(_update_Misa_I(_update_Misa_H(_update_Misa_F(_update_Misa_D(_update_Misa_C(_update_Misa_B(_update_Misa_A(m, if hartSupports(Ext_A) then
        _get_Misa_A(v)
      else
        0b0), if hartSupports(Ext_B) then _get_Misa_B(v) else 0b0), if hartSupports(Ext_C) then
        _get_Misa_C(v)
      else
        0b0), if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(hartSupports(Ext_D), $[overloaded { "name" = "==", "is_infix" = true }] eq_bits(_get_Misa_F(v), 0b1)) then
        _get_Misa_D(v)
      else
        0b0), if hartSupports(Ext_F) then _get_Misa_F(v) else 0b0), if hartSupports(Ext_H) then
        _get_Misa_H(v)
      else
        0b0), bool_to_bits(not(base_E_enabled))), bool_to_bits(base_E_enabled)), if hartSupports(Ext_M) then
        _get_Misa_M(v)
      else
        0b0), if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(hartSupports(Ext_S), $[overloaded { "name" = "==", "is_infix" = true }] eq_bits(_get_Misa_U(v), 0b1)) then
        _get_Misa_S(v)
      else
        0b0), if hartSupports(Ext_U) then _get_Misa_U(v) else 0b0), if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(hartSupports(Ext_V), $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_bits(_get_Misa_F(v), 0b1), $[overloaded { "name" = "==", "is_infix" = true }] eq_bits(_get_Misa_D(v), 0b1))) then
        _get_Misa_V(v)
      else
        0b0)
}

val virtual_memory_supported : unit -> bool

$[complete]
function virtual_memory_supported () = {
    $[overloaded { "name" = "|", "is_infix" = true }] or_bool(currentlyEnabled(Ext_Sv32), $[overloaded { "name" = "|", "is_infix" = true }] or_bool(currentlyEnabled(Ext_Sv39), $[overloaded { "name" = "|", "is_infix" = true }] or_bool(currentlyEnabled(Ext_Sv48), currentlyEnabled(Ext_Sv57))))
}

val lowest_supported_privLevel : unit -> Privilege

$[complete]
function lowest_supported_privLevel () = if currentlyEnabled(Ext_U) then User
else
  Machine

val have_nominal_privLevel : bitvector(2) -> bool

$[complete]
function have_nominal_privLevel priv : nom_priv_bits = $[complete] match priv {
  0b00 => currentlyEnabled(Ext_U),
  0b01 => currentlyEnabled(Ext_S),
  0b10 => false,
  _ : bitvector(2) => true
}

$[undefined_gen "skip"]
$[bitfield]
struct Mstatus = {bits : bitvector(64)}

val undefined_Mstatus : unit -> Mstatus

$[complete]
function undefined_Mstatus () = struct Mstatus { bits = undefined }

val Mk_Mstatus : bitvector(64) -> Mstatus

$[complete]
function Mk_Mstatus v = struct Mstatus { bits = v }

$[fix_location]
val _get_Mstatus_bits : Mstatus -> bitvector(64)

$[complete]
$[fix_location]
function _get_Mstatus_bits v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, sub_atom(64, 1), 0)

$[fix_location]
val _update_Mstatus_bits : (Mstatus, bitvector(64)) -> Mstatus

$[complete]
$[fix_location]
function _update_Mstatus_bits (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, sub_atom(64, 1), 0, x) }

$[fix_location]
overload update_bits = {_update_Mstatus_bits}

$[fix_location]
val _set_Mstatus_bits : (register(Mstatus), bitvector(64)) -> unit

$[complete]
$[fix_location]
function _set_Mstatus_bits (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Mstatus_bits(r, v)
}

overload _mod_bits = {_get_Mstatus_bits, _set_Mstatus_bits}

$[fix_location]
val _get_Mstatus_FS : Mstatus -> bitvector(2)

$[complete]
$[fix_location]
function _get_Mstatus_FS v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 14, 13)

$[fix_location]
val _update_Mstatus_FS : (Mstatus, bitvector(2)) -> Mstatus

$[complete]
$[fix_location]
function _update_Mstatus_FS (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 14, 13, x) }

$[fix_location]
overload update_FS = {_update_Mstatus_FS}

$[fix_location]
val _set_Mstatus_FS : (register(Mstatus), bitvector(2)) -> unit

$[complete]
$[fix_location]
function _set_Mstatus_FS (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Mstatus_FS(r, v)
}

overload _mod_FS = {_get_Mstatus_FS, _set_Mstatus_FS}

$[fix_location]
val _get_Mstatus_MBE : Mstatus -> bitvector(1)

$[complete]
$[fix_location]
function _get_Mstatus_MBE v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 37, 37)

$[fix_location]
val _update_Mstatus_MBE : (Mstatus, bitvector(1)) -> Mstatus

$[complete]
$[fix_location]
function _update_Mstatus_MBE (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 37, 37, x) }

$[fix_location]
overload update_MBE = {_update_Mstatus_MBE}

$[fix_location]
val _set_Mstatus_MBE : (register(Mstatus), bitvector(1)) -> unit

$[complete]
$[fix_location]
function _set_Mstatus_MBE (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Mstatus_MBE(r, v)
}

overload _mod_MBE = {_get_Mstatus_MBE, _set_Mstatus_MBE}

$[fix_location]
val _get_Mstatus_MIE : Mstatus -> bitvector(1)

$[complete]
$[fix_location]
function _get_Mstatus_MIE v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 3, 3)

$[fix_location]
val _update_Mstatus_MIE : (Mstatus, bitvector(1)) -> Mstatus

$[complete]
$[fix_location]
function _update_Mstatus_MIE (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 3, 3, x) }

$[fix_location]
overload update_MIE = {_update_Mstatus_MIE}

$[fix_location]
val _set_Mstatus_MIE : (register(Mstatus), bitvector(1)) -> unit

$[complete]
$[fix_location]
function _set_Mstatus_MIE (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Mstatus_MIE(r, v)
}

overload _mod_MIE = {_get_Mstatus_MIE, _set_Mstatus_MIE}

$[fix_location]
val _get_Mstatus_MPIE : Mstatus -> bitvector(1)

$[complete]
$[fix_location]
function _get_Mstatus_MPIE v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 7, 7)

$[fix_location]
val _update_Mstatus_MPIE : (Mstatus, bitvector(1)) -> Mstatus

$[complete]
$[fix_location]
function _update_Mstatus_MPIE (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 7, 7, x) }

$[fix_location]
overload update_MPIE = {_update_Mstatus_MPIE}

$[fix_location]
val _set_Mstatus_MPIE : (register(Mstatus), bitvector(1)) -> unit

$[complete]
$[fix_location]
function _set_Mstatus_MPIE (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Mstatus_MPIE(r, v)
}

overload _mod_MPIE = {_get_Mstatus_MPIE, _set_Mstatus_MPIE}

$[fix_location]
val _get_Mstatus_MPP : Mstatus -> bitvector(2)

$[complete]
$[fix_location]
function _get_Mstatus_MPP v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 12, 11)

$[fix_location]
val _update_Mstatus_MPP : (Mstatus, bitvector(2)) -> Mstatus

$[complete]
$[fix_location]
function _update_Mstatus_MPP (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 12, 11, x) }

$[fix_location]
overload update_MPP = {_update_Mstatus_MPP}

$[fix_location]
val _set_Mstatus_MPP : (register(Mstatus), bitvector(2)) -> unit

$[complete]
$[fix_location]
function _set_Mstatus_MPP (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Mstatus_MPP(r, v)
}

overload _mod_MPP = {_get_Mstatus_MPP, _set_Mstatus_MPP}

$[fix_location]
val _get_Mstatus_MPRV : Mstatus -> bitvector(1)

$[complete]
$[fix_location]
function _get_Mstatus_MPRV v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 17, 17)

$[fix_location]
val _update_Mstatus_MPRV : (Mstatus, bitvector(1)) -> Mstatus

$[complete]
$[fix_location]
function _update_Mstatus_MPRV (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 17, 17, x) }

$[fix_location]
overload update_MPRV = {_update_Mstatus_MPRV}

$[fix_location]
val _set_Mstatus_MPRV : (register(Mstatus), bitvector(1)) -> unit

$[complete]
$[fix_location]
function _set_Mstatus_MPRV (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Mstatus_MPRV(r, v)
}

overload _mod_MPRV = {_get_Mstatus_MPRV, _set_Mstatus_MPRV}

$[fix_location]
val _get_Mstatus_MXR : Mstatus -> bitvector(1)

$[complete]
$[fix_location]
function _get_Mstatus_MXR v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 19, 19)

$[fix_location]
val _update_Mstatus_MXR : (Mstatus, bitvector(1)) -> Mstatus

$[complete]
$[fix_location]
function _update_Mstatus_MXR (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 19, 19, x) }

$[fix_location]
overload update_MXR = {_update_Mstatus_MXR}

$[fix_location]
val _set_Mstatus_MXR : (register(Mstatus), bitvector(1)) -> unit

$[complete]
$[fix_location]
function _set_Mstatus_MXR (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Mstatus_MXR(r, v)
}

overload _mod_MXR = {_get_Mstatus_MXR, _set_Mstatus_MXR}

$[fix_location]
val _get_Mstatus_SBE : Mstatus -> bitvector(1)

$[complete]
$[fix_location]
function _get_Mstatus_SBE v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 36, 36)

$[fix_location]
val _update_Mstatus_SBE : (Mstatus, bitvector(1)) -> Mstatus

$[complete]
$[fix_location]
function _update_Mstatus_SBE (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 36, 36, x) }

$[fix_location]
overload update_SBE = {_update_Mstatus_SBE}

$[fix_location]
val _set_Mstatus_SBE : (register(Mstatus), bitvector(1)) -> unit

$[complete]
$[fix_location]
function _set_Mstatus_SBE (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Mstatus_SBE(r, v)
}

overload _mod_SBE = {_get_Mstatus_SBE, _set_Mstatus_SBE}

$[fix_location]
val _get_Mstatus_SD : Mstatus -> bitvector(xlen - 1 - (xlen - 1) + 1)

$[complete]
$[fix_location]
function _get_Mstatus_SD v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, sub_atom(sizeof(xlen), 1), sub_atom(sizeof(xlen), 1))

$[fix_location]
val _update_Mstatus_SD : (Mstatus, bitvector(xlen - 1 - (xlen - 1) + 1)) -> Mstatus

$[complete]
$[fix_location]
function _update_Mstatus_SD (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, sub_atom(sizeof(xlen), 1), sub_atom(sizeof(xlen), 1), x) }

$[fix_location]
overload update_SD = {_update_Mstatus_SD}

$[fix_location]
val _set_Mstatus_SD : (register(Mstatus), bitvector(xlen - 1 - (xlen - 1) + 1)) -> unit

$[complete]
$[fix_location]
function _set_Mstatus_SD (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Mstatus_SD(r, v)
}

overload _mod_SD = {_get_Mstatus_SD, _set_Mstatus_SD}

$[fix_location]
val _get_Mstatus_SIE : Mstatus -> bitvector(1)

$[complete]
$[fix_location]
function _get_Mstatus_SIE v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 1, 1)

$[fix_location]
val _update_Mstatus_SIE : (Mstatus, bitvector(1)) -> Mstatus

$[complete]
$[fix_location]
function _update_Mstatus_SIE (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 1, 1, x) }

$[fix_location]
overload update_SIE = {_update_Mstatus_SIE}

$[fix_location]
val _set_Mstatus_SIE : (register(Mstatus), bitvector(1)) -> unit

$[complete]
$[fix_location]
function _set_Mstatus_SIE (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Mstatus_SIE(r, v)
}

overload _mod_SIE = {_get_Mstatus_SIE, _set_Mstatus_SIE}

$[fix_location]
val _get_Mstatus_SPIE : Mstatus -> bitvector(1)

$[complete]
$[fix_location]
function _get_Mstatus_SPIE v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 5, 5)

$[fix_location]
val _update_Mstatus_SPIE : (Mstatus, bitvector(1)) -> Mstatus

$[complete]
$[fix_location]
function _update_Mstatus_SPIE (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 5, 5, x) }

$[fix_location]
overload update_SPIE = {_update_Mstatus_SPIE}

$[fix_location]
val _set_Mstatus_SPIE : (register(Mstatus), bitvector(1)) -> unit

$[complete]
$[fix_location]
function _set_Mstatus_SPIE (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Mstatus_SPIE(r, v)
}

overload _mod_SPIE = {_get_Mstatus_SPIE, _set_Mstatus_SPIE}

$[fix_location]
val _get_Mstatus_SPP : Mstatus -> bitvector(1)

$[complete]
$[fix_location]
function _get_Mstatus_SPP v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 8, 8)

$[fix_location]
val _update_Mstatus_SPP : (Mstatus, bitvector(1)) -> Mstatus

$[complete]
$[fix_location]
function _update_Mstatus_SPP (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 8, 8, x) }

$[fix_location]
overload update_SPP = {_update_Mstatus_SPP}

$[fix_location]
val _set_Mstatus_SPP : (register(Mstatus), bitvector(1)) -> unit

$[complete]
$[fix_location]
function _set_Mstatus_SPP (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Mstatus_SPP(r, v)
}

overload _mod_SPP = {_get_Mstatus_SPP, _set_Mstatus_SPP}

$[fix_location]
val _get_Mstatus_SUM : Mstatus -> bitvector(1)

$[complete]
$[fix_location]
function _get_Mstatus_SUM v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 18, 18)

$[fix_location]
val _update_Mstatus_SUM : (Mstatus, bitvector(1)) -> Mstatus

$[complete]
$[fix_location]
function _update_Mstatus_SUM (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 18, 18, x) }

$[fix_location]
overload update_SUM = {_update_Mstatus_SUM}

$[fix_location]
val _set_Mstatus_SUM : (register(Mstatus), bitvector(1)) -> unit

$[complete]
$[fix_location]
function _set_Mstatus_SUM (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Mstatus_SUM(r, v)
}

overload _mod_SUM = {_get_Mstatus_SUM, _set_Mstatus_SUM}

$[fix_location]
val _get_Mstatus_SXL : Mstatus -> bitvector(2)

$[complete]
$[fix_location]
function _get_Mstatus_SXL v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 35, 34)

$[fix_location]
val _update_Mstatus_SXL : (Mstatus, bitvector(2)) -> Mstatus

$[complete]
$[fix_location]
function _update_Mstatus_SXL (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 35, 34, x) }

$[fix_location]
overload update_SXL = {_update_Mstatus_SXL}

$[fix_location]
val _set_Mstatus_SXL : (register(Mstatus), bitvector(2)) -> unit

$[complete]
$[fix_location]
function _set_Mstatus_SXL (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Mstatus_SXL(r, v)
}

overload _mod_SXL = {_get_Mstatus_SXL, _set_Mstatus_SXL}

$[fix_location]
val _get_Mstatus_TSR : Mstatus -> bitvector(1)

$[complete]
$[fix_location]
function _get_Mstatus_TSR v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 22, 22)

$[fix_location]
val _update_Mstatus_TSR : (Mstatus, bitvector(1)) -> Mstatus

$[complete]
$[fix_location]
function _update_Mstatus_TSR (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 22, 22, x) }

$[fix_location]
overload update_TSR = {_update_Mstatus_TSR}

$[fix_location]
val _set_Mstatus_TSR : (register(Mstatus), bitvector(1)) -> unit

$[complete]
$[fix_location]
function _set_Mstatus_TSR (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Mstatus_TSR(r, v)
}

overload _mod_TSR = {_get_Mstatus_TSR, _set_Mstatus_TSR}

$[fix_location]
val _get_Mstatus_TVM : Mstatus -> bitvector(1)

$[complete]
$[fix_location]
function _get_Mstatus_TVM v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 20, 20)

$[fix_location]
val _update_Mstatus_TVM : (Mstatus, bitvector(1)) -> Mstatus

$[complete]
$[fix_location]
function _update_Mstatus_TVM (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 20, 20, x) }

$[fix_location]
overload update_TVM = {_update_Mstatus_TVM}

$[fix_location]
val _set_Mstatus_TVM : (register(Mstatus), bitvector(1)) -> unit

$[complete]
$[fix_location]
function _set_Mstatus_TVM (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Mstatus_TVM(r, v)
}

overload _mod_TVM = {_get_Mstatus_TVM, _set_Mstatus_TVM}

$[fix_location]
val _get_Mstatus_TW : Mstatus -> bitvector(1)

$[complete]
$[fix_location]
function _get_Mstatus_TW v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 21, 21)

$[fix_location]
val _update_Mstatus_TW : (Mstatus, bitvector(1)) -> Mstatus

$[complete]
$[fix_location]
function _update_Mstatus_TW (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 21, 21, x) }

$[fix_location]
overload update_TW = {_update_Mstatus_TW}

$[fix_location]
val _set_Mstatus_TW : (register(Mstatus), bitvector(1)) -> unit

$[complete]
$[fix_location]
function _set_Mstatus_TW (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Mstatus_TW(r, v)
}

overload _mod_TW = {_get_Mstatus_TW, _set_Mstatus_TW}

$[fix_location]
val _get_Mstatus_UXL : Mstatus -> bitvector(2)

$[complete]
$[fix_location]
function _get_Mstatus_UXL v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 33, 32)

$[fix_location]
val _update_Mstatus_UXL : (Mstatus, bitvector(2)) -> Mstatus

$[complete]
$[fix_location]
function _update_Mstatus_UXL (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 33, 32, x) }

$[fix_location]
overload update_UXL = {_update_Mstatus_UXL}

$[fix_location]
val _set_Mstatus_UXL : (register(Mstatus), bitvector(2)) -> unit

$[complete]
$[fix_location]
function _set_Mstatus_UXL (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Mstatus_UXL(r, v)
}

overload _mod_UXL = {_get_Mstatus_UXL, _set_Mstatus_UXL}

$[fix_location]
val _get_Mstatus_VS : Mstatus -> bitvector(2)

$[complete]
$[fix_location]
function _get_Mstatus_VS v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 10, 9)

$[fix_location]
val _update_Mstatus_VS : (Mstatus, bitvector(2)) -> Mstatus

$[complete]
$[fix_location]
function _update_Mstatus_VS (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 10, 9, x) }

$[fix_location]
overload update_VS = {_update_Mstatus_VS}

$[fix_location]
val _set_Mstatus_VS : (register(Mstatus), bitvector(2)) -> unit

$[complete]
$[fix_location]
function _set_Mstatus_VS (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Mstatus_VS(r, v)
}

overload _mod_VS = {_get_Mstatus_VS, _set_Mstatus_VS}

$[fix_location]
val _get_Mstatus_XS : Mstatus -> bitvector(2)

$[complete]
$[fix_location]
function _get_Mstatus_XS v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 16, 15)

$[fix_location]
val _update_Mstatus_XS : (Mstatus, bitvector(2)) -> Mstatus

$[complete]
$[fix_location]
function _update_Mstatus_XS (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 16, 15, x) }

$[fix_location]
overload update_XS = {_update_Mstatus_XS}

$[fix_location]
val _set_Mstatus_XS : (register(Mstatus), bitvector(2)) -> unit

$[complete]
$[fix_location]
function _set_Mstatus_XS (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Mstatus_XS(r, v)
}

overload _mod_XS = {_get_Mstatus_XS, _set_Mstatus_XS}

val get_mstatus_SXL : Mstatus -> bitvector(2)

$[complete]
function get_mstatus_SXL m : Mstatus = {
    if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 32) then
      architecture_forwards(RV32)
    else
      _get_Mstatus_SXL(m)
}

val get_mstatus_UXL : Mstatus -> bitvector(2)

$[complete]
function get_mstatus_UXL m : Mstatus = {
    if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 32) then
      architecture_forwards(RV32)
    else
      _get_Mstatus_UXL(m)
}

val legalize_mstatus : (Mstatus, bitvector(64)) -> Mstatus

$[complete]
function legalize_mstatus (o : Mstatus, v : bits(64)) = {
    let v = Mk_Mstatus(v);
    let o = _update_Mstatus_SIE(_update_Mstatus_MIE(_update_Mstatus_SPIE(_update_Mstatus_MPIE(_update_Mstatus_VS(_update_Mstatus_SPP(_update_Mstatus_MPP(_update_Mstatus_FS(_update_Mstatus_XS(_update_Mstatus_MPRV(_update_Mstatus_SUM(_update_Mstatus_MXR(_update_Mstatus_TVM(_update_Mstatus_TW(_update_Mstatus_TSR(o, if currentlyEnabled(Ext_S) then
      _get_Mstatus_TSR(v)
    else
      0b0), if currentlyEnabled(Ext_U) then _get_Mstatus_TW(v) else 0b0), if currentlyEnabled(Ext_S) then
      _get_Mstatus_TVM(v)
    else
      0b0), if currentlyEnabled(Ext_S) then _get_Mstatus_MXR(v) else 0b0), if virtual_memory_supported() then
      _get_Mstatus_SUM(v)
    else
      0b0), if currentlyEnabled(Ext_U) then _get_Mstatus_MPRV(v) else 0b0), extStatus_to_bits(Off)), if hartSupports(Ext_Zfinx) then
      extStatus_to_bits(Off)
    else
      _get_Mstatus_FS(v)), if have_nominal_privLevel(_get_Mstatus_MPP(v)) then
      _get_Mstatus_MPP(v)
    else
      privLevel_to_bits(lowest_supported_privLevel())), if currentlyEnabled(Ext_S) then
      _get_Mstatus_SPP(v)
    else
      0b0), if hartSupports(Ext_V) then _get_Mstatus_VS(v) else 0b00), _get_Mstatus_MPIE(v)), if currentlyEnabled(Ext_S) then
      _get_Mstatus_SPIE(v)
    else
      0b0), _get_Mstatus_MIE(v)), if currentlyEnabled(Ext_S) then
      _get_Mstatus_SIE(v)
    else
      0b0);
    let dirty = $[overloaded { "name" = "|", "is_infix" = true }] or_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_anything(extStatus_of_bits(_get_Mstatus_FS(o)), Dirty), $[overloaded { "name" = "|", "is_infix" = true }] or_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_anything(extStatus_of_bits(_get_Mstatus_XS(o)), Dirty), $[overloaded { "name" = "==", "is_infix" = true }] eq_anything(extStatus_of_bits(_get_Mstatus_VS(o)), Dirty)));
    _update_Mstatus_SD(o, bool_to_bits(dirty))
}

register mstatus : Mstatus = {
    let mxl = architecture_forwards(if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 32) then
      RV32
    else
      RV64);
    _update_Mstatus_UXL(_update_Mstatus_SXL(Mk_Mstatus(zeros(64)), if $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "!=", "is_infix" = true }] neq_int(xlen, 32), hartSupports(Ext_S)) then
      mxl
    else
      zeros(2)), if $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "!=", "is_infix" = true }] neq_int(xlen, 32), hartSupports(Ext_U)) then
      mxl
    else
      zeros(2))
}

val cur_architecture : unit -> Architecture

$[complete]
function cur_architecture () = {
    let a : arch_xlen = $[complete] match cur_privilege {
      Machine => _get_Misa_MXL(misa),
      Supervisor => get_mstatus_SXL(mstatus),
      User => get_mstatus_UXL(mstatus),
      VirtualUser => internal_error("./core/sys_regs.sail", 296, "Hypervisor extension not supported"),
      VirtualSupervisor => internal_error("./core/sys_regs.sail", 297, "Hypervisor extension not supported")
    };
    architecture_backwards(a)
}

val in32BitMode : unit -> bool

$[complete]
function in32BitMode () = {
    $[overloaded { "name" = "==", "is_infix" = true }] eq_anything(cur_architecture(), RV32)
}

$[undefined_gen "skip"]
$[bitfield]
struct Seccfg = {bits : bitvector(64)}

val undefined_Seccfg : unit -> Seccfg

$[complete]
function undefined_Seccfg () = struct Seccfg { bits = undefined }

val Mk_Seccfg : bitvector(64) -> Seccfg

$[complete]
function Mk_Seccfg v = struct Seccfg { bits = v }

$[fix_location]
val _get_Seccfg_bits : Seccfg -> bitvector(64)

$[complete]
$[fix_location]
function _get_Seccfg_bits v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, sub_atom(64, 1), 0)

$[fix_location]
val _update_Seccfg_bits : (Seccfg, bitvector(64)) -> Seccfg

$[complete]
$[fix_location]
function _update_Seccfg_bits (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, sub_atom(64, 1), 0, x) }

$[fix_location]
overload update_bits = {_update_Seccfg_bits}

$[fix_location]
val _set_Seccfg_bits : (register(Seccfg), bitvector(64)) -> unit

$[complete]
$[fix_location]
function _set_Seccfg_bits (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Seccfg_bits(r, v)
}

overload _mod_bits = {_get_Seccfg_bits, _set_Seccfg_bits}

$[fix_location]
val _get_Seccfg_SSEED : Seccfg -> bitvector(1)

$[complete]
$[fix_location]
function _get_Seccfg_SSEED v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 9, 9)

$[fix_location]
val _update_Seccfg_SSEED : (Seccfg, bitvector(1)) -> Seccfg

$[complete]
$[fix_location]
function _update_Seccfg_SSEED (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 9, 9, x) }

$[fix_location]
overload update_SSEED = {_update_Seccfg_SSEED}

$[fix_location]
val _set_Seccfg_SSEED : (register(Seccfg), bitvector(1)) -> unit

$[complete]
$[fix_location]
function _set_Seccfg_SSEED (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Seccfg_SSEED(r, v)
}

overload _mod_SSEED = {_get_Seccfg_SSEED, _set_Seccfg_SSEED}

$[fix_location]
val _get_Seccfg_USEED : Seccfg -> bitvector(1)

$[complete]
$[fix_location]
function _get_Seccfg_USEED v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 8, 8)

$[fix_location]
val _update_Seccfg_USEED : (Seccfg, bitvector(1)) -> Seccfg

$[complete]
$[fix_location]
function _update_Seccfg_USEED (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 8, 8, x) }

$[fix_location]
overload update_USEED = {_update_Seccfg_USEED}

$[fix_location]
val _set_Seccfg_USEED : (register(Seccfg), bitvector(1)) -> unit

$[complete]
$[fix_location]
function _set_Seccfg_USEED (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Seccfg_USEED(r, v)
}

overload _mod_USEED = {_get_Seccfg_USEED, _set_Seccfg_USEED}

val legalize_mseccfg : (Seccfg, bitvector(64)) -> Seccfg

$[complete]
function legalize_mseccfg (o : Seccfg, v : bits(64)) = {
    let sseed_read_only_zero = $[overloaded { "name" = "|", "is_infix" = true }] or_bool(config extensions.Zkr.sseed_read_only_zero : bool, $[overloaded { "name" = "|", "is_infix" = true }] or_bool(not(currentlyEnabled(Ext_S)), not(currentlyEnabled(Ext_Zkr))));
    let useed_read_only_zero = $[overloaded { "name" = "|", "is_infix" = true }] or_bool(config extensions.Zkr.useed_read_only_zero : bool, $[overloaded { "name" = "|", "is_infix" = true }] or_bool(not(currentlyEnabled(Ext_U)), not(currentlyEnabled(Ext_Zkr))));
    let v = Mk_Seccfg(v);
    _update_Seccfg_USEED(_update_Seccfg_SSEED(o, if sseed_read_only_zero then
      0b0
    else
      _get_Seccfg_SSEED(v)), if useed_read_only_zero then 0b0 else
      _get_Seccfg_USEED(v))
}

register mseccfg : Seccfg = legalize_mseccfg(Mk_Seccfg(zeros(64)), zeros(64))

$[undefined_gen "skip"]
$[bitfield]
struct MEnvcfg = {bits : bitvector(64)}

val undefined_MEnvcfg : unit -> MEnvcfg

$[complete]
function undefined_MEnvcfg () = struct MEnvcfg { bits = undefined }

val Mk_MEnvcfg : bitvector(64) -> MEnvcfg

$[complete]
function Mk_MEnvcfg v = struct MEnvcfg { bits = v }

$[fix_location]
val _get_MEnvcfg_bits : MEnvcfg -> bitvector(64)

$[complete]
$[fix_location]
function _get_MEnvcfg_bits v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, sub_atom(64, 1), 0)

$[fix_location]
val _update_MEnvcfg_bits : (MEnvcfg, bitvector(64)) -> MEnvcfg

$[complete]
$[fix_location]
function _update_MEnvcfg_bits (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, sub_atom(64, 1), 0, x) }

$[fix_location]
overload update_bits = {_update_MEnvcfg_bits}

$[fix_location]
val _set_MEnvcfg_bits : (register(MEnvcfg), bitvector(64)) -> unit

$[complete]
$[fix_location]
function _set_MEnvcfg_bits (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_MEnvcfg_bits(r, v)
}

overload _mod_bits = {_get_MEnvcfg_bits, _set_MEnvcfg_bits}

$[fix_location]
val _get_MEnvcfg_CBCFE : MEnvcfg -> bitvector(1)

$[complete]
$[fix_location]
function _get_MEnvcfg_CBCFE v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 6, 6)

$[fix_location]
val _update_MEnvcfg_CBCFE : (MEnvcfg, bitvector(1)) -> MEnvcfg

$[complete]
$[fix_location]
function _update_MEnvcfg_CBCFE (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 6, 6, x) }

$[fix_location]
overload update_CBCFE = {_update_MEnvcfg_CBCFE}

$[fix_location]
val _set_MEnvcfg_CBCFE : (register(MEnvcfg), bitvector(1)) -> unit

$[complete]
$[fix_location]
function _set_MEnvcfg_CBCFE (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_MEnvcfg_CBCFE(r, v)
}

overload _mod_CBCFE = {_get_MEnvcfg_CBCFE, _set_MEnvcfg_CBCFE}

$[fix_location]
val _get_MEnvcfg_CBIE : MEnvcfg -> bitvector(2)

$[complete]
$[fix_location]
function _get_MEnvcfg_CBIE v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 5, 4)

$[fix_location]
val _update_MEnvcfg_CBIE : (MEnvcfg, bitvector(2)) -> MEnvcfg

$[complete]
$[fix_location]
function _update_MEnvcfg_CBIE (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 5, 4, x) }

$[fix_location]
overload update_CBIE = {_update_MEnvcfg_CBIE}

$[fix_location]
val _set_MEnvcfg_CBIE : (register(MEnvcfg), bitvector(2)) -> unit

$[complete]
$[fix_location]
function _set_MEnvcfg_CBIE (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_MEnvcfg_CBIE(r, v)
}

overload _mod_CBIE = {_get_MEnvcfg_CBIE, _set_MEnvcfg_CBIE}

$[fix_location]
val _get_MEnvcfg_CBZE : MEnvcfg -> bitvector(1)

$[complete]
$[fix_location]
function _get_MEnvcfg_CBZE v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 7, 7)

$[fix_location]
val _update_MEnvcfg_CBZE : (MEnvcfg, bitvector(1)) -> MEnvcfg

$[complete]
$[fix_location]
function _update_MEnvcfg_CBZE (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 7, 7, x) }

$[fix_location]
overload update_CBZE = {_update_MEnvcfg_CBZE}

$[fix_location]
val _set_MEnvcfg_CBZE : (register(MEnvcfg), bitvector(1)) -> unit

$[complete]
$[fix_location]
function _set_MEnvcfg_CBZE (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_MEnvcfg_CBZE(r, v)
}

overload _mod_CBZE = {_get_MEnvcfg_CBZE, _set_MEnvcfg_CBZE}

$[fix_location]
val _get_MEnvcfg_FIOM : MEnvcfg -> bitvector(1)

$[complete]
$[fix_location]
function _get_MEnvcfg_FIOM v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 0, 0)

$[fix_location]
val _update_MEnvcfg_FIOM : (MEnvcfg, bitvector(1)) -> MEnvcfg

$[complete]
$[fix_location]
function _update_MEnvcfg_FIOM (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 0, 0, x) }

$[fix_location]
overload update_FIOM = {_update_MEnvcfg_FIOM}

$[fix_location]
val _set_MEnvcfg_FIOM : (register(MEnvcfg), bitvector(1)) -> unit

$[complete]
$[fix_location]
function _set_MEnvcfg_FIOM (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_MEnvcfg_FIOM(r, v)
}

overload _mod_FIOM = {_get_MEnvcfg_FIOM, _set_MEnvcfg_FIOM}

$[fix_location]
val _get_MEnvcfg_PBMTE : MEnvcfg -> bitvector(1)

$[complete]
$[fix_location]
function _get_MEnvcfg_PBMTE v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 62, 62)

$[fix_location]
val _update_MEnvcfg_PBMTE : (MEnvcfg, bitvector(1)) -> MEnvcfg

$[complete]
$[fix_location]
function _update_MEnvcfg_PBMTE (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 62, 62, x) }

$[fix_location]
overload update_PBMTE = {_update_MEnvcfg_PBMTE}

$[fix_location]
val _set_MEnvcfg_PBMTE : (register(MEnvcfg), bitvector(1)) -> unit

$[complete]
$[fix_location]
function _set_MEnvcfg_PBMTE (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_MEnvcfg_PBMTE(r, v)
}

overload _mod_PBMTE = {_get_MEnvcfg_PBMTE, _set_MEnvcfg_PBMTE}

$[fix_location]
val _get_MEnvcfg_STCE : MEnvcfg -> bitvector(1)

$[complete]
$[fix_location]
function _get_MEnvcfg_STCE v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 63, 63)

$[fix_location]
val _update_MEnvcfg_STCE : (MEnvcfg, bitvector(1)) -> MEnvcfg

$[complete]
$[fix_location]
function _update_MEnvcfg_STCE (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 63, 63, x) }

$[fix_location]
overload update_STCE = {_update_MEnvcfg_STCE}

$[fix_location]
val _set_MEnvcfg_STCE : (register(MEnvcfg), bitvector(1)) -> unit

$[complete]
$[fix_location]
function _set_MEnvcfg_STCE (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_MEnvcfg_STCE(r, v)
}

overload _mod_STCE = {_get_MEnvcfg_STCE, _set_MEnvcfg_STCE}

$[fix_location]
val _get_MEnvcfg_wpri_0 : MEnvcfg -> bitvector(3)

$[complete]
$[fix_location]
function _get_MEnvcfg_wpri_0 v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 3, 1)

$[fix_location]
val _update_MEnvcfg_wpri_0 : (MEnvcfg, bitvector(3)) -> MEnvcfg

$[complete]
$[fix_location]
function _update_MEnvcfg_wpri_0 (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 3, 1, x) }

$[fix_location]
overload update_wpri_0 = {_update_MEnvcfg_wpri_0}

$[fix_location]
val _set_MEnvcfg_wpri_0 : (register(MEnvcfg), bitvector(3)) -> unit

$[complete]
$[fix_location]
function _set_MEnvcfg_wpri_0 (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_MEnvcfg_wpri_0(r, v)
}

overload _mod_wpri_0 = {_get_MEnvcfg_wpri_0, _set_MEnvcfg_wpri_0}

$[fix_location]
val _get_MEnvcfg_wpri_1 : MEnvcfg -> bitvector(54)

$[complete]
$[fix_location]
function _get_MEnvcfg_wpri_1 v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 61, 8)

$[fix_location]
val _update_MEnvcfg_wpri_1 : (MEnvcfg, bitvector(54)) -> MEnvcfg

$[complete]
$[fix_location]
function _update_MEnvcfg_wpri_1 (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 61, 8, x) }

$[fix_location]
overload update_wpri_1 = {_update_MEnvcfg_wpri_1}

$[fix_location]
val _set_MEnvcfg_wpri_1 : (register(MEnvcfg), bitvector(54)) -> unit

$[complete]
$[fix_location]
function _set_MEnvcfg_wpri_1 (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_MEnvcfg_wpri_1(r, v)
}

overload _mod_wpri_1 = {_get_MEnvcfg_wpri_1, _set_MEnvcfg_wpri_1}

$[undefined_gen "skip"]
$[bitfield]
struct SEnvcfg = {bits : bitvector(xlen)}

val undefined_SEnvcfg : unit -> SEnvcfg

$[complete]
function undefined_SEnvcfg () = struct SEnvcfg { bits = undefined }

val Mk_SEnvcfg : bitvector(xlen) -> SEnvcfg

$[complete]
function Mk_SEnvcfg v = struct SEnvcfg { bits = v }

$[fix_location]
val _get_SEnvcfg_bits : SEnvcfg -> bitvector(xlen)

$[complete]
$[fix_location]
function _get_SEnvcfg_bits v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, sub_atom(sizeof(xlen), 1), 0)

$[fix_location]
val _update_SEnvcfg_bits : (SEnvcfg, bitvector(xlen)) -> SEnvcfg

$[complete]
$[fix_location]
function _update_SEnvcfg_bits (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, sub_atom(sizeof(xlen), 1), 0, x) }

$[fix_location]
overload update_bits = {_update_SEnvcfg_bits}

$[fix_location]
val _set_SEnvcfg_bits : (register(SEnvcfg), bitvector(xlen)) -> unit

$[complete]
$[fix_location]
function _set_SEnvcfg_bits (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_SEnvcfg_bits(r, v)
}

overload _mod_bits = {_get_SEnvcfg_bits, _set_SEnvcfg_bits}

$[fix_location]
val _get_SEnvcfg_CBCFE : SEnvcfg -> bitvector(1)

$[complete]
$[fix_location]
function _get_SEnvcfg_CBCFE v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 6, 6)

$[fix_location]
val _update_SEnvcfg_CBCFE : (SEnvcfg, bitvector(1)) -> SEnvcfg

$[complete]
$[fix_location]
function _update_SEnvcfg_CBCFE (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 6, 6, x) }

$[fix_location]
overload update_CBCFE = {_update_SEnvcfg_CBCFE}

$[fix_location]
val _set_SEnvcfg_CBCFE : (register(SEnvcfg), bitvector(1)) -> unit

$[complete]
$[fix_location]
function _set_SEnvcfg_CBCFE (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_SEnvcfg_CBCFE(r, v)
}

overload _mod_CBCFE = {_get_SEnvcfg_CBCFE, _set_SEnvcfg_CBCFE}

$[fix_location]
val _get_SEnvcfg_CBIE : SEnvcfg -> bitvector(2)

$[complete]
$[fix_location]
function _get_SEnvcfg_CBIE v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 5, 4)

$[fix_location]
val _update_SEnvcfg_CBIE : (SEnvcfg, bitvector(2)) -> SEnvcfg

$[complete]
$[fix_location]
function _update_SEnvcfg_CBIE (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 5, 4, x) }

$[fix_location]
overload update_CBIE = {_update_SEnvcfg_CBIE}

$[fix_location]
val _set_SEnvcfg_CBIE : (register(SEnvcfg), bitvector(2)) -> unit

$[complete]
$[fix_location]
function _set_SEnvcfg_CBIE (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_SEnvcfg_CBIE(r, v)
}

overload _mod_CBIE = {_get_SEnvcfg_CBIE, _set_SEnvcfg_CBIE}

$[fix_location]
val _get_SEnvcfg_CBZE : SEnvcfg -> bitvector(1)

$[complete]
$[fix_location]
function _get_SEnvcfg_CBZE v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 7, 7)

$[fix_location]
val _update_SEnvcfg_CBZE : (SEnvcfg, bitvector(1)) -> SEnvcfg

$[complete]
$[fix_location]
function _update_SEnvcfg_CBZE (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 7, 7, x) }

$[fix_location]
overload update_CBZE = {_update_SEnvcfg_CBZE}

$[fix_location]
val _set_SEnvcfg_CBZE : (register(SEnvcfg), bitvector(1)) -> unit

$[complete]
$[fix_location]
function _set_SEnvcfg_CBZE (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_SEnvcfg_CBZE(r, v)
}

overload _mod_CBZE = {_get_SEnvcfg_CBZE, _set_SEnvcfg_CBZE}

$[fix_location]
val _get_SEnvcfg_FIOM : SEnvcfg -> bitvector(1)

$[complete]
$[fix_location]
function _get_SEnvcfg_FIOM v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 0, 0)

$[fix_location]
val _update_SEnvcfg_FIOM : (SEnvcfg, bitvector(1)) -> SEnvcfg

$[complete]
$[fix_location]
function _update_SEnvcfg_FIOM (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 0, 0, x) }

$[fix_location]
overload update_FIOM = {_update_SEnvcfg_FIOM}

$[fix_location]
val _set_SEnvcfg_FIOM : (register(SEnvcfg), bitvector(1)) -> unit

$[complete]
$[fix_location]
function _set_SEnvcfg_FIOM (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_SEnvcfg_FIOM(r, v)
}

overload _mod_FIOM = {_get_SEnvcfg_FIOM, _set_SEnvcfg_FIOM}

$[fix_location]
val _get_SEnvcfg_wpri_0 : SEnvcfg -> bitvector(3)

$[complete]
$[fix_location]
function _get_SEnvcfg_wpri_0 v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 3, 1)

$[fix_location]
val _update_SEnvcfg_wpri_0 : (SEnvcfg, bitvector(3)) -> SEnvcfg

$[complete]
$[fix_location]
function _update_SEnvcfg_wpri_0 (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 3, 1, x) }

$[fix_location]
overload update_wpri_0 = {_update_SEnvcfg_wpri_0}

$[fix_location]
val _set_SEnvcfg_wpri_0 : (register(SEnvcfg), bitvector(3)) -> unit

$[complete]
$[fix_location]
function _set_SEnvcfg_wpri_0 (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_SEnvcfg_wpri_0(r, v)
}

overload _mod_wpri_0 = {_get_SEnvcfg_wpri_0, _set_SEnvcfg_wpri_0}

val legalize_menvcfg : (MEnvcfg, bitvector(64)) -> MEnvcfg

$[complete]
function legalize_menvcfg (o : MEnvcfg, v : bits(64)) = {
    let v = Mk_MEnvcfg(v);
    _update_MEnvcfg_STCE(_update_MEnvcfg_CBIE(_update_MEnvcfg_CBCFE(_update_MEnvcfg_CBZE(_update_MEnvcfg_FIOM(o, if sys_enable_writable_fiom then
      _get_MEnvcfg_FIOM(v)
    else
      0b0), if currentlyEnabled(Ext_Zicboz) then _get_MEnvcfg_CBZE(v) else 0b0), if currentlyEnabled(Ext_Zicbom) then
      _get_MEnvcfg_CBCFE(v)
    else
      0b0), if currentlyEnabled(Ext_Zicbom) then
      if $[overloaded { "name" = "!=", "is_infix" = true }] neq_bits(_get_MEnvcfg_CBIE(v), 0b10) then
        _get_MEnvcfg_CBIE(v)
      else
        0b00
    else 0b00), if currentlyEnabled(Ext_Sstc) then _get_MEnvcfg_STCE(v) else 0b0)
}

val legalize_senvcfg : (SEnvcfg, bitvector(xlen)) -> SEnvcfg

$[complete]
function legalize_senvcfg (o : SEnvcfg, v : xlenbits) = {
    let v = Mk_SEnvcfg(v);
    _update_SEnvcfg_CBIE(_update_SEnvcfg_CBCFE(_update_SEnvcfg_CBZE(_update_SEnvcfg_FIOM(o, if sys_enable_writable_fiom then
      _get_SEnvcfg_FIOM(v)
    else
      0b0), if currentlyEnabled(Ext_Zicboz) then _get_SEnvcfg_CBZE(v) else 0b0), if currentlyEnabled(Ext_Zicbom) then
      _get_SEnvcfg_CBCFE(v)
    else
      0b0), if currentlyEnabled(Ext_Zicbom) then
      if $[overloaded { "name" = "!=", "is_infix" = true }] neq_bits(_get_SEnvcfg_CBIE(v), 0b10) then
        _get_SEnvcfg_CBIE(v)
      else
        0b00
    else 0b00)
}

register menvcfg : MEnvcfg = legalize_menvcfg(Mk_MEnvcfg(zeros(64)), zeros(64))

register senvcfg : SEnvcfg = legalize_senvcfg(Mk_SEnvcfg(zeros(sizeof(xlen))), zeros(sizeof(xlen)))

val is_fiom_active : unit -> bool

$[complete]
function is_fiom_active () = {
    $[complete] match cur_privilege {
      Machine => false,
      Supervisor => $[overloaded { "name" = "==", "is_infix" = true }] eq_bits(_get_MEnvcfg_FIOM(menvcfg), 0b1),
      User => $[overloaded { "name" = "==", "is_infix" = true }] eq_bits($[overloaded { "name" = "|", "is_infix" = true }] or_vec(_get_MEnvcfg_FIOM(menvcfg), _get_SEnvcfg_FIOM(senvcfg)), 0b1),
      VirtualUser => internal_error("./core/sys_regs.sail", 441, "Hypervisor extension not supported"),
      VirtualSupervisor => internal_error("./core/sys_regs.sail", 442, "Hypervisor extension not supported")
    }
}

$[undefined_gen "skip"]
$[bitfield]
struct Minterrupts = {bits : bitvector(xlen)}

val undefined_Minterrupts : unit -> Minterrupts

$[complete]
function undefined_Minterrupts () = struct Minterrupts { bits = undefined }

val Mk_Minterrupts : bitvector(xlen) -> Minterrupts

$[complete]
function Mk_Minterrupts v = struct Minterrupts { bits = v }

$[fix_location]
val _get_Minterrupts_bits : Minterrupts -> bitvector(xlen)

$[complete]
$[fix_location]
function _get_Minterrupts_bits v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, sub_atom(sizeof(xlen), 1), 0)

$[fix_location]
val _update_Minterrupts_bits : (Minterrupts, bitvector(xlen)) -> Minterrupts

$[complete]
$[fix_location]
function _update_Minterrupts_bits (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, sub_atom(sizeof(xlen), 1), 0, x) }

$[fix_location]
overload update_bits = {_update_Minterrupts_bits}

$[fix_location]
val _set_Minterrupts_bits : (register(Minterrupts), bitvector(xlen)) -> unit

$[complete]
$[fix_location]
function _set_Minterrupts_bits (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Minterrupts_bits(r, v)
}

overload _mod_bits = {_get_Minterrupts_bits, _set_Minterrupts_bits}

$[fix_location]
val _get_Minterrupts_MEI : Minterrupts -> bitvector(1)

$[complete]
$[fix_location]
function _get_Minterrupts_MEI v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 11, 11)

$[fix_location]
val _update_Minterrupts_MEI : (Minterrupts, bitvector(1)) -> Minterrupts

$[complete]
$[fix_location]
function _update_Minterrupts_MEI (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 11, 11, x) }

$[fix_location]
overload update_MEI = {_update_Minterrupts_MEI}

$[fix_location]
val _set_Minterrupts_MEI : (register(Minterrupts), bitvector(1)) -> unit

$[complete]
$[fix_location]
function _set_Minterrupts_MEI (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Minterrupts_MEI(r, v)
}

overload _mod_MEI = {_get_Minterrupts_MEI, _set_Minterrupts_MEI}

$[fix_location]
val _get_Minterrupts_MSI : Minterrupts -> bitvector(1)

$[complete]
$[fix_location]
function _get_Minterrupts_MSI v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 3, 3)

$[fix_location]
val _update_Minterrupts_MSI : (Minterrupts, bitvector(1)) -> Minterrupts

$[complete]
$[fix_location]
function _update_Minterrupts_MSI (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 3, 3, x) }

$[fix_location]
overload update_MSI = {_update_Minterrupts_MSI}

$[fix_location]
val _set_Minterrupts_MSI : (register(Minterrupts), bitvector(1)) -> unit

$[complete]
$[fix_location]
function _set_Minterrupts_MSI (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Minterrupts_MSI(r, v)
}

overload _mod_MSI = {_get_Minterrupts_MSI, _set_Minterrupts_MSI}

$[fix_location]
val _get_Minterrupts_MTI : Minterrupts -> bitvector(1)

$[complete]
$[fix_location]
function _get_Minterrupts_MTI v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 7, 7)

$[fix_location]
val _update_Minterrupts_MTI : (Minterrupts, bitvector(1)) -> Minterrupts

$[complete]
$[fix_location]
function _update_Minterrupts_MTI (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 7, 7, x) }

$[fix_location]
overload update_MTI = {_update_Minterrupts_MTI}

$[fix_location]
val _set_Minterrupts_MTI : (register(Minterrupts), bitvector(1)) -> unit

$[complete]
$[fix_location]
function _set_Minterrupts_MTI (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Minterrupts_MTI(r, v)
}

overload _mod_MTI = {_get_Minterrupts_MTI, _set_Minterrupts_MTI}

$[fix_location]
val _get_Minterrupts_SEI : Minterrupts -> bitvector(1)

$[complete]
$[fix_location]
function _get_Minterrupts_SEI v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 9, 9)

$[fix_location]
val _update_Minterrupts_SEI : (Minterrupts, bitvector(1)) -> Minterrupts

$[complete]
$[fix_location]
function _update_Minterrupts_SEI (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 9, 9, x) }

$[fix_location]
overload update_SEI = {_update_Minterrupts_SEI}

$[fix_location]
val _set_Minterrupts_SEI : (register(Minterrupts), bitvector(1)) -> unit

$[complete]
$[fix_location]
function _set_Minterrupts_SEI (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Minterrupts_SEI(r, v)
}

overload _mod_SEI = {_get_Minterrupts_SEI, _set_Minterrupts_SEI}

$[fix_location]
val _get_Minterrupts_SSI : Minterrupts -> bitvector(1)

$[complete]
$[fix_location]
function _get_Minterrupts_SSI v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 1, 1)

$[fix_location]
val _update_Minterrupts_SSI : (Minterrupts, bitvector(1)) -> Minterrupts

$[complete]
$[fix_location]
function _update_Minterrupts_SSI (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 1, 1, x) }

$[fix_location]
overload update_SSI = {_update_Minterrupts_SSI}

$[fix_location]
val _set_Minterrupts_SSI : (register(Minterrupts), bitvector(1)) -> unit

$[complete]
$[fix_location]
function _set_Minterrupts_SSI (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Minterrupts_SSI(r, v)
}

overload _mod_SSI = {_get_Minterrupts_SSI, _set_Minterrupts_SSI}

$[fix_location]
val _get_Minterrupts_STI : Minterrupts -> bitvector(1)

$[complete]
$[fix_location]
function _get_Minterrupts_STI v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 5, 5)

$[fix_location]
val _update_Minterrupts_STI : (Minterrupts, bitvector(1)) -> Minterrupts

$[complete]
$[fix_location]
function _update_Minterrupts_STI (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 5, 5, x) }

$[fix_location]
overload update_STI = {_update_Minterrupts_STI}

$[fix_location]
val _set_Minterrupts_STI : (register(Minterrupts), bitvector(1)) -> unit

$[complete]
$[fix_location]
function _set_Minterrupts_STI (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Minterrupts_STI(r, v)
}

overload _mod_STI = {_get_Minterrupts_STI, _set_Minterrupts_STI}

val legalize_mip : (Minterrupts, bitvector(xlen)) -> Minterrupts

$[complete]
function legalize_mip (o : Minterrupts, v : xlenbits) = {
    let v = Mk_Minterrupts(v);
    _update_Minterrupts_STI(_update_Minterrupts_SSI(_update_Minterrupts_SEI(o, if currentlyEnabled(Ext_S) then
      _get_Minterrupts_SEI(v)
    else
      0b0), if currentlyEnabled(Ext_S) then _get_Minterrupts_SSI(v) else 0b0), if currentlyEnabled(Ext_S) then
      if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Sstc), $[overloaded { "name" = "==", "is_infix" = true }] eq_bits(_get_MEnvcfg_STCE(menvcfg), 0b1)) then
        _get_Minterrupts_STI(o)
      else
        _get_Minterrupts_STI(v)
    else 0b0)
}

val legalize_mie : (Minterrupts, bitvector(xlen)) -> Minterrupts

$[complete]
function legalize_mie (o : Minterrupts, v : xlenbits) = {
    let v = Mk_Minterrupts(v);
    _update_Minterrupts_SSI(_update_Minterrupts_STI(_update_Minterrupts_SEI(_update_Minterrupts_MSI(_update_Minterrupts_MTI(_update_Minterrupts_MEI(o, _get_Minterrupts_MEI(v)), _get_Minterrupts_MTI(v)), _get_Minterrupts_MSI(v)), if currentlyEnabled(Ext_S) then
      _get_Minterrupts_SEI(v)
    else
      0b0), if currentlyEnabled(Ext_S) then _get_Minterrupts_STI(v) else 0b0), if currentlyEnabled(Ext_S) then
      _get_Minterrupts_SSI(v)
    else
      0b0)
}

val legalize_mideleg : (Minterrupts, bitvector(xlen)) -> Minterrupts

$[complete]
function legalize_mideleg (o : Minterrupts, v : xlenbits) = {
    _update_Minterrupts_MSI(_update_Minterrupts_MTI(_update_Minterrupts_MEI(Mk_Minterrupts(v), 0b0), 0b0), 0b0)
}

$[undefined_gen "skip"]
$[bitfield]
struct Medeleg = {bits : bitvector(64)}

val undefined_Medeleg : unit -> Medeleg

$[complete]
function undefined_Medeleg () = struct Medeleg { bits = undefined }

val Mk_Medeleg : bitvector(64) -> Medeleg

$[complete]
function Mk_Medeleg v = struct Medeleg { bits = v }

$[fix_location]
val _get_Medeleg_bits : Medeleg -> bitvector(64)

$[complete]
$[fix_location]
function _get_Medeleg_bits v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, sub_atom(64, 1), 0)

$[fix_location]
val _update_Medeleg_bits : (Medeleg, bitvector(64)) -> Medeleg

$[complete]
$[fix_location]
function _update_Medeleg_bits (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, sub_atom(64, 1), 0, x) }

$[fix_location]
overload update_bits = {_update_Medeleg_bits}

$[fix_location]
val _set_Medeleg_bits : (register(Medeleg), bitvector(64)) -> unit

$[complete]
$[fix_location]
function _set_Medeleg_bits (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Medeleg_bits(r, v)
}

overload _mod_bits = {_get_Medeleg_bits, _set_Medeleg_bits}

$[fix_location]
val _get_Medeleg_Breakpoint : Medeleg -> bitvector(1)

$[complete]
$[fix_location]
function _get_Medeleg_Breakpoint v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 3, 3)

$[fix_location]
val _update_Medeleg_Breakpoint : (Medeleg, bitvector(1)) -> Medeleg

$[complete]
$[fix_location]
function _update_Medeleg_Breakpoint (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 3, 3, x) }

$[fix_location]
overload update_Breakpoint = {_update_Medeleg_Breakpoint}

$[fix_location]
val _set_Medeleg_Breakpoint : (register(Medeleg), bitvector(1)) -> unit

$[complete]
$[fix_location]
function _set_Medeleg_Breakpoint (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Medeleg_Breakpoint(r, v)
}

overload _mod_Breakpoint = {_get_Medeleg_Breakpoint, _set_Medeleg_Breakpoint}

$[fix_location]
val _get_Medeleg_Fetch_Access_Fault : Medeleg -> bitvector(1)

$[complete]
$[fix_location]
function _get_Medeleg_Fetch_Access_Fault v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 1, 1)

$[fix_location]
val _update_Medeleg_Fetch_Access_Fault : (Medeleg, bitvector(1)) -> Medeleg

$[complete]
$[fix_location]
function _update_Medeleg_Fetch_Access_Fault (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 1, 1, x) }

$[fix_location]
overload update_Fetch_Access_Fault = {_update_Medeleg_Fetch_Access_Fault}

$[fix_location]
val _set_Medeleg_Fetch_Access_Fault : (register(Medeleg), bitvector(1)) -> unit

$[complete]
$[fix_location]
function _set_Medeleg_Fetch_Access_Fault (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Medeleg_Fetch_Access_Fault(r, v)
}

overload _mod_Fetch_Access_Fault = {
  _get_Medeleg_Fetch_Access_Fault,
  _set_Medeleg_Fetch_Access_Fault
}

$[fix_location]
val _get_Medeleg_Fetch_Addr_Align : Medeleg -> bitvector(1)

$[complete]
$[fix_location]
function _get_Medeleg_Fetch_Addr_Align v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 0, 0)

$[fix_location]
val _update_Medeleg_Fetch_Addr_Align : (Medeleg, bitvector(1)) -> Medeleg

$[complete]
$[fix_location]
function _update_Medeleg_Fetch_Addr_Align (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 0, 0, x) }

$[fix_location]
overload update_Fetch_Addr_Align = {_update_Medeleg_Fetch_Addr_Align}

$[fix_location]
val _set_Medeleg_Fetch_Addr_Align : (register(Medeleg), bitvector(1)) -> unit

$[complete]
$[fix_location]
function _set_Medeleg_Fetch_Addr_Align (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Medeleg_Fetch_Addr_Align(r, v)
}

overload _mod_Fetch_Addr_Align = {
  _get_Medeleg_Fetch_Addr_Align,
  _set_Medeleg_Fetch_Addr_Align
}

$[fix_location]
val _get_Medeleg_Fetch_Page_Fault : Medeleg -> bitvector(1)

$[complete]
$[fix_location]
function _get_Medeleg_Fetch_Page_Fault v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 12, 12)

$[fix_location]
val _update_Medeleg_Fetch_Page_Fault : (Medeleg, bitvector(1)) -> Medeleg

$[complete]
$[fix_location]
function _update_Medeleg_Fetch_Page_Fault (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 12, 12, x) }

$[fix_location]
overload update_Fetch_Page_Fault = {_update_Medeleg_Fetch_Page_Fault}

$[fix_location]
val _set_Medeleg_Fetch_Page_Fault : (register(Medeleg), bitvector(1)) -> unit

$[complete]
$[fix_location]
function _set_Medeleg_Fetch_Page_Fault (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Medeleg_Fetch_Page_Fault(r, v)
}

overload _mod_Fetch_Page_Fault = {
  _get_Medeleg_Fetch_Page_Fault,
  _set_Medeleg_Fetch_Page_Fault
}

$[fix_location]
val _get_Medeleg_Illegal_Instr : Medeleg -> bitvector(1)

$[complete]
$[fix_location]
function _get_Medeleg_Illegal_Instr v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 2, 2)

$[fix_location]
val _update_Medeleg_Illegal_Instr : (Medeleg, bitvector(1)) -> Medeleg

$[complete]
$[fix_location]
function _update_Medeleg_Illegal_Instr (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 2, 2, x) }

$[fix_location]
overload update_Illegal_Instr = {_update_Medeleg_Illegal_Instr}

$[fix_location]
val _set_Medeleg_Illegal_Instr : (register(Medeleg), bitvector(1)) -> unit

$[complete]
$[fix_location]
function _set_Medeleg_Illegal_Instr (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Medeleg_Illegal_Instr(r, v)
}

overload _mod_Illegal_Instr = {
  _get_Medeleg_Illegal_Instr,
  _set_Medeleg_Illegal_Instr
}

$[fix_location]
val _get_Medeleg_Load_Access_Fault : Medeleg -> bitvector(1)

$[complete]
$[fix_location]
function _get_Medeleg_Load_Access_Fault v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 5, 5)

$[fix_location]
val _update_Medeleg_Load_Access_Fault : (Medeleg, bitvector(1)) -> Medeleg

$[complete]
$[fix_location]
function _update_Medeleg_Load_Access_Fault (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 5, 5, x) }

$[fix_location]
overload update_Load_Access_Fault = {_update_Medeleg_Load_Access_Fault}

$[fix_location]
val _set_Medeleg_Load_Access_Fault : (register(Medeleg), bitvector(1)) -> unit

$[complete]
$[fix_location]
function _set_Medeleg_Load_Access_Fault (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Medeleg_Load_Access_Fault(r, v)
}

overload _mod_Load_Access_Fault = {
  _get_Medeleg_Load_Access_Fault,
  _set_Medeleg_Load_Access_Fault
}

$[fix_location]
val _get_Medeleg_Load_Addr_Align : Medeleg -> bitvector(1)

$[complete]
$[fix_location]
function _get_Medeleg_Load_Addr_Align v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 4, 4)

$[fix_location]
val _update_Medeleg_Load_Addr_Align : (Medeleg, bitvector(1)) -> Medeleg

$[complete]
$[fix_location]
function _update_Medeleg_Load_Addr_Align (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 4, 4, x) }

$[fix_location]
overload update_Load_Addr_Align = {_update_Medeleg_Load_Addr_Align}

$[fix_location]
val _set_Medeleg_Load_Addr_Align : (register(Medeleg), bitvector(1)) -> unit

$[complete]
$[fix_location]
function _set_Medeleg_Load_Addr_Align (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Medeleg_Load_Addr_Align(r, v)
}

overload _mod_Load_Addr_Align = {
  _get_Medeleg_Load_Addr_Align,
  _set_Medeleg_Load_Addr_Align
}

$[fix_location]
val _get_Medeleg_Load_Page_Fault : Medeleg -> bitvector(1)

$[complete]
$[fix_location]
function _get_Medeleg_Load_Page_Fault v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 13, 13)

$[fix_location]
val _update_Medeleg_Load_Page_Fault : (Medeleg, bitvector(1)) -> Medeleg

$[complete]
$[fix_location]
function _update_Medeleg_Load_Page_Fault (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 13, 13, x) }

$[fix_location]
overload update_Load_Page_Fault = {_update_Medeleg_Load_Page_Fault}

$[fix_location]
val _set_Medeleg_Load_Page_Fault : (register(Medeleg), bitvector(1)) -> unit

$[complete]
$[fix_location]
function _set_Medeleg_Load_Page_Fault (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Medeleg_Load_Page_Fault(r, v)
}

overload _mod_Load_Page_Fault = {
  _get_Medeleg_Load_Page_Fault,
  _set_Medeleg_Load_Page_Fault
}

$[fix_location]
val _get_Medeleg_MEnvCall : Medeleg -> bitvector(1)

$[complete]
$[fix_location]
function _get_Medeleg_MEnvCall v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 11, 11)

$[fix_location]
val _update_Medeleg_MEnvCall : (Medeleg, bitvector(1)) -> Medeleg

$[complete]
$[fix_location]
function _update_Medeleg_MEnvCall (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 11, 11, x) }

$[fix_location]
overload update_MEnvCall = {_update_Medeleg_MEnvCall}

$[fix_location]
val _set_Medeleg_MEnvCall : (register(Medeleg), bitvector(1)) -> unit

$[complete]
$[fix_location]
function _set_Medeleg_MEnvCall (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Medeleg_MEnvCall(r, v)
}

overload _mod_MEnvCall = {_get_Medeleg_MEnvCall, _set_Medeleg_MEnvCall}

$[fix_location]
val _get_Medeleg_SAMO_Access_Fault : Medeleg -> bitvector(1)

$[complete]
$[fix_location]
function _get_Medeleg_SAMO_Access_Fault v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 7, 7)

$[fix_location]
val _update_Medeleg_SAMO_Access_Fault : (Medeleg, bitvector(1)) -> Medeleg

$[complete]
$[fix_location]
function _update_Medeleg_SAMO_Access_Fault (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 7, 7, x) }

$[fix_location]
overload update_SAMO_Access_Fault = {_update_Medeleg_SAMO_Access_Fault}

$[fix_location]
val _set_Medeleg_SAMO_Access_Fault : (register(Medeleg), bitvector(1)) -> unit

$[complete]
$[fix_location]
function _set_Medeleg_SAMO_Access_Fault (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Medeleg_SAMO_Access_Fault(r, v)
}

overload _mod_SAMO_Access_Fault = {
  _get_Medeleg_SAMO_Access_Fault,
  _set_Medeleg_SAMO_Access_Fault
}

$[fix_location]
val _get_Medeleg_SAMO_Addr_Align : Medeleg -> bitvector(1)

$[complete]
$[fix_location]
function _get_Medeleg_SAMO_Addr_Align v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 6, 6)

$[fix_location]
val _update_Medeleg_SAMO_Addr_Align : (Medeleg, bitvector(1)) -> Medeleg

$[complete]
$[fix_location]
function _update_Medeleg_SAMO_Addr_Align (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 6, 6, x) }

$[fix_location]
overload update_SAMO_Addr_Align = {_update_Medeleg_SAMO_Addr_Align}

$[fix_location]
val _set_Medeleg_SAMO_Addr_Align : (register(Medeleg), bitvector(1)) -> unit

$[complete]
$[fix_location]
function _set_Medeleg_SAMO_Addr_Align (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Medeleg_SAMO_Addr_Align(r, v)
}

overload _mod_SAMO_Addr_Align = {
  _get_Medeleg_SAMO_Addr_Align,
  _set_Medeleg_SAMO_Addr_Align
}

$[fix_location]
val _get_Medeleg_SAMO_Page_Fault : Medeleg -> bitvector(1)

$[complete]
$[fix_location]
function _get_Medeleg_SAMO_Page_Fault v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 15, 15)

$[fix_location]
val _update_Medeleg_SAMO_Page_Fault : (Medeleg, bitvector(1)) -> Medeleg

$[complete]
$[fix_location]
function _update_Medeleg_SAMO_Page_Fault (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 15, 15, x) }

$[fix_location]
overload update_SAMO_Page_Fault = {_update_Medeleg_SAMO_Page_Fault}

$[fix_location]
val _set_Medeleg_SAMO_Page_Fault : (register(Medeleg), bitvector(1)) -> unit

$[complete]
$[fix_location]
function _set_Medeleg_SAMO_Page_Fault (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Medeleg_SAMO_Page_Fault(r, v)
}

overload _mod_SAMO_Page_Fault = {
  _get_Medeleg_SAMO_Page_Fault,
  _set_Medeleg_SAMO_Page_Fault
}

$[fix_location]
val _get_Medeleg_SEnvCall : Medeleg -> bitvector(1)

$[complete]
$[fix_location]
function _get_Medeleg_SEnvCall v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 9, 9)

$[fix_location]
val _update_Medeleg_SEnvCall : (Medeleg, bitvector(1)) -> Medeleg

$[complete]
$[fix_location]
function _update_Medeleg_SEnvCall (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 9, 9, x) }

$[fix_location]
overload update_SEnvCall = {_update_Medeleg_SEnvCall}

$[fix_location]
val _set_Medeleg_SEnvCall : (register(Medeleg), bitvector(1)) -> unit

$[complete]
$[fix_location]
function _set_Medeleg_SEnvCall (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Medeleg_SEnvCall(r, v)
}

overload _mod_SEnvCall = {_get_Medeleg_SEnvCall, _set_Medeleg_SEnvCall}

$[fix_location]
val _get_Medeleg_UEnvCall : Medeleg -> bitvector(1)

$[complete]
$[fix_location]
function _get_Medeleg_UEnvCall v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 8, 8)

$[fix_location]
val _update_Medeleg_UEnvCall : (Medeleg, bitvector(1)) -> Medeleg

$[complete]
$[fix_location]
function _update_Medeleg_UEnvCall (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 8, 8, x) }

$[fix_location]
overload update_UEnvCall = {_update_Medeleg_UEnvCall}

$[fix_location]
val _set_Medeleg_UEnvCall : (register(Medeleg), bitvector(1)) -> unit

$[complete]
$[fix_location]
function _set_Medeleg_UEnvCall (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Medeleg_UEnvCall(r, v)
}

overload _mod_UEnvCall = {_get_Medeleg_UEnvCall, _set_Medeleg_UEnvCall}

val legalize_medeleg : (Medeleg, bitvector(64)) -> Medeleg

$[complete]
function legalize_medeleg (o : Medeleg, v : bits(64)) = {
    _update_Medeleg_MEnvCall(Mk_Medeleg(v), 0b0)
}

register mie : Minterrupts

register mip : Minterrupts

register medeleg : Medeleg

register mideleg : Minterrupts

$[undefined_gen "skip"]
$[bitfield]
struct Mtvec = {bits : bitvector(xlen)}

val undefined_Mtvec : unit -> Mtvec

$[complete]
function undefined_Mtvec () = struct Mtvec { bits = undefined }

val Mk_Mtvec : bitvector(xlen) -> Mtvec

$[complete]
function Mk_Mtvec v = struct Mtvec { bits = v }

$[fix_location]
val _get_Mtvec_bits : Mtvec -> bitvector(xlen)

$[complete]
$[fix_location]
function _get_Mtvec_bits v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, sub_atom(sizeof(xlen), 1), 0)

$[fix_location]
val _update_Mtvec_bits : (Mtvec, bitvector(xlen)) -> Mtvec

$[complete]
$[fix_location]
function _update_Mtvec_bits (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, sub_atom(sizeof(xlen), 1), 0, x) }

$[fix_location]
overload update_bits = {_update_Mtvec_bits}

$[fix_location]
val _set_Mtvec_bits : (register(Mtvec), bitvector(xlen)) -> unit

$[complete]
$[fix_location]
function _set_Mtvec_bits (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Mtvec_bits(r, v)
}

overload _mod_bits = {_get_Mtvec_bits, _set_Mtvec_bits}

$[fix_location]
val _get_Mtvec_Base : Mtvec -> bitvector(xlen - 2)

$[complete]
$[fix_location]
function _get_Mtvec_Base v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, sub_atom(sizeof(xlen), 1), 2)

$[fix_location]
val _update_Mtvec_Base : (Mtvec, bitvector(xlen - 2)) -> Mtvec

$[complete]
$[fix_location]
function _update_Mtvec_Base (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, sub_atom(sizeof(xlen), 1), 2, x) }

$[fix_location]
overload update_Base = {_update_Mtvec_Base}

$[fix_location]
val _set_Mtvec_Base : (register(Mtvec), bitvector(xlen - 2)) -> unit

$[complete]
$[fix_location]
function _set_Mtvec_Base (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Mtvec_Base(r, v)
}

overload _mod_Base = {_get_Mtvec_Base, _set_Mtvec_Base}

$[fix_location]
val _get_Mtvec_Mode : Mtvec -> bitvector(2)

$[complete]
$[fix_location]
function _get_Mtvec_Mode v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 1, 0)

$[fix_location]
val _update_Mtvec_Mode : (Mtvec, bitvector(2)) -> Mtvec

$[complete]
$[fix_location]
function _update_Mtvec_Mode (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 1, 0, x) }

$[fix_location]
overload update_Mode = {_update_Mtvec_Mode}

$[fix_location]
val _set_Mtvec_Mode : (register(Mtvec), bitvector(2)) -> unit

$[complete]
$[fix_location]
function _set_Mtvec_Mode (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Mtvec_Mode(r, v)
}

overload _mod_Mode = {_get_Mtvec_Mode, _set_Mtvec_Mode}

register mtvec : Mtvec

val legalize_tvec : (Mtvec, bitvector(xlen)) -> Mtvec

$[complete]
function legalize_tvec (o : Mtvec, v : xlenbits) = {
    let v = Mk_Mtvec(v);
    $[complete] match trapVectorMode_of_bits(_get_Mtvec_Mode(v)) {
      TV_Direct => v,
      TV_Vector => v,
      _ => _update_Mtvec_Mode(v, _get_Mtvec_Mode(o))
    }
}

$[undefined_gen "skip"]
$[bitfield]
struct Mcause = {bits : bitvector(xlen)}

val undefined_Mcause : unit -> Mcause

$[complete]
function undefined_Mcause () = struct Mcause { bits = undefined }

val Mk_Mcause : bitvector(xlen) -> Mcause

$[complete]
function Mk_Mcause v = struct Mcause { bits = v }

$[fix_location]
val _get_Mcause_bits : Mcause -> bitvector(xlen)

$[complete]
$[fix_location]
function _get_Mcause_bits v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, sub_atom(sizeof(xlen), 1), 0)

$[fix_location]
val _update_Mcause_bits : (Mcause, bitvector(xlen)) -> Mcause

$[complete]
$[fix_location]
function _update_Mcause_bits (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, sub_atom(sizeof(xlen), 1), 0, x) }

$[fix_location]
overload update_bits = {_update_Mcause_bits}

$[fix_location]
val _set_Mcause_bits : (register(Mcause), bitvector(xlen)) -> unit

$[complete]
$[fix_location]
function _set_Mcause_bits (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Mcause_bits(r, v)
}

overload _mod_bits = {_get_Mcause_bits, _set_Mcause_bits}

$[fix_location]
val _get_Mcause_Cause : Mcause -> bitvector(xlen - 1)

$[complete]
$[fix_location]
function _get_Mcause_Cause v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, sub_atom(sizeof(xlen), 2), 0)

$[fix_location]
val _update_Mcause_Cause : (Mcause, bitvector(xlen - 1)) -> Mcause

$[complete]
$[fix_location]
function _update_Mcause_Cause (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, sub_atom(sizeof(xlen), 2), 0, x) }

$[fix_location]
overload update_Cause = {_update_Mcause_Cause}

$[fix_location]
val _set_Mcause_Cause : (register(Mcause), bitvector(xlen - 1)) -> unit

$[complete]
$[fix_location]
function _set_Mcause_Cause (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Mcause_Cause(r, v)
}

overload _mod_Cause = {_get_Mcause_Cause, _set_Mcause_Cause}

$[fix_location]
val _get_Mcause_IsInterrupt : Mcause -> bitvector(xlen - 1 - (xlen - 1) + 1)

$[complete]
$[fix_location]
function _get_Mcause_IsInterrupt v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, sub_atom(sizeof(xlen), 1), sub_atom(sizeof(xlen), 1))

$[fix_location]
val _update_Mcause_IsInterrupt : (Mcause, bitvector(xlen - 1 - (xlen - 1) + 1)) -> Mcause

$[complete]
$[fix_location]
function _update_Mcause_IsInterrupt (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, sub_atom(sizeof(xlen), 1), sub_atom(sizeof(xlen), 1), x) }

$[fix_location]
overload update_IsInterrupt = {_update_Mcause_IsInterrupt}

$[fix_location]
val _set_Mcause_IsInterrupt : (register(Mcause), bitvector(xlen - 1 - (xlen - 1) + 1)) -> unit

$[complete]
$[fix_location]
function _set_Mcause_IsInterrupt (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Mcause_IsInterrupt(r, v)
}

overload _mod_IsInterrupt = {_get_Mcause_IsInterrupt, _set_Mcause_IsInterrupt}

register mcause : Mcause

val tvec_addr : (Mtvec, Mcause) -> option(bitvector(xlen))

$[complete]
function tvec_addr (m : Mtvec, c : Mcause) = {
    let base : xlenbits = $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(_get_Mtvec_Base(m), 0b00);
    $[complete] match trapVectorMode_of_bits(_get_Mtvec_Mode(m)) {
      TV_Direct => Some(base),
      TV_Vector => if $[overloaded { "name" = "==", "is_infix" = true }] eq_bits(_get_Mcause_IsInterrupt(c), 0b1) then
        Some($[overloaded { "name" = "+", "is_infix" = true }] add_bits(base, $[overloaded { "name" = "<<", "is_infix" = true }] shiftl(zero_extend(sizeof(xlen), _get_Mcause_Cause(c)), 2)))
      else
        Some(base),
      TV_Reserved => None()
    }
}

register mepc : xlenbits

val legalize_xepc : bitvector(xlen) -> bitvector(xlen)

$[complete]
function legalize_xepc v : xlenbits = {
    if hartSupports(Ext_Zca) then
      $[overloaded { "name" = "vector_update", "is_infix" = false }] bitvector_update(v, 0, bitzero)
    else
      $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v, 1, 0, zeros(sub_atom(1, sub_atom(0, 1))))
}

val align_pc : bitvector(xlen) -> bitvector(xlen)

$[complete]
function align_pc addr : xlenbits = {
    if currentlyEnabled(Ext_Zca) then
      $[overloaded { "name" = "vector_update", "is_infix" = false }] bitvector_update(addr, 0, bitzero)
    else
      $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(addr, 1, 0, zeros(sub_atom(1, sub_atom(0, 1))))
}

register mtval : xlenbits

register mscratch : xlenbits

$[undefined_gen "skip"]
$[bitfield]
struct Counteren = {bits : bitvector(32)}

val undefined_Counteren : unit -> Counteren

$[complete]
function undefined_Counteren () = struct Counteren { bits = undefined }

val Mk_Counteren : bitvector(32) -> Counteren

$[complete]
function Mk_Counteren v = struct Counteren { bits = v }

$[fix_location]
val _get_Counteren_bits : Counteren -> bitvector(32)

$[complete]
$[fix_location]
function _get_Counteren_bits v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, sub_atom(32, 1), 0)

$[fix_location]
val _update_Counteren_bits : (Counteren, bitvector(32)) -> Counteren

$[complete]
$[fix_location]
function _update_Counteren_bits (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, sub_atom(32, 1), 0, x) }

$[fix_location]
overload update_bits = {_update_Counteren_bits}

$[fix_location]
val _set_Counteren_bits : (register(Counteren), bitvector(32)) -> unit

$[complete]
$[fix_location]
function _set_Counteren_bits (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Counteren_bits(r, v)
}

overload _mod_bits = {_get_Counteren_bits, _set_Counteren_bits}

$[fix_location]
val _get_Counteren_CY : Counteren -> bitvector(1)

$[complete]
$[fix_location]
function _get_Counteren_CY v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 0, 0)

$[fix_location]
val _update_Counteren_CY : (Counteren, bitvector(1)) -> Counteren

$[complete]
$[fix_location]
function _update_Counteren_CY (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 0, 0, x) }

$[fix_location]
overload update_CY = {_update_Counteren_CY}

$[fix_location]
val _set_Counteren_CY : (register(Counteren), bitvector(1)) -> unit

$[complete]
$[fix_location]
function _set_Counteren_CY (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Counteren_CY(r, v)
}

overload _mod_CY = {_get_Counteren_CY, _set_Counteren_CY}

$[fix_location]
val _get_Counteren_HPM : Counteren -> bitvector(29)

$[complete]
$[fix_location]
function _get_Counteren_HPM v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 31, 3)

$[fix_location]
val _update_Counteren_HPM : (Counteren, bitvector(29)) -> Counteren

$[complete]
$[fix_location]
function _update_Counteren_HPM (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 31, 3, x) }

$[fix_location]
overload update_HPM = {_update_Counteren_HPM}

$[fix_location]
val _set_Counteren_HPM : (register(Counteren), bitvector(29)) -> unit

$[complete]
$[fix_location]
function _set_Counteren_HPM (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Counteren_HPM(r, v)
}

overload _mod_HPM = {_get_Counteren_HPM, _set_Counteren_HPM}

$[fix_location]
val _get_Counteren_IR : Counteren -> bitvector(1)

$[complete]
$[fix_location]
function _get_Counteren_IR v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 2, 2)

$[fix_location]
val _update_Counteren_IR : (Counteren, bitvector(1)) -> Counteren

$[complete]
$[fix_location]
function _update_Counteren_IR (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 2, 2, x) }

$[fix_location]
overload update_IR = {_update_Counteren_IR}

$[fix_location]
val _set_Counteren_IR : (register(Counteren), bitvector(1)) -> unit

$[complete]
$[fix_location]
function _set_Counteren_IR (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Counteren_IR(r, v)
}

overload _mod_IR = {_get_Counteren_IR, _set_Counteren_IR}

$[fix_location]
val _get_Counteren_TM : Counteren -> bitvector(1)

$[complete]
$[fix_location]
function _get_Counteren_TM v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 1, 1)

$[fix_location]
val _update_Counteren_TM : (Counteren, bitvector(1)) -> Counteren

$[complete]
$[fix_location]
function _update_Counteren_TM (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 1, 1, x) }

$[fix_location]
overload update_TM = {_update_Counteren_TM}

$[fix_location]
val _set_Counteren_TM : (register(Counteren), bitvector(1)) -> unit

$[complete]
$[fix_location]
function _set_Counteren_TM (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Counteren_TM(r, v)
}

overload _mod_TM = {_get_Counteren_TM, _set_Counteren_TM}

val legalize_scounteren : (Counteren, bitvector(xlen)) -> Counteren

$[complete]
function legalize_scounteren (c : Counteren, v : xlenbits) = {
    let supported_counters = $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(sys_writable_hpm_counters, 31, 3), 0b111);
    Mk_Counteren($[overloaded { "name" = "&", "is_infix" = true }] and_vec($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v, 31, 0), supported_counters))
}

register scounteren : Counteren

val legalize_mcounteren : (Counteren, bitvector(xlen)) -> Counteren

$[complete]
function legalize_mcounteren (c : Counteren, v : xlenbits) = {
    let supported_counters = $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(sys_writable_hpm_counters, 31, 3), 0b111);
    Mk_Counteren($[overloaded { "name" = "&", "is_infix" = true }] and_vec($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v, 31, 0), supported_counters))
}

register mcounteren : Counteren

$[undefined_gen "skip"]
$[bitfield]
struct Counterin = {bits : bitvector(32)}

val undefined_Counterin : unit -> Counterin

$[complete]
function undefined_Counterin () = struct Counterin { bits = undefined }

val Mk_Counterin : bitvector(32) -> Counterin

$[complete]
function Mk_Counterin v = struct Counterin { bits = v }

$[fix_location]
val _get_Counterin_bits : Counterin -> bitvector(32)

$[complete]
$[fix_location]
function _get_Counterin_bits v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, sub_atom(32, 1), 0)

$[fix_location]
val _update_Counterin_bits : (Counterin, bitvector(32)) -> Counterin

$[complete]
$[fix_location]
function _update_Counterin_bits (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, sub_atom(32, 1), 0, x) }

$[fix_location]
overload update_bits = {_update_Counterin_bits}

$[fix_location]
val _set_Counterin_bits : (register(Counterin), bitvector(32)) -> unit

$[complete]
$[fix_location]
function _set_Counterin_bits (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Counterin_bits(r, v)
}

overload _mod_bits = {_get_Counterin_bits, _set_Counterin_bits}

$[fix_location]
val _get_Counterin_CY : Counterin -> bitvector(1)

$[complete]
$[fix_location]
function _get_Counterin_CY v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 0, 0)

$[fix_location]
val _update_Counterin_CY : (Counterin, bitvector(1)) -> Counterin

$[complete]
$[fix_location]
function _update_Counterin_CY (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 0, 0, x) }

$[fix_location]
overload update_CY = {_update_Counterin_CY}

$[fix_location]
val _set_Counterin_CY : (register(Counterin), bitvector(1)) -> unit

$[complete]
$[fix_location]
function _set_Counterin_CY (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Counterin_CY(r, v)
}

overload _mod_CY = {_get_Counterin_CY, _set_Counterin_CY}

$[fix_location]
val _get_Counterin_HPM : Counterin -> bitvector(29)

$[complete]
$[fix_location]
function _get_Counterin_HPM v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 31, 3)

$[fix_location]
val _update_Counterin_HPM : (Counterin, bitvector(29)) -> Counterin

$[complete]
$[fix_location]
function _update_Counterin_HPM (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 31, 3, x) }

$[fix_location]
overload update_HPM = {_update_Counterin_HPM}

$[fix_location]
val _set_Counterin_HPM : (register(Counterin), bitvector(29)) -> unit

$[complete]
$[fix_location]
function _set_Counterin_HPM (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Counterin_HPM(r, v)
}

overload _mod_HPM = {_get_Counterin_HPM, _set_Counterin_HPM}

$[fix_location]
val _get_Counterin_IR : Counterin -> bitvector(1)

$[complete]
$[fix_location]
function _get_Counterin_IR v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 2, 2)

$[fix_location]
val _update_Counterin_IR : (Counterin, bitvector(1)) -> Counterin

$[complete]
$[fix_location]
function _update_Counterin_IR (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 2, 2, x) }

$[fix_location]
overload update_IR = {_update_Counterin_IR}

$[fix_location]
val _set_Counterin_IR : (register(Counterin), bitvector(1)) -> unit

$[complete]
$[fix_location]
function _set_Counterin_IR (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Counterin_IR(r, v)
}

overload _mod_IR = {_get_Counterin_IR, _set_Counterin_IR}

val legalize_mcountinhibit : (Counterin, bitvector(xlen)) -> Counterin

$[complete]
function legalize_mcountinhibit (c : Counterin, v : xlenbits) = {
    let supported_counters = $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(sys_writable_hpm_counters, 31, 3), 0b101);
    Mk_Counterin($[overloaded { "name" = "&", "is_infix" = true }] and_vec($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v, 31, 0), supported_counters))
}

register mcountinhibit : Counterin

register mcycle : bits(64)

register mtime : bits(64)

register minstret : bits(64)

register minstret_increment : bool

register mvendorid : bits(32) = to_bits_checked(32, config platform.vendorid : int)

register mimpid : xlenbits = to_bits_checked(sizeof(xlen), config platform.impid : int)

register marchid : xlenbits = to_bits_checked(sizeof(xlen), config platform.archid : int)

register mhartid : xlenbits = to_bits_checked(sizeof(xlen), config platform.hartid : int)

register mconfigptr : xlenbits = zeros(sizeof(xlen))

$[undefined_gen "skip"]
$[bitfield]
struct Sstatus = {bits : bitvector(64)}

val undefined_Sstatus : unit -> Sstatus

$[complete]
function undefined_Sstatus () = struct Sstatus { bits = undefined }

val Mk_Sstatus : bitvector(64) -> Sstatus

$[complete]
function Mk_Sstatus v = struct Sstatus { bits = v }

$[fix_location]
val _get_Sstatus_bits : Sstatus -> bitvector(64)

$[complete]
$[fix_location]
function _get_Sstatus_bits v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, sub_atom(64, 1), 0)

$[fix_location]
val _update_Sstatus_bits : (Sstatus, bitvector(64)) -> Sstatus

$[complete]
$[fix_location]
function _update_Sstatus_bits (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, sub_atom(64, 1), 0, x) }

$[fix_location]
overload update_bits = {_update_Sstatus_bits}

$[fix_location]
val _set_Sstatus_bits : (register(Sstatus), bitvector(64)) -> unit

$[complete]
$[fix_location]
function _set_Sstatus_bits (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Sstatus_bits(r, v)
}

overload _mod_bits = {_get_Sstatus_bits, _set_Sstatus_bits}

$[fix_location]
val _get_Sstatus_FS : Sstatus -> bitvector(2)

$[complete]
$[fix_location]
function _get_Sstatus_FS v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 14, 13)

$[fix_location]
val _update_Sstatus_FS : (Sstatus, bitvector(2)) -> Sstatus

$[complete]
$[fix_location]
function _update_Sstatus_FS (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 14, 13, x) }

$[fix_location]
overload update_FS = {_update_Sstatus_FS}

$[fix_location]
val _set_Sstatus_FS : (register(Sstatus), bitvector(2)) -> unit

$[complete]
$[fix_location]
function _set_Sstatus_FS (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Sstatus_FS(r, v)
}

overload _mod_FS = {_get_Sstatus_FS, _set_Sstatus_FS}

$[fix_location]
val _get_Sstatus_MXR : Sstatus -> bitvector(1)

$[complete]
$[fix_location]
function _get_Sstatus_MXR v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 19, 19)

$[fix_location]
val _update_Sstatus_MXR : (Sstatus, bitvector(1)) -> Sstatus

$[complete]
$[fix_location]
function _update_Sstatus_MXR (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 19, 19, x) }

$[fix_location]
overload update_MXR = {_update_Sstatus_MXR}

$[fix_location]
val _set_Sstatus_MXR : (register(Sstatus), bitvector(1)) -> unit

$[complete]
$[fix_location]
function _set_Sstatus_MXR (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Sstatus_MXR(r, v)
}

overload _mod_MXR = {_get_Sstatus_MXR, _set_Sstatus_MXR}

$[fix_location]
val _get_Sstatus_SD : Sstatus -> bitvector(xlen - 1 - (xlen - 1) + 1)

$[complete]
$[fix_location]
function _get_Sstatus_SD v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, sub_atom(sizeof(xlen), 1), sub_atom(sizeof(xlen), 1))

$[fix_location]
val _update_Sstatus_SD : (Sstatus, bitvector(xlen - 1 - (xlen - 1) + 1)) -> Sstatus

$[complete]
$[fix_location]
function _update_Sstatus_SD (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, sub_atom(sizeof(xlen), 1), sub_atom(sizeof(xlen), 1), x) }

$[fix_location]
overload update_SD = {_update_Sstatus_SD}

$[fix_location]
val _set_Sstatus_SD : (register(Sstatus), bitvector(xlen - 1 - (xlen - 1) + 1)) -> unit

$[complete]
$[fix_location]
function _set_Sstatus_SD (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Sstatus_SD(r, v)
}

overload _mod_SD = {_get_Sstatus_SD, _set_Sstatus_SD}

$[fix_location]
val _get_Sstatus_SIE : Sstatus -> bitvector(1)

$[complete]
$[fix_location]
function _get_Sstatus_SIE v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 1, 1)

$[fix_location]
val _update_Sstatus_SIE : (Sstatus, bitvector(1)) -> Sstatus

$[complete]
$[fix_location]
function _update_Sstatus_SIE (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 1, 1, x) }

$[fix_location]
overload update_SIE = {_update_Sstatus_SIE}

$[fix_location]
val _set_Sstatus_SIE : (register(Sstatus), bitvector(1)) -> unit

$[complete]
$[fix_location]
function _set_Sstatus_SIE (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Sstatus_SIE(r, v)
}

overload _mod_SIE = {_get_Sstatus_SIE, _set_Sstatus_SIE}

$[fix_location]
val _get_Sstatus_SPIE : Sstatus -> bitvector(1)

$[complete]
$[fix_location]
function _get_Sstatus_SPIE v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 5, 5)

$[fix_location]
val _update_Sstatus_SPIE : (Sstatus, bitvector(1)) -> Sstatus

$[complete]
$[fix_location]
function _update_Sstatus_SPIE (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 5, 5, x) }

$[fix_location]
overload update_SPIE = {_update_Sstatus_SPIE}

$[fix_location]
val _set_Sstatus_SPIE : (register(Sstatus), bitvector(1)) -> unit

$[complete]
$[fix_location]
function _set_Sstatus_SPIE (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Sstatus_SPIE(r, v)
}

overload _mod_SPIE = {_get_Sstatus_SPIE, _set_Sstatus_SPIE}

$[fix_location]
val _get_Sstatus_SPP : Sstatus -> bitvector(1)

$[complete]
$[fix_location]
function _get_Sstatus_SPP v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 8, 8)

$[fix_location]
val _update_Sstatus_SPP : (Sstatus, bitvector(1)) -> Sstatus

$[complete]
$[fix_location]
function _update_Sstatus_SPP (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 8, 8, x) }

$[fix_location]
overload update_SPP = {_update_Sstatus_SPP}

$[fix_location]
val _set_Sstatus_SPP : (register(Sstatus), bitvector(1)) -> unit

$[complete]
$[fix_location]
function _set_Sstatus_SPP (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Sstatus_SPP(r, v)
}

overload _mod_SPP = {_get_Sstatus_SPP, _set_Sstatus_SPP}

$[fix_location]
val _get_Sstatus_SUM : Sstatus -> bitvector(1)

$[complete]
$[fix_location]
function _get_Sstatus_SUM v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 18, 18)

$[fix_location]
val _update_Sstatus_SUM : (Sstatus, bitvector(1)) -> Sstatus

$[complete]
$[fix_location]
function _update_Sstatus_SUM (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 18, 18, x) }

$[fix_location]
overload update_SUM = {_update_Sstatus_SUM}

$[fix_location]
val _set_Sstatus_SUM : (register(Sstatus), bitvector(1)) -> unit

$[complete]
$[fix_location]
function _set_Sstatus_SUM (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Sstatus_SUM(r, v)
}

overload _mod_SUM = {_get_Sstatus_SUM, _set_Sstatus_SUM}

$[fix_location]
val _get_Sstatus_UXL : Sstatus -> bitvector(2)

$[complete]
$[fix_location]
function _get_Sstatus_UXL v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 33, 32)

$[fix_location]
val _update_Sstatus_UXL : (Sstatus, bitvector(2)) -> Sstatus

$[complete]
$[fix_location]
function _update_Sstatus_UXL (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 33, 32, x) }

$[fix_location]
overload update_UXL = {_update_Sstatus_UXL}

$[fix_location]
val _set_Sstatus_UXL : (register(Sstatus), bitvector(2)) -> unit

$[complete]
$[fix_location]
function _set_Sstatus_UXL (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Sstatus_UXL(r, v)
}

overload _mod_UXL = {_get_Sstatus_UXL, _set_Sstatus_UXL}

$[fix_location]
val _get_Sstatus_VS : Sstatus -> bitvector(2)

$[complete]
$[fix_location]
function _get_Sstatus_VS v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 10, 9)

$[fix_location]
val _update_Sstatus_VS : (Sstatus, bitvector(2)) -> Sstatus

$[complete]
$[fix_location]
function _update_Sstatus_VS (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 10, 9, x) }

$[fix_location]
overload update_VS = {_update_Sstatus_VS}

$[fix_location]
val _set_Sstatus_VS : (register(Sstatus), bitvector(2)) -> unit

$[complete]
$[fix_location]
function _set_Sstatus_VS (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Sstatus_VS(r, v)
}

overload _mod_VS = {_get_Sstatus_VS, _set_Sstatus_VS}

$[fix_location]
val _get_Sstatus_XS : Sstatus -> bitvector(2)

$[complete]
$[fix_location]
function _get_Sstatus_XS v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 16, 15)

$[fix_location]
val _update_Sstatus_XS : (Sstatus, bitvector(2)) -> Sstatus

$[complete]
$[fix_location]
function _update_Sstatus_XS (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 16, 15, x) }

$[fix_location]
overload update_XS = {_update_Sstatus_XS}

$[fix_location]
val _set_Sstatus_XS : (register(Sstatus), bitvector(2)) -> unit

$[complete]
$[fix_location]
function _set_Sstatus_XS (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Sstatus_XS(r, v)
}

overload _mod_XS = {_get_Sstatus_XS, _set_Sstatus_XS}

val lower_mstatus : Mstatus -> Sstatus

$[complete]
function lower_mstatus m : Mstatus = {
    let s = Mk_Sstatus(zeros(64));
    _update_Sstatus_SIE(_update_Sstatus_SPIE(_update_Sstatus_SPP(_update_Sstatus_VS(_update_Sstatus_FS(_update_Sstatus_XS(_update_Sstatus_SUM(_update_Sstatus_MXR(_update_Sstatus_UXL(_update_Sstatus_SD(s, _get_Mstatus_SD(m)), _get_Mstatus_UXL(m)), _get_Mstatus_MXR(m)), _get_Mstatus_SUM(m)), _get_Mstatus_XS(m)), _get_Mstatus_FS(m)), _get_Mstatus_VS(m)), _get_Mstatus_SPP(m)), _get_Mstatus_SPIE(m)), _get_Mstatus_SIE(m))
}

val lift_sstatus : (Mstatus, Sstatus) -> Mstatus

$[complete]
function lift_sstatus (m : Mstatus, s : Sstatus) = {
    let dirty = $[overloaded { "name" = "|", "is_infix" = true }] or_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_anything(extStatus_of_bits(_get_Sstatus_FS(s)), Dirty), $[overloaded { "name" = "|", "is_infix" = true }] or_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_anything(extStatus_of_bits(_get_Sstatus_XS(s)), Dirty), $[overloaded { "name" = "==", "is_infix" = true }] eq_anything(extStatus_of_bits(_get_Sstatus_VS(s)), Dirty)));
    _update_Mstatus_SIE(_update_Mstatus_SPIE(_update_Mstatus_SPP(_update_Mstatus_VS(_update_Mstatus_FS(_update_Mstatus_XS(_update_Mstatus_SUM(_update_Mstatus_MXR(_update_Mstatus_UXL(_update_Mstatus_SD(m, bool_to_bits(dirty)), _get_Sstatus_UXL(s)), _get_Sstatus_MXR(s)), _get_Sstatus_SUM(s)), _get_Sstatus_XS(s)), _get_Sstatus_FS(s)), _get_Sstatus_VS(s)), _get_Sstatus_SPP(s)), _get_Sstatus_SPIE(s)), _get_Sstatus_SIE(s))
}

val legalize_sstatus : (Mstatus, bitvector(xlen)) -> Mstatus

$[complete]
function legalize_sstatus (m : Mstatus, v : xlenbits) = {
    legalize_mstatus(m, lift_sstatus(m, Mk_Sstatus(zero_extend(64, v))).bits)
}

$[undefined_gen "skip"]
$[bitfield]
struct Sinterrupts = {bits : bitvector(xlen)}

val undefined_Sinterrupts : unit -> Sinterrupts

$[complete]
function undefined_Sinterrupts () = struct Sinterrupts { bits = undefined }

val Mk_Sinterrupts : bitvector(xlen) -> Sinterrupts

$[complete]
function Mk_Sinterrupts v = struct Sinterrupts { bits = v }

$[fix_location]
val _get_Sinterrupts_bits : Sinterrupts -> bitvector(xlen)

$[complete]
$[fix_location]
function _get_Sinterrupts_bits v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, sub_atom(sizeof(xlen), 1), 0)

$[fix_location]
val _update_Sinterrupts_bits : (Sinterrupts, bitvector(xlen)) -> Sinterrupts

$[complete]
$[fix_location]
function _update_Sinterrupts_bits (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, sub_atom(sizeof(xlen), 1), 0, x) }

$[fix_location]
overload update_bits = {_update_Sinterrupts_bits}

$[fix_location]
val _set_Sinterrupts_bits : (register(Sinterrupts), bitvector(xlen)) -> unit

$[complete]
$[fix_location]
function _set_Sinterrupts_bits (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Sinterrupts_bits(r, v)
}

overload _mod_bits = {_get_Sinterrupts_bits, _set_Sinterrupts_bits}

$[fix_location]
val _get_Sinterrupts_SEI : Sinterrupts -> bitvector(1)

$[complete]
$[fix_location]
function _get_Sinterrupts_SEI v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 9, 9)

$[fix_location]
val _update_Sinterrupts_SEI : (Sinterrupts, bitvector(1)) -> Sinterrupts

$[complete]
$[fix_location]
function _update_Sinterrupts_SEI (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 9, 9, x) }

$[fix_location]
overload update_SEI = {_update_Sinterrupts_SEI}

$[fix_location]
val _set_Sinterrupts_SEI : (register(Sinterrupts), bitvector(1)) -> unit

$[complete]
$[fix_location]
function _set_Sinterrupts_SEI (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Sinterrupts_SEI(r, v)
}

overload _mod_SEI = {_get_Sinterrupts_SEI, _set_Sinterrupts_SEI}

$[fix_location]
val _get_Sinterrupts_SSI : Sinterrupts -> bitvector(1)

$[complete]
$[fix_location]
function _get_Sinterrupts_SSI v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 1, 1)

$[fix_location]
val _update_Sinterrupts_SSI : (Sinterrupts, bitvector(1)) -> Sinterrupts

$[complete]
$[fix_location]
function _update_Sinterrupts_SSI (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 1, 1, x) }

$[fix_location]
overload update_SSI = {_update_Sinterrupts_SSI}

$[fix_location]
val _set_Sinterrupts_SSI : (register(Sinterrupts), bitvector(1)) -> unit

$[complete]
$[fix_location]
function _set_Sinterrupts_SSI (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Sinterrupts_SSI(r, v)
}

overload _mod_SSI = {_get_Sinterrupts_SSI, _set_Sinterrupts_SSI}

$[fix_location]
val _get_Sinterrupts_STI : Sinterrupts -> bitvector(1)

$[complete]
$[fix_location]
function _get_Sinterrupts_STI v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 5, 5)

$[fix_location]
val _update_Sinterrupts_STI : (Sinterrupts, bitvector(1)) -> Sinterrupts

$[complete]
$[fix_location]
function _update_Sinterrupts_STI (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 5, 5, x) }

$[fix_location]
overload update_STI = {_update_Sinterrupts_STI}

$[fix_location]
val _set_Sinterrupts_STI : (register(Sinterrupts), bitvector(1)) -> unit

$[complete]
$[fix_location]
function _set_Sinterrupts_STI (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Sinterrupts_STI(r, v)
}

overload _mod_STI = {_get_Sinterrupts_STI, _set_Sinterrupts_STI}

val lower_mip : (Minterrupts, Minterrupts) -> Sinterrupts

$[complete]
function lower_mip (m : Minterrupts, d : Minterrupts) = {
    let s : Sinterrupts = Mk_Sinterrupts(zeros(sizeof(xlen)));
    _update_Sinterrupts_SSI(_update_Sinterrupts_STI(_update_Sinterrupts_SEI(s, $[overloaded { "name" = "&", "is_infix" = true }] and_vec(_get_Minterrupts_SEI(m), _get_Minterrupts_SEI(d))), $[overloaded { "name" = "&", "is_infix" = true }] and_vec(_get_Minterrupts_STI(m), _get_Minterrupts_STI(d))), $[overloaded { "name" = "&", "is_infix" = true }] and_vec(_get_Minterrupts_SSI(m), _get_Minterrupts_SSI(d)))
}

val lower_mie : (Minterrupts, Minterrupts) -> Sinterrupts

$[complete]
function lower_mie (m : Minterrupts, d : Minterrupts) = {
    let s : Sinterrupts = Mk_Sinterrupts(zeros(sizeof(xlen)));
    _update_Sinterrupts_SSI(_update_Sinterrupts_STI(_update_Sinterrupts_SEI(s, $[overloaded { "name" = "&", "is_infix" = true }] and_vec(_get_Minterrupts_SEI(m), _get_Minterrupts_SEI(d))), $[overloaded { "name" = "&", "is_infix" = true }] and_vec(_get_Minterrupts_STI(m), _get_Minterrupts_STI(d))), $[overloaded { "name" = "&", "is_infix" = true }] and_vec(_get_Minterrupts_SSI(m), _get_Minterrupts_SSI(d)))
}

val lift_sip : (Minterrupts, Minterrupts, Sinterrupts) -> Minterrupts

$[complete]
function lift_sip (o : Minterrupts, d : Minterrupts, s : Sinterrupts) = {
    let m : Minterrupts = o;
    let m = if $[overloaded { "name" = "==", "is_infix" = true }] eq_bits(_get_Minterrupts_SSI(d), 0b1) then
      _update_Minterrupts_SSI(m, _get_Sinterrupts_SSI(s))
    else
      m;
    m
}

val legalize_sip : (Minterrupts, Minterrupts, bitvector(xlen)) -> Minterrupts

$[complete]
function legalize_sip (m : Minterrupts, d : Minterrupts, v : xlenbits) = {
    lift_sip(m, d, Mk_Sinterrupts(v))
}

val lift_sie : (Minterrupts, Minterrupts, Sinterrupts) -> Minterrupts

$[complete]
function lift_sie (o : Minterrupts, d : Minterrupts, s : Sinterrupts) = {
    let m : Minterrupts = o;
    _update_Minterrupts_SSI(_update_Minterrupts_STI(_update_Minterrupts_SEI(m, if $[overloaded { "name" = "==", "is_infix" = true }] eq_bits(_get_Minterrupts_SEI(d), 0b1) then
      _get_Sinterrupts_SEI(s)
    else
      _get_Minterrupts_SEI(m)), if $[overloaded { "name" = "==", "is_infix" = true }] eq_bits(_get_Minterrupts_STI(d), 0b1) then
      _get_Sinterrupts_STI(s)
    else
      _get_Minterrupts_STI(m)), if $[overloaded { "name" = "==", "is_infix" = true }] eq_bits(_get_Minterrupts_SSI(d), 0b1) then
      _get_Sinterrupts_SSI(s)
    else
      _get_Minterrupts_SSI(m))
}

val legalize_sie : (Minterrupts, Minterrupts, bitvector(xlen)) -> Minterrupts

$[complete]
function legalize_sie (m : Minterrupts, d : Minterrupts, v : xlenbits) = {
    lift_sie(m, d, Mk_Sinterrupts(v))
}

register stvec : Mtvec

register sscratch : xlenbits

register sepc : xlenbits

register scause : Mcause

register stval : xlenbits

$[undefined_gen "skip"]
$[bitfield]
struct Satp64 = {bits : bitvector(64)}

val undefined_Satp64 : unit -> Satp64

$[complete]
function undefined_Satp64 () = struct Satp64 { bits = undefined }

val Mk_Satp64 : bitvector(64) -> Satp64

$[complete]
function Mk_Satp64 v = struct Satp64 { bits = v }

$[fix_location]
val _get_Satp64_bits : Satp64 -> bitvector(64)

$[complete]
$[fix_location]
function _get_Satp64_bits v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, sub_atom(64, 1), 0)

$[fix_location]
val _update_Satp64_bits : (Satp64, bitvector(64)) -> Satp64

$[complete]
$[fix_location]
function _update_Satp64_bits (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, sub_atom(64, 1), 0, x) }

$[fix_location]
overload update_bits = {_update_Satp64_bits}

$[fix_location]
val _set_Satp64_bits : (register(Satp64), bitvector(64)) -> unit

$[complete]
$[fix_location]
function _set_Satp64_bits (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Satp64_bits(r, v)
}

overload _mod_bits = {_get_Satp64_bits, _set_Satp64_bits}

$[fix_location]
val _get_Satp64_Asid : Satp64 -> bitvector(16)

$[complete]
$[fix_location]
function _get_Satp64_Asid v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 59, 44)

$[fix_location]
val _update_Satp64_Asid : (Satp64, bitvector(16)) -> Satp64

$[complete]
$[fix_location]
function _update_Satp64_Asid (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 59, 44, x) }

$[fix_location]
overload update_Asid = {_update_Satp64_Asid}

$[fix_location]
val _set_Satp64_Asid : (register(Satp64), bitvector(16)) -> unit

$[complete]
$[fix_location]
function _set_Satp64_Asid (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Satp64_Asid(r, v)
}

overload _mod_Asid = {_get_Satp64_Asid, _set_Satp64_Asid}

$[fix_location]
val _get_Satp64_Mode : Satp64 -> bitvector(4)

$[complete]
$[fix_location]
function _get_Satp64_Mode v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 63, 60)

$[fix_location]
val _update_Satp64_Mode : (Satp64, bitvector(4)) -> Satp64

$[complete]
$[fix_location]
function _update_Satp64_Mode (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 63, 60, x) }

$[fix_location]
overload update_Mode = {_update_Satp64_Mode}

$[fix_location]
val _set_Satp64_Mode : (register(Satp64), bitvector(4)) -> unit

$[complete]
$[fix_location]
function _set_Satp64_Mode (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Satp64_Mode(r, v)
}

overload _mod_Mode = {_get_Satp64_Mode, _set_Satp64_Mode}

$[fix_location]
val _get_Satp64_PPN : Satp64 -> bitvector(44)

$[complete]
$[fix_location]
function _get_Satp64_PPN v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 43, 0)

$[fix_location]
val _update_Satp64_PPN : (Satp64, bitvector(44)) -> Satp64

$[complete]
$[fix_location]
function _update_Satp64_PPN (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 43, 0, x) }

$[fix_location]
overload update_PPN = {_update_Satp64_PPN}

$[fix_location]
val _set_Satp64_PPN : (register(Satp64), bitvector(44)) -> unit

$[complete]
$[fix_location]
function _set_Satp64_PPN (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Satp64_PPN(r, v)
}

overload _mod_PPN = {_get_Satp64_PPN, _set_Satp64_PPN}

$[undefined_gen "skip"]
$[bitfield]
struct Satp32 = {bits : bitvector(32)}

val undefined_Satp32 : unit -> Satp32

$[complete]
function undefined_Satp32 () = struct Satp32 { bits = undefined }

val Mk_Satp32 : bitvector(32) -> Satp32

$[complete]
function Mk_Satp32 v = struct Satp32 { bits = v }

$[fix_location]
val _get_Satp32_bits : Satp32 -> bitvector(32)

$[complete]
$[fix_location]
function _get_Satp32_bits v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, sub_atom(32, 1), 0)

$[fix_location]
val _update_Satp32_bits : (Satp32, bitvector(32)) -> Satp32

$[complete]
$[fix_location]
function _update_Satp32_bits (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, sub_atom(32, 1), 0, x) }

$[fix_location]
overload update_bits = {_update_Satp32_bits}

$[fix_location]
val _set_Satp32_bits : (register(Satp32), bitvector(32)) -> unit

$[complete]
$[fix_location]
function _set_Satp32_bits (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Satp32_bits(r, v)
}

overload _mod_bits = {_get_Satp32_bits, _set_Satp32_bits}

$[fix_location]
val _get_Satp32_Asid : Satp32 -> bitvector(9)

$[complete]
$[fix_location]
function _get_Satp32_Asid v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 30, 22)

$[fix_location]
val _update_Satp32_Asid : (Satp32, bitvector(9)) -> Satp32

$[complete]
$[fix_location]
function _update_Satp32_Asid (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 30, 22, x) }

$[fix_location]
overload update_Asid = {_update_Satp32_Asid}

$[fix_location]
val _set_Satp32_Asid : (register(Satp32), bitvector(9)) -> unit

$[complete]
$[fix_location]
function _set_Satp32_Asid (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Satp32_Asid(r, v)
}

overload _mod_Asid = {_get_Satp32_Asid, _set_Satp32_Asid}

$[fix_location]
val _get_Satp32_Mode : Satp32 -> bitvector(1)

$[complete]
$[fix_location]
function _get_Satp32_Mode v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 31, 31)

$[fix_location]
val _update_Satp32_Mode : (Satp32, bitvector(1)) -> Satp32

$[complete]
$[fix_location]
function _update_Satp32_Mode (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 31, 31, x) }

$[fix_location]
overload update_Mode = {_update_Satp32_Mode}

$[fix_location]
val _set_Satp32_Mode : (register(Satp32), bitvector(1)) -> unit

$[complete]
$[fix_location]
function _set_Satp32_Mode (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Satp32_Mode(r, v)
}

overload _mod_Mode = {_get_Satp32_Mode, _set_Satp32_Mode}

$[fix_location]
val _get_Satp32_PPN : Satp32 -> bitvector(22)

$[complete]
$[fix_location]
function _get_Satp32_PPN v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 21, 0)

$[fix_location]
val _update_Satp32_PPN : (Satp32, bitvector(22)) -> Satp32

$[complete]
$[fix_location]
function _update_Satp32_PPN (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 21, 0, x) }

$[fix_location]
overload update_PPN = {_update_Satp32_PPN}

$[fix_location]
val _set_Satp32_PPN : (register(Satp32), bitvector(22)) -> unit

$[complete]
$[fix_location]
function _set_Satp32_PPN (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Satp32_PPN(r, v)
}

overload _mod_PPN = {_get_Satp32_PPN, _set_Satp32_PPN}

val legalize_satp : (Architecture, bitvector(xlen), bitvector(xlen)) -> bitvector(xlen)

$[complete]
function legalize_satp (arch : Architecture, prev_value : xlenbits, written_value : xlenbits) = {
    if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 32) then {
        let s = Mk_Satp32(written_value);
        $[complete] match satpMode_of_bits(arch, $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(0b000, _get_Satp32_Mode(s))) {
          None(()) => prev_value,
          Some(Sv_mode) => $[complete] match Sv_mode {
            Bare if currentlyEnabled(Ext_Svbare) => s.bits,
            Sv32 if currentlyEnabled(Ext_Sv32) => s.bits,
            _ => prev_value
          }
        }
    } else if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64) then {
        let s = Mk_Satp64(written_value);
        $[complete] match satpMode_of_bits(arch, _get_Satp64_Mode(s)) {
          None(()) => prev_value,
          Some(Sv_mode) => $[complete] match Sv_mode {
            Bare if currentlyEnabled(Ext_Svbare) => s.bits,
            Sv39 if currentlyEnabled(Ext_Sv39) => s.bits,
            Sv48 if currentlyEnabled(Ext_Sv48) => s.bits,
            Sv57 if currentlyEnabled(Ext_Sv57) => s.bits,
            _ => prev_value
          }
        }
    } else {
        internal_error("./core/sys_regs.sail", 925, $[overloaded { "name" = "^", "is_infix" = true }] concat_str("Unsupported xlen", dec_str(xlen)))
    }
}

register tselect : xlenbits

val get_16_random_bits = monadic {interpreter: "Platform.get_16_random_bits", c: "plat_get_16_random_bits", lem: "plat_get_16_random_bits"}: unit -> bitvector(16)

val feature_enabled_for_priv : (Privilege, bit, bit) -> bool

$[complete]
function feature_enabled_for_priv (p : Privilege, machine_enable_bit : bit, supervisor_enable_bit : bit) = $[complete] match p {
  Machine => true,
  Supervisor => $[overloaded { "name" = "==", "is_infix" = true }] eq_bit(machine_enable_bit, bitone),
  User => $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_bit(machine_enable_bit, bitone), $[overloaded { "name" = "|", "is_infix" = true }] or_bool(not(currentlyEnabled(Ext_S)), $[overloaded { "name" = "==", "is_infix" = true }] eq_bit(supervisor_enable_bit, bitone))),
  VirtualSupervisor => internal_error("./core/sys_regs.sail", 960, "Hypervisor extension not supported"),
  VirtualUser => internal_error("./core/sys_regs.sail", 961, "Hypervisor extension not supported")
}

val counter_enabled : (range(0, 31), Privilege) -> bool

$[complete]
function counter_enabled (index : range(0, 31), priv : Privilege) = feature_enabled_for_priv(priv, $[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(mcounteren.bits, index), $[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(scounteren.bits, index))

/*!
THIS(csrno, priv, isWrite) allows an extension to block access to csrno,
at Privilege level priv. It should return true if the access is allowed.
*/
val ext_check_CSR : (bitvector(12), Privilege, bool) -> bool

$[complete]
function ext_check_CSR (csrno, p, isWrite) = true

/*!
THIS is called if ext_check_CSR returns false. It should
cause an appropriate RISCV exception.
 */
val ext_check_CSR_fail : unit -> unit

$[complete]
function ext_check_CSR_fail () = ()

union Ext_DataAddr_Check ('a: Type) = {
  Ext_DataAddr_OK : virtaddr,
  Ext_DataAddr_Error : 'a
}

type ext_fetch_addr_error = unit

val ext_fetch_check_pc : (bitvector(xlen), bitvector(xlen)) -> option(unit)

$[complete]
function ext_fetch_check_pc (start_pc : xlenbits, pc : xlenbits) = None()

val ext_handle_fetch_check_error : unit -> unit

$[complete]
function ext_handle_fetch_check_error err : ext_fetch_addr_error = ()

type ext_control_addr_error = unit

val ext_control_check_pc : bitvector(xlen) -> option(unit)

$[complete]
function ext_control_check_pc pc : xlenbits = None()

val ext_handle_control_check_error : unit -> unit

$[complete]
function ext_handle_control_check_error err : ext_control_addr_error = ()

type ext_data_addr_error = unit

val ext_data_get_addr : (regidx, bitvector(xlen), AccessType(unit), range(1, 4096)) -> Ext_DataAddr_Check(unit)

$[complete]
function ext_data_get_addr (base : regidx, offset : xlenbits, acc : AccessType(ext_access_type), width : mem_access_width) = let addr =
  Virtaddr($[overloaded { "name" = "+", "is_infix" = true }] add_bits($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(base), offset))
in
  Ext_DataAddr_OK(addr)

val ext_handle_data_check_error : unit -> unit

$[complete]
function ext_handle_data_check_error err : ext_data_addr_error = ()

$[complete]
function ext_veto_disable_C () = false

type bits_rm = bits(3)

type bits_fflags = bits(5)

type bits_BF16 = bits(16)

type bits_H = bits(16)

type bits_S = bits(32)

type bits_D = bits(64)

type bits_W = bits(32)

type bits_WU = bits(32)

type bits_L = bits(64)

type bits_LU = bits(64)

register float_result : bits(64)

register float_fflags : bits(64)

val extern_f16Add = pure {c: "softfloat_f16add", lem: "softfloat_f16_add"}: (bitvector(3), bitvector(16), bitvector(16)) -> unit

val riscv_f16Add : (bitvector(3), bitvector(16), bitvector(16)) -> (bitvector(5), bitvector(16))

$[complete]
function riscv_f16Add (rm, v1, v2) = {
    extern_f16Add(rm, v1, v2);
    ($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(float_fflags, 4, 0), $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(float_result, 15, 0))
}

val extern_f16Sub = pure {c: "softfloat_f16sub", lem: "softfloat_f16_sub"}: (bitvector(3), bitvector(16), bitvector(16)) -> unit

val riscv_f16Sub : (bitvector(3), bitvector(16), bitvector(16)) -> (bitvector(5), bitvector(16))

$[complete]
function riscv_f16Sub (rm, v1, v2) = {
    extern_f16Sub(rm, v1, v2);
    ($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(float_fflags, 4, 0), $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(float_result, 15, 0))
}

val extern_f16Mul = pure {c: "softfloat_f16mul", lem: "softfloat_f16_mul"}: (bitvector(3), bitvector(16), bitvector(16)) -> unit

val riscv_f16Mul : (bitvector(3), bitvector(16), bitvector(16)) -> (bitvector(5), bitvector(16))

$[complete]
function riscv_f16Mul (rm, v1, v2) = {
    extern_f16Mul(rm, v1, v2);
    ($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(float_fflags, 4, 0), $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(float_result, 15, 0))
}

val extern_f16Div = pure {c: "softfloat_f16div", lem: "softfloat_f16_div"}: (bitvector(3), bitvector(16), bitvector(16)) -> unit

val riscv_f16Div : (bitvector(3), bitvector(16), bitvector(16)) -> (bitvector(5), bitvector(16))

$[complete]
function riscv_f16Div (rm, v1, v2) = {
    extern_f16Div(rm, v1, v2);
    ($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(float_fflags, 4, 0), $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(float_result, 15, 0))
}

val extern_f32Add = pure {c: "softfloat_f32add", lem: "softfloat_f32_add"}: (bitvector(3), bitvector(32), bitvector(32)) -> unit

val riscv_f32Add : (bitvector(3), bitvector(32), bitvector(32)) -> (bitvector(5), bitvector(32))

$[complete]
function riscv_f32Add (rm, v1, v2) = {
    extern_f32Add(rm, v1, v2);
    ($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(float_fflags, 4, 0), $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(float_result, 31, 0))
}

val extern_f32Sub = pure {c: "softfloat_f32sub", lem: "softfloat_f32_sub"}: (bitvector(3), bitvector(32), bitvector(32)) -> unit

val riscv_f32Sub : (bitvector(3), bitvector(32), bitvector(32)) -> (bitvector(5), bitvector(32))

$[complete]
function riscv_f32Sub (rm, v1, v2) = {
    extern_f32Sub(rm, v1, v2);
    ($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(float_fflags, 4, 0), $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(float_result, 31, 0))
}

val extern_f32Mul = pure {c: "softfloat_f32mul", lem: "softfloat_f32_mul"}: (bitvector(3), bitvector(32), bitvector(32)) -> unit

val riscv_f32Mul : (bitvector(3), bitvector(32), bitvector(32)) -> (bitvector(5), bitvector(32))

$[complete]
function riscv_f32Mul (rm, v1, v2) = {
    extern_f32Mul(rm, v1, v2);
    ($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(float_fflags, 4, 0), $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(float_result, 31, 0))
}

val extern_f32Div = pure {c: "softfloat_f32div", lem: "softfloat_f32_div"}: (bitvector(3), bitvector(32), bitvector(32)) -> unit

val riscv_f32Div : (bitvector(3), bitvector(32), bitvector(32)) -> (bitvector(5), bitvector(32))

$[complete]
function riscv_f32Div (rm, v1, v2) = {
    extern_f32Div(rm, v1, v2);
    ($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(float_fflags, 4, 0), $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(float_result, 31, 0))
}

val extern_f64Add = pure {c: "softfloat_f64add", lem: "softfloat_f64_add"}: (bitvector(3), bitvector(64), bitvector(64)) -> unit

val riscv_f64Add : (bitvector(3), bitvector(64), bitvector(64)) -> (bitvector(5), bitvector(64))

$[complete]
function riscv_f64Add (rm, v1, v2) = {
    extern_f64Add(rm, v1, v2);
    ($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(float_fflags, 4, 0), float_result)
}

val extern_f64Sub = pure {c: "softfloat_f64sub", lem: "softfloat_f64_sub"}: (bitvector(3), bitvector(64), bitvector(64)) -> unit

val riscv_f64Sub : (bitvector(3), bitvector(64), bitvector(64)) -> (bitvector(5), bitvector(64))

$[complete]
function riscv_f64Sub (rm, v1, v2) = {
    extern_f64Sub(rm, v1, v2);
    ($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(float_fflags, 4, 0), float_result)
}

val extern_f64Mul = pure {c: "softfloat_f64mul", lem: "softfloat_f64_mul"}: (bitvector(3), bitvector(64), bitvector(64)) -> unit

val riscv_f64Mul : (bitvector(3), bitvector(64), bitvector(64)) -> (bitvector(5), bitvector(64))

$[complete]
function riscv_f64Mul (rm, v1, v2) = {
    extern_f64Mul(rm, v1, v2);
    ($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(float_fflags, 4, 0), float_result)
}

val extern_f64Div = pure {c: "softfloat_f64div", lem: "softfloat_f64_div"}: (bitvector(3), bitvector(64), bitvector(64)) -> unit

val riscv_f64Div : (bitvector(3), bitvector(64), bitvector(64)) -> (bitvector(5), bitvector(64))

$[complete]
function riscv_f64Div (rm, v1, v2) = {
    extern_f64Div(rm, v1, v2);
    ($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(float_fflags, 4, 0), float_result)
}

val extern_f16MulAdd = pure {c: "softfloat_f16muladd", lem: "softfloat_f16_muladd"}: (bitvector(3), bitvector(16), bitvector(16), bitvector(16)) -> unit

val riscv_f16MulAdd : (bitvector(3), bitvector(16), bitvector(16), bitvector(16)) -> (bitvector(5), bitvector(16))

$[complete]
function riscv_f16MulAdd (rm, v1, v2, v3) = {
    extern_f16MulAdd(rm, v1, v2, v3);
    ($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(float_fflags, 4, 0), $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(float_result, 15, 0))
}

val extern_f32MulAdd = pure {c: "softfloat_f32muladd", lem: "softfloat_f32_muladd"}: (bitvector(3), bitvector(32), bitvector(32), bitvector(32)) -> unit

val riscv_f32MulAdd : (bitvector(3), bitvector(32), bitvector(32), bitvector(32)) -> (bitvector(5), bitvector(32))

$[complete]
function riscv_f32MulAdd (rm, v1, v2, v3) = {
    extern_f32MulAdd(rm, v1, v2, v3);
    ($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(float_fflags, 4, 0), $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(float_result, 31, 0))
}

val extern_f64MulAdd = pure {c: "softfloat_f64muladd", lem: "softfloat_f64_muladd"}: (bitvector(3), bitvector(64), bitvector(64), bitvector(64)) -> unit

val riscv_f64MulAdd : (bitvector(3), bitvector(64), bitvector(64), bitvector(64)) -> (bitvector(5), bitvector(64))

$[complete]
function riscv_f64MulAdd (rm, v1, v2, v3) = {
    extern_f64MulAdd(rm, v1, v2, v3);
    ($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(float_fflags, 4, 0), float_result)
}

val extern_f16Sqrt = pure {c: "softfloat_f16sqrt", lem: "softfloat_f16_sqrt"}: (bitvector(3), bitvector(16)) -> unit

val riscv_f16Sqrt : (bitvector(3), bitvector(16)) -> (bitvector(5), bitvector(16))

$[complete]
function riscv_f16Sqrt (rm, v) = {
    extern_f16Sqrt(rm, v);
    ($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(float_fflags, 4, 0), $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(float_result, 15, 0))
}

val extern_f32Sqrt = pure {c: "softfloat_f32sqrt", lem: "softfloat_f32_sqrt"}: (bitvector(3), bitvector(32)) -> unit

val riscv_f32Sqrt : (bitvector(3), bitvector(32)) -> (bitvector(5), bitvector(32))

$[complete]
function riscv_f32Sqrt (rm, v) = {
    extern_f32Sqrt(rm, v);
    ($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(float_fflags, 4, 0), $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(float_result, 31, 0))
}

val extern_f64Sqrt = pure {c: "softfloat_f64sqrt", lem: "softfloat_f64_sqrt"}: (bitvector(3), bitvector(64)) -> unit

val riscv_f64Sqrt : (bitvector(3), bitvector(64)) -> (bitvector(5), bitvector(64))

$[complete]
function riscv_f64Sqrt (rm, v) = {
    extern_f64Sqrt(rm, v);
    ($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(float_fflags, 4, 0), float_result)
}

val extern_f16ToI32 = pure {c: "softfloat_f16toi32", lem: "softfloat_f16_to_i32"}: (bitvector(3), bitvector(16)) -> unit

val riscv_f16ToI32 : (bitvector(3), bitvector(16)) -> (bitvector(5), bitvector(32))

$[complete]
function riscv_f16ToI32 (rm, v) = {
    extern_f16ToI32(rm, v);
    ($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(float_fflags, 4, 0), $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(float_result, 31, 0))
}

val extern_f16ToUi32 = pure {c: "softfloat_f16toui32", lem: "softfloat_f16_to_ui32"}: (bitvector(3), bitvector(16)) -> unit

val riscv_f16ToUi32 : (bitvector(3), bitvector(16)) -> (bitvector(5), bitvector(32))

$[complete]
function riscv_f16ToUi32 (rm, v) = {
    extern_f16ToUi32(rm, v);
    ($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(float_fflags, 4, 0), $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(float_result, 31, 0))
}

val extern_i32ToF16 = pure {c: "softfloat_i32tof16", lem: "softfloat_i32_to_f16"}: (bitvector(3), bitvector(32)) -> unit

val riscv_i32ToF16 : (bitvector(3), bitvector(32)) -> (bitvector(5), bitvector(16))

$[complete]
function riscv_i32ToF16 (rm, v) = {
    extern_i32ToF16(rm, v);
    ($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(float_fflags, 4, 0), $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(float_result, 15, 0))
}

val extern_ui32ToF16 = pure {c: "softfloat_ui32tof16", lem: "softfloat_ui32_to_f16"}: (bitvector(3), bitvector(32)) -> unit

val riscv_ui32ToF16 : (bitvector(3), bitvector(32)) -> (bitvector(5), bitvector(16))

$[complete]
function riscv_ui32ToF16 (rm, v) = {
    extern_ui32ToF16(rm, v);
    ($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(float_fflags, 4, 0), $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(float_result, 15, 0))
}

val extern_f16ToI64 = pure {c: "softfloat_f16toi64", lem: "softfloat_f16_to_i64"}: (bitvector(3), bitvector(16)) -> unit

val riscv_f16ToI64 : (bitvector(3), bitvector(16)) -> (bitvector(5), bitvector(64))

$[complete]
function riscv_f16ToI64 (rm, v) = {
    extern_f16ToI64(rm, v);
    ($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(float_fflags, 4, 0), float_result)
}

val extern_f16ToUi64 = pure {c: "softfloat_f16toui64", lem: "softfloat_f16_to_ui64"}: (bitvector(3), bitvector(16)) -> unit

val riscv_f16ToUi64 : (bitvector(3), bitvector(16)) -> (bitvector(5), bitvector(64))

$[complete]
function riscv_f16ToUi64 (rm, v) = {
    extern_f16ToUi64(rm, v);
    ($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(float_fflags, 4, 0), float_result)
}

val extern_i64ToF16 = pure {c: "softfloat_i64tof16", lem: "softfloat_i64_to_f16"}: (bitvector(3), bitvector(64)) -> unit

val riscv_i64ToF16 : (bitvector(3), bitvector(64)) -> (bitvector(5), bitvector(16))

$[complete]
function riscv_i64ToF16 (rm, v) = {
    extern_i64ToF16(rm, v);
    ($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(float_fflags, 4, 0), $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(float_result, 15, 0))
}

val extern_ui64ToF16 = pure {c: "softfloat_ui64tof16", lem: "softfloat_ui64_to_f16"}: (bitvector(3), bitvector(64)) -> unit

val riscv_ui64ToF16 : (bitvector(3), bitvector(64)) -> (bitvector(5), bitvector(16))

$[complete]
function riscv_ui64ToF16 (rm, v) = {
    extern_ui64ToF16(rm, v);
    ($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(float_fflags, 4, 0), $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(float_result, 15, 0))
}

val extern_f32ToI32 = pure {c: "softfloat_f32toi32", lem: "softfloat_f32_to_i32"}: (bitvector(3), bitvector(32)) -> unit

val riscv_f32ToI32 : (bitvector(3), bitvector(32)) -> (bitvector(5), bitvector(32))

$[complete]
function riscv_f32ToI32 (rm, v) = {
    extern_f32ToI32(rm, v);
    ($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(float_fflags, 4, 0), $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(float_result, 31, 0))
}

val extern_f32ToUi32 = pure {c: "softfloat_f32toui32", lem: "softfloat_f32_to_ui32"}: (bitvector(3), bitvector(32)) -> unit

val riscv_f32ToUi32 : (bitvector(3), bitvector(32)) -> (bitvector(5), bitvector(32))

$[complete]
function riscv_f32ToUi32 (rm, v) = {
    extern_f32ToUi32(rm, v);
    ($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(float_fflags, 4, 0), $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(float_result, 31, 0))
}

val extern_i32ToF32 = pure {c: "softfloat_i32tof32", lem: "softfloat_i32_to_f32"}: (bitvector(3), bitvector(32)) -> unit

val riscv_i32ToF32 : (bitvector(3), bitvector(32)) -> (bitvector(5), bitvector(32))

$[complete]
function riscv_i32ToF32 (rm, v) = {
    extern_i32ToF32(rm, v);
    ($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(float_fflags, 4, 0), $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(float_result, 31, 0))
}

val extern_ui32ToF32 = pure {c: "softfloat_ui32tof32", lem: "softfloat_ui32_to_f32"}: (bitvector(3), bitvector(32)) -> unit

val riscv_ui32ToF32 : (bitvector(3), bitvector(32)) -> (bitvector(5), bitvector(32))

$[complete]
function riscv_ui32ToF32 (rm, v) = {
    extern_ui32ToF32(rm, v);
    ($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(float_fflags, 4, 0), $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(float_result, 31, 0))
}

val extern_f32ToI64 = pure {c: "softfloat_f32toi64", lem: "softfloat_f32_to_i64"}: (bitvector(3), bitvector(32)) -> unit

val riscv_f32ToI64 : (bitvector(3), bitvector(32)) -> (bitvector(5), bitvector(64))

$[complete]
function riscv_f32ToI64 (rm, v) = {
    extern_f32ToI64(rm, v);
    ($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(float_fflags, 4, 0), float_result)
}

val extern_f32ToUi64 = pure {c: "softfloat_f32toui64", lem: "softfloat_f32_to_ui64"}: (bitvector(3), bitvector(32)) -> unit

val riscv_f32ToUi64 : (bitvector(3), bitvector(32)) -> (bitvector(5), bitvector(64))

$[complete]
function riscv_f32ToUi64 (rm, v) = {
    extern_f32ToUi64(rm, v);
    ($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(float_fflags, 4, 0), float_result)
}

val extern_i64ToF32 = pure {c: "softfloat_i64tof32", lem: "softfloat_i64_to_f32"}: (bitvector(3), bitvector(64)) -> unit

val riscv_i64ToF32 : (bitvector(3), bitvector(64)) -> (bitvector(5), bitvector(32))

$[complete]
function riscv_i64ToF32 (rm, v) = {
    extern_i64ToF32(rm, v);
    ($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(float_fflags, 4, 0), $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(float_result, 31, 0))
}

val extern_ui64ToF32 = pure {c: "softfloat_ui64tof32", lem: "softfloat_ui64_to_f32"}: (bitvector(3), bitvector(64)) -> unit

val riscv_ui64ToF32 : (bitvector(3), bitvector(64)) -> (bitvector(5), bitvector(32))

$[complete]
function riscv_ui64ToF32 (rm, v) = {
    extern_ui64ToF32(rm, v);
    ($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(float_fflags, 4, 0), $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(float_result, 31, 0))
}

val extern_f64ToI32 = pure {c: "softfloat_f64toi32", lem: "softfloat_f64_to_i32"}: (bitvector(3), bitvector(64)) -> unit

val riscv_f64ToI32 : (bitvector(3), bitvector(64)) -> (bitvector(5), bitvector(32))

$[complete]
function riscv_f64ToI32 (rm, v) = {
    extern_f64ToI32(rm, v);
    ($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(float_fflags, 4, 0), $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(float_result, 31, 0))
}

val extern_f64ToUi32 = pure {c: "softfloat_f64toui32", lem: "softfloat_f64_to_ui32"}: (bitvector(3), bitvector(64)) -> unit

val riscv_f64ToUi32 : (bitvector(3), bitvector(64)) -> (bitvector(5), bitvector(32))

$[complete]
function riscv_f64ToUi32 (rm, v) = {
    extern_f64ToUi32(rm, v);
    ($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(float_fflags, 4, 0), $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(float_result, 31, 0))
}

val extern_i32ToF64 = pure {c: "softfloat_i32tof64", lem: "softfloat_i32_to_f64"}: (bitvector(3), bitvector(32)) -> unit

val riscv_i32ToF64 : (bitvector(3), bitvector(32)) -> (bitvector(5), bitvector(64))

$[complete]
function riscv_i32ToF64 (rm, v) = {
    extern_i32ToF64(rm, v);
    ($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(float_fflags, 4, 0), float_result)
}

val extern_ui32ToF64 = pure {c: "softfloat_ui32tof64", lem: "softfloat_ui32_to_f64"}: (bitvector(3), bitvector(32)) -> unit

val riscv_ui32ToF64 : (bitvector(3), bitvector(32)) -> (bitvector(5), bitvector(64))

$[complete]
function riscv_ui32ToF64 (rm, v) = {
    extern_ui32ToF64(rm, v);
    ($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(float_fflags, 4, 0), float_result)
}

val extern_f64ToI64 = pure {c: "softfloat_f64toi64", lem: "softfloat_f64_to_i64"}: (bitvector(3), bitvector(64)) -> unit

val riscv_f64ToI64 : (bitvector(3), bitvector(64)) -> (bitvector(5), bitvector(64))

$[complete]
function riscv_f64ToI64 (rm, v) = {
    extern_f64ToI64(rm, v);
    ($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(float_fflags, 4, 0), float_result)
}

val extern_f64ToUi64 = pure {c: "softfloat_f64toui64", lem: "softfloat_f64_to_ui64"}: (bitvector(3), bitvector(64)) -> unit

val riscv_f64ToUi64 : (bitvector(3), bitvector(64)) -> (bitvector(5), bitvector(64))

$[complete]
function riscv_f64ToUi64 (rm, v) = {
    extern_f64ToUi64(rm, v);
    ($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(float_fflags, 4, 0), float_result)
}

val extern_i64ToF64 = pure {c: "softfloat_i64tof64", lem: "softfloat_i64_to_f64"}: (bitvector(3), bitvector(64)) -> unit

val riscv_i64ToF64 : (bitvector(3), bitvector(64)) -> (bitvector(5), bitvector(64))

$[complete]
function riscv_i64ToF64 (rm, v) = {
    extern_i64ToF64(rm, v);
    ($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(float_fflags, 4, 0), float_result)
}

val extern_ui64ToF64 = pure {c: "softfloat_ui64tof64", lem: "softfloat_ui64_to_f64"}: (bitvector(3), bitvector(64)) -> unit

val riscv_ui64ToF64 : (bitvector(3), bitvector(64)) -> (bitvector(5), bitvector(64))

$[complete]
function riscv_ui64ToF64 (rm, v) = {
    extern_ui64ToF64(rm, v);
    ($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(float_fflags, 4, 0), float_result)
}

val extern_f16ToF32 = pure {c: "softfloat_f16tof32", lem: "softfloat_f16_to_f32"}: (bitvector(3), bitvector(16)) -> unit

val riscv_f16ToF32 : (bitvector(3), bitvector(16)) -> (bitvector(5), bitvector(32))

$[complete]
function riscv_f16ToF32 (rm, v) = {
    extern_f16ToF32(rm, v);
    ($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(float_fflags, 4, 0), $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(float_result, 31, 0))
}

val extern_f16ToF64 = pure {c: "softfloat_f16tof64", lem: "softfloat_f16_to_f64"}: (bitvector(3), bitvector(16)) -> unit

val riscv_f16ToF64 : (bitvector(3), bitvector(16)) -> (bitvector(5), bitvector(64))

$[complete]
function riscv_f16ToF64 (rm, v) = {
    extern_f16ToF64(rm, v);
    ($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(float_fflags, 4, 0), float_result)
}

val extern_f32ToF64 = pure {c: "softfloat_f32tof64", lem: "softfloat_f32_to_f64"}: (bitvector(3), bitvector(32)) -> unit

val riscv_f32ToF64 : (bitvector(3), bitvector(32)) -> (bitvector(5), bitvector(64))

$[complete]
function riscv_f32ToF64 (rm, v) = {
    extern_f32ToF64(rm, v);
    ($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(float_fflags, 4, 0), float_result)
}

val extern_f32ToF16 = pure {c: "softfloat_f32tof16", lem: "softfloat_f32_to_f16"}: (bitvector(3), bitvector(32)) -> unit

val riscv_f32ToF16 : (bitvector(3), bitvector(32)) -> (bitvector(5), bitvector(16))

$[complete]
function riscv_f32ToF16 (rm, v) = {
    extern_f32ToF16(rm, v);
    ($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(float_fflags, 4, 0), $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(float_result, 15, 0))
}

val extern_f64ToF16 = pure {c: "softfloat_f64tof16", lem: "softfloat_f64_to_f16"}: (bitvector(3), bitvector(64)) -> unit

val riscv_f64ToF16 : (bitvector(3), bitvector(64)) -> (bitvector(5), bitvector(16))

$[complete]
function riscv_f64ToF16 (rm, v) = {
    extern_f64ToF16(rm, v);
    ($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(float_fflags, 4, 0), $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(float_result, 15, 0))
}

val extern_f64ToF32 = pure {c: "softfloat_f64tof32", lem: "softfloat_f64_to_f32"}: (bitvector(3), bitvector(64)) -> unit

val riscv_f64ToF32 : (bitvector(3), bitvector(64)) -> (bitvector(5), bitvector(32))

$[complete]
function riscv_f64ToF32 (rm, v) = {
    extern_f64ToF32(rm, v);
    ($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(float_fflags, 4, 0), $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(float_result, 31, 0))
}

val extern_f32ToBF16 = pure {c: "softfloat_f32tobf16", lem: "softfloat_f32_to_bf16"}: (bitvector(3), bitvector(32)) -> unit

val riscv_f32ToBF16 : (bitvector(3), bitvector(32)) -> (bitvector(5), bitvector(16))

$[complete]
function riscv_f32ToBF16 (rm, v) = {
    extern_f32ToBF16(rm, v);
    ($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(float_fflags, 4, 0), $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(float_result, 15, 0))
}

val extern_f16Lt = pure {c: "softfloat_f16lt", lem: "softfloat_f16_lt"}: (bitvector(16), bitvector(16)) -> unit

val riscv_f16Lt : (bitvector(16), bitvector(16)) -> (bitvector(5), bool)

$[complete]
function riscv_f16Lt (v1, v2) = {
    extern_f16Lt(v1, v2);
    ($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(float_fflags, 4, 0), bit_to_bool($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(float_result, 0)))
}

val extern_f16Lt_quiet = pure {c: "softfloat_f16lt_quiet", lem: "softfloat_f16_lt_quiet"}: (bitvector(16), bitvector(16)) -> unit

val riscv_f16Lt_quiet : (bitvector(16), bitvector(16)) -> (bitvector(5), bool)

$[complete]
function riscv_f16Lt_quiet (v1, v2) = {
    extern_f16Lt_quiet(v1, v2);
    ($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(float_fflags, 4, 0), bit_to_bool($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(float_result, 0)))
}

val extern_f16Le = pure {c: "softfloat_f16le", lem: "softfloat_f16_le"}: (bitvector(16), bitvector(16)) -> unit

val riscv_f16Le : (bitvector(16), bitvector(16)) -> (bitvector(5), bool)

$[complete]
function riscv_f16Le (v1, v2) = {
    extern_f16Le(v1, v2);
    ($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(float_fflags, 4, 0), bit_to_bool($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(float_result, 0)))
}

val extern_f16Le_quiet = pure {c: "softfloat_f16le_quiet", lem: "softfloat_f16_le_quiet"}: (bitvector(16), bitvector(16)) -> unit

val riscv_f16Le_quiet : (bitvector(16), bitvector(16)) -> (bitvector(5), bool)

$[complete]
function riscv_f16Le_quiet (v1, v2) = {
    extern_f16Le_quiet(v1, v2);
    ($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(float_fflags, 4, 0), bit_to_bool($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(float_result, 0)))
}

val extern_f16Eq = pure {c: "softfloat_f16eq", lem: "softfloat_f16_eq"}: (bitvector(16), bitvector(16)) -> unit

val riscv_f16Eq : (bitvector(16), bitvector(16)) -> (bitvector(5), bool)

$[complete]
function riscv_f16Eq (v1, v2) = {
    extern_f16Eq(v1, v2);
    ($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(float_fflags, 4, 0), bit_to_bool($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(float_result, 0)))
}

val extern_f32Lt = pure {c: "softfloat_f32lt", lem: "softfloat_f32_lt"}: (bitvector(32), bitvector(32)) -> unit

val riscv_f32Lt : (bitvector(32), bitvector(32)) -> (bitvector(5), bool)

$[complete]
function riscv_f32Lt (v1, v2) = {
    extern_f32Lt(v1, v2);
    ($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(float_fflags, 4, 0), bit_to_bool($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(float_result, 0)))
}

val extern_f32Lt_quiet = pure {c: "softfloat_f32lt_quiet", lem: "softfloat_f32_lt_quiet"}: (bitvector(32), bitvector(32)) -> unit

val riscv_f32Lt_quiet : (bitvector(32), bitvector(32)) -> (bitvector(5), bool)

$[complete]
function riscv_f32Lt_quiet (v1, v2) = {
    extern_f32Lt_quiet(v1, v2);
    ($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(float_fflags, 4, 0), bit_to_bool($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(float_result, 0)))
}

val extern_f32Le = pure {c: "softfloat_f32le", lem: "softfloat_f32_le"}: (bitvector(32), bitvector(32)) -> unit

val riscv_f32Le : (bitvector(32), bitvector(32)) -> (bitvector(5), bool)

$[complete]
function riscv_f32Le (v1, v2) = {
    extern_f32Le(v1, v2);
    ($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(float_fflags, 4, 0), bit_to_bool($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(float_result, 0)))
}

val extern_f32Le_quiet = pure {c: "softfloat_f32le_quiet", lem: "softfloat_f32_le_quiet"}: (bitvector(32), bitvector(32)) -> unit

val riscv_f32Le_quiet : (bitvector(32), bitvector(32)) -> (bitvector(5), bool)

$[complete]
function riscv_f32Le_quiet (v1, v2) = {
    extern_f32Le_quiet(v1, v2);
    ($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(float_fflags, 4, 0), bit_to_bool($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(float_result, 0)))
}

val extern_f32Eq = pure {c: "softfloat_f32eq", lem: "softfloat_f32_eq"}: (bitvector(32), bitvector(32)) -> unit

val riscv_f32Eq : (bitvector(32), bitvector(32)) -> (bitvector(5), bool)

$[complete]
function riscv_f32Eq (v1, v2) = {
    extern_f32Eq(v1, v2);
    ($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(float_fflags, 4, 0), bit_to_bool($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(float_result, 0)))
}

val extern_f64Lt = pure {c: "softfloat_f64lt", lem: "softfloat_f64_lt"}: (bitvector(64), bitvector(64)) -> unit

val riscv_f64Lt : (bitvector(64), bitvector(64)) -> (bitvector(5), bool)

$[complete]
function riscv_f64Lt (v1, v2) = {
    extern_f64Lt(v1, v2);
    ($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(float_fflags, 4, 0), bit_to_bool($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(float_result, 0)))
}

val extern_f64Lt_quiet = pure {c: "softfloat_f64lt_quiet", lem: "softfloat_f64_lt_quiet"}: (bitvector(64), bitvector(64)) -> unit

val riscv_f64Lt_quiet : (bitvector(64), bitvector(64)) -> (bitvector(5), bool)

$[complete]
function riscv_f64Lt_quiet (v1, v2) = {
    extern_f64Lt_quiet(v1, v2);
    ($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(float_fflags, 4, 0), bit_to_bool($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(float_result, 0)))
}

val extern_f64Le = pure {c: "softfloat_f64le", lem: "softfloat_f64_le"}: (bitvector(64), bitvector(64)) -> unit

val riscv_f64Le : (bitvector(64), bitvector(64)) -> (bitvector(5), bool)

$[complete]
function riscv_f64Le (v1, v2) = {
    extern_f64Le(v1, v2);
    ($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(float_fflags, 4, 0), bit_to_bool($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(float_result, 0)))
}

val extern_f64Le_quiet = pure {c: "softfloat_f64le_quiet", lem: "softfloat_f64_le_quiet"}: (bitvector(64), bitvector(64)) -> unit

val riscv_f64Le_quiet : (bitvector(64), bitvector(64)) -> (bitvector(5), bool)

$[complete]
function riscv_f64Le_quiet (v1, v2) = {
    extern_f64Le_quiet(v1, v2);
    ($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(float_fflags, 4, 0), bit_to_bool($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(float_result, 0)))
}

val extern_f64Eq = pure {c: "softfloat_f64eq", lem: "softfloat_f64_eq"}: (bitvector(64), bitvector(64)) -> unit

val riscv_f64Eq : (bitvector(64), bitvector(64)) -> (bitvector(5), bool)

$[complete]
function riscv_f64Eq (v1, v2) = {
    extern_f64Eq(v1, v2);
    ($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(float_fflags, 4, 0), bit_to_bool($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(float_result, 0)))
}

val extern_f16roundToInt = pure {c: "softfloat_f16roundToInt", lem: "softfloat_f16_round_to_int"}: (bitvector(3), bitvector(16), bool) -> unit

val riscv_f16roundToInt : (bitvector(3), bitvector(16), bool) -> (bitvector(5), bitvector(16))

$[complete]
function riscv_f16roundToInt (rm, v, exact) = {
    extern_f16roundToInt(rm, v, exact);
    ($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(float_fflags, 4, 0), $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(float_result, 15, 0))
}

val extern_f32roundToInt = pure {c: "softfloat_f32roundToInt", lem: "softfloat_f32_round_to_int"}: (bitvector(3), bitvector(32), bool) -> unit

val riscv_f32roundToInt : (bitvector(3), bitvector(32), bool) -> (bitvector(5), bitvector(32))

$[complete]
function riscv_f32roundToInt (rm, v, exact) = {
    extern_f32roundToInt(rm, v, exact);
    ($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(float_fflags, 4, 0), $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(float_result, 31, 0))
}

val extern_f64roundToInt = pure {c: "softfloat_f64roundToInt", lem: "softfloat_f64_round_to_int"}: (bitvector(3), bitvector(64), bool) -> unit

val riscv_f64roundToInt : (bitvector(3), bitvector(64), bool) -> (bitvector(5), bitvector(64))

$[complete]
function riscv_f64roundToInt (rm, v, exact) = {
    extern_f64roundToInt(rm, v, exact);
    ($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(float_fflags, 4, 0), float_result)
}

type ext_exception = unit

val ext_check_xret_priv : Privilege -> bool

$[complete]
function ext_check_xret_priv p : Privilege : Privilege = true

val ext_fail_xret_priv : unit -> unit

$[complete]
function ext_fail_xret_priv () : unit = ()

val handle_trap_extension : (Privilege, bitvector(xlen), option(unit)) -> unit

$[complete]
function handle_trap_extension (p : Privilege, pc : xlenbits, u : option(unit)) = ()

val prepare_trap_vector : (Privilege, Mcause) -> bitvector(xlen)

$[complete]
function prepare_trap_vector (p : Privilege, cause : Mcause) = {
    let tvec : Mtvec = $[complete] match p {
      Machine => mtvec,
      Supervisor => stvec,
      User => internal_error("./exceptions/sys_exceptions.sail", 25, "Invalid privilege level"),
      VirtualUser => internal_error("./exceptions/sys_exceptions.sail", 26, "Hypervisor extension not supported"),
      VirtualSupervisor => internal_error("./exceptions/sys_exceptions.sail", 27, "Hypervisor extension not supported")
    };
    $[complete] match tvec_addr(tvec, cause) {
      Some(epc) => epc,
      None(()) => internal_error("./exceptions/sys_exceptions.sail", 31, "Invalid tvec mode")
    }
}

val get_xepc : Privilege -> bitvector(xlen)

$[complete]
function get_xepc p = $[complete] match p {
  Machine => align_pc(mepc),
  Supervisor => align_pc(sepc),
  User => internal_error("./exceptions/sys_exceptions.sail", 46, "Invalid privilege level"),
  VirtualUser => internal_error("./exceptions/sys_exceptions.sail", 47, "Hypervisor extension not supported"),
  VirtualSupervisor => internal_error("./exceptions/sys_exceptions.sail", 48, "Hypervisor extension not supported")
}

val set_xepc : (Privilege, bitvector(xlen)) -> bitvector(xlen)

$[complete]
function set_xepc (p, value) = {
    let target = legalize_xepc(value);
    $[complete] match p {
      Machine => mepc = target,
      Supervisor => sepc = target,
      User => internal_error("./exceptions/sys_exceptions.sail", 57, "Invalid privilege level"),
      VirtualUser => internal_error("./exceptions/sys_exceptions.sail", 58, "Hypervisor extension not supported"),
      VirtualSupervisor => internal_error("./exceptions/sys_exceptions.sail", 59, "Hypervisor extension not supported")
    };
    target
}

val prepare_xret_target : Privilege -> bitvector(xlen)

$[complete]
function prepare_xret_target p = get_xepc(p)

val get_mtvec : unit -> bitvector(xlen)

$[complete]
function get_mtvec () = mtvec.bits

val get_stvec : unit -> bitvector(xlen)

$[complete]
function get_stvec () = stvec.bits

val set_mtvec : bitvector(xlen) -> bitvector(xlen)

$[complete]
function set_mtvec value : xlenbits = {
    mtvec = legalize_tvec(mtvec, value);
    mtvec.bits
}

val set_stvec : bitvector(xlen) -> bitvector(xlen)

$[complete]
function set_stvec value : xlenbits = {
    stvec = legalize_tvec(stvec, value);
    stvec.bits
}

$[undefined_gen "forbid"]
struct sync_exception = {
  trap : ExceptionType,
  excinfo : option(xlenbits),
  ext : option(ext_exception)
}

let sys_pmp_count : {0, 16, 64} = config memory.pmp.count

let sys_pmp_grain : range(0, 63) = config memory.pmp.grain

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum PmpAddrMatchType = {OFF, TOR, NA4, NAPOT}

val undefined_PmpAddrMatchType : unit -> PmpAddrMatchType

$[complete]
function undefined_PmpAddrMatchType () = internal_pick([|OFF, TOR, NA4, NAPOT|])

val PmpAddrMatchType_of_num : forall ('e : Int), (0 <= 'e & 'e <= 3).
  int('e) -> PmpAddrMatchType

$[complete]
function PmpAddrMatchType_of_num arg# = $[complete] match arg# {
  0 => OFF,
  1 => TOR,
  2 => NA4,
  _ => NAPOT
}

val num_of_PmpAddrMatchType : PmpAddrMatchType -> {('e : Int), (0 <= 'e & 'e <= 3). int('e)}

$[complete]
function num_of_PmpAddrMatchType arg# = $[complete] match arg# {
  OFF => 0,
  TOR => 1,
  NA4 => 2,
  NAPOT => 3
}

val pmpAddrMatchType_encdec : PmpAddrMatchType <-> bitvector(2)

mapping pmpAddrMatchType_encdec = {
  OFF <-> 0b00,
  TOR <-> 0b01,
  NA4 <-> 0b10,
  NAPOT <-> 0b11
}

$[undefined_gen "skip"]
$[bitfield]
struct Pmpcfg_ent = {bits : bitvector(8)}

val undefined_Pmpcfg_ent : unit -> Pmpcfg_ent

$[complete]
function undefined_Pmpcfg_ent () = struct Pmpcfg_ent { bits = undefined }

val Mk_Pmpcfg_ent : bitvector(8) -> Pmpcfg_ent

$[complete]
function Mk_Pmpcfg_ent v = struct Pmpcfg_ent { bits = v }

$[fix_location]
val _get_Pmpcfg_ent_bits : Pmpcfg_ent -> bitvector(8)

$[complete]
$[fix_location]
function _get_Pmpcfg_ent_bits v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, sub_atom(8, 1), 0)

$[fix_location]
val _update_Pmpcfg_ent_bits : (Pmpcfg_ent, bitvector(8)) -> Pmpcfg_ent

$[complete]
$[fix_location]
function _update_Pmpcfg_ent_bits (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, sub_atom(8, 1), 0, x) }

$[fix_location]
overload update_bits = {_update_Pmpcfg_ent_bits}

$[fix_location]
val _set_Pmpcfg_ent_bits : (register(Pmpcfg_ent), bitvector(8)) -> unit

$[complete]
$[fix_location]
function _set_Pmpcfg_ent_bits (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Pmpcfg_ent_bits(r, v)
}

overload _mod_bits = {_get_Pmpcfg_ent_bits, _set_Pmpcfg_ent_bits}

$[fix_location]
val _get_Pmpcfg_ent_A : Pmpcfg_ent -> bitvector(2)

$[complete]
$[fix_location]
function _get_Pmpcfg_ent_A v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 4, 3)

$[fix_location]
val _update_Pmpcfg_ent_A : (Pmpcfg_ent, bitvector(2)) -> Pmpcfg_ent

$[complete]
$[fix_location]
function _update_Pmpcfg_ent_A (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 4, 3, x) }

$[fix_location]
overload update_A = {_update_Pmpcfg_ent_A}

$[fix_location]
val _set_Pmpcfg_ent_A : (register(Pmpcfg_ent), bitvector(2)) -> unit

$[complete]
$[fix_location]
function _set_Pmpcfg_ent_A (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Pmpcfg_ent_A(r, v)
}

overload _mod_A = {_get_Pmpcfg_ent_A, _set_Pmpcfg_ent_A}

$[fix_location]
val _get_Pmpcfg_ent_L : Pmpcfg_ent -> bitvector(1)

$[complete]
$[fix_location]
function _get_Pmpcfg_ent_L v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 7, 7)

$[fix_location]
val _update_Pmpcfg_ent_L : (Pmpcfg_ent, bitvector(1)) -> Pmpcfg_ent

$[complete]
$[fix_location]
function _update_Pmpcfg_ent_L (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 7, 7, x) }

$[fix_location]
overload update_L = {_update_Pmpcfg_ent_L}

$[fix_location]
val _set_Pmpcfg_ent_L : (register(Pmpcfg_ent), bitvector(1)) -> unit

$[complete]
$[fix_location]
function _set_Pmpcfg_ent_L (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Pmpcfg_ent_L(r, v)
}

overload _mod_L = {_get_Pmpcfg_ent_L, _set_Pmpcfg_ent_L}

$[fix_location]
val _get_Pmpcfg_ent_R : Pmpcfg_ent -> bitvector(1)

$[complete]
$[fix_location]
function _get_Pmpcfg_ent_R v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 0, 0)

$[fix_location]
val _update_Pmpcfg_ent_R : (Pmpcfg_ent, bitvector(1)) -> Pmpcfg_ent

$[complete]
$[fix_location]
function _update_Pmpcfg_ent_R (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 0, 0, x) }

$[fix_location]
overload update_R = {_update_Pmpcfg_ent_R}

$[fix_location]
val _set_Pmpcfg_ent_R : (register(Pmpcfg_ent), bitvector(1)) -> unit

$[complete]
$[fix_location]
function _set_Pmpcfg_ent_R (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Pmpcfg_ent_R(r, v)
}

overload _mod_R = {_get_Pmpcfg_ent_R, _set_Pmpcfg_ent_R}

$[fix_location]
val _get_Pmpcfg_ent_W : Pmpcfg_ent -> bitvector(1)

$[complete]
$[fix_location]
function _get_Pmpcfg_ent_W v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 1, 1)

$[fix_location]
val _update_Pmpcfg_ent_W : (Pmpcfg_ent, bitvector(1)) -> Pmpcfg_ent

$[complete]
$[fix_location]
function _update_Pmpcfg_ent_W (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 1, 1, x) }

$[fix_location]
overload update_W = {_update_Pmpcfg_ent_W}

$[fix_location]
val _set_Pmpcfg_ent_W : (register(Pmpcfg_ent), bitvector(1)) -> unit

$[complete]
$[fix_location]
function _set_Pmpcfg_ent_W (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Pmpcfg_ent_W(r, v)
}

overload _mod_W = {_get_Pmpcfg_ent_W, _set_Pmpcfg_ent_W}

$[fix_location]
val _get_Pmpcfg_ent_X : Pmpcfg_ent -> bitvector(1)

$[complete]
$[fix_location]
function _get_Pmpcfg_ent_X v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 2, 2)

$[fix_location]
val _update_Pmpcfg_ent_X : (Pmpcfg_ent, bitvector(1)) -> Pmpcfg_ent

$[complete]
$[fix_location]
function _update_Pmpcfg_ent_X (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 2, 2, x) }

$[fix_location]
overload update_X = {_update_Pmpcfg_ent_X}

$[fix_location]
val _set_Pmpcfg_ent_X : (register(Pmpcfg_ent), bitvector(1)) -> unit

$[complete]
$[fix_location]
function _set_Pmpcfg_ent_X (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Pmpcfg_ent_X(r, v)
}

overload _mod_X = {_get_Pmpcfg_ent_X, _set_Pmpcfg_ent_X}

register pmpcfg_n : vector(64, Pmpcfg_ent)

register pmpaddr_n : vector(64, xlenbits)

val pmpReadCfgReg : range(0, 15) -> bitvector(xlen)

$[complete]
function pmpReadCfgReg n : range(0, 15) = {
    if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 32) then {
        $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(plain_vector_access(pmpcfg_n, $[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(n, 4), 3)).bits, $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(plain_vector_access(pmpcfg_n, $[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(n, 4), 2)).bits, $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(plain_vector_access(pmpcfg_n, $[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(n, 4), 1)).bits, plain_vector_access(pmpcfg_n, $[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(n, 4), 0)).bits)))
    } else {
        assert($[overloaded { "name" = "==", "is_infix" = true }] eq_int($[overloaded { "name" = "%", "is_infix" = true }] rem_positive_round_zero(n, 2), 0), "Unexpected pmp config reg read");
        $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(plain_vector_access(pmpcfg_n, $[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(n, 4), 7)).bits, $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(plain_vector_access(pmpcfg_n, $[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(n, 4), 6)).bits, $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(plain_vector_access(pmpcfg_n, $[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(n, 4), 5)).bits, $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(plain_vector_access(pmpcfg_n, $[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(n, 4), 4)).bits, $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(plain_vector_access(pmpcfg_n, $[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(n, 4), 3)).bits, $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(plain_vector_access(pmpcfg_n, $[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(n, 4), 2)).bits, $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(plain_vector_access(pmpcfg_n, $[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(n, 4), 1)).bits, plain_vector_access(pmpcfg_n, $[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(n, 4), 0)).bits)))))))
    }
}

val pmpReadAddrReg : range(0, 63) -> bitvector(xlen)

$[complete]
function pmpReadAddrReg n : range(0, 63) = {
    let G = sys_pmp_grain;
    let match_type = _get_Pmpcfg_ent_A($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(pmpcfg_n, n));
    let addr = $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(pmpaddr_n, n);
    $[complete] match $[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(match_type, 1) {
      bitone if $[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(G, 2) => {
          let mask : xlenbits = zero_extend(sizeof(xlen), ones($[overloaded { "name" = "min", "is_infix" = false }] min_int($[overloaded { "name" = "-", "is_infix" = true }] sub_atom(G, 1), xlen)));
          $[overloaded { "name" = "|", "is_infix" = true }] or_vec(addr, mask)
      },
      bitzero if $[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(G, 1) => {
          let mask : xlenbits = zero_extend(sizeof(xlen), ones($[overloaded { "name" = "min", "is_infix" = false }] min_int(G, xlen)));
          $[overloaded { "name" = "&", "is_infix" = true }] and_vec(addr, $[overloaded { "name" = "~", "is_infix" = false }] not_vec(mask))
      },
      _ => addr
    }
}

val pmpLocked : Pmpcfg_ent -> bool

$[complete]
function pmpLocked cfg : Pmpcfg_ent = $[overloaded { "name" = "==", "is_infix" = true }] eq_bits(_get_Pmpcfg_ent_L(cfg), 0b1)

val pmpTORLocked : Pmpcfg_ent -> bool

$[complete]
function pmpTORLocked cfg : Pmpcfg_ent = $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_bits(_get_Pmpcfg_ent_L(cfg), 0b1), $[overloaded { "name" = "==", "is_infix" = true }] eq_anything(pmpAddrMatchType_encdec_backwards(_get_Pmpcfg_ent_A(cfg)), TOR))

val pmpWriteCfg : (range(0, 63), Pmpcfg_ent, bitvector(8)) -> Pmpcfg_ent

$[complete]
function pmpWriteCfg (n : range(0, 63), cfg : Pmpcfg_ent, v : bits(8)) = if pmpLocked(cfg) then
  cfg
else {
    let cfg = Mk_Pmpcfg_ent($[overloaded { "name" = "&", "is_infix" = true }] and_vec(v, 0x9f));
    let cfg = if $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_bits(_get_Pmpcfg_ent_W(cfg), 0b1), $[overloaded { "name" = "==", "is_infix" = true }] eq_bits(_get_Pmpcfg_ent_R(cfg), 0b0)) then
      _update_Pmpcfg_ent_R(_update_Pmpcfg_ent_W(_update_Pmpcfg_ent_X(cfg, 0b0), 0b0), 0b0)
    else
      cfg;
    let mode_supported : bool = $[complete] match pmpAddrMatchType_encdec_backwards(_get_Pmpcfg_ent_A(cfg)) {
      OFF => true,
      TOR => config memory.pmp.tor_supported,
      NA4 => $[overloaded { "name" = "&", "is_infix" = true }] and_bool(config memory.pmp.na4_supported : bool, $[overloaded { "name" = "==", "is_infix" = true }] eq_int(sys_pmp_grain, 0)),
      NAPOT => config memory.pmp.napot_supported
    };
    let cfg = if mode_supported then cfg else
      _update_Pmpcfg_ent_A(cfg, pmpAddrMatchType_encdec_forwards(OFF));
    cfg
}

val pmpWriteCfgReg : (range(0, 15), bitvector(xlen)) -> unit

$[complete]
function pmpWriteCfgReg (n : range(0, 15), v : xlenbits) = {
    if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 32) then {
        foreach (i from 0 to 3 by 1 in inc) {
            let idx = $[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(n, 4), i);
            pmpcfg_n[idx] = pmpWriteCfg(idx, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(pmpcfg_n, idx), $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v, $[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(8, i), 7), $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(8, i)))
        }
    } else {
        assert($[overloaded { "name" = "==", "is_infix" = true }] eq_int($[overloaded { "name" = "%", "is_infix" = true }] rem_positive_round_zero(n, 2), 0), "Unexpected pmp config reg write");
        foreach (i from 0 to 7 by 1 in inc) {
            let idx = $[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(n, 4), i);
            pmpcfg_n[idx] = pmpWriteCfg(idx, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(pmpcfg_n, idx), $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v, $[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(8, i), 7), $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(8, i)))
        }
    }
}

val pmpWriteAddr : (bool, bool, bitvector(xlen), bitvector(xlen)) -> bitvector(xlen)

$[complete]
function pmpWriteAddr (locked : bool, tor_locked : bool, reg : xlenbits, v : xlenbits) = if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 32) then {
    if $[overloaded { "name" = "|", "is_infix" = true }] or_bool(locked, tor_locked) then
      reg
    else
      v
} else {
    if $[overloaded { "name" = "|", "is_infix" = true }] or_bool(locked, tor_locked) then
      reg
    else
      zero_extend(sizeof(xlen), $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v, 53, 0))
}

val pmpWriteAddrReg : (range(0, 63), bitvector(xlen)) -> unit

$[complete]
function pmpWriteAddrReg (n : range(0, 63), v : xlenbits) = {
    pmpaddr_n[n] = pmpWriteAddr(pmpLocked($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(pmpcfg_n, n)), if $[overloaded { "name" = "<", "is_infix" = true }] lt_int($[overloaded { "name" = "+", "is_infix" = true }] add_atom(n, 1), 64) then
      pmpTORLocked($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(pmpcfg_n, $[overloaded { "name" = "+", "is_infix" = true }] add_atom(n, 1)))
    else
      false, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(pmpaddr_n, n), v)
}

val pmpCheckRWX : (Pmpcfg_ent, AccessType(unit)) -> bool

$[complete]
function pmpCheckRWX (ent, acc) = $[complete] match acc {
  Read(_) => $[overloaded { "name" = "==", "is_infix" = true }] eq_bits(_get_Pmpcfg_ent_R(ent), 0b1),
  Write(_) => $[overloaded { "name" = "==", "is_infix" = true }] eq_bits(_get_Pmpcfg_ent_W(ent), 0b1),
  ReadWrite(_) => $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_bits(_get_Pmpcfg_ent_R(ent), 0b1), $[overloaded { "name" = "==", "is_infix" = true }] eq_bits(_get_Pmpcfg_ent_W(ent), 0b1)),
  InstructionFetch(()) => $[overloaded { "name" = "==", "is_infix" = true }] eq_bits(_get_Pmpcfg_ent_X(ent), 0b1)
}

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum pmpAddrMatch = {PMP_NoMatch, PMP_PartialMatch, PMP_Match}

val undefined_pmpAddrMatch : unit -> pmpAddrMatch

$[complete]
function undefined_pmpAddrMatch () = internal_pick([|PMP_NoMatch, PMP_PartialMatch, PMP_Match|])

val pmpAddrMatch_of_num : forall ('e : Int), (0 <= 'e & 'e <= 2).
  int('e) -> pmpAddrMatch

$[complete]
function pmpAddrMatch_of_num arg# = $[complete] match arg# {
  0 => PMP_NoMatch,
  1 => PMP_PartialMatch,
  _ => PMP_Match
}

val num_of_pmpAddrMatch : pmpAddrMatch -> {('e : Int), (0 <= 'e & 'e <= 2). int('e)}

$[complete]
function num_of_pmpAddrMatch arg# = $[complete] match arg# {
  PMP_NoMatch => 0,
  PMP_PartialMatch => 1,
  PMP_Match => 2
}

val pmpRangeMatch : (nat, nat, nat, nat) -> pmpAddrMatch

$[complete]
function pmpRangeMatch (begin : nat, end_ : nat, addr : nat, width : nat) = if $[overloaded { "name" = "|", "is_infix" = true }] or_bool($[overloaded { "name" = "<=", "is_infix" = true }] lteq_int($[overloaded { "name" = "+", "is_infix" = true }] add_atom(addr, width), begin), $[overloaded { "name" = "<=", "is_infix" = true }] lteq_int(end_, addr)) then
  PMP_NoMatch
else
  if $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "<=", "is_infix" = true }] lteq_int(begin, addr), $[overloaded { "name" = "<=", "is_infix" = true }] lteq_int($[overloaded { "name" = "+", "is_infix" = true }] add_atom(addr, width), end_)) then
    PMP_Match
  else
    PMP_PartialMatch

val pmpMatchAddr : (physaddr, bitvector(xlen), Pmpcfg_ent, bitvector(xlen), bitvector(xlen)) -> pmpAddrMatch

$[complete]
function pmpMatchAddr (Physaddr(addr) : physaddr, width : xlenbits, ent : Pmpcfg_ent, pmpaddr : xlenbits, prev_pmpaddr : xlenbits) = {
    let addr = unsigned(addr);
    let width = unsigned(width);
    $[complete] match pmpAddrMatchType_encdec_backwards(_get_Pmpcfg_ent_A(ent)) {
      OFF => PMP_NoMatch,
      TOR => {
          if operator >=_u(prev_pmpaddr, pmpaddr) then PMP_NoMatch else
            pmpRangeMatch($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(unsigned(prev_pmpaddr), 4), $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(unsigned(pmpaddr), 4), addr, width)
      },
      NA4 => {
          assert($[overloaded { "name" = "<", "is_infix" = true }] lt_int(sys_pmp_grain, 1), "NA4 cannot be selected when PMP grain G >= 1.");
          let begin = $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(unsigned(pmpaddr), 4);
          pmpRangeMatch(begin, $[overloaded { "name" = "+", "is_infix" = true }] add_atom(begin, 4), addr, width)
      },
      NAPOT => {
          let mask = $[overloaded { "name" = "^", "is_infix" = true }] xor_vec(pmpaddr, $[overloaded { "name" = "+", "is_infix" = true }] add_bits_int(pmpaddr, 1));
          let begin_words = unsigned($[overloaded { "name" = "&", "is_infix" = true }] and_vec(pmpaddr, $[overloaded { "name" = "~", "is_infix" = false }] not_vec(mask)));
          let end_words = $[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "+", "is_infix" = true }] add_atom(begin_words, unsigned(mask)), 1);
          pmpRangeMatch($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(begin_words, 4), $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(end_words, 4), addr, width)
      }
    }
}

val accessToFault : AccessType(unit) -> ExceptionType

$[complete]
function accessToFault acc : AccessType(ext_access_type) = $[complete] match acc {
  Read(_) => E_Load_Access_Fault(),
  Write(_) => E_SAMO_Access_Fault(),
  ReadWrite(_) => E_SAMO_Access_Fault(),
  InstructionFetch(()) => E_Fetch_Access_Fault()
}

val pmpCheck : forall ('n : Int), (0 < 'n & 'n <= max_mem_access).
  (physaddr, int('n), AccessType(unit), Privilege) -> option(ExceptionType)

$[complete]
function pmpCheck (addr : physaddr, width : int('n), acc : AccessType(ext_access_type), priv : Privilege) = {
    let width : xlenbits = to_bits(sizeof(xlen), width);
    foreach (i from 0 to 63 by 1 in inc) {
        let prev_pmpaddr = if $[overloaded { "name" = ">", "is_infix" = true }] gt_int(i, 0) then
          pmpReadAddrReg($[overloaded { "name" = "-", "is_infix" = true }] sub_atom(i, 1))
        else
          zeros(sizeof(xlen));
        let cfg = $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(pmpcfg_n, i);
        $[complete] match pmpMatchAddr(addr, width, cfg, pmpReadAddrReg(i), prev_pmpaddr) {
          PMP_NoMatch => (),
          PMP_PartialMatch => return(Some(accessToFault(acc))),
          PMP_Match => return(if $[overloaded { "name" = "|", "is_infix" = true }] or_bool(pmpCheckRWX(cfg, acc), $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_anything(priv, Machine), not(pmpLocked(cfg)))) then
            None()
          else
            Some(accessToFault(acc)))
        }
    };
    if $[overloaded { "name" = "==", "is_infix" = true }] eq_anything(priv, Machine) then
      None()
    else
      Some(accessToFault(acc))
}

val reset_pmp : unit -> unit

$[complete]
function reset_pmp () = {
    foreach (i from 0 to 63 by 1 in inc) {
        pmpcfg_n[i] = _update_Pmpcfg_ent_L(_update_Pmpcfg_ent_A($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(pmpcfg_n, i), pmpAddrMatchType_encdec_forwards(OFF)), 0b0)
    }
}

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum uop = {LUI, AUIPC}

val undefined_uop : unit -> uop

$[complete]
function undefined_uop () = internal_pick([|LUI, AUIPC|])

val uop_of_num : forall ('e : Int), (0 <= 'e & 'e <= 1). int('e) -> uop

$[complete]
function uop_of_num arg# = $[complete] match arg# {
  0 => LUI,
  _ => AUIPC
}

val num_of_uop : uop -> {('e : Int), (0 <= 'e & 'e <= 1). int('e)}

$[complete]
function num_of_uop arg# = $[complete] match arg# {
  LUI => 0,
  AUIPC => 1
}

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum bop = {BEQ, BNE, BLT, BGE, BLTU, BGEU}

val undefined_bop : unit -> bop

$[complete]
function undefined_bop () = internal_pick([|BEQ, BNE, BLT, BGE, BLTU, BGEU|])

val bop_of_num : forall ('e : Int), (0 <= 'e & 'e <= 5). int('e) -> bop

$[complete]
function bop_of_num arg# = $[complete] match arg# {
  0 => BEQ,
  1 => BNE,
  2 => BLT,
  3 => BGE,
  4 => BLTU,
  _ => BGEU
}

val num_of_bop : bop -> {('e : Int), (0 <= 'e & 'e <= 5). int('e)}

$[complete]
function num_of_bop arg# = $[complete] match arg# {
  BEQ => 0,
  BNE => 1,
  BLT => 2,
  BGE => 3,
  BLTU => 4,
  BGEU => 5
}

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum iop = {ADDI, SLTI, SLTIU, XORI, ORI, ANDI}

val undefined_iop : unit -> iop

$[complete]
function undefined_iop () = internal_pick([|ADDI, SLTI, SLTIU, XORI, ORI, ANDI|])

val iop_of_num : forall ('e : Int), (0 <= 'e & 'e <= 5). int('e) -> iop

$[complete]
function iop_of_num arg# = $[complete] match arg# {
  0 => ADDI,
  1 => SLTI,
  2 => SLTIU,
  3 => XORI,
  4 => ORI,
  _ => ANDI
}

val num_of_iop : iop -> {('e : Int), (0 <= 'e & 'e <= 5). int('e)}

$[complete]
function num_of_iop arg# = $[complete] match arg# {
  ADDI => 0,
  SLTI => 1,
  SLTIU => 2,
  XORI => 3,
  ORI => 4,
  ANDI => 5
}

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum sop = {SLLI, SRLI, SRAI}

val undefined_sop : unit -> sop

$[complete]
function undefined_sop () = internal_pick([|SLLI, SRLI, SRAI|])

val sop_of_num : forall ('e : Int), (0 <= 'e & 'e <= 2). int('e) -> sop

$[complete]
function sop_of_num arg# = $[complete] match arg# {
  0 => SLLI,
  1 => SRLI,
  _ => SRAI
}

val num_of_sop : sop -> {('e : Int), (0 <= 'e & 'e <= 2). int('e)}

$[complete]
function num_of_sop arg# = $[complete] match arg# {
  SLLI => 0,
  SRLI => 1,
  SRAI => 2
}

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum rop = {ADD, SUB, SLL, SLT, SLTU, XOR, SRL, SRA, OR, AND}

val undefined_rop : unit -> rop

$[complete]
function undefined_rop () = internal_pick([|ADD, SUB, SLL, SLT, SLTU, XOR, SRL, SRA, OR, AND|])

val rop_of_num : forall ('e : Int), (0 <= 'e & 'e <= 9). int('e) -> rop

$[complete]
function rop_of_num arg# = $[complete] match arg# {
  0 => ADD,
  1 => SUB,
  2 => SLL,
  3 => SLT,
  4 => SLTU,
  5 => XOR,
  6 => SRL,
  7 => SRA,
  8 => OR,
  _ => AND
}

val num_of_rop : rop -> {('e : Int), (0 <= 'e & 'e <= 9). int('e)}

$[complete]
function num_of_rop arg# = $[complete] match arg# {
  ADD => 0,
  SUB => 1,
  SLL => 2,
  SLT => 3,
  SLTU => 4,
  XOR => 5,
  SRL => 6,
  SRA => 7,
  OR => 8,
  AND => 9
}

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum ropw = {ADDW, SUBW, SLLW, SRLW, SRAW}

val undefined_ropw : unit -> ropw

$[complete]
function undefined_ropw () = internal_pick([|ADDW, SUBW, SLLW, SRLW, SRAW|])

val ropw_of_num : forall ('e : Int), (0 <= 'e & 'e <= 4). int('e) -> ropw

$[complete]
function ropw_of_num arg# = $[complete] match arg# {
  0 => ADDW,
  1 => SUBW,
  2 => SLLW,
  3 => SRLW,
  _ => SRAW
}

val num_of_ropw : ropw -> {('e : Int), (0 <= 'e & 'e <= 4). int('e)}

$[complete]
function num_of_ropw arg# = $[complete] match arg# {
  ADDW => 0,
  SUBW => 1,
  SLLW => 2,
  SRLW => 3,
  SRAW => 4
}

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum sopw = {SLLIW, SRLIW, SRAIW}

val undefined_sopw : unit -> sopw

$[complete]
function undefined_sopw () = internal_pick([|SLLIW, SRLIW, SRAIW|])

val sopw_of_num : forall ('e : Int), (0 <= 'e & 'e <= 2). int('e) -> sopw

$[complete]
function sopw_of_num arg# = $[complete] match arg# {
  0 => SLLIW,
  1 => SRLIW,
  _ => SRAIW
}

val num_of_sopw : sopw -> {('e : Int), (0 <= 'e & 'e <= 2). int('e)}

$[complete]
function num_of_sopw arg# = $[complete] match arg# {
  SLLIW => 0,
  SRLIW => 1,
  SRAIW => 2
}

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum amoop = {
  AMOSWAP,
  AMOADD,
  AMOXOR,
  AMOAND,
  AMOOR,
  AMOMIN,
  AMOMAX,
  AMOMINU,
  AMOMAXU,
  AMOCAS
}

val undefined_amoop : unit -> amoop

$[complete]
function undefined_amoop () = internal_pick([|AMOSWAP, AMOADD, AMOXOR, AMOAND, AMOOR, AMOMIN, AMOMAX, AMOMINU, AMOMAXU, AMOCAS|])

val amoop_of_num : forall ('e : Int), (0 <= 'e & 'e <= 9). int('e) -> amoop

$[complete]
function amoop_of_num arg# = $[complete] match arg# {
  0 => AMOSWAP,
  1 => AMOADD,
  2 => AMOXOR,
  3 => AMOAND,
  4 => AMOOR,
  5 => AMOMIN,
  6 => AMOMAX,
  7 => AMOMINU,
  8 => AMOMAXU,
  _ => AMOCAS
}

val num_of_amoop : amoop -> {('e : Int), (0 <= 'e & 'e <= 9). int('e)}

$[complete]
function num_of_amoop arg# = $[complete] match arg# {
  AMOSWAP => 0,
  AMOADD => 1,
  AMOXOR => 2,
  AMOAND => 3,
  AMOOR => 4,
  AMOMIN => 5,
  AMOMAX => 6,
  AMOMINU => 7,
  AMOMAXU => 8,
  AMOCAS => 9
}

val maybe_aqrl : (bool, bool) <-> string

mapping maybe_aqrl = {
  (true, true) <-> ".aqrl",
  (true, false) <-> ".aq",
  (false, true) <-> ".rl",
  (false, false) <-> ""
}

$[undefined_gen "skip"]
struct mul_op = {high : bool, signed_rs1 : bool, signed_rs2 : bool}

val undefined_mul_op : unit -> mul_op

$[complete]
function undefined_mul_op () = struct mul_op { high = undefined, signed_rs1 = undefined, signed_rs2 = undefined }

type shamt_zba = bits(2)

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum brop_zbb = {ANDN, ORN, XNOR, MAX, MAXU, MIN, MINU, ROL, ROR}

val undefined_brop_zbb : unit -> brop_zbb

$[complete]
function undefined_brop_zbb () = internal_pick([|ANDN, ORN, XNOR, MAX, MAXU, MIN, MINU, ROL, ROR|])

val brop_zbb_of_num : forall ('e : Int), (0 <= 'e & 'e <= 8).
  int('e) -> brop_zbb

$[complete]
function brop_zbb_of_num arg# = $[complete] match arg# {
  0 => ANDN,
  1 => ORN,
  2 => XNOR,
  3 => MAX,
  4 => MAXU,
  5 => MIN,
  6 => MINU,
  7 => ROL,
  _ => ROR
}

val num_of_brop_zbb : brop_zbb -> {('e : Int), (0 <= 'e & 'e <= 8). int('e)}

$[complete]
function num_of_brop_zbb arg# = $[complete] match arg# {
  ANDN => 0,
  ORN => 1,
  XNOR => 2,
  MAX => 3,
  MAXU => 4,
  MIN => 5,
  MINU => 6,
  ROL => 7,
  ROR => 8
}

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum brop_zbkb = {PACK, PACKH}

val undefined_brop_zbkb : unit -> brop_zbkb

$[complete]
function undefined_brop_zbkb () = internal_pick([|PACK, PACKH|])

val brop_zbkb_of_num : forall ('e : Int), (0 <= 'e & 'e <= 1).
  int('e) -> brop_zbkb

$[complete]
function brop_zbkb_of_num arg# = $[complete] match arg# {
  0 => PACK,
  _ => PACKH
}

val num_of_brop_zbkb : brop_zbkb -> {('e : Int), (0 <= 'e & 'e <= 1). int('e)}

$[complete]
function num_of_brop_zbkb arg# = $[complete] match arg# {
  PACK => 0,
  PACKH => 1
}

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum brop_zbs = {BCLR, BEXT, BINV, BSET}

val undefined_brop_zbs : unit -> brop_zbs

$[complete]
function undefined_brop_zbs () = internal_pick([|BCLR, BEXT, BINV, BSET|])

val brop_zbs_of_num : forall ('e : Int), (0 <= 'e & 'e <= 3).
  int('e) -> brop_zbs

$[complete]
function brop_zbs_of_num arg# = $[complete] match arg# {
  0 => BCLR,
  1 => BEXT,
  2 => BINV,
  _ => BSET
}

val num_of_brop_zbs : brop_zbs -> {('e : Int), (0 <= 'e & 'e <= 3). int('e)}

$[complete]
function num_of_brop_zbs arg# = $[complete] match arg# {
  BCLR => 0,
  BEXT => 1,
  BINV => 2,
  BSET => 3
}

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum bropw_zbb = {ROLW, RORW}

val undefined_bropw_zbb : unit -> bropw_zbb

$[complete]
function undefined_bropw_zbb () = internal_pick([|ROLW, RORW|])

val bropw_zbb_of_num : forall ('e : Int), (0 <= 'e & 'e <= 1).
  int('e) -> bropw_zbb

$[complete]
function bropw_zbb_of_num arg# = $[complete] match arg# {
  0 => ROLW,
  _ => RORW
}

val num_of_bropw_zbb : bropw_zbb -> {('e : Int), (0 <= 'e & 'e <= 1). int('e)}

$[complete]
function num_of_bropw_zbb arg# = $[complete] match arg# {
  ROLW => 0,
  RORW => 1
}

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum biop_zbs = {BCLRI, BEXTI, BINVI, BSETI}

val undefined_biop_zbs : unit -> biop_zbs

$[complete]
function undefined_biop_zbs () = internal_pick([|BCLRI, BEXTI, BINVI, BSETI|])

val biop_zbs_of_num : forall ('e : Int), (0 <= 'e & 'e <= 3).
  int('e) -> biop_zbs

$[complete]
function biop_zbs_of_num arg# = $[complete] match arg# {
  0 => BCLRI,
  1 => BEXTI,
  2 => BINVI,
  _ => BSETI
}

val num_of_biop_zbs : biop_zbs -> {('e : Int), (0 <= 'e & 'e <= 3). int('e)}

$[complete]
function num_of_biop_zbs arg# = $[complete] match arg# {
  BCLRI => 0,
  BEXTI => 1,
  BINVI => 2,
  BSETI => 3
}

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum extop_zbb = {SEXTB, SEXTH, ZEXTH}

val undefined_extop_zbb : unit -> extop_zbb

$[complete]
function undefined_extop_zbb () = internal_pick([|SEXTB, SEXTH, ZEXTH|])

val extop_zbb_of_num : forall ('e : Int), (0 <= 'e & 'e <= 2).
  int('e) -> extop_zbb

$[complete]
function extop_zbb_of_num arg# = $[complete] match arg# {
  0 => SEXTB,
  1 => SEXTH,
  _ => ZEXTH
}

val num_of_extop_zbb : extop_zbb -> {('e : Int), (0 <= 'e & 'e <= 2). int('e)}

$[complete]
function num_of_extop_zbb arg# = $[complete] match arg# {
  SEXTB => 0,
  SEXTH => 1,
  ZEXTH => 2
}

type fregtype = flenbits

let zero_freg : fregtype = zeros(mult_atom(if constraint(ext_d_supported) then 8
else
  4, 8))

val FRegStr : bitvector((if ext_d_supported then 8 else 4) * 8) -> string

$[complete]
function FRegStr r = bits_str(r)

val fregval_from_freg : bitvector((if ext_d_supported then 8 else 4) * 8) -> bitvector((if ext_d_supported then 8 else 4) * 8)

$[complete]
function fregval_from_freg r = r

val fregval_into_freg : bitvector((if ext_d_supported then 8 else 4) * 8) -> bitvector((if ext_d_supported then 8 else 4) * 8)

$[complete]
function fregval_into_freg v = v

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum f_madd_op_H = {FMADD_H, FMSUB_H, FNMSUB_H, FNMADD_H}

val undefined_f_madd_op_H : unit -> f_madd_op_H

$[complete]
function undefined_f_madd_op_H () = internal_pick([|FMADD_H, FMSUB_H, FNMSUB_H, FNMADD_H|])

val f_madd_op_H_of_num : forall ('e : Int), (0 <= 'e & 'e <= 3).
  int('e) -> f_madd_op_H

$[complete]
function f_madd_op_H_of_num arg# = $[complete] match arg# {
  0 => FMADD_H,
  1 => FMSUB_H,
  2 => FNMSUB_H,
  _ => FNMADD_H
}

val num_of_f_madd_op_H : f_madd_op_H -> {('e : Int), (0 <= 'e & 'e <= 3). int('e)}

$[complete]
function num_of_f_madd_op_H arg# = $[complete] match arg# {
  FMADD_H => 0,
  FMSUB_H => 1,
  FNMSUB_H => 2,
  FNMADD_H => 3
}

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum f_bin_rm_op_H = {FADD_H, FSUB_H, FMUL_H, FDIV_H}

val undefined_f_bin_rm_op_H : unit -> f_bin_rm_op_H

$[complete]
function undefined_f_bin_rm_op_H () = internal_pick([|FADD_H, FSUB_H, FMUL_H, FDIV_H|])

val f_bin_rm_op_H_of_num : forall ('e : Int), (0 <= 'e & 'e <= 3).
  int('e) -> f_bin_rm_op_H

$[complete]
function f_bin_rm_op_H_of_num arg# = $[complete] match arg# {
  0 => FADD_H,
  1 => FSUB_H,
  2 => FMUL_H,
  _ => FDIV_H
}

val num_of_f_bin_rm_op_H : f_bin_rm_op_H -> {('e : Int), (0 <= 'e & 'e <= 3). int('e)}

$[complete]
function num_of_f_bin_rm_op_H arg# = $[complete] match arg# {
  FADD_H => 0,
  FSUB_H => 1,
  FMUL_H => 2,
  FDIV_H => 3
}

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum f_un_rm_ff_op_H = {FSQRT_H, FCVT_H_S, FCVT_H_D, FCVT_S_H, FCVT_D_H}

val undefined_f_un_rm_ff_op_H : unit -> f_un_rm_ff_op_H

$[complete]
function undefined_f_un_rm_ff_op_H () = internal_pick([|FSQRT_H, FCVT_H_S, FCVT_H_D, FCVT_S_H, FCVT_D_H|])

val f_un_rm_ff_op_H_of_num : forall ('e : Int), (0 <= 'e & 'e <= 4).
  int('e) -> f_un_rm_ff_op_H

$[complete]
function f_un_rm_ff_op_H_of_num arg# = $[complete] match arg# {
  0 => FSQRT_H,
  1 => FCVT_H_S,
  2 => FCVT_H_D,
  3 => FCVT_S_H,
  _ => FCVT_D_H
}

val num_of_f_un_rm_ff_op_H : f_un_rm_ff_op_H -> {('e : Int), (0 <= 'e & 'e <= 4). int('e)}

$[complete]
function num_of_f_un_rm_ff_op_H arg# = $[complete] match arg# {
  FSQRT_H => 0,
  FCVT_H_S => 1,
  FCVT_H_D => 2,
  FCVT_S_H => 3,
  FCVT_D_H => 4
}

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum f_un_rm_fx_op_H = {FCVT_W_H, FCVT_WU_H, FCVT_L_H, FCVT_LU_H}

val undefined_f_un_rm_fx_op_H : unit -> f_un_rm_fx_op_H

$[complete]
function undefined_f_un_rm_fx_op_H () = internal_pick([|FCVT_W_H, FCVT_WU_H, FCVT_L_H, FCVT_LU_H|])

val f_un_rm_fx_op_H_of_num : forall ('e : Int), (0 <= 'e & 'e <= 3).
  int('e) -> f_un_rm_fx_op_H

$[complete]
function f_un_rm_fx_op_H_of_num arg# = $[complete] match arg# {
  0 => FCVT_W_H,
  1 => FCVT_WU_H,
  2 => FCVT_L_H,
  _ => FCVT_LU_H
}

val num_of_f_un_rm_fx_op_H : f_un_rm_fx_op_H -> {('e : Int), (0 <= 'e & 'e <= 3). int('e)}

$[complete]
function num_of_f_un_rm_fx_op_H arg# = $[complete] match arg# {
  FCVT_W_H => 0,
  FCVT_WU_H => 1,
  FCVT_L_H => 2,
  FCVT_LU_H => 3
}

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum f_un_rm_xf_op_H = {FCVT_H_W, FCVT_H_WU, FCVT_H_L, FCVT_H_LU}

val undefined_f_un_rm_xf_op_H : unit -> f_un_rm_xf_op_H

$[complete]
function undefined_f_un_rm_xf_op_H () = internal_pick([|FCVT_H_W, FCVT_H_WU, FCVT_H_L, FCVT_H_LU|])

val f_un_rm_xf_op_H_of_num : forall ('e : Int), (0 <= 'e & 'e <= 3).
  int('e) -> f_un_rm_xf_op_H

$[complete]
function f_un_rm_xf_op_H_of_num arg# = $[complete] match arg# {
  0 => FCVT_H_W,
  1 => FCVT_H_WU,
  2 => FCVT_H_L,
  _ => FCVT_H_LU
}

val num_of_f_un_rm_xf_op_H : f_un_rm_xf_op_H -> {('e : Int), (0 <= 'e & 'e <= 3). int('e)}

$[complete]
function num_of_f_un_rm_xf_op_H arg# = $[complete] match arg# {
  FCVT_H_W => 0,
  FCVT_H_WU => 1,
  FCVT_H_L => 2,
  FCVT_H_LU => 3
}

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum f_un_x_op_H = {FCLASS_H, FMV_X_H}

val undefined_f_un_x_op_H : unit -> f_un_x_op_H

$[complete]
function undefined_f_un_x_op_H () = internal_pick([|FCLASS_H, FMV_X_H|])

val f_un_x_op_H_of_num : forall ('e : Int), (0 <= 'e & 'e <= 1).
  int('e) -> f_un_x_op_H

$[complete]
function f_un_x_op_H_of_num arg# = $[complete] match arg# {
  0 => FCLASS_H,
  _ => FMV_X_H
}

val num_of_f_un_x_op_H : f_un_x_op_H -> {('e : Int), (0 <= 'e & 'e <= 1). int('e)}

$[complete]
function num_of_f_un_x_op_H arg# = $[complete] match arg# {
  FCLASS_H => 0,
  FMV_X_H => 1
}

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum f_un_f_op_H = {FMV_H_X}

val undefined_f_un_f_op_H : unit -> f_un_f_op_H

$[complete]
function undefined_f_un_f_op_H () = internal_pick([|FMV_H_X|])

val f_un_f_op_H_of_num : forall ('e : Int), (0 <= 'e & 'e <= 0).
  int('e) -> f_un_f_op_H

$[complete]
function f_un_f_op_H_of_num arg# = $[complete] match arg# {_ => FMV_H_X}

val num_of_f_un_f_op_H : f_un_f_op_H -> {('e : Int), (0 <= 'e & 'e <= 0). int('e)}

$[complete]
function num_of_f_un_f_op_H arg# = $[complete] match arg# {FMV_H_X => 0}

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum f_bin_f_op_H = {FSGNJ_H, FSGNJN_H, FSGNJX_H, FMIN_H, FMAX_H}

val undefined_f_bin_f_op_H : unit -> f_bin_f_op_H

$[complete]
function undefined_f_bin_f_op_H () = internal_pick([|FSGNJ_H, FSGNJN_H, FSGNJX_H, FMIN_H, FMAX_H|])

val f_bin_f_op_H_of_num : forall ('e : Int), (0 <= 'e & 'e <= 4).
  int('e) -> f_bin_f_op_H

$[complete]
function f_bin_f_op_H_of_num arg# = $[complete] match arg# {
  0 => FSGNJ_H,
  1 => FSGNJN_H,
  2 => FSGNJX_H,
  3 => FMIN_H,
  _ => FMAX_H
}

val num_of_f_bin_f_op_H : f_bin_f_op_H -> {('e : Int), (0 <= 'e & 'e <= 4). int('e)}

$[complete]
function num_of_f_bin_f_op_H arg# = $[complete] match arg# {
  FSGNJ_H => 0,
  FSGNJN_H => 1,
  FSGNJX_H => 2,
  FMIN_H => 3,
  FMAX_H => 4
}

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum f_bin_x_op_H = {FEQ_H, FLT_H, FLE_H}

val undefined_f_bin_x_op_H : unit -> f_bin_x_op_H

$[complete]
function undefined_f_bin_x_op_H () = internal_pick([|FEQ_H, FLT_H, FLE_H|])

val f_bin_x_op_H_of_num : forall ('e : Int), (0 <= 'e & 'e <= 2).
  int('e) -> f_bin_x_op_H

$[complete]
function f_bin_x_op_H_of_num arg# = $[complete] match arg# {
  0 => FEQ_H,
  1 => FLT_H,
  _ => FLE_H
}

val num_of_f_bin_x_op_H : f_bin_x_op_H -> {('e : Int), (0 <= 'e & 'e <= 2). int('e)}

$[complete]
function num_of_f_bin_x_op_H arg# = $[complete] match arg# {
  FEQ_H => 0,
  FLT_H => 1,
  FLE_H => 2
}

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum rounding_mode = {RM_RNE, RM_RTZ, RM_RDN, RM_RUP, RM_RMM, RM_DYN}

val undefined_rounding_mode : unit -> rounding_mode

$[complete]
function undefined_rounding_mode () = internal_pick([|RM_RNE, RM_RTZ, RM_RDN, RM_RUP, RM_RMM, RM_DYN|])

val rounding_mode_of_num : forall ('e : Int), (0 <= 'e & 'e <= 5).
  int('e) -> rounding_mode

$[complete]
function rounding_mode_of_num arg# = $[complete] match arg# {
  0 => RM_RNE,
  1 => RM_RTZ,
  2 => RM_RDN,
  3 => RM_RUP,
  4 => RM_RMM,
  _ => RM_DYN
}

val num_of_rounding_mode : rounding_mode -> {('e : Int), (0 <= 'e & 'e <= 5). int('e)}

$[complete]
function num_of_rounding_mode arg# = $[complete] match arg# {
  RM_RNE => 0,
  RM_RTZ => 1,
  RM_RDN => 2,
  RM_RUP => 3,
  RM_RMM => 4,
  RM_DYN => 5
}

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum f_madd_op_S = {FMADD_S, FMSUB_S, FNMSUB_S, FNMADD_S}

val undefined_f_madd_op_S : unit -> f_madd_op_S

$[complete]
function undefined_f_madd_op_S () = internal_pick([|FMADD_S, FMSUB_S, FNMSUB_S, FNMADD_S|])

val f_madd_op_S_of_num : forall ('e : Int), (0 <= 'e & 'e <= 3).
  int('e) -> f_madd_op_S

$[complete]
function f_madd_op_S_of_num arg# = $[complete] match arg# {
  0 => FMADD_S,
  1 => FMSUB_S,
  2 => FNMSUB_S,
  _ => FNMADD_S
}

val num_of_f_madd_op_S : f_madd_op_S -> {('e : Int), (0 <= 'e & 'e <= 3). int('e)}

$[complete]
function num_of_f_madd_op_S arg# = $[complete] match arg# {
  FMADD_S => 0,
  FMSUB_S => 1,
  FNMSUB_S => 2,
  FNMADD_S => 3
}

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum f_bin_rm_op_S = {FADD_S, FSUB_S, FMUL_S, FDIV_S}

val undefined_f_bin_rm_op_S : unit -> f_bin_rm_op_S

$[complete]
function undefined_f_bin_rm_op_S () = internal_pick([|FADD_S, FSUB_S, FMUL_S, FDIV_S|])

val f_bin_rm_op_S_of_num : forall ('e : Int), (0 <= 'e & 'e <= 3).
  int('e) -> f_bin_rm_op_S

$[complete]
function f_bin_rm_op_S_of_num arg# = $[complete] match arg# {
  0 => FADD_S,
  1 => FSUB_S,
  2 => FMUL_S,
  _ => FDIV_S
}

val num_of_f_bin_rm_op_S : f_bin_rm_op_S -> {('e : Int), (0 <= 'e & 'e <= 3). int('e)}

$[complete]
function num_of_f_bin_rm_op_S arg# = $[complete] match arg# {
  FADD_S => 0,
  FSUB_S => 1,
  FMUL_S => 2,
  FDIV_S => 3
}

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum f_un_rm_ff_op_S = {FSQRT_S}

val undefined_f_un_rm_ff_op_S : unit -> f_un_rm_ff_op_S

$[complete]
function undefined_f_un_rm_ff_op_S () = internal_pick([|FSQRT_S|])

val f_un_rm_ff_op_S_of_num : forall ('e : Int), (0 <= 'e & 'e <= 0).
  int('e) -> f_un_rm_ff_op_S

$[complete]
function f_un_rm_ff_op_S_of_num arg# = $[complete] match arg# {_ => FSQRT_S}

val num_of_f_un_rm_ff_op_S : f_un_rm_ff_op_S -> {('e : Int), (0 <= 'e & 'e <= 0). int('e)}

$[complete]
function num_of_f_un_rm_ff_op_S arg# = $[complete] match arg# {FSQRT_S => 0}

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum f_un_rm_fx_op_S = {FCVT_W_S, FCVT_WU_S, FCVT_L_S, FCVT_LU_S}

val undefined_f_un_rm_fx_op_S : unit -> f_un_rm_fx_op_S

$[complete]
function undefined_f_un_rm_fx_op_S () = internal_pick([|FCVT_W_S, FCVT_WU_S, FCVT_L_S, FCVT_LU_S|])

val f_un_rm_fx_op_S_of_num : forall ('e : Int), (0 <= 'e & 'e <= 3).
  int('e) -> f_un_rm_fx_op_S

$[complete]
function f_un_rm_fx_op_S_of_num arg# = $[complete] match arg# {
  0 => FCVT_W_S,
  1 => FCVT_WU_S,
  2 => FCVT_L_S,
  _ => FCVT_LU_S
}

val num_of_f_un_rm_fx_op_S : f_un_rm_fx_op_S -> {('e : Int), (0 <= 'e & 'e <= 3). int('e)}

$[complete]
function num_of_f_un_rm_fx_op_S arg# = $[complete] match arg# {
  FCVT_W_S => 0,
  FCVT_WU_S => 1,
  FCVT_L_S => 2,
  FCVT_LU_S => 3
}

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum f_un_rm_xf_op_S = {FCVT_S_W, FCVT_S_WU, FCVT_S_L, FCVT_S_LU}

val undefined_f_un_rm_xf_op_S : unit -> f_un_rm_xf_op_S

$[complete]
function undefined_f_un_rm_xf_op_S () = internal_pick([|FCVT_S_W, FCVT_S_WU, FCVT_S_L, FCVT_S_LU|])

val f_un_rm_xf_op_S_of_num : forall ('e : Int), (0 <= 'e & 'e <= 3).
  int('e) -> f_un_rm_xf_op_S

$[complete]
function f_un_rm_xf_op_S_of_num arg# = $[complete] match arg# {
  0 => FCVT_S_W,
  1 => FCVT_S_WU,
  2 => FCVT_S_L,
  _ => FCVT_S_LU
}

val num_of_f_un_rm_xf_op_S : f_un_rm_xf_op_S -> {('e : Int), (0 <= 'e & 'e <= 3). int('e)}

$[complete]
function num_of_f_un_rm_xf_op_S arg# = $[complete] match arg# {
  FCVT_S_W => 0,
  FCVT_S_WU => 1,
  FCVT_S_L => 2,
  FCVT_S_LU => 3
}

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum f_un_op_f_S = {FMV_W_X}

val undefined_f_un_op_f_S : unit -> f_un_op_f_S

$[complete]
function undefined_f_un_op_f_S () = internal_pick([|FMV_W_X|])

val f_un_op_f_S_of_num : forall ('e : Int), (0 <= 'e & 'e <= 0).
  int('e) -> f_un_op_f_S

$[complete]
function f_un_op_f_S_of_num arg# = $[complete] match arg# {_ => FMV_W_X}

val num_of_f_un_op_f_S : f_un_op_f_S -> {('e : Int), (0 <= 'e & 'e <= 0). int('e)}

$[complete]
function num_of_f_un_op_f_S arg# = $[complete] match arg# {FMV_W_X => 0}

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum f_un_op_x_S = {FCLASS_S, FMV_X_W}

val undefined_f_un_op_x_S : unit -> f_un_op_x_S

$[complete]
function undefined_f_un_op_x_S () = internal_pick([|FCLASS_S, FMV_X_W|])

val f_un_op_x_S_of_num : forall ('e : Int), (0 <= 'e & 'e <= 1).
  int('e) -> f_un_op_x_S

$[complete]
function f_un_op_x_S_of_num arg# = $[complete] match arg# {
  0 => FCLASS_S,
  _ => FMV_X_W
}

val num_of_f_un_op_x_S : f_un_op_x_S -> {('e : Int), (0 <= 'e & 'e <= 1). int('e)}

$[complete]
function num_of_f_un_op_x_S arg# = $[complete] match arg# {
  FCLASS_S => 0,
  FMV_X_W => 1
}

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum f_bin_op_f_S = {FSGNJ_S, FSGNJN_S, FSGNJX_S, FMIN_S, FMAX_S}

val undefined_f_bin_op_f_S : unit -> f_bin_op_f_S

$[complete]
function undefined_f_bin_op_f_S () = internal_pick([|FSGNJ_S, FSGNJN_S, FSGNJX_S, FMIN_S, FMAX_S|])

val f_bin_op_f_S_of_num : forall ('e : Int), (0 <= 'e & 'e <= 4).
  int('e) -> f_bin_op_f_S

$[complete]
function f_bin_op_f_S_of_num arg# = $[complete] match arg# {
  0 => FSGNJ_S,
  1 => FSGNJN_S,
  2 => FSGNJX_S,
  3 => FMIN_S,
  _ => FMAX_S
}

val num_of_f_bin_op_f_S : f_bin_op_f_S -> {('e : Int), (0 <= 'e & 'e <= 4). int('e)}

$[complete]
function num_of_f_bin_op_f_S arg# = $[complete] match arg# {
  FSGNJ_S => 0,
  FSGNJN_S => 1,
  FSGNJX_S => 2,
  FMIN_S => 3,
  FMAX_S => 4
}

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum f_bin_op_x_S = {FEQ_S, FLT_S, FLE_S}

val undefined_f_bin_op_x_S : unit -> f_bin_op_x_S

$[complete]
function undefined_f_bin_op_x_S () = internal_pick([|FEQ_S, FLT_S, FLE_S|])

val f_bin_op_x_S_of_num : forall ('e : Int), (0 <= 'e & 'e <= 2).
  int('e) -> f_bin_op_x_S

$[complete]
function f_bin_op_x_S_of_num arg# = $[complete] match arg# {
  0 => FEQ_S,
  1 => FLT_S,
  _ => FLE_S
}

val num_of_f_bin_op_x_S : f_bin_op_x_S -> {('e : Int), (0 <= 'e & 'e <= 2). int('e)}

$[complete]
function num_of_f_bin_op_x_S arg# = $[complete] match arg# {
  FEQ_S => 0,
  FLT_S => 1,
  FLE_S => 2
}

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum f_madd_op_D = {FMADD_D, FMSUB_D, FNMSUB_D, FNMADD_D}

val undefined_f_madd_op_D : unit -> f_madd_op_D

$[complete]
function undefined_f_madd_op_D () = internal_pick([|FMADD_D, FMSUB_D, FNMSUB_D, FNMADD_D|])

val f_madd_op_D_of_num : forall ('e : Int), (0 <= 'e & 'e <= 3).
  int('e) -> f_madd_op_D

$[complete]
function f_madd_op_D_of_num arg# = $[complete] match arg# {
  0 => FMADD_D,
  1 => FMSUB_D,
  2 => FNMSUB_D,
  _ => FNMADD_D
}

val num_of_f_madd_op_D : f_madd_op_D -> {('e : Int), (0 <= 'e & 'e <= 3). int('e)}

$[complete]
function num_of_f_madd_op_D arg# = $[complete] match arg# {
  FMADD_D => 0,
  FMSUB_D => 1,
  FNMSUB_D => 2,
  FNMADD_D => 3
}

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum f_bin_rm_op_D = {FADD_D, FSUB_D, FMUL_D, FDIV_D}

val undefined_f_bin_rm_op_D : unit -> f_bin_rm_op_D

$[complete]
function undefined_f_bin_rm_op_D () = internal_pick([|FADD_D, FSUB_D, FMUL_D, FDIV_D|])

val f_bin_rm_op_D_of_num : forall ('e : Int), (0 <= 'e & 'e <= 3).
  int('e) -> f_bin_rm_op_D

$[complete]
function f_bin_rm_op_D_of_num arg# = $[complete] match arg# {
  0 => FADD_D,
  1 => FSUB_D,
  2 => FMUL_D,
  _ => FDIV_D
}

val num_of_f_bin_rm_op_D : f_bin_rm_op_D -> {('e : Int), (0 <= 'e & 'e <= 3). int('e)}

$[complete]
function num_of_f_bin_rm_op_D arg# = $[complete] match arg# {
  FADD_D => 0,
  FSUB_D => 1,
  FMUL_D => 2,
  FDIV_D => 3
}

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum f_un_rm_ff_op_D = {FSQRT_D, FCVT_S_D, FCVT_D_S}

val undefined_f_un_rm_ff_op_D : unit -> f_un_rm_ff_op_D

$[complete]
function undefined_f_un_rm_ff_op_D () = internal_pick([|FSQRT_D, FCVT_S_D, FCVT_D_S|])

val f_un_rm_ff_op_D_of_num : forall ('e : Int), (0 <= 'e & 'e <= 2).
  int('e) -> f_un_rm_ff_op_D

$[complete]
function f_un_rm_ff_op_D_of_num arg# = $[complete] match arg# {
  0 => FSQRT_D,
  1 => FCVT_S_D,
  _ => FCVT_D_S
}

val num_of_f_un_rm_ff_op_D : f_un_rm_ff_op_D -> {('e : Int), (0 <= 'e & 'e <= 2). int('e)}

$[complete]
function num_of_f_un_rm_ff_op_D arg# = $[complete] match arg# {
  FSQRT_D => 0,
  FCVT_S_D => 1,
  FCVT_D_S => 2
}

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum f_un_rm_fx_op_D = {FCVT_W_D, FCVT_WU_D, FCVT_L_D, FCVT_LU_D}

val undefined_f_un_rm_fx_op_D : unit -> f_un_rm_fx_op_D

$[complete]
function undefined_f_un_rm_fx_op_D () = internal_pick([|FCVT_W_D, FCVT_WU_D, FCVT_L_D, FCVT_LU_D|])

val f_un_rm_fx_op_D_of_num : forall ('e : Int), (0 <= 'e & 'e <= 3).
  int('e) -> f_un_rm_fx_op_D

$[complete]
function f_un_rm_fx_op_D_of_num arg# = $[complete] match arg# {
  0 => FCVT_W_D,
  1 => FCVT_WU_D,
  2 => FCVT_L_D,
  _ => FCVT_LU_D
}

val num_of_f_un_rm_fx_op_D : f_un_rm_fx_op_D -> {('e : Int), (0 <= 'e & 'e <= 3). int('e)}

$[complete]
function num_of_f_un_rm_fx_op_D arg# = $[complete] match arg# {
  FCVT_W_D => 0,
  FCVT_WU_D => 1,
  FCVT_L_D => 2,
  FCVT_LU_D => 3
}

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum f_un_rm_xf_op_D = {FCVT_D_W, FCVT_D_WU, FCVT_D_L, FCVT_D_LU}

val undefined_f_un_rm_xf_op_D : unit -> f_un_rm_xf_op_D

$[complete]
function undefined_f_un_rm_xf_op_D () = internal_pick([|FCVT_D_W, FCVT_D_WU, FCVT_D_L, FCVT_D_LU|])

val f_un_rm_xf_op_D_of_num : forall ('e : Int), (0 <= 'e & 'e <= 3).
  int('e) -> f_un_rm_xf_op_D

$[complete]
function f_un_rm_xf_op_D_of_num arg# = $[complete] match arg# {
  0 => FCVT_D_W,
  1 => FCVT_D_WU,
  2 => FCVT_D_L,
  _ => FCVT_D_LU
}

val num_of_f_un_rm_xf_op_D : f_un_rm_xf_op_D -> {('e : Int), (0 <= 'e & 'e <= 3). int('e)}

$[complete]
function num_of_f_un_rm_xf_op_D arg# = $[complete] match arg# {
  FCVT_D_W => 0,
  FCVT_D_WU => 1,
  FCVT_D_L => 2,
  FCVT_D_LU => 3
}

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum f_bin_f_op_D = {FSGNJ_D, FSGNJN_D, FSGNJX_D, FMIN_D, FMAX_D}

val undefined_f_bin_f_op_D : unit -> f_bin_f_op_D

$[complete]
function undefined_f_bin_f_op_D () = internal_pick([|FSGNJ_D, FSGNJN_D, FSGNJX_D, FMIN_D, FMAX_D|])

val f_bin_f_op_D_of_num : forall ('e : Int), (0 <= 'e & 'e <= 4).
  int('e) -> f_bin_f_op_D

$[complete]
function f_bin_f_op_D_of_num arg# = $[complete] match arg# {
  0 => FSGNJ_D,
  1 => FSGNJN_D,
  2 => FSGNJX_D,
  3 => FMIN_D,
  _ => FMAX_D
}

val num_of_f_bin_f_op_D : f_bin_f_op_D -> {('e : Int), (0 <= 'e & 'e <= 4). int('e)}

$[complete]
function num_of_f_bin_f_op_D arg# = $[complete] match arg# {
  FSGNJ_D => 0,
  FSGNJN_D => 1,
  FSGNJX_D => 2,
  FMIN_D => 3,
  FMAX_D => 4
}

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum f_bin_x_op_D = {FEQ_D, FLT_D, FLE_D}

val undefined_f_bin_x_op_D : unit -> f_bin_x_op_D

$[complete]
function undefined_f_bin_x_op_D () = internal_pick([|FEQ_D, FLT_D, FLE_D|])

val f_bin_x_op_D_of_num : forall ('e : Int), (0 <= 'e & 'e <= 2).
  int('e) -> f_bin_x_op_D

$[complete]
function f_bin_x_op_D_of_num arg# = $[complete] match arg# {
  0 => FEQ_D,
  1 => FLT_D,
  _ => FLE_D
}

val num_of_f_bin_x_op_D : f_bin_x_op_D -> {('e : Int), (0 <= 'e & 'e <= 2). int('e)}

$[complete]
function num_of_f_bin_x_op_D arg# = $[complete] match arg# {
  FEQ_D => 0,
  FLT_D => 1,
  FLE_D => 2
}

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum f_un_x_op_D = {FCLASS_D, FMV_X_D}

val undefined_f_un_x_op_D : unit -> f_un_x_op_D

$[complete]
function undefined_f_un_x_op_D () = internal_pick([|FCLASS_D, FMV_X_D|])

val f_un_x_op_D_of_num : forall ('e : Int), (0 <= 'e & 'e <= 1).
  int('e) -> f_un_x_op_D

$[complete]
function f_un_x_op_D_of_num arg# = $[complete] match arg# {
  0 => FCLASS_D,
  _ => FMV_X_D
}

val num_of_f_un_x_op_D : f_un_x_op_D -> {('e : Int), (0 <= 'e & 'e <= 1). int('e)}

$[complete]
function num_of_f_un_x_op_D arg# = $[complete] match arg# {
  FCLASS_D => 0,
  FMV_X_D => 1
}

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum f_un_f_op_D = {FMV_D_X}

val undefined_f_un_f_op_D : unit -> f_un_f_op_D

$[complete]
function undefined_f_un_f_op_D () = internal_pick([|FMV_D_X|])

val f_un_f_op_D_of_num : forall ('e : Int), (0 <= 'e & 'e <= 0).
  int('e) -> f_un_f_op_D

$[complete]
function f_un_f_op_D_of_num arg# = $[complete] match arg# {_ => FMV_D_X}

val num_of_f_un_f_op_D : f_un_f_op_D -> {('e : Int), (0 <= 'e & 'e <= 0). int('e)}

$[complete]
function num_of_f_un_f_op_D arg# = $[complete] match arg# {FMV_D_X => 0}

val canonical_NaN : forall ('n : Int), 'n in {16, 32, 64, 128}.
  implicit('n) -> bitvector('n)

$[complete]
function canonical_NaN n = $[complete] match $[overloaded { "name" = "__size", "is_infix" = false }] __id(n) {
  16 => $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(0b0, $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(ones(5), $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(0b1, zeros(9)))),
  32 => $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(0b0, $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(ones(8), $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(0b1, zeros(22)))),
  64 => $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(0b0, $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(ones(11), $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(0b1, zeros(51)))),
  ($[int_wildcard 128] _) => $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(0b0, $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(ones(15), $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(0b1, zeros(111))))
}

val canonical_NaN_H : unit -> bitvector(16)

$[complete]
function canonical_NaN_H () = canonical_NaN(16)

val canonical_NaN_S : unit -> bitvector(32)

$[complete]
function canonical_NaN_S () = canonical_NaN(32)

val canonical_NaN_D : unit -> bitvector(64)

$[complete]
function canonical_NaN_D () = canonical_NaN(64)

val canonical_NaN_Q : unit -> bitvector(128)

$[complete]
function canonical_NaN_Q () = canonical_NaN(128)

val nan_box : forall ('n : Int) ('m : Int), 'n <= 'm.
  (implicit('m), bitvector('n)) -> bitvector('m)

$[complete]
function nan_box (n, x) = $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(ones($[overloaded { "name" = "-", "is_infix" = true }] sub_atom($[overloaded { "name" = "__size", "is_infix" = false }] __id(n), $[overloaded { "name" = "__size", "is_infix" = false }] bitvector_length(x))), x)

val nan_unbox : forall ('n : Int) ('m : Int), ('m in {16, 32, 64, 128} & 'n >= 'm).
  (implicit('m), bitvector('n)) -> bitvector('m)

$[complete]
function nan_unbox (m, x) = if $[overloaded { "name" = "==", "is_infix" = true }] eq_int($[overloaded { "name" = "__size", "is_infix" = false }] bitvector_length(x), $[overloaded { "name" = "__size", "is_infix" = false }] __id(m)) then
  x
else
  if $[overloaded { "name" = "==", "is_infix" = true }] eq_bits($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(x, $[overloaded { "name" = "-", "is_infix" = true }] sub_atom($[overloaded { "name" = "__size", "is_infix" = false }] bitvector_length(x), 1), $[overloaded { "name" = "__size", "is_infix" = false }] __id(m)), ones(add_atom(sub_atom(sub_atom($[overloaded { "name" = "__size", "is_infix" = false }] bitvector_length(x), 1), $[overloaded { "name" = "__size", "is_infix" = false }] __id(m)), 1))) then
    $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(x, $[overloaded { "name" = "-", "is_infix" = true }] sub_atom($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), 1), 0)
  else
    canonical_NaN($[overloaded { "name" = "__size", "is_infix" = false }] __id(m))

newtype fregidx = Fregidx : bits(5)

newtype fregno = Fregno : range(0, 31)

newtype cfregidx = Cfregidx : bits(3)

val fregidx_bits : fregidx -> bitvector(5)

$[complete]
function fregidx_bits Fregidx(r) : fregidx = r

val cfregidx_to_fregidx : cfregidx -> fregidx

$[complete]
function cfregidx_to_fregidx Cfregidx(b) : cfregidx = Fregidx($[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(0b01, b))

val encdec_cfreg : cfregidx <-> bitvector(3)

mapping encdec_cfreg = {Cfregidx(r) <-> r}

val fregidx_to_regidx : fregidx -> regidx

$[complete]
function fregidx_to_regidx Fregidx(b) : fregidx = Regidx(trunc(if constraint(base_E_enabled) then
  4
else
  5, b))

val encdec_freg : fregidx <-> bitvector(5)

mapping encdec_freg = {Fregidx(r) <-> r}

val freg_write_callback = pure {c: "freg_write_callback"}: (fregidx, bitvector((if ext_d_supported then 8 else 4) * 8)) -> unit

$[complete]
function freg_write_callback _ = ()

register f0 : fregtype

register f1 : fregtype

register f2 : fregtype

register f3 : fregtype

register f4 : fregtype

register f5 : fregtype

register f6 : fregtype

register f7 : fregtype

register f8 : fregtype

register f9 : fregtype

register f10 : fregtype

register f11 : fregtype

register f12 : fregtype

register f13 : fregtype

register f14 : fregtype

register f15 : fregtype

register f16 : fregtype

register f17 : fregtype

register f18 : fregtype

register f19 : fregtype

register f20 : fregtype

register f21 : fregtype

register f22 : fregtype

register f23 : fregtype

register f24 : fregtype

register f25 : fregtype

register f26 : fregtype

register f27 : fregtype

register f28 : fregtype

register f29 : fregtype

register f30 : fregtype

register f31 : fregtype

val dirty_fd_context : unit -> unit

$[complete]
function dirty_fd_context () = {
    assert(hartSupports(Ext_F), "./extensions/FD/fdext_regs.sail:110.28-110.29");
    mstatus.bits[14 .. 13] = extStatus_to_bits(Dirty);
    mstatus.bits[sub_atom(sizeof(xlen), 1) .. sub_atom(sizeof(xlen), 1)] = 0b1;
    long_csr_write_callback("mstatus", "mstatush", mstatus.bits)
}

val dirty_fd_context_if_present : unit -> unit

$[complete]
function dirty_fd_context_if_present () = {
    assert($[overloaded { "name" = "!=", "is_infix" = true }] neq_bool(hartSupports(Ext_F), hartSupports(Ext_Zfinx)), "./extensions/FD/fdext_regs.sail:117.55-117.56");
    if hartSupports(Ext_F) then dirty_fd_context();
    ()
}

val rF : fregno -> bitvector((if ext_d_supported then 8 else 4) * 8)

$[complete]
function rF Fregno(r) : fregno = {
    assert(hartSupports(Ext_F), "./extensions/FD/fdext_regs.sail:122.28-122.29");
    let v : fregtype = $[complete] match r {
      0 => f0,
      1 => f1,
      2 => f2,
      3 => f3,
      4 => f4,
      5 => f5,
      6 => f6,
      7 => f7,
      8 => f8,
      9 => f9,
      10 => f10,
      11 => f11,
      12 => f12,
      13 => f13,
      14 => f14,
      15 => f15,
      16 => f16,
      17 => f17,
      18 => f18,
      19 => f19,
      20 => f20,
      21 => f21,
      22 => f22,
      23 => f23,
      24 => f24,
      25 => f25,
      26 => f26,
      27 => f27,
      28 => f28,
      29 => f29,
      30 => f30,
      31 => f31,
      _ => {
          assert(false, "invalid floating point register number");
          exit(())
      }
    };
    fregval_from_freg(v)
}

val wF : (fregno, bitvector((if ext_d_supported then 8 else 4) * 8)) -> unit

$[complete]
function wF (Fregno(r) : fregno, in_v : flenbits) = {
    assert(hartSupports(Ext_F), "./extensions/FD/fdext_regs.sail:163.28-163.29");
    let v = fregval_into_freg(in_v);
    $[complete] match r {
      0 => f0 = v,
      1 => f1 = v,
      2 => f2 = v,
      3 => f3 = v,
      4 => f4 = v,
      5 => f5 = v,
      6 => f6 = v,
      7 => f7 = v,
      8 => f8 = v,
      9 => f9 = v,
      10 => f10 = v,
      11 => f11 = v,
      12 => f12 = v,
      13 => f13 = v,
      14 => f14 = v,
      15 => f15 = v,
      16 => f16 = v,
      17 => f17 = v,
      18 => f18 = v,
      19 => f19 = v,
      20 => f20 = v,
      21 => f21 = v,
      22 => f22 = v,
      23 => f23 = v,
      24 => f24 = v,
      25 => f25 = v,
      26 => f26 = v,
      27 => f27 = v,
      28 => f28 = v,
      29 => f29 = v,
      30 => f30 = v,
      ($[int_wildcard 31] _) => f31 = v
    };
    freg_write_callback(Fregidx(to_bits(5, r)), in_v);
    dirty_fd_context()
}

val rF_bits : fregidx -> bitvector((if ext_d_supported then 8 else 4) * 8)

$[complete]
function rF_bits Fregidx(i) : fregidx = rF(Fregno(unsigned(i)))

val wF_bits : (fregidx, bitvector((if ext_d_supported then 8 else 4) * 8)) -> unit

$[complete]
function wF_bits (Fregidx(i) : fregidx, data : flenbits) = {
    $[setter] wF(Fregno(unsigned(i)), data)
}

overload F = {rF_bits, wF_bits, rF, wF}

val rF_BF16 : fregidx -> bitvector(16)

$[complete]
function rF_BF16 i = {
    nan_unbox(16, $[overloaded { "name" = "F", "is_infix" = false }] rF_bits(i))
}

val wF_BF16 : (fregidx, bitvector(16)) -> unit

$[complete]
function wF_BF16 (i, data) = {
    $[overloaded { "name" = "F", "is_infix" = false }] $[setter] wF_bits(i, nan_box(mult_atom(if constraint(ext_d_supported) then
      8
    else
      4, 8), data))
}

val rF_H : fregidx -> bitvector(16)

$[complete]
function rF_H i = {
    assert($[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(flen, 16), "./extensions/FD/fdext_regs.sail:224.19-224.20");
    assert($[overloaded { "name" = "&", "is_infix" = true }] and_bool(hartSupports(Ext_F), not(hartSupports(Ext_Zfinx))), "./extensions/FD/fdext_regs.sail:225.59-225.60");
    nan_unbox(16, $[overloaded { "name" = "F", "is_infix" = false }] rF_bits(i))
}

val wF_H : (fregidx, bitvector(16)) -> unit

$[complete]
function wF_H (i, data) = {
    assert($[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(flen, 16), "./extensions/FD/fdext_regs.sail:231.19-231.20");
    assert($[overloaded { "name" = "&", "is_infix" = true }] and_bool(hartSupports(Ext_F), not(hartSupports(Ext_Zfinx))), "./extensions/FD/fdext_regs.sail:232.59-232.60");
    $[overloaded { "name" = "F", "is_infix" = false }] $[setter] wF_bits(i, nan_box(mult_atom(if constraint(ext_d_supported) then
      8
    else
      4, 8), data))
}

val rF_S : fregidx -> bitvector(32)

$[complete]
function rF_S i = {
    assert($[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(flen, 32), "./extensions/FD/fdext_regs.sail:238.19-238.20");
    assert($[overloaded { "name" = "&", "is_infix" = true }] and_bool(hartSupports(Ext_F), not(hartSupports(Ext_Zfinx))), "./extensions/FD/fdext_regs.sail:239.59-239.60");
    nan_unbox(32, $[overloaded { "name" = "F", "is_infix" = false }] rF_bits(i))
}

val wF_S : (fregidx, bitvector(32)) -> unit

$[complete]
function wF_S (i, data) = {
    assert($[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(flen, 32), "./extensions/FD/fdext_regs.sail:245.19-245.20");
    assert($[overloaded { "name" = "&", "is_infix" = true }] and_bool(hartSupports(Ext_F), not(hartSupports(Ext_Zfinx))), "./extensions/FD/fdext_regs.sail:246.59-246.60");
    $[overloaded { "name" = "F", "is_infix" = false }] $[setter] wF_bits(i, nan_box(mult_atom(if constraint(ext_d_supported) then
      8
    else
      4, 8), data))
}

val rF_D : fregidx -> bitvector(64)

$[complete]
function rF_D i = {
    assert($[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(flen, 64), "./extensions/FD/fdext_regs.sail:252.19-252.20");
    assert($[overloaded { "name" = "&", "is_infix" = true }] and_bool(hartSupports(Ext_F), not(hartSupports(Ext_Zfinx))), "./extensions/FD/fdext_regs.sail:253.59-253.60");
    $[overloaded { "name" = "F", "is_infix" = false }] rF_bits(i)
}

val wF_D : (fregidx, bitvector(64)) -> unit

$[complete]
function wF_D (i, data) = {
    assert($[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(flen, 64), "./extensions/FD/fdext_regs.sail:259.19-259.20");
    assert($[overloaded { "name" = "&", "is_infix" = true }] and_bool(hartSupports(Ext_F), not(hartSupports(Ext_Zfinx))), "./extensions/FD/fdext_regs.sail:260.59-260.60");
    $[overloaded { "name" = "F", "is_infix" = false }] $[setter] wF_bits(i, data)
}

overload F_BF16 = {rF_BF16, wF_BF16}

overload F_H = {rF_H, wF_H}

overload F_S = {rF_S, wF_S}

overload F_D = {rF_D, wF_D}

val rF_or_X_H : fregidx -> bitvector(16)

$[complete]
function rF_or_X_H i = {
    assert($[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(flen, 16), "./extensions/FD/fdext_regs.sail:271.19-271.20");
    assert($[overloaded { "name" = "!=", "is_infix" = true }] neq_bool(hartSupports(Ext_F), hartSupports(Ext_Zfinx)), "./extensions/FD/fdext_regs.sail:272.55-272.56");
    if hartSupports(Ext_F) then
      $[overloaded { "name" = "F_H", "is_infix" = false }] rF_H(i)
    else
      $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(fregidx_to_regidx(i)), 15, 0)
}

val rF_or_X_S : fregidx -> bitvector(32)

$[complete]
function rF_or_X_S i = {
    assert($[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(flen, 32), "./extensions/FD/fdext_regs.sail:280.19-280.20");
    assert($[overloaded { "name" = "!=", "is_infix" = true }] neq_bool(hartSupports(Ext_F), hartSupports(Ext_Zfinx)), "./extensions/FD/fdext_regs.sail:281.55-281.56");
    if hartSupports(Ext_F) then
      $[overloaded { "name" = "F_S", "is_infix" = false }] rF_S(i)
    else
      $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(fregidx_to_regidx(i)), 31, 0)
}

val rF_or_X_D : fregidx -> bitvector(64)

$[complete]
function rF_or_X_D i = {
    assert($[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(flen, 64), "./extensions/FD/fdext_regs.sail:289.19-289.20");
    assert($[overloaded { "name" = "!=", "is_infix" = true }] neq_bool(hartSupports(Ext_F), hartSupports(Ext_Zfinx)), "./extensions/FD/fdext_regs.sail:290.55-290.56");
    if hartSupports(Ext_F) then
      $[overloaded { "name" = "F_D", "is_infix" = false }] rF_D(i)
    else
      if $[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(xlen, 64) then
        $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(fregidx_to_regidx(i)), 63, 0)
      else {
          let ridx = fregidx_to_regidx(i);
          assert($[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(regidx_bits(ridx), 0), bitzero), "./extensions/FD/fdext_regs.sail:297.42-297.43");
          if $[overloaded { "name" = "==", "is_infix" = true }] eq_anything(ridx, zreg) then
            zeros(64)
          else
            $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat($[overloaded { "name" = "X", "is_infix" = false }] rX_bits($[overloaded { "name" = "+", "is_infix" = true }] regidx_offset_range(ridx, 1)), $[overloaded { "name" = "X", "is_infix" = false }] rX_bits(ridx))
      }
}

val wF_or_X_H : (fregidx, bitvector(16)) -> unit

$[complete]
function wF_or_X_H (i, data) = {
    assert($[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(flen, 16), "./extensions/FD/fdext_regs.sail:304.19-304.20");
    assert($[overloaded { "name" = "!=", "is_infix" = true }] neq_bool(hartSupports(Ext_F), hartSupports(Ext_Zfinx)), "./extensions/FD/fdext_regs.sail:305.55-305.56");
    if hartSupports(Ext_F) then
      $[overloaded { "name" = "F_H", "is_infix" = false }] $[setter] wF_H(i, data)
    else
      $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(fregidx_to_regidx(i), sign_extend(sizeof(xlen), data))
}

val wF_or_X_S : (fregidx, bitvector(32)) -> unit

$[complete]
function wF_or_X_S (i, data) = {
    assert($[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(flen, 32), "./extensions/FD/fdext_regs.sail:313.19-313.20");
    assert($[overloaded { "name" = "!=", "is_infix" = true }] neq_bool(hartSupports(Ext_F), hartSupports(Ext_Zfinx)), "./extensions/FD/fdext_regs.sail:314.55-314.56");
    if hartSupports(Ext_F) then
      $[overloaded { "name" = "F_S", "is_infix" = false }] $[setter] wF_S(i, data)
    else
      $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(fregidx_to_regidx(i), sign_extend(sizeof(xlen), data))
}

val wF_or_X_D : (fregidx, bitvector(64)) -> unit

$[complete]
function wF_or_X_D (i, data) = {
    assert($[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(flen, 64), "./extensions/FD/fdext_regs.sail:322.20-322.21");
    assert($[overloaded { "name" = "!=", "is_infix" = true }] neq_bool(hartSupports(Ext_F), hartSupports(Ext_Zfinx)), "./extensions/FD/fdext_regs.sail:323.55-323.56");
    if hartSupports(Ext_F) then
      $[overloaded { "name" = "F_D", "is_infix" = false }] $[setter] wF_D(i, data)
    else
      if $[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(xlen, 64) then
        $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(fregidx_to_regidx(i), sign_extend(sizeof(xlen), data))
      else {
          let ridx = fregidx_to_regidx(i);
          assert($[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(regidx_bits(ridx), 0), bitzero), "./extensions/FD/fdext_regs.sail:330.43-330.44");
          if $[overloaded { "name" = "!=", "is_infix" = true }] neq_anything(ridx, zreg) then {
              $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(ridx, $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(data, 31, 0));
              $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits($[overloaded { "name" = "+", "is_infix" = true }] regidx_offset_range(ridx, 1), $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(data, 63, 32))
          };
          ()
      }
}

overload F_or_X_H = {rF_or_X_H, wF_or_X_H}

overload F_or_X_S = {rF_or_X_S, wF_or_X_S}

overload F_or_X_D = {rF_or_X_D, wF_or_X_D}

val freg_abi_name_raw : bitvector(5) <-> string

mapping freg_abi_name_raw = {
  0b00000 <-> "ft0",
  0b00001 <-> "ft1",
  0b00010 <-> "ft2",
  0b00011 <-> "ft3",
  0b00100 <-> "ft4",
  0b00101 <-> "ft5",
  0b00110 <-> "ft6",
  0b00111 <-> "ft7",
  0b01000 <-> "fs0",
  0b01001 <-> "fs1",
  0b01010 <-> "fa0",
  0b01011 <-> "fa1",
  0b01100 <-> "fa2",
  0b01101 <-> "fa3",
  0b01110 <-> "fa4",
  0b01111 <-> "fa5",
  0b10000 <-> "fa6",
  0b10001 <-> "fa7",
  0b10010 <-> "fs2",
  0b10011 <-> "fs3",
  0b10100 <-> "fs4",
  0b10101 <-> "fs5",
  0b10110 <-> "fs6",
  0b10111 <-> "fs7",
  0b11000 <-> "fs8",
  0b11001 <-> "fs9",
  0b11010 <-> "fs10",
  0b11011 <-> "fs11",
  0b11100 <-> "ft8",
  0b11101 <-> "ft9",
  0b11110 <-> "ft10",
  0b11111 <-> "ft11"
}

val freg_arch_name_raw : bitvector(5) <-> string

mapping freg_arch_name_raw = {
  0b00000 <-> "f0",
  0b00001 <-> "f1",
  0b00010 <-> "f2",
  0b00011 <-> "f3",
  0b00100 <-> "f4",
  0b00101 <-> "f5",
  0b00110 <-> "f6",
  0b00111 <-> "f7",
  0b01000 <-> "f8",
  0b01001 <-> "f9",
  0b01010 <-> "f10",
  0b01011 <-> "f11",
  0b01100 <-> "f12",
  0b01101 <-> "f13",
  0b01110 <-> "f14",
  0b01111 <-> "f15",
  0b10000 <-> "f16",
  0b10001 <-> "f17",
  0b10010 <-> "f18",
  0b10011 <-> "f19",
  0b10100 <-> "f20",
  0b10101 <-> "f21",
  0b10110 <-> "f22",
  0b10111 <-> "f23",
  0b11000 <-> "f24",
  0b11001 <-> "f25",
  0b11010 <-> "f26",
  0b11011 <-> "f27",
  0b11100 <-> "f28",
  0b11101 <-> "f29",
  0b11110 <-> "f30",
  0b11111 <-> "f31"
}

val freg_name : fregidx <-> string

mapping freg_name = {
  Fregidx(i) if get_config_use_abi_names() <-> freg_abi_name_raw(i),
  Fregidx(i) if not(get_config_use_abi_names()) <-> freg_arch_name_raw(i)
}

val freg_or_reg_name : fregidx <-> string

mapping freg_or_reg_name = {
  forwards f if hartSupports(Ext_Zfinx) => reg_name_forwards(fregidx_to_regidx(f)),
  backwards ($[backwards] reg_name(Regidx(i))) if hartSupports(Ext_Zfinx) => Fregidx(zero_extend(5, i)),
  f <-> freg_name(f)
}

val cfreg_name : cfregidx <-> string

mapping cfreg_name = {
  Cfregidx(i) <-> freg_name(Fregidx(0b01 @ (i : bitvector(3))))
}

$[undefined_gen "skip"]
$[bitfield]
struct Fcsr = {bits : bitvector(32)}

val undefined_Fcsr : unit -> Fcsr

$[complete]
function undefined_Fcsr () = struct Fcsr { bits = undefined }

val Mk_Fcsr : bitvector(32) -> Fcsr

$[complete]
function Mk_Fcsr v = struct Fcsr { bits = v }

$[fix_location]
val _get_Fcsr_bits : Fcsr -> bitvector(32)

$[complete]
$[fix_location]
function _get_Fcsr_bits v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, sub_atom(32, 1), 0)

$[fix_location]
val _update_Fcsr_bits : (Fcsr, bitvector(32)) -> Fcsr

$[complete]
$[fix_location]
function _update_Fcsr_bits (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, sub_atom(32, 1), 0, x) }

$[fix_location]
overload update_bits = {_update_Fcsr_bits}

$[fix_location]
val _set_Fcsr_bits : (register(Fcsr), bitvector(32)) -> unit

$[complete]
$[fix_location]
function _set_Fcsr_bits (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Fcsr_bits(r, v)
}

overload _mod_bits = {_get_Fcsr_bits, _set_Fcsr_bits}

$[fix_location]
val _get_Fcsr_FFLAGS : Fcsr -> bitvector(5)

$[complete]
$[fix_location]
function _get_Fcsr_FFLAGS v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 4, 0)

$[fix_location]
val _update_Fcsr_FFLAGS : (Fcsr, bitvector(5)) -> Fcsr

$[complete]
$[fix_location]
function _update_Fcsr_FFLAGS (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 4, 0, x) }

$[fix_location]
overload update_FFLAGS = {_update_Fcsr_FFLAGS}

$[fix_location]
val _set_Fcsr_FFLAGS : (register(Fcsr), bitvector(5)) -> unit

$[complete]
$[fix_location]
function _set_Fcsr_FFLAGS (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Fcsr_FFLAGS(r, v)
}

overload _mod_FFLAGS = {_get_Fcsr_FFLAGS, _set_Fcsr_FFLAGS}

$[fix_location]
val _get_Fcsr_FRM : Fcsr -> bitvector(3)

$[complete]
$[fix_location]
function _get_Fcsr_FRM v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 7, 5)

$[fix_location]
val _update_Fcsr_FRM : (Fcsr, bitvector(3)) -> Fcsr

$[complete]
$[fix_location]
function _update_Fcsr_FRM (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 7, 5, x) }

$[fix_location]
overload update_FRM = {_update_Fcsr_FRM}

$[fix_location]
val _set_Fcsr_FRM : (register(Fcsr), bitvector(3)) -> unit

$[complete]
$[fix_location]
function _set_Fcsr_FRM (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Fcsr_FRM(r, v)
}

overload _mod_FRM = {_get_Fcsr_FRM, _set_Fcsr_FRM}

register fcsr : Fcsr

val write_fcsr : (bitvector(3), bitvector(5)) -> unit

$[complete]
function write_fcsr (frm, fflags) = {
    fcsr.bits[7 .. 5] = frm;
    fcsr.bits[4 .. 0] = fflags;
    dirty_fd_context_if_present()
}

val accrue_fflags : bitvector(5) -> unit

$[complete]
function accrue_fflags flags = {
    let f = $[overloaded { "name" = "|", "is_infix" = true }] or_vec(_get_Fcsr_FFLAGS(fcsr), flags);
    if $[overloaded { "name" = "!=", "is_infix" = true }] neq_bits(_get_Fcsr_FFLAGS(fcsr), f) then {
        fcsr.bits[4 .. 0] = f;
        dirty_fd_context_if_present()
    };
    ()
}

type vlenbits = bits(vlen)

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum vvfunct6 = {
  VV_VADD,
  VV_VSUB,
  VV_VMINU,
  VV_VMIN,
  VV_VMAXU,
  VV_VMAX,
  VV_VAND,
  VV_VOR,
  VV_VXOR,
  VV_VRGATHER,
  VV_VRGATHEREI16,
  VV_VSADDU,
  VV_VSADD,
  VV_VSSUBU,
  VV_VSSUB,
  VV_VSLL,
  VV_VSMUL,
  VV_VSRL,
  VV_VSRA,
  VV_VSSRL,
  VV_VSSRA
}

val undefined_vvfunct6 : unit -> vvfunct6

$[complete]
function undefined_vvfunct6 () = internal_pick([|VV_VADD, VV_VSUB, VV_VMINU, VV_VMIN, VV_VMAXU, VV_VMAX, VV_VAND, VV_VOR, VV_VXOR, VV_VRGATHER, VV_VRGATHEREI16, VV_VSADDU, VV_VSADD, VV_VSSUBU, VV_VSSUB, VV_VSLL, VV_VSMUL, VV_VSRL, VV_VSRA, VV_VSSRL, VV_VSSRA|])

val vvfunct6_of_num : forall ('e : Int), (0 <= 'e & 'e <= 20).
  int('e) -> vvfunct6

$[complete]
function vvfunct6_of_num arg# = $[complete] match arg# {
  0 => VV_VADD,
  1 => VV_VSUB,
  2 => VV_VMINU,
  3 => VV_VMIN,
  4 => VV_VMAXU,
  5 => VV_VMAX,
  6 => VV_VAND,
  7 => VV_VOR,
  8 => VV_VXOR,
  9 => VV_VRGATHER,
  10 => VV_VRGATHEREI16,
  11 => VV_VSADDU,
  12 => VV_VSADD,
  13 => VV_VSSUBU,
  14 => VV_VSSUB,
  15 => VV_VSLL,
  16 => VV_VSMUL,
  17 => VV_VSRL,
  18 => VV_VSRA,
  19 => VV_VSSRL,
  _ => VV_VSSRA
}

val num_of_vvfunct6 : vvfunct6 -> {('e : Int), (0 <= 'e & 'e <= 20). int('e)}

$[complete]
function num_of_vvfunct6 arg# = $[complete] match arg# {
  VV_VADD => 0,
  VV_VSUB => 1,
  VV_VMINU => 2,
  VV_VMIN => 3,
  VV_VMAXU => 4,
  VV_VMAX => 5,
  VV_VAND => 6,
  VV_VOR => 7,
  VV_VXOR => 8,
  VV_VRGATHER => 9,
  VV_VRGATHEREI16 => 10,
  VV_VSADDU => 11,
  VV_VSADD => 12,
  VV_VSSUBU => 13,
  VV_VSSUB => 14,
  VV_VSLL => 15,
  VV_VSMUL => 16,
  VV_VSRL => 17,
  VV_VSRA => 18,
  VV_VSSRL => 19,
  VV_VSSRA => 20
}

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum vvcmpfunct6 = {
  VVCMP_VMSEQ,
  VVCMP_VMSNE,
  VVCMP_VMSLTU,
  VVCMP_VMSLT,
  VVCMP_VMSLEU,
  VVCMP_VMSLE
}

val undefined_vvcmpfunct6 : unit -> vvcmpfunct6

$[complete]
function undefined_vvcmpfunct6 () = internal_pick([|VVCMP_VMSEQ, VVCMP_VMSNE, VVCMP_VMSLTU, VVCMP_VMSLT, VVCMP_VMSLEU, VVCMP_VMSLE|])

val vvcmpfunct6_of_num : forall ('e : Int), (0 <= 'e & 'e <= 5).
  int('e) -> vvcmpfunct6

$[complete]
function vvcmpfunct6_of_num arg# = $[complete] match arg# {
  0 => VVCMP_VMSEQ,
  1 => VVCMP_VMSNE,
  2 => VVCMP_VMSLTU,
  3 => VVCMP_VMSLT,
  4 => VVCMP_VMSLEU,
  _ => VVCMP_VMSLE
}

val num_of_vvcmpfunct6 : vvcmpfunct6 -> {('e : Int), (0 <= 'e & 'e <= 5). int('e)}

$[complete]
function num_of_vvcmpfunct6 arg# = $[complete] match arg# {
  VVCMP_VMSEQ => 0,
  VVCMP_VMSNE => 1,
  VVCMP_VMSLTU => 2,
  VVCMP_VMSLT => 3,
  VVCMP_VMSLEU => 4,
  VVCMP_VMSLE => 5
}

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum vvmfunct6 = {VVM_VMADC, VVM_VMSBC}

val undefined_vvmfunct6 : unit -> vvmfunct6

$[complete]
function undefined_vvmfunct6 () = internal_pick([|VVM_VMADC, VVM_VMSBC|])

val vvmfunct6_of_num : forall ('e : Int), (0 <= 'e & 'e <= 1).
  int('e) -> vvmfunct6

$[complete]
function vvmfunct6_of_num arg# = $[complete] match arg# {
  0 => VVM_VMADC,
  _ => VVM_VMSBC
}

val num_of_vvmfunct6 : vvmfunct6 -> {('e : Int), (0 <= 'e & 'e <= 1). int('e)}

$[complete]
function num_of_vvmfunct6 arg# = $[complete] match arg# {
  VVM_VMADC => 0,
  VVM_VMSBC => 1
}

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum vvmcfunct6 = {VVMC_VMADC, VVMC_VMSBC}

val undefined_vvmcfunct6 : unit -> vvmcfunct6

$[complete]
function undefined_vvmcfunct6 () = internal_pick([|VVMC_VMADC, VVMC_VMSBC|])

val vvmcfunct6_of_num : forall ('e : Int), (0 <= 'e & 'e <= 1).
  int('e) -> vvmcfunct6

$[complete]
function vvmcfunct6_of_num arg# = $[complete] match arg# {
  0 => VVMC_VMADC,
  _ => VVMC_VMSBC
}

val num_of_vvmcfunct6 : vvmcfunct6 -> {('e : Int), (0 <= 'e & 'e <= 1). int('e)}

$[complete]
function num_of_vvmcfunct6 arg# = $[complete] match arg# {
  VVMC_VMADC => 0,
  VVMC_VMSBC => 1
}

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum vvmsfunct6 = {VVMS_VADC, VVMS_VSBC}

val undefined_vvmsfunct6 : unit -> vvmsfunct6

$[complete]
function undefined_vvmsfunct6 () = internal_pick([|VVMS_VADC, VVMS_VSBC|])

val vvmsfunct6_of_num : forall ('e : Int), (0 <= 'e & 'e <= 1).
  int('e) -> vvmsfunct6

$[complete]
function vvmsfunct6_of_num arg# = $[complete] match arg# {
  0 => VVMS_VADC,
  _ => VVMS_VSBC
}

val num_of_vvmsfunct6 : vvmsfunct6 -> {('e : Int), (0 <= 'e & 'e <= 1). int('e)}

$[complete]
function num_of_vvmsfunct6 arg# = $[complete] match arg# {
  VVMS_VADC => 0,
  VVMS_VSBC => 1
}

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum vxmfunct6 = {VXM_VMADC, VXM_VMSBC}

val undefined_vxmfunct6 : unit -> vxmfunct6

$[complete]
function undefined_vxmfunct6 () = internal_pick([|VXM_VMADC, VXM_VMSBC|])

val vxmfunct6_of_num : forall ('e : Int), (0 <= 'e & 'e <= 1).
  int('e) -> vxmfunct6

$[complete]
function vxmfunct6_of_num arg# = $[complete] match arg# {
  0 => VXM_VMADC,
  _ => VXM_VMSBC
}

val num_of_vxmfunct6 : vxmfunct6 -> {('e : Int), (0 <= 'e & 'e <= 1). int('e)}

$[complete]
function num_of_vxmfunct6 arg# = $[complete] match arg# {
  VXM_VMADC => 0,
  VXM_VMSBC => 1
}

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum vxmcfunct6 = {VXMC_VMADC, VXMC_VMSBC}

val undefined_vxmcfunct6 : unit -> vxmcfunct6

$[complete]
function undefined_vxmcfunct6 () = internal_pick([|VXMC_VMADC, VXMC_VMSBC|])

val vxmcfunct6_of_num : forall ('e : Int), (0 <= 'e & 'e <= 1).
  int('e) -> vxmcfunct6

$[complete]
function vxmcfunct6_of_num arg# = $[complete] match arg# {
  0 => VXMC_VMADC,
  _ => VXMC_VMSBC
}

val num_of_vxmcfunct6 : vxmcfunct6 -> {('e : Int), (0 <= 'e & 'e <= 1). int('e)}

$[complete]
function num_of_vxmcfunct6 arg# = $[complete] match arg# {
  VXMC_VMADC => 0,
  VXMC_VMSBC => 1
}

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum vxmsfunct6 = {VXMS_VADC, VXMS_VSBC}

val undefined_vxmsfunct6 : unit -> vxmsfunct6

$[complete]
function undefined_vxmsfunct6 () = internal_pick([|VXMS_VADC, VXMS_VSBC|])

val vxmsfunct6_of_num : forall ('e : Int), (0 <= 'e & 'e <= 1).
  int('e) -> vxmsfunct6

$[complete]
function vxmsfunct6_of_num arg# = $[complete] match arg# {
  0 => VXMS_VADC,
  _ => VXMS_VSBC
}

val num_of_vxmsfunct6 : vxmsfunct6 -> {('e : Int), (0 <= 'e & 'e <= 1). int('e)}

$[complete]
function num_of_vxmsfunct6 arg# = $[complete] match arg# {
  VXMS_VADC => 0,
  VXMS_VSBC => 1
}

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum vimfunct6 = {VIM_VMADC}

val undefined_vimfunct6 : unit -> vimfunct6

$[complete]
function undefined_vimfunct6 () = internal_pick([|VIM_VMADC|])

val vimfunct6_of_num : forall ('e : Int), (0 <= 'e & 'e <= 0).
  int('e) -> vimfunct6

$[complete]
function vimfunct6_of_num arg# = $[complete] match arg# {_ => VIM_VMADC}

val num_of_vimfunct6 : vimfunct6 -> {('e : Int), (0 <= 'e & 'e <= 0). int('e)}

$[complete]
function num_of_vimfunct6 arg# = $[complete] match arg# {VIM_VMADC => 0}

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum vimcfunct6 = {VIMC_VMADC}

val undefined_vimcfunct6 : unit -> vimcfunct6

$[complete]
function undefined_vimcfunct6 () = internal_pick([|VIMC_VMADC|])

val vimcfunct6_of_num : forall ('e : Int), (0 <= 'e & 'e <= 0).
  int('e) -> vimcfunct6

$[complete]
function vimcfunct6_of_num arg# = $[complete] match arg# {_ => VIMC_VMADC}

val num_of_vimcfunct6 : vimcfunct6 -> {('e : Int), (0 <= 'e & 'e <= 0). int('e)}

$[complete]
function num_of_vimcfunct6 arg# = $[complete] match arg# {VIMC_VMADC => 0}

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum vimsfunct6 = {VIMS_VADC}

val undefined_vimsfunct6 : unit -> vimsfunct6

$[complete]
function undefined_vimsfunct6 () = internal_pick([|VIMS_VADC|])

val vimsfunct6_of_num : forall ('e : Int), (0 <= 'e & 'e <= 0).
  int('e) -> vimsfunct6

$[complete]
function vimsfunct6_of_num arg# = $[complete] match arg# {_ => VIMS_VADC}

val num_of_vimsfunct6 : vimsfunct6 -> {('e : Int), (0 <= 'e & 'e <= 0). int('e)}

$[complete]
function num_of_vimsfunct6 arg# = $[complete] match arg# {VIMS_VADC => 0}

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum vxcmpfunct6 = {
  VXCMP_VMSEQ,
  VXCMP_VMSNE,
  VXCMP_VMSLTU,
  VXCMP_VMSLT,
  VXCMP_VMSLEU,
  VXCMP_VMSLE,
  VXCMP_VMSGTU,
  VXCMP_VMSGT
}

val undefined_vxcmpfunct6 : unit -> vxcmpfunct6

$[complete]
function undefined_vxcmpfunct6 () = internal_pick([|VXCMP_VMSEQ, VXCMP_VMSNE, VXCMP_VMSLTU, VXCMP_VMSLT, VXCMP_VMSLEU, VXCMP_VMSLE, VXCMP_VMSGTU, VXCMP_VMSGT|])

val vxcmpfunct6_of_num : forall ('e : Int), (0 <= 'e & 'e <= 7).
  int('e) -> vxcmpfunct6

$[complete]
function vxcmpfunct6_of_num arg# = $[complete] match arg# {
  0 => VXCMP_VMSEQ,
  1 => VXCMP_VMSNE,
  2 => VXCMP_VMSLTU,
  3 => VXCMP_VMSLT,
  4 => VXCMP_VMSLEU,
  5 => VXCMP_VMSLE,
  6 => VXCMP_VMSGTU,
  _ => VXCMP_VMSGT
}

val num_of_vxcmpfunct6 : vxcmpfunct6 -> {('e : Int), (0 <= 'e & 'e <= 7). int('e)}

$[complete]
function num_of_vxcmpfunct6 arg# = $[complete] match arg# {
  VXCMP_VMSEQ => 0,
  VXCMP_VMSNE => 1,
  VXCMP_VMSLTU => 2,
  VXCMP_VMSLT => 3,
  VXCMP_VMSLEU => 4,
  VXCMP_VMSLE => 5,
  VXCMP_VMSGTU => 6,
  VXCMP_VMSGT => 7
}

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum vicmpfunct6 = {
  VICMP_VMSEQ,
  VICMP_VMSNE,
  VICMP_VMSLEU,
  VICMP_VMSLE,
  VICMP_VMSGTU,
  VICMP_VMSGT
}

val undefined_vicmpfunct6 : unit -> vicmpfunct6

$[complete]
function undefined_vicmpfunct6 () = internal_pick([|VICMP_VMSEQ, VICMP_VMSNE, VICMP_VMSLEU, VICMP_VMSLE, VICMP_VMSGTU, VICMP_VMSGT|])

val vicmpfunct6_of_num : forall ('e : Int), (0 <= 'e & 'e <= 5).
  int('e) -> vicmpfunct6

$[complete]
function vicmpfunct6_of_num arg# = $[complete] match arg# {
  0 => VICMP_VMSEQ,
  1 => VICMP_VMSNE,
  2 => VICMP_VMSLEU,
  3 => VICMP_VMSLE,
  4 => VICMP_VMSGTU,
  _ => VICMP_VMSGT
}

val num_of_vicmpfunct6 : vicmpfunct6 -> {('e : Int), (0 <= 'e & 'e <= 5). int('e)}

$[complete]
function num_of_vicmpfunct6 arg# = $[complete] match arg# {
  VICMP_VMSEQ => 0,
  VICMP_VMSNE => 1,
  VICMP_VMSLEU => 2,
  VICMP_VMSLE => 3,
  VICMP_VMSGTU => 4,
  VICMP_VMSGT => 5
}

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum nvfunct6 = {NV_VNCLIPU, NV_VNCLIP}

val undefined_nvfunct6 : unit -> nvfunct6

$[complete]
function undefined_nvfunct6 () = internal_pick([|NV_VNCLIPU, NV_VNCLIP|])

val nvfunct6_of_num : forall ('e : Int), (0 <= 'e & 'e <= 1).
  int('e) -> nvfunct6

$[complete]
function nvfunct6_of_num arg# = $[complete] match arg# {
  0 => NV_VNCLIPU,
  _ => NV_VNCLIP
}

val num_of_nvfunct6 : nvfunct6 -> {('e : Int), (0 <= 'e & 'e <= 1). int('e)}

$[complete]
function num_of_nvfunct6 arg# = $[complete] match arg# {
  NV_VNCLIPU => 0,
  NV_VNCLIP => 1
}

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum nvsfunct6 = {NVS_VNSRL, NVS_VNSRA}

val undefined_nvsfunct6 : unit -> nvsfunct6

$[complete]
function undefined_nvsfunct6 () = internal_pick([|NVS_VNSRL, NVS_VNSRA|])

val nvsfunct6_of_num : forall ('e : Int), (0 <= 'e & 'e <= 1).
  int('e) -> nvsfunct6

$[complete]
function nvsfunct6_of_num arg# = $[complete] match arg# {
  0 => NVS_VNSRL,
  _ => NVS_VNSRA
}

val num_of_nvsfunct6 : nvsfunct6 -> {('e : Int), (0 <= 'e & 'e <= 1). int('e)}

$[complete]
function num_of_nvsfunct6 arg# = $[complete] match arg# {
  NVS_VNSRL => 0,
  NVS_VNSRA => 1
}

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum nxfunct6 = {NX_VNCLIPU, NX_VNCLIP}

val undefined_nxfunct6 : unit -> nxfunct6

$[complete]
function undefined_nxfunct6 () = internal_pick([|NX_VNCLIPU, NX_VNCLIP|])

val nxfunct6_of_num : forall ('e : Int), (0 <= 'e & 'e <= 1).
  int('e) -> nxfunct6

$[complete]
function nxfunct6_of_num arg# = $[complete] match arg# {
  0 => NX_VNCLIPU,
  _ => NX_VNCLIP
}

val num_of_nxfunct6 : nxfunct6 -> {('e : Int), (0 <= 'e & 'e <= 1). int('e)}

$[complete]
function num_of_nxfunct6 arg# = $[complete] match arg# {
  NX_VNCLIPU => 0,
  NX_VNCLIP => 1
}

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum nxsfunct6 = {NXS_VNSRL, NXS_VNSRA}

val undefined_nxsfunct6 : unit -> nxsfunct6

$[complete]
function undefined_nxsfunct6 () = internal_pick([|NXS_VNSRL, NXS_VNSRA|])

val nxsfunct6_of_num : forall ('e : Int), (0 <= 'e & 'e <= 1).
  int('e) -> nxsfunct6

$[complete]
function nxsfunct6_of_num arg# = $[complete] match arg# {
  0 => NXS_VNSRL,
  _ => NXS_VNSRA
}

val num_of_nxsfunct6 : nxsfunct6 -> {('e : Int), (0 <= 'e & 'e <= 1). int('e)}

$[complete]
function num_of_nxsfunct6 arg# = $[complete] match arg# {
  NXS_VNSRL => 0,
  NXS_VNSRA => 1
}

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum mmfunct6 = {
  MM_VMAND,
  MM_VMNAND,
  MM_VMANDN,
  MM_VMXOR,
  MM_VMOR,
  MM_VMNOR,
  MM_VMORN,
  MM_VMXNOR
}

val undefined_mmfunct6 : unit -> mmfunct6

$[complete]
function undefined_mmfunct6 () = internal_pick([|MM_VMAND, MM_VMNAND, MM_VMANDN, MM_VMXOR, MM_VMOR, MM_VMNOR, MM_VMORN, MM_VMXNOR|])

val mmfunct6_of_num : forall ('e : Int), (0 <= 'e & 'e <= 7).
  int('e) -> mmfunct6

$[complete]
function mmfunct6_of_num arg# = $[complete] match arg# {
  0 => MM_VMAND,
  1 => MM_VMNAND,
  2 => MM_VMANDN,
  3 => MM_VMXOR,
  4 => MM_VMOR,
  5 => MM_VMNOR,
  6 => MM_VMORN,
  _ => MM_VMXNOR
}

val num_of_mmfunct6 : mmfunct6 -> {('e : Int), (0 <= 'e & 'e <= 7). int('e)}

$[complete]
function num_of_mmfunct6 arg# = $[complete] match arg# {
  MM_VMAND => 0,
  MM_VMNAND => 1,
  MM_VMANDN => 2,
  MM_VMXOR => 3,
  MM_VMOR => 4,
  MM_VMNOR => 5,
  MM_VMORN => 6,
  MM_VMXNOR => 7
}

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum nifunct6 = {NI_VNCLIPU, NI_VNCLIP}

val undefined_nifunct6 : unit -> nifunct6

$[complete]
function undefined_nifunct6 () = internal_pick([|NI_VNCLIPU, NI_VNCLIP|])

val nifunct6_of_num : forall ('e : Int), (0 <= 'e & 'e <= 1).
  int('e) -> nifunct6

$[complete]
function nifunct6_of_num arg# = $[complete] match arg# {
  0 => NI_VNCLIPU,
  _ => NI_VNCLIP
}

val num_of_nifunct6 : nifunct6 -> {('e : Int), (0 <= 'e & 'e <= 1). int('e)}

$[complete]
function num_of_nifunct6 arg# = $[complete] match arg# {
  NI_VNCLIPU => 0,
  NI_VNCLIP => 1
}

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum nisfunct6 = {NIS_VNSRL, NIS_VNSRA}

val undefined_nisfunct6 : unit -> nisfunct6

$[complete]
function undefined_nisfunct6 () = internal_pick([|NIS_VNSRL, NIS_VNSRA|])

val nisfunct6_of_num : forall ('e : Int), (0 <= 'e & 'e <= 1).
  int('e) -> nisfunct6

$[complete]
function nisfunct6_of_num arg# = $[complete] match arg# {
  0 => NIS_VNSRL,
  _ => NIS_VNSRA
}

val num_of_nisfunct6 : nisfunct6 -> {('e : Int), (0 <= 'e & 'e <= 1). int('e)}

$[complete]
function num_of_nisfunct6 arg# = $[complete] match arg# {
  NIS_VNSRL => 0,
  NIS_VNSRA => 1
}

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum wvvfunct6 = {
  WVV_VADD,
  WVV_VSUB,
  WVV_VADDU,
  WVV_VSUBU,
  WVV_VWMUL,
  WVV_VWMULU,
  WVV_VWMULSU
}

val undefined_wvvfunct6 : unit -> wvvfunct6

$[complete]
function undefined_wvvfunct6 () = internal_pick([|WVV_VADD, WVV_VSUB, WVV_VADDU, WVV_VSUBU, WVV_VWMUL, WVV_VWMULU, WVV_VWMULSU|])

val wvvfunct6_of_num : forall ('e : Int), (0 <= 'e & 'e <= 6).
  int('e) -> wvvfunct6

$[complete]
function wvvfunct6_of_num arg# = $[complete] match arg# {
  0 => WVV_VADD,
  1 => WVV_VSUB,
  2 => WVV_VADDU,
  3 => WVV_VSUBU,
  4 => WVV_VWMUL,
  5 => WVV_VWMULU,
  _ => WVV_VWMULSU
}

val num_of_wvvfunct6 : wvvfunct6 -> {('e : Int), (0 <= 'e & 'e <= 6). int('e)}

$[complete]
function num_of_wvvfunct6 arg# = $[complete] match arg# {
  WVV_VADD => 0,
  WVV_VSUB => 1,
  WVV_VADDU => 2,
  WVV_VSUBU => 3,
  WVV_VWMUL => 4,
  WVV_VWMULU => 5,
  WVV_VWMULSU => 6
}

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum wvfunct6 = {WV_VADD, WV_VSUB, WV_VADDU, WV_VSUBU}

val undefined_wvfunct6 : unit -> wvfunct6

$[complete]
function undefined_wvfunct6 () = internal_pick([|WV_VADD, WV_VSUB, WV_VADDU, WV_VSUBU|])

val wvfunct6_of_num : forall ('e : Int), (0 <= 'e & 'e <= 3).
  int('e) -> wvfunct6

$[complete]
function wvfunct6_of_num arg# = $[complete] match arg# {
  0 => WV_VADD,
  1 => WV_VSUB,
  2 => WV_VADDU,
  _ => WV_VSUBU
}

val num_of_wvfunct6 : wvfunct6 -> {('e : Int), (0 <= 'e & 'e <= 3). int('e)}

$[complete]
function num_of_wvfunct6 arg# = $[complete] match arg# {
  WV_VADD => 0,
  WV_VSUB => 1,
  WV_VADDU => 2,
  WV_VSUBU => 3
}

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum wvxfunct6 = {
  WVX_VADD,
  WVX_VSUB,
  WVX_VADDU,
  WVX_VSUBU,
  WVX_VWMUL,
  WVX_VWMULU,
  WVX_VWMULSU
}

val undefined_wvxfunct6 : unit -> wvxfunct6

$[complete]
function undefined_wvxfunct6 () = internal_pick([|WVX_VADD, WVX_VSUB, WVX_VADDU, WVX_VSUBU, WVX_VWMUL, WVX_VWMULU, WVX_VWMULSU|])

val wvxfunct6_of_num : forall ('e : Int), (0 <= 'e & 'e <= 6).
  int('e) -> wvxfunct6

$[complete]
function wvxfunct6_of_num arg# = $[complete] match arg# {
  0 => WVX_VADD,
  1 => WVX_VSUB,
  2 => WVX_VADDU,
  3 => WVX_VSUBU,
  4 => WVX_VWMUL,
  5 => WVX_VWMULU,
  _ => WVX_VWMULSU
}

val num_of_wvxfunct6 : wvxfunct6 -> {('e : Int), (0 <= 'e & 'e <= 6). int('e)}

$[complete]
function num_of_wvxfunct6 arg# = $[complete] match arg# {
  WVX_VADD => 0,
  WVX_VSUB => 1,
  WVX_VADDU => 2,
  WVX_VSUBU => 3,
  WVX_VWMUL => 4,
  WVX_VWMULU => 5,
  WVX_VWMULSU => 6
}

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum wxfunct6 = {WX_VADD, WX_VSUB, WX_VADDU, WX_VSUBU}

val undefined_wxfunct6 : unit -> wxfunct6

$[complete]
function undefined_wxfunct6 () = internal_pick([|WX_VADD, WX_VSUB, WX_VADDU, WX_VSUBU|])

val wxfunct6_of_num : forall ('e : Int), (0 <= 'e & 'e <= 3).
  int('e) -> wxfunct6

$[complete]
function wxfunct6_of_num arg# = $[complete] match arg# {
  0 => WX_VADD,
  1 => WX_VSUB,
  2 => WX_VADDU,
  _ => WX_VSUBU
}

val num_of_wxfunct6 : wxfunct6 -> {('e : Int), (0 <= 'e & 'e <= 3). int('e)}

$[complete]
function num_of_wxfunct6 arg# = $[complete] match arg# {
  WX_VADD => 0,
  WX_VSUB => 1,
  WX_VADDU => 2,
  WX_VSUBU => 3
}

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum vextfunct6 = {
  VEXT2_ZVF2,
  VEXT2_SVF2,
  VEXT4_ZVF4,
  VEXT4_SVF4,
  VEXT8_ZVF8,
  VEXT8_SVF8
}

val undefined_vextfunct6 : unit -> vextfunct6

$[complete]
function undefined_vextfunct6 () = internal_pick([|VEXT2_ZVF2, VEXT2_SVF2, VEXT4_ZVF4, VEXT4_SVF4, VEXT8_ZVF8, VEXT8_SVF8|])

val vextfunct6_of_num : forall ('e : Int), (0 <= 'e & 'e <= 5).
  int('e) -> vextfunct6

$[complete]
function vextfunct6_of_num arg# = $[complete] match arg# {
  0 => VEXT2_ZVF2,
  1 => VEXT2_SVF2,
  2 => VEXT4_ZVF4,
  3 => VEXT4_SVF4,
  4 => VEXT8_ZVF8,
  _ => VEXT8_SVF8
}

val num_of_vextfunct6 : vextfunct6 -> {('e : Int), (0 <= 'e & 'e <= 5). int('e)}

$[complete]
function num_of_vextfunct6 arg# = $[complete] match arg# {
  VEXT2_ZVF2 => 0,
  VEXT2_SVF2 => 1,
  VEXT4_ZVF4 => 2,
  VEXT4_SVF4 => 3,
  VEXT8_ZVF8 => 4,
  VEXT8_SVF8 => 5
}

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum vxfunct6 = {
  VX_VADD,
  VX_VSUB,
  VX_VRSUB,
  VX_VMINU,
  VX_VMIN,
  VX_VMAXU,
  VX_VMAX,
  VX_VAND,
  VX_VOR,
  VX_VXOR,
  VX_VSADDU,
  VX_VSADD,
  VX_VSSUBU,
  VX_VSSUB,
  VX_VSLL,
  VX_VSMUL,
  VX_VSRL,
  VX_VSRA,
  VX_VSSRL,
  VX_VSSRA
}

val undefined_vxfunct6 : unit -> vxfunct6

$[complete]
function undefined_vxfunct6 () = internal_pick([|VX_VADD, VX_VSUB, VX_VRSUB, VX_VMINU, VX_VMIN, VX_VMAXU, VX_VMAX, VX_VAND, VX_VOR, VX_VXOR, VX_VSADDU, VX_VSADD, VX_VSSUBU, VX_VSSUB, VX_VSLL, VX_VSMUL, VX_VSRL, VX_VSRA, VX_VSSRL, VX_VSSRA|])

val vxfunct6_of_num : forall ('e : Int), (0 <= 'e & 'e <= 19).
  int('e) -> vxfunct6

$[complete]
function vxfunct6_of_num arg# = $[complete] match arg# {
  0 => VX_VADD,
  1 => VX_VSUB,
  2 => VX_VRSUB,
  3 => VX_VMINU,
  4 => VX_VMIN,
  5 => VX_VMAXU,
  6 => VX_VMAX,
  7 => VX_VAND,
  8 => VX_VOR,
  9 => VX_VXOR,
  10 => VX_VSADDU,
  11 => VX_VSADD,
  12 => VX_VSSUBU,
  13 => VX_VSSUB,
  14 => VX_VSLL,
  15 => VX_VSMUL,
  16 => VX_VSRL,
  17 => VX_VSRA,
  18 => VX_VSSRL,
  _ => VX_VSSRA
}

val num_of_vxfunct6 : vxfunct6 -> {('e : Int), (0 <= 'e & 'e <= 19). int('e)}

$[complete]
function num_of_vxfunct6 arg# = $[complete] match arg# {
  VX_VADD => 0,
  VX_VSUB => 1,
  VX_VRSUB => 2,
  VX_VMINU => 3,
  VX_VMIN => 4,
  VX_VMAXU => 5,
  VX_VMAX => 6,
  VX_VAND => 7,
  VX_VOR => 8,
  VX_VXOR => 9,
  VX_VSADDU => 10,
  VX_VSADD => 11,
  VX_VSSUBU => 12,
  VX_VSSUB => 13,
  VX_VSLL => 14,
  VX_VSMUL => 15,
  VX_VSRL => 16,
  VX_VSRA => 17,
  VX_VSSRL => 18,
  VX_VSSRA => 19
}

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum vifunct6 = {
  VI_VADD,
  VI_VRSUB,
  VI_VAND,
  VI_VOR,
  VI_VXOR,
  VI_VSADDU,
  VI_VSADD,
  VI_VSLL,
  VI_VSRL,
  VI_VSRA,
  VI_VSSRL,
  VI_VSSRA
}

val undefined_vifunct6 : unit -> vifunct6

$[complete]
function undefined_vifunct6 () = internal_pick([|VI_VADD, VI_VRSUB, VI_VAND, VI_VOR, VI_VXOR, VI_VSADDU, VI_VSADD, VI_VSLL, VI_VSRL, VI_VSRA, VI_VSSRL, VI_VSSRA|])

val vifunct6_of_num : forall ('e : Int), (0 <= 'e & 'e <= 11).
  int('e) -> vifunct6

$[complete]
function vifunct6_of_num arg# = $[complete] match arg# {
  0 => VI_VADD,
  1 => VI_VRSUB,
  2 => VI_VAND,
  3 => VI_VOR,
  4 => VI_VXOR,
  5 => VI_VSADDU,
  6 => VI_VSADD,
  7 => VI_VSLL,
  8 => VI_VSRL,
  9 => VI_VSRA,
  10 => VI_VSSRL,
  _ => VI_VSSRA
}

val num_of_vifunct6 : vifunct6 -> {('e : Int), (0 <= 'e & 'e <= 11). int('e)}

$[complete]
function num_of_vifunct6 arg# = $[complete] match arg# {
  VI_VADD => 0,
  VI_VRSUB => 1,
  VI_VAND => 2,
  VI_VOR => 3,
  VI_VXOR => 4,
  VI_VSADDU => 5,
  VI_VSADD => 6,
  VI_VSLL => 7,
  VI_VSRL => 8,
  VI_VSRA => 9,
  VI_VSSRL => 10,
  VI_VSSRA => 11
}

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum vxsgfunct6 = {VX_VSLIDEUP, VX_VSLIDEDOWN, VX_VRGATHER}

val undefined_vxsgfunct6 : unit -> vxsgfunct6

$[complete]
function undefined_vxsgfunct6 () = internal_pick([|VX_VSLIDEUP, VX_VSLIDEDOWN, VX_VRGATHER|])

val vxsgfunct6_of_num : forall ('e : Int), (0 <= 'e & 'e <= 2).
  int('e) -> vxsgfunct6

$[complete]
function vxsgfunct6_of_num arg# = $[complete] match arg# {
  0 => VX_VSLIDEUP,
  1 => VX_VSLIDEDOWN,
  _ => VX_VRGATHER
}

val num_of_vxsgfunct6 : vxsgfunct6 -> {('e : Int), (0 <= 'e & 'e <= 2). int('e)}

$[complete]
function num_of_vxsgfunct6 arg# = $[complete] match arg# {
  VX_VSLIDEUP => 0,
  VX_VSLIDEDOWN => 1,
  VX_VRGATHER => 2
}

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum visgfunct6 = {VI_VSLIDEUP, VI_VSLIDEDOWN, VI_VRGATHER}

val undefined_visgfunct6 : unit -> visgfunct6

$[complete]
function undefined_visgfunct6 () = internal_pick([|VI_VSLIDEUP, VI_VSLIDEDOWN, VI_VRGATHER|])

val visgfunct6_of_num : forall ('e : Int), (0 <= 'e & 'e <= 2).
  int('e) -> visgfunct6

$[complete]
function visgfunct6_of_num arg# = $[complete] match arg# {
  0 => VI_VSLIDEUP,
  1 => VI_VSLIDEDOWN,
  _ => VI_VRGATHER
}

val num_of_visgfunct6 : visgfunct6 -> {('e : Int), (0 <= 'e & 'e <= 2). int('e)}

$[complete]
function num_of_visgfunct6 arg# = $[complete] match arg# {
  VI_VSLIDEUP => 0,
  VI_VSLIDEDOWN => 1,
  VI_VRGATHER => 2
}

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum mvvfunct6 = {
  MVV_VAADDU,
  MVV_VAADD,
  MVV_VASUBU,
  MVV_VASUB,
  MVV_VMUL,
  MVV_VMULH,
  MVV_VMULHU,
  MVV_VMULHSU,
  MVV_VDIVU,
  MVV_VDIV,
  MVV_VREMU,
  MVV_VREM
}

val undefined_mvvfunct6 : unit -> mvvfunct6

$[complete]
function undefined_mvvfunct6 () = internal_pick([|MVV_VAADDU, MVV_VAADD, MVV_VASUBU, MVV_VASUB, MVV_VMUL, MVV_VMULH, MVV_VMULHU, MVV_VMULHSU, MVV_VDIVU, MVV_VDIV, MVV_VREMU, MVV_VREM|])

val mvvfunct6_of_num : forall ('e : Int), (0 <= 'e & 'e <= 11).
  int('e) -> mvvfunct6

$[complete]
function mvvfunct6_of_num arg# = $[complete] match arg# {
  0 => MVV_VAADDU,
  1 => MVV_VAADD,
  2 => MVV_VASUBU,
  3 => MVV_VASUB,
  4 => MVV_VMUL,
  5 => MVV_VMULH,
  6 => MVV_VMULHU,
  7 => MVV_VMULHSU,
  8 => MVV_VDIVU,
  9 => MVV_VDIV,
  10 => MVV_VREMU,
  _ => MVV_VREM
}

val num_of_mvvfunct6 : mvvfunct6 -> {('e : Int), (0 <= 'e & 'e <= 11). int('e)}

$[complete]
function num_of_mvvfunct6 arg# = $[complete] match arg# {
  MVV_VAADDU => 0,
  MVV_VAADD => 1,
  MVV_VASUBU => 2,
  MVV_VASUB => 3,
  MVV_VMUL => 4,
  MVV_VMULH => 5,
  MVV_VMULHU => 6,
  MVV_VMULHSU => 7,
  MVV_VDIVU => 8,
  MVV_VDIV => 9,
  MVV_VREMU => 10,
  MVV_VREM => 11
}

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum mvvmafunct6 = {MVV_VMACC, MVV_VNMSAC, MVV_VMADD, MVV_VNMSUB}

val undefined_mvvmafunct6 : unit -> mvvmafunct6

$[complete]
function undefined_mvvmafunct6 () = internal_pick([|MVV_VMACC, MVV_VNMSAC, MVV_VMADD, MVV_VNMSUB|])

val mvvmafunct6_of_num : forall ('e : Int), (0 <= 'e & 'e <= 3).
  int('e) -> mvvmafunct6

$[complete]
function mvvmafunct6_of_num arg# = $[complete] match arg# {
  0 => MVV_VMACC,
  1 => MVV_VNMSAC,
  2 => MVV_VMADD,
  _ => MVV_VNMSUB
}

val num_of_mvvmafunct6 : mvvmafunct6 -> {('e : Int), (0 <= 'e & 'e <= 3). int('e)}

$[complete]
function num_of_mvvmafunct6 arg# = $[complete] match arg# {
  MVV_VMACC => 0,
  MVV_VNMSAC => 1,
  MVV_VMADD => 2,
  MVV_VNMSUB => 3
}

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum rmvvfunct6 = {
  MVV_VREDSUM,
  MVV_VREDAND,
  MVV_VREDOR,
  MVV_VREDXOR,
  MVV_VREDMINU,
  MVV_VREDMIN,
  MVV_VREDMAXU,
  MVV_VREDMAX
}

val undefined_rmvvfunct6 : unit -> rmvvfunct6

$[complete]
function undefined_rmvvfunct6 () = internal_pick([|MVV_VREDSUM, MVV_VREDAND, MVV_VREDOR, MVV_VREDXOR, MVV_VREDMINU, MVV_VREDMIN, MVV_VREDMAXU, MVV_VREDMAX|])

val rmvvfunct6_of_num : forall ('e : Int), (0 <= 'e & 'e <= 7).
  int('e) -> rmvvfunct6

$[complete]
function rmvvfunct6_of_num arg# = $[complete] match arg# {
  0 => MVV_VREDSUM,
  1 => MVV_VREDAND,
  2 => MVV_VREDOR,
  3 => MVV_VREDXOR,
  4 => MVV_VREDMINU,
  5 => MVV_VREDMIN,
  6 => MVV_VREDMAXU,
  _ => MVV_VREDMAX
}

val num_of_rmvvfunct6 : rmvvfunct6 -> {('e : Int), (0 <= 'e & 'e <= 7). int('e)}

$[complete]
function num_of_rmvvfunct6 arg# = $[complete] match arg# {
  MVV_VREDSUM => 0,
  MVV_VREDAND => 1,
  MVV_VREDOR => 2,
  MVV_VREDXOR => 3,
  MVV_VREDMINU => 4,
  MVV_VREDMIN => 5,
  MVV_VREDMAXU => 6,
  MVV_VREDMAX => 7
}

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum rivvfunct6 = {IVV_VWREDSUMU, IVV_VWREDSUM}

val undefined_rivvfunct6 : unit -> rivvfunct6

$[complete]
function undefined_rivvfunct6 () = internal_pick([|IVV_VWREDSUMU, IVV_VWREDSUM|])

val rivvfunct6_of_num : forall ('e : Int), (0 <= 'e & 'e <= 1).
  int('e) -> rivvfunct6

$[complete]
function rivvfunct6_of_num arg# = $[complete] match arg# {
  0 => IVV_VWREDSUMU,
  _ => IVV_VWREDSUM
}

val num_of_rivvfunct6 : rivvfunct6 -> {('e : Int), (0 <= 'e & 'e <= 1). int('e)}

$[complete]
function num_of_rivvfunct6 arg# = $[complete] match arg# {
  IVV_VWREDSUMU => 0,
  IVV_VWREDSUM => 1
}

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum rfvvfunct6 = {
  FVV_VFREDOSUM,
  FVV_VFREDUSUM,
  FVV_VFREDMAX,
  FVV_VFREDMIN,
  FVV_VFWREDOSUM,
  FVV_VFWREDUSUM
}

val undefined_rfvvfunct6 : unit -> rfvvfunct6

$[complete]
function undefined_rfvvfunct6 () = internal_pick([|FVV_VFREDOSUM, FVV_VFREDUSUM, FVV_VFREDMAX, FVV_VFREDMIN, FVV_VFWREDOSUM, FVV_VFWREDUSUM|])

val rfvvfunct6_of_num : forall ('e : Int), (0 <= 'e & 'e <= 5).
  int('e) -> rfvvfunct6

$[complete]
function rfvvfunct6_of_num arg# = $[complete] match arg# {
  0 => FVV_VFREDOSUM,
  1 => FVV_VFREDUSUM,
  2 => FVV_VFREDMAX,
  3 => FVV_VFREDMIN,
  4 => FVV_VFWREDOSUM,
  _ => FVV_VFWREDUSUM
}

val num_of_rfvvfunct6 : rfvvfunct6 -> {('e : Int), (0 <= 'e & 'e <= 5). int('e)}

$[complete]
function num_of_rfvvfunct6 arg# = $[complete] match arg# {
  FVV_VFREDOSUM => 0,
  FVV_VFREDUSUM => 1,
  FVV_VFREDMAX => 2,
  FVV_VFREDMIN => 3,
  FVV_VFWREDOSUM => 4,
  FVV_VFWREDUSUM => 5
}

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum wmvvfunct6 = {WMVV_VWMACCU, WMVV_VWMACC, WMVV_VWMACCSU}

val undefined_wmvvfunct6 : unit -> wmvvfunct6

$[complete]
function undefined_wmvvfunct6 () = internal_pick([|WMVV_VWMACCU, WMVV_VWMACC, WMVV_VWMACCSU|])

val wmvvfunct6_of_num : forall ('e : Int), (0 <= 'e & 'e <= 2).
  int('e) -> wmvvfunct6

$[complete]
function wmvvfunct6_of_num arg# = $[complete] match arg# {
  0 => WMVV_VWMACCU,
  1 => WMVV_VWMACC,
  _ => WMVV_VWMACCSU
}

val num_of_wmvvfunct6 : wmvvfunct6 -> {('e : Int), (0 <= 'e & 'e <= 2). int('e)}

$[complete]
function num_of_wmvvfunct6 arg# = $[complete] match arg# {
  WMVV_VWMACCU => 0,
  WMVV_VWMACC => 1,
  WMVV_VWMACCSU => 2
}

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum mvxfunct6 = {
  MVX_VAADDU,
  MVX_VAADD,
  MVX_VASUBU,
  MVX_VASUB,
  MVX_VSLIDE1UP,
  MVX_VSLIDE1DOWN,
  MVX_VMUL,
  MVX_VMULH,
  MVX_VMULHU,
  MVX_VMULHSU,
  MVX_VDIVU,
  MVX_VDIV,
  MVX_VREMU,
  MVX_VREM
}

val undefined_mvxfunct6 : unit -> mvxfunct6

$[complete]
function undefined_mvxfunct6 () = internal_pick([|MVX_VAADDU, MVX_VAADD, MVX_VASUBU, MVX_VASUB, MVX_VSLIDE1UP, MVX_VSLIDE1DOWN, MVX_VMUL, MVX_VMULH, MVX_VMULHU, MVX_VMULHSU, MVX_VDIVU, MVX_VDIV, MVX_VREMU, MVX_VREM|])

val mvxfunct6_of_num : forall ('e : Int), (0 <= 'e & 'e <= 13).
  int('e) -> mvxfunct6

$[complete]
function mvxfunct6_of_num arg# = $[complete] match arg# {
  0 => MVX_VAADDU,
  1 => MVX_VAADD,
  2 => MVX_VASUBU,
  3 => MVX_VASUB,
  4 => MVX_VSLIDE1UP,
  5 => MVX_VSLIDE1DOWN,
  6 => MVX_VMUL,
  7 => MVX_VMULH,
  8 => MVX_VMULHU,
  9 => MVX_VMULHSU,
  10 => MVX_VDIVU,
  11 => MVX_VDIV,
  12 => MVX_VREMU,
  _ => MVX_VREM
}

val num_of_mvxfunct6 : mvxfunct6 -> {('e : Int), (0 <= 'e & 'e <= 13). int('e)}

$[complete]
function num_of_mvxfunct6 arg# = $[complete] match arg# {
  MVX_VAADDU => 0,
  MVX_VAADD => 1,
  MVX_VASUBU => 2,
  MVX_VASUB => 3,
  MVX_VSLIDE1UP => 4,
  MVX_VSLIDE1DOWN => 5,
  MVX_VMUL => 6,
  MVX_VMULH => 7,
  MVX_VMULHU => 8,
  MVX_VMULHSU => 9,
  MVX_VDIVU => 10,
  MVX_VDIV => 11,
  MVX_VREMU => 12,
  MVX_VREM => 13
}

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum mvxmafunct6 = {MVX_VMACC, MVX_VNMSAC, MVX_VMADD, MVX_VNMSUB}

val undefined_mvxmafunct6 : unit -> mvxmafunct6

$[complete]
function undefined_mvxmafunct6 () = internal_pick([|MVX_VMACC, MVX_VNMSAC, MVX_VMADD, MVX_VNMSUB|])

val mvxmafunct6_of_num : forall ('e : Int), (0 <= 'e & 'e <= 3).
  int('e) -> mvxmafunct6

$[complete]
function mvxmafunct6_of_num arg# = $[complete] match arg# {
  0 => MVX_VMACC,
  1 => MVX_VNMSAC,
  2 => MVX_VMADD,
  _ => MVX_VNMSUB
}

val num_of_mvxmafunct6 : mvxmafunct6 -> {('e : Int), (0 <= 'e & 'e <= 3). int('e)}

$[complete]
function num_of_mvxmafunct6 arg# = $[complete] match arg# {
  MVX_VMACC => 0,
  MVX_VNMSAC => 1,
  MVX_VMADD => 2,
  MVX_VNMSUB => 3
}

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum wmvxfunct6 = {WMVX_VWMACCU, WMVX_VWMACC, WMVX_VWMACCUS, WMVX_VWMACCSU}

val undefined_wmvxfunct6 : unit -> wmvxfunct6

$[complete]
function undefined_wmvxfunct6 () = internal_pick([|WMVX_VWMACCU, WMVX_VWMACC, WMVX_VWMACCUS, WMVX_VWMACCSU|])

val wmvxfunct6_of_num : forall ('e : Int), (0 <= 'e & 'e <= 3).
  int('e) -> wmvxfunct6

$[complete]
function wmvxfunct6_of_num arg# = $[complete] match arg# {
  0 => WMVX_VWMACCU,
  1 => WMVX_VWMACC,
  2 => WMVX_VWMACCUS,
  _ => WMVX_VWMACCSU
}

val num_of_wmvxfunct6 : wmvxfunct6 -> {('e : Int), (0 <= 'e & 'e <= 3). int('e)}

$[complete]
function num_of_wmvxfunct6 arg# = $[complete] match arg# {
  WMVX_VWMACCU => 0,
  WMVX_VWMACC => 1,
  WMVX_VWMACCUS => 2,
  WMVX_VWMACCSU => 3
}

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum maskfunct3 = {VV_VMERGE, VI_VMERGE, VX_VMERGE}

val undefined_maskfunct3 : unit -> maskfunct3

$[complete]
function undefined_maskfunct3 () = internal_pick([|VV_VMERGE, VI_VMERGE, VX_VMERGE|])

val maskfunct3_of_num : forall ('e : Int), (0 <= 'e & 'e <= 2).
  int('e) -> maskfunct3

$[complete]
function maskfunct3_of_num arg# = $[complete] match arg# {
  0 => VV_VMERGE,
  1 => VI_VMERGE,
  _ => VX_VMERGE
}

val num_of_maskfunct3 : maskfunct3 -> {('e : Int), (0 <= 'e & 'e <= 2). int('e)}

$[complete]
function num_of_maskfunct3 arg# = $[complete] match arg# {
  VV_VMERGE => 0,
  VI_VMERGE => 1,
  VX_VMERGE => 2
}

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum vlewidth = {VLE8, VLE16, VLE32, VLE64}

val undefined_vlewidth : unit -> vlewidth

$[complete]
function undefined_vlewidth () = internal_pick([|VLE8, VLE16, VLE32, VLE64|])

val vlewidth_of_num : forall ('e : Int), (0 <= 'e & 'e <= 3).
  int('e) -> vlewidth

$[complete]
function vlewidth_of_num arg# = $[complete] match arg# {
  0 => VLE8,
  1 => VLE16,
  2 => VLE32,
  _ => VLE64
}

val num_of_vlewidth : vlewidth -> {('e : Int), (0 <= 'e & 'e <= 3). int('e)}

$[complete]
function num_of_vlewidth arg# = $[complete] match arg# {
  VLE8 => 0,
  VLE16 => 1,
  VLE32 => 2,
  VLE64 => 3
}

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum fvvfunct6 = {
  FVV_VADD,
  FVV_VSUB,
  FVV_VMIN,
  FVV_VMAX,
  FVV_VSGNJ,
  FVV_VSGNJN,
  FVV_VSGNJX,
  FVV_VDIV,
  FVV_VMUL
}

val undefined_fvvfunct6 : unit -> fvvfunct6

$[complete]
function undefined_fvvfunct6 () = internal_pick([|FVV_VADD, FVV_VSUB, FVV_VMIN, FVV_VMAX, FVV_VSGNJ, FVV_VSGNJN, FVV_VSGNJX, FVV_VDIV, FVV_VMUL|])

val fvvfunct6_of_num : forall ('e : Int), (0 <= 'e & 'e <= 8).
  int('e) -> fvvfunct6

$[complete]
function fvvfunct6_of_num arg# = $[complete] match arg# {
  0 => FVV_VADD,
  1 => FVV_VSUB,
  2 => FVV_VMIN,
  3 => FVV_VMAX,
  4 => FVV_VSGNJ,
  5 => FVV_VSGNJN,
  6 => FVV_VSGNJX,
  7 => FVV_VDIV,
  _ => FVV_VMUL
}

val num_of_fvvfunct6 : fvvfunct6 -> {('e : Int), (0 <= 'e & 'e <= 8). int('e)}

$[complete]
function num_of_fvvfunct6 arg# = $[complete] match arg# {
  FVV_VADD => 0,
  FVV_VSUB => 1,
  FVV_VMIN => 2,
  FVV_VMAX => 3,
  FVV_VSGNJ => 4,
  FVV_VSGNJN => 5,
  FVV_VSGNJX => 6,
  FVV_VDIV => 7,
  FVV_VMUL => 8
}

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum fvvmafunct6 = {
  FVV_VMADD,
  FVV_VNMADD,
  FVV_VMSUB,
  FVV_VNMSUB,
  FVV_VMACC,
  FVV_VNMACC,
  FVV_VMSAC,
  FVV_VNMSAC
}

val undefined_fvvmafunct6 : unit -> fvvmafunct6

$[complete]
function undefined_fvvmafunct6 () = internal_pick([|FVV_VMADD, FVV_VNMADD, FVV_VMSUB, FVV_VNMSUB, FVV_VMACC, FVV_VNMACC, FVV_VMSAC, FVV_VNMSAC|])

val fvvmafunct6_of_num : forall ('e : Int), (0 <= 'e & 'e <= 7).
  int('e) -> fvvmafunct6

$[complete]
function fvvmafunct6_of_num arg# = $[complete] match arg# {
  0 => FVV_VMADD,
  1 => FVV_VNMADD,
  2 => FVV_VMSUB,
  3 => FVV_VNMSUB,
  4 => FVV_VMACC,
  5 => FVV_VNMACC,
  6 => FVV_VMSAC,
  _ => FVV_VNMSAC
}

val num_of_fvvmafunct6 : fvvmafunct6 -> {('e : Int), (0 <= 'e & 'e <= 7). int('e)}

$[complete]
function num_of_fvvmafunct6 arg# = $[complete] match arg# {
  FVV_VMADD => 0,
  FVV_VNMADD => 1,
  FVV_VMSUB => 2,
  FVV_VNMSUB => 3,
  FVV_VMACC => 4,
  FVV_VNMACC => 5,
  FVV_VMSAC => 6,
  FVV_VNMSAC => 7
}

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum fwvvfunct6 = {FWVV_VADD, FWVV_VSUB, FWVV_VMUL}

val undefined_fwvvfunct6 : unit -> fwvvfunct6

$[complete]
function undefined_fwvvfunct6 () = internal_pick([|FWVV_VADD, FWVV_VSUB, FWVV_VMUL|])

val fwvvfunct6_of_num : forall ('e : Int), (0 <= 'e & 'e <= 2).
  int('e) -> fwvvfunct6

$[complete]
function fwvvfunct6_of_num arg# = $[complete] match arg# {
  0 => FWVV_VADD,
  1 => FWVV_VSUB,
  _ => FWVV_VMUL
}

val num_of_fwvvfunct6 : fwvvfunct6 -> {('e : Int), (0 <= 'e & 'e <= 2). int('e)}

$[complete]
function num_of_fwvvfunct6 arg# = $[complete] match arg# {
  FWVV_VADD => 0,
  FWVV_VSUB => 1,
  FWVV_VMUL => 2
}

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum fwvvmafunct6 = {FWVV_VMACC, FWVV_VNMACC, FWVV_VMSAC, FWVV_VNMSAC}

val undefined_fwvvmafunct6 : unit -> fwvvmafunct6

$[complete]
function undefined_fwvvmafunct6 () = internal_pick([|FWVV_VMACC, FWVV_VNMACC, FWVV_VMSAC, FWVV_VNMSAC|])

val fwvvmafunct6_of_num : forall ('e : Int), (0 <= 'e & 'e <= 3).
  int('e) -> fwvvmafunct6

$[complete]
function fwvvmafunct6_of_num arg# = $[complete] match arg# {
  0 => FWVV_VMACC,
  1 => FWVV_VNMACC,
  2 => FWVV_VMSAC,
  _ => FWVV_VNMSAC
}

val num_of_fwvvmafunct6 : fwvvmafunct6 -> {('e : Int), (0 <= 'e & 'e <= 3). int('e)}

$[complete]
function num_of_fwvvmafunct6 arg# = $[complete] match arg# {
  FWVV_VMACC => 0,
  FWVV_VNMACC => 1,
  FWVV_VMSAC => 2,
  FWVV_VNMSAC => 3
}

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum fwvfunct6 = {FWV_VADD, FWV_VSUB}

val undefined_fwvfunct6 : unit -> fwvfunct6

$[complete]
function undefined_fwvfunct6 () = internal_pick([|FWV_VADD, FWV_VSUB|])

val fwvfunct6_of_num : forall ('e : Int), (0 <= 'e & 'e <= 1).
  int('e) -> fwvfunct6

$[complete]
function fwvfunct6_of_num arg# = $[complete] match arg# {
  0 => FWV_VADD,
  _ => FWV_VSUB
}

val num_of_fwvfunct6 : fwvfunct6 -> {('e : Int), (0 <= 'e & 'e <= 1). int('e)}

$[complete]
function num_of_fwvfunct6 arg# = $[complete] match arg# {
  FWV_VADD => 0,
  FWV_VSUB => 1
}

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum fvvmfunct6 = {FVVM_VMFEQ, FVVM_VMFLE, FVVM_VMFLT, FVVM_VMFNE}

val undefined_fvvmfunct6 : unit -> fvvmfunct6

$[complete]
function undefined_fvvmfunct6 () = internal_pick([|FVVM_VMFEQ, FVVM_VMFLE, FVVM_VMFLT, FVVM_VMFNE|])

val fvvmfunct6_of_num : forall ('e : Int), (0 <= 'e & 'e <= 3).
  int('e) -> fvvmfunct6

$[complete]
function fvvmfunct6_of_num arg# = $[complete] match arg# {
  0 => FVVM_VMFEQ,
  1 => FVVM_VMFLE,
  2 => FVVM_VMFLT,
  _ => FVVM_VMFNE
}

val num_of_fvvmfunct6 : fvvmfunct6 -> {('e : Int), (0 <= 'e & 'e <= 3). int('e)}

$[complete]
function num_of_fvvmfunct6 arg# = $[complete] match arg# {
  FVVM_VMFEQ => 0,
  FVVM_VMFLE => 1,
  FVVM_VMFLT => 2,
  FVVM_VMFNE => 3
}

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum vfunary0 = {
  FV_CVT_XU_F,
  FV_CVT_X_F,
  FV_CVT_F_XU,
  FV_CVT_F_X,
  FV_CVT_RTZ_XU_F,
  FV_CVT_RTZ_X_F
}

val undefined_vfunary0 : unit -> vfunary0

$[complete]
function undefined_vfunary0 () = internal_pick([|FV_CVT_XU_F, FV_CVT_X_F, FV_CVT_F_XU, FV_CVT_F_X, FV_CVT_RTZ_XU_F, FV_CVT_RTZ_X_F|])

val vfunary0_of_num : forall ('e : Int), (0 <= 'e & 'e <= 5).
  int('e) -> vfunary0

$[complete]
function vfunary0_of_num arg# = $[complete] match arg# {
  0 => FV_CVT_XU_F,
  1 => FV_CVT_X_F,
  2 => FV_CVT_F_XU,
  3 => FV_CVT_F_X,
  4 => FV_CVT_RTZ_XU_F,
  _ => FV_CVT_RTZ_X_F
}

val num_of_vfunary0 : vfunary0 -> {('e : Int), (0 <= 'e & 'e <= 5). int('e)}

$[complete]
function num_of_vfunary0 arg# = $[complete] match arg# {
  FV_CVT_XU_F => 0,
  FV_CVT_X_F => 1,
  FV_CVT_F_XU => 2,
  FV_CVT_F_X => 3,
  FV_CVT_RTZ_XU_F => 4,
  FV_CVT_RTZ_X_F => 5
}

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum vfwunary0 = {
  FWV_CVT_XU_F,
  FWV_CVT_X_F,
  FWV_CVT_F_XU,
  FWV_CVT_F_X,
  FWV_CVT_F_F,
  FWV_CVT_RTZ_XU_F,
  FWV_CVT_RTZ_X_F
}

val undefined_vfwunary0 : unit -> vfwunary0

$[complete]
function undefined_vfwunary0 () = internal_pick([|FWV_CVT_XU_F, FWV_CVT_X_F, FWV_CVT_F_XU, FWV_CVT_F_X, FWV_CVT_F_F, FWV_CVT_RTZ_XU_F, FWV_CVT_RTZ_X_F|])

val vfwunary0_of_num : forall ('e : Int), (0 <= 'e & 'e <= 6).
  int('e) -> vfwunary0

$[complete]
function vfwunary0_of_num arg# = $[complete] match arg# {
  0 => FWV_CVT_XU_F,
  1 => FWV_CVT_X_F,
  2 => FWV_CVT_F_XU,
  3 => FWV_CVT_F_X,
  4 => FWV_CVT_F_F,
  5 => FWV_CVT_RTZ_XU_F,
  _ => FWV_CVT_RTZ_X_F
}

val num_of_vfwunary0 : vfwunary0 -> {('e : Int), (0 <= 'e & 'e <= 6). int('e)}

$[complete]
function num_of_vfwunary0 arg# = $[complete] match arg# {
  FWV_CVT_XU_F => 0,
  FWV_CVT_X_F => 1,
  FWV_CVT_F_XU => 2,
  FWV_CVT_F_X => 3,
  FWV_CVT_F_F => 4,
  FWV_CVT_RTZ_XU_F => 5,
  FWV_CVT_RTZ_X_F => 6
}

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum vfnunary0 = {
  FNV_CVT_XU_F,
  FNV_CVT_X_F,
  FNV_CVT_F_XU,
  FNV_CVT_F_X,
  FNV_CVT_F_F,
  FNV_CVT_ROD_F_F,
  FNV_CVT_RTZ_XU_F,
  FNV_CVT_RTZ_X_F
}

val undefined_vfnunary0 : unit -> vfnunary0

$[complete]
function undefined_vfnunary0 () = internal_pick([|FNV_CVT_XU_F, FNV_CVT_X_F, FNV_CVT_F_XU, FNV_CVT_F_X, FNV_CVT_F_F, FNV_CVT_ROD_F_F, FNV_CVT_RTZ_XU_F, FNV_CVT_RTZ_X_F|])

val vfnunary0_of_num : forall ('e : Int), (0 <= 'e & 'e <= 7).
  int('e) -> vfnunary0

$[complete]
function vfnunary0_of_num arg# = $[complete] match arg# {
  0 => FNV_CVT_XU_F,
  1 => FNV_CVT_X_F,
  2 => FNV_CVT_F_XU,
  3 => FNV_CVT_F_X,
  4 => FNV_CVT_F_F,
  5 => FNV_CVT_ROD_F_F,
  6 => FNV_CVT_RTZ_XU_F,
  _ => FNV_CVT_RTZ_X_F
}

val num_of_vfnunary0 : vfnunary0 -> {('e : Int), (0 <= 'e & 'e <= 7). int('e)}

$[complete]
function num_of_vfnunary0 arg# = $[complete] match arg# {
  FNV_CVT_XU_F => 0,
  FNV_CVT_X_F => 1,
  FNV_CVT_F_XU => 2,
  FNV_CVT_F_X => 3,
  FNV_CVT_F_F => 4,
  FNV_CVT_ROD_F_F => 5,
  FNV_CVT_RTZ_XU_F => 6,
  FNV_CVT_RTZ_X_F => 7
}

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum vfunary1 = {FVV_VSQRT, FVV_VRSQRT7, FVV_VREC7, FVV_VCLASS}

val undefined_vfunary1 : unit -> vfunary1

$[complete]
function undefined_vfunary1 () = internal_pick([|FVV_VSQRT, FVV_VRSQRT7, FVV_VREC7, FVV_VCLASS|])

val vfunary1_of_num : forall ('e : Int), (0 <= 'e & 'e <= 3).
  int('e) -> vfunary1

$[complete]
function vfunary1_of_num arg# = $[complete] match arg# {
  0 => FVV_VSQRT,
  1 => FVV_VRSQRT7,
  2 => FVV_VREC7,
  _ => FVV_VCLASS
}

val num_of_vfunary1 : vfunary1 -> {('e : Int), (0 <= 'e & 'e <= 3). int('e)}

$[complete]
function num_of_vfunary1 arg# = $[complete] match arg# {
  FVV_VSQRT => 0,
  FVV_VRSQRT7 => 1,
  FVV_VREC7 => 2,
  FVV_VCLASS => 3
}

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum fvffunct6 = {
  VF_VADD,
  VF_VSUB,
  VF_VMIN,
  VF_VMAX,
  VF_VSGNJ,
  VF_VSGNJN,
  VF_VSGNJX,
  VF_VDIV,
  VF_VRDIV,
  VF_VMUL,
  VF_VRSUB,
  VF_VSLIDE1UP,
  VF_VSLIDE1DOWN
}

val undefined_fvffunct6 : unit -> fvffunct6

$[complete]
function undefined_fvffunct6 () = internal_pick([|VF_VADD, VF_VSUB, VF_VMIN, VF_VMAX, VF_VSGNJ, VF_VSGNJN, VF_VSGNJX, VF_VDIV, VF_VRDIV, VF_VMUL, VF_VRSUB, VF_VSLIDE1UP, VF_VSLIDE1DOWN|])

val fvffunct6_of_num : forall ('e : Int), (0 <= 'e & 'e <= 12).
  int('e) -> fvffunct6

$[complete]
function fvffunct6_of_num arg# = $[complete] match arg# {
  0 => VF_VADD,
  1 => VF_VSUB,
  2 => VF_VMIN,
  3 => VF_VMAX,
  4 => VF_VSGNJ,
  5 => VF_VSGNJN,
  6 => VF_VSGNJX,
  7 => VF_VDIV,
  8 => VF_VRDIV,
  9 => VF_VMUL,
  10 => VF_VRSUB,
  11 => VF_VSLIDE1UP,
  _ => VF_VSLIDE1DOWN
}

val num_of_fvffunct6 : fvffunct6 -> {('e : Int), (0 <= 'e & 'e <= 12). int('e)}

$[complete]
function num_of_fvffunct6 arg# = $[complete] match arg# {
  VF_VADD => 0,
  VF_VSUB => 1,
  VF_VMIN => 2,
  VF_VMAX => 3,
  VF_VSGNJ => 4,
  VF_VSGNJN => 5,
  VF_VSGNJX => 6,
  VF_VDIV => 7,
  VF_VRDIV => 8,
  VF_VMUL => 9,
  VF_VRSUB => 10,
  VF_VSLIDE1UP => 11,
  VF_VSLIDE1DOWN => 12
}

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum fvfmafunct6 = {
  VF_VMADD,
  VF_VNMADD,
  VF_VMSUB,
  VF_VNMSUB,
  VF_VMACC,
  VF_VNMACC,
  VF_VMSAC,
  VF_VNMSAC
}

val undefined_fvfmafunct6 : unit -> fvfmafunct6

$[complete]
function undefined_fvfmafunct6 () = internal_pick([|VF_VMADD, VF_VNMADD, VF_VMSUB, VF_VNMSUB, VF_VMACC, VF_VNMACC, VF_VMSAC, VF_VNMSAC|])

val fvfmafunct6_of_num : forall ('e : Int), (0 <= 'e & 'e <= 7).
  int('e) -> fvfmafunct6

$[complete]
function fvfmafunct6_of_num arg# = $[complete] match arg# {
  0 => VF_VMADD,
  1 => VF_VNMADD,
  2 => VF_VMSUB,
  3 => VF_VNMSUB,
  4 => VF_VMACC,
  5 => VF_VNMACC,
  6 => VF_VMSAC,
  _ => VF_VNMSAC
}

val num_of_fvfmafunct6 : fvfmafunct6 -> {('e : Int), (0 <= 'e & 'e <= 7). int('e)}

$[complete]
function num_of_fvfmafunct6 arg# = $[complete] match arg# {
  VF_VMADD => 0,
  VF_VNMADD => 1,
  VF_VMSUB => 2,
  VF_VNMSUB => 3,
  VF_VMACC => 4,
  VF_VNMACC => 5,
  VF_VMSAC => 6,
  VF_VNMSAC => 7
}

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum fwvffunct6 = {FWVF_VADD, FWVF_VSUB, FWVF_VMUL}

val undefined_fwvffunct6 : unit -> fwvffunct6

$[complete]
function undefined_fwvffunct6 () = internal_pick([|FWVF_VADD, FWVF_VSUB, FWVF_VMUL|])

val fwvffunct6_of_num : forall ('e : Int), (0 <= 'e & 'e <= 2).
  int('e) -> fwvffunct6

$[complete]
function fwvffunct6_of_num arg# = $[complete] match arg# {
  0 => FWVF_VADD,
  1 => FWVF_VSUB,
  _ => FWVF_VMUL
}

val num_of_fwvffunct6 : fwvffunct6 -> {('e : Int), (0 <= 'e & 'e <= 2). int('e)}

$[complete]
function num_of_fwvffunct6 arg# = $[complete] match arg# {
  FWVF_VADD => 0,
  FWVF_VSUB => 1,
  FWVF_VMUL => 2
}

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum fwvfmafunct6 = {FWVF_VMACC, FWVF_VNMACC, FWVF_VMSAC, FWVF_VNMSAC}

val undefined_fwvfmafunct6 : unit -> fwvfmafunct6

$[complete]
function undefined_fwvfmafunct6 () = internal_pick([|FWVF_VMACC, FWVF_VNMACC, FWVF_VMSAC, FWVF_VNMSAC|])

val fwvfmafunct6_of_num : forall ('e : Int), (0 <= 'e & 'e <= 3).
  int('e) -> fwvfmafunct6

$[complete]
function fwvfmafunct6_of_num arg# = $[complete] match arg# {
  0 => FWVF_VMACC,
  1 => FWVF_VNMACC,
  2 => FWVF_VMSAC,
  _ => FWVF_VNMSAC
}

val num_of_fwvfmafunct6 : fwvfmafunct6 -> {('e : Int), (0 <= 'e & 'e <= 3). int('e)}

$[complete]
function num_of_fwvfmafunct6 arg# = $[complete] match arg# {
  FWVF_VMACC => 0,
  FWVF_VNMACC => 1,
  FWVF_VMSAC => 2,
  FWVF_VNMSAC => 3
}

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum fwffunct6 = {FWF_VADD, FWF_VSUB}

val undefined_fwffunct6 : unit -> fwffunct6

$[complete]
function undefined_fwffunct6 () = internal_pick([|FWF_VADD, FWF_VSUB|])

val fwffunct6_of_num : forall ('e : Int), (0 <= 'e & 'e <= 1).
  int('e) -> fwffunct6

$[complete]
function fwffunct6_of_num arg# = $[complete] match arg# {
  0 => FWF_VADD,
  _ => FWF_VSUB
}

val num_of_fwffunct6 : fwffunct6 -> {('e : Int), (0 <= 'e & 'e <= 1). int('e)}

$[complete]
function num_of_fwffunct6 arg# = $[complete] match arg# {
  FWF_VADD => 0,
  FWF_VSUB => 1
}

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum fvfmfunct6 = {
  VFM_VMFEQ,
  VFM_VMFLE,
  VFM_VMFLT,
  VFM_VMFNE,
  VFM_VMFGT,
  VFM_VMFGE
}

val undefined_fvfmfunct6 : unit -> fvfmfunct6

$[complete]
function undefined_fvfmfunct6 () = internal_pick([|VFM_VMFEQ, VFM_VMFLE, VFM_VMFLT, VFM_VMFNE, VFM_VMFGT, VFM_VMFGE|])

val fvfmfunct6_of_num : forall ('e : Int), (0 <= 'e & 'e <= 5).
  int('e) -> fvfmfunct6

$[complete]
function fvfmfunct6_of_num arg# = $[complete] match arg# {
  0 => VFM_VMFEQ,
  1 => VFM_VMFLE,
  2 => VFM_VMFLT,
  3 => VFM_VMFNE,
  4 => VFM_VMFGT,
  _ => VFM_VMFGE
}

val num_of_fvfmfunct6 : fvfmfunct6 -> {('e : Int), (0 <= 'e & 'e <= 5). int('e)}

$[complete]
function num_of_fvfmfunct6 arg# = $[complete] match arg# {
  VFM_VMFEQ => 0,
  VFM_VMFLE => 1,
  VFM_VMFLT => 2,
  VFM_VMFNE => 3,
  VFM_VMFGT => 4,
  VFM_VMFGE => 5
}

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum vmlsop = {VLM, VSM}

val undefined_vmlsop : unit -> vmlsop

$[complete]
function undefined_vmlsop () = internal_pick([|VLM, VSM|])

val vmlsop_of_num : forall ('e : Int), (0 <= 'e & 'e <= 1). int('e) -> vmlsop

$[complete]
function vmlsop_of_num arg# = $[complete] match arg# {
  0 => VLM,
  _ => VSM
}

val num_of_vmlsop : vmlsop -> {('e : Int), (0 <= 'e & 'e <= 1). int('e)}

$[complete]
function num_of_vmlsop arg# = $[complete] match arg# {
  VLM => 0,
  VSM => 1
}

newtype vregidx = Vregidx : bits(5)

newtype vregno = Vregno : range(0, 31)

val vregidx_to_vregno : vregidx -> vregno

$[complete]
function vregidx_to_vregno Vregidx(b) : vregidx = Vregno(unsigned(b))

val vregno_to_vregidx : vregno -> vregidx

$[complete]
function vregno_to_vregidx Vregno(b) : vregno = Vregidx(to_bits(5, b))

val vregidx_offset : (vregidx, bitvector(5)) -> vregidx

$[complete]
function vregidx_offset (Vregidx(r) : vregidx, o : bits(5)) = Vregidx($[overloaded { "name" = "+", "is_infix" = true }] add_bits(r, o))

val vregidx_offset_range : (vregidx, range(0, 31)) -> vregidx

$[complete]
function vregidx_offset_range (Vregidx(r) : vregidx, o : range(0, 31)) = Vregidx($[overloaded { "name" = "+", "is_infix" = true }] add_bits_int(r, o))

overload operator + = {vregidx_offset, vregidx_offset_range}

val vregidx_bits : vregidx -> bitvector(5)

$[complete]
function vregidx_bits Vregidx(b) : vregidx = b

val encdec_vreg : vregidx <-> bitvector(5)

mapping encdec_vreg = {Vregidx(r) <-> r}

val vreg_write_callback = pure {c: "vreg_write_callback"}: (vregidx, bitvector(2 ^ vlen_exp)) -> unit

$[complete]
function vreg_write_callback _ = ()

let zvreg : vregidx = Vregidx(0b00000)

register vr0 : vlenbits

register vr1 : vlenbits

register vr2 : vlenbits

register vr3 : vlenbits

register vr4 : vlenbits

register vr5 : vlenbits

register vr6 : vlenbits

register vr7 : vlenbits

register vr8 : vlenbits

register vr9 : vlenbits

register vr10 : vlenbits

register vr11 : vlenbits

register vr12 : vlenbits

register vr13 : vlenbits

register vr14 : vlenbits

register vr15 : vlenbits

register vr16 : vlenbits

register vr17 : vlenbits

register vr18 : vlenbits

register vr19 : vlenbits

register vr20 : vlenbits

register vr21 : vlenbits

register vr22 : vlenbits

register vr23 : vlenbits

register vr24 : vlenbits

register vr25 : vlenbits

register vr26 : vlenbits

register vr27 : vlenbits

register vr28 : vlenbits

register vr29 : vlenbits

register vr30 : vlenbits

register vr31 : vlenbits

val vreg_name_raw : bitvector(5) <-> string

mapping vreg_name_raw = {
  0b00000 <-> "v0",
  0b00001 <-> "v1",
  0b00010 <-> "v2",
  0b00011 <-> "v3",
  0b00100 <-> "v4",
  0b00101 <-> "v5",
  0b00110 <-> "v6",
  0b00111 <-> "v7",
  0b01000 <-> "v8",
  0b01001 <-> "v9",
  0b01010 <-> "v10",
  0b01011 <-> "v11",
  0b01100 <-> "v12",
  0b01101 <-> "v13",
  0b01110 <-> "v14",
  0b01111 <-> "v15",
  0b10000 <-> "v16",
  0b10001 <-> "v17",
  0b10010 <-> "v18",
  0b10011 <-> "v19",
  0b10100 <-> "v20",
  0b10101 <-> "v21",
  0b10110 <-> "v22",
  0b10111 <-> "v23",
  0b11000 <-> "v24",
  0b11001 <-> "v25",
  0b11010 <-> "v26",
  0b11011 <-> "v27",
  0b11100 <-> "v28",
  0b11101 <-> "v29",
  0b11110 <-> "v30",
  0b11111 <-> "v31"
}

val vreg_name : vregidx <-> string

mapping vreg_name = {Vregidx(i) <-> vreg_name_raw(i)}

val rV : vregno -> bitvector(2 ^ vlen_exp)

$[complete]
function rV Vregno(r) : vregno = {
    $[complete] match r {
      0 => vr0,
      1 => vr1,
      2 => vr2,
      3 => vr3,
      4 => vr4,
      5 => vr5,
      6 => vr6,
      7 => vr7,
      8 => vr8,
      9 => vr9,
      10 => vr10,
      11 => vr11,
      12 => vr12,
      13 => vr13,
      14 => vr14,
      15 => vr15,
      16 => vr16,
      17 => vr17,
      18 => vr18,
      19 => vr19,
      20 => vr20,
      21 => vr21,
      22 => vr22,
      23 => vr23,
      24 => vr24,
      25 => vr25,
      26 => vr26,
      27 => vr27,
      28 => vr28,
      29 => vr29,
      30 => vr30,
      ($[int_wildcard 31] _) => vr31
    }
}

val dirty_v_context : unit -> unit

$[complete]
function dirty_v_context () = {
    assert(hartSupports(Ext_V), "./extensions/V/vext_regs.sail:138.28-138.29");
    mstatus.bits[10 .. 9] = extStatus_to_bits(Dirty);
    mstatus.bits[sub_atom(sizeof(xlen), 1) .. sub_atom(sizeof(xlen), 1)] = 0b1;
    long_csr_write_callback("mstatus", "mstatush", mstatus.bits)
}

val wV : (vregno, bitvector(2 ^ vlen_exp)) -> unit

$[complete]
function wV (Vregno(r) : vregno, v : vlenbits) = {
    $[complete] match r {
      0 => vr0 = v,
      1 => vr1 = v,
      2 => vr2 = v,
      3 => vr3 = v,
      4 => vr4 = v,
      5 => vr5 = v,
      6 => vr6 = v,
      7 => vr7 = v,
      8 => vr8 = v,
      9 => vr9 = v,
      10 => vr10 = v,
      11 => vr11 = v,
      12 => vr12 = v,
      13 => vr13 = v,
      14 => vr14 = v,
      15 => vr15 = v,
      16 => vr16 = v,
      17 => vr17 = v,
      18 => vr18 = v,
      19 => vr19 = v,
      20 => vr20 = v,
      21 => vr21 = v,
      22 => vr22 = v,
      23 => vr23 = v,
      24 => vr24 = v,
      25 => vr25 = v,
      26 => vr26 = v,
      27 => vr27 = v,
      28 => vr28 = v,
      29 => vr29 = v,
      30 => vr30 = v,
      ($[int_wildcard 31] _) => vr31 = v
    };
    dirty_v_context();
    vreg_write_callback(vregno_to_vregidx(Vregno(r)), v)
}

val rV_bits : vregidx -> bitvector(2 ^ vlen_exp)

$[complete]
function rV_bits i : vregidx = rV(vregidx_to_vregno(i))

val wV_bits : (vregidx, bitvector(2 ^ vlen_exp)) -> unit

$[complete]
function wV_bits (i : vregidx, data : vlenbits) = {
    $[setter] wV(vregidx_to_vregno(i), data)
}

overload V = {rV_bits, wV_bits, rV, wV}

val init_vregs : unit -> unit

$[complete]
function init_vregs () = {
    let zero_vreg : vlenbits = zeros(2 ^ sizeof(vlen_exp));
    vr0 = zero_vreg;
    vr1 = zero_vreg;
    vr2 = zero_vreg;
    vr3 = zero_vreg;
    vr4 = zero_vreg;
    vr5 = zero_vreg;
    vr6 = zero_vreg;
    vr7 = zero_vreg;
    vr8 = zero_vreg;
    vr9 = zero_vreg;
    vr10 = zero_vreg;
    vr11 = zero_vreg;
    vr12 = zero_vreg;
    vr13 = zero_vreg;
    vr14 = zero_vreg;
    vr15 = zero_vreg;
    vr16 = zero_vreg;
    vr17 = zero_vreg;
    vr18 = zero_vreg;
    vr19 = zero_vreg;
    vr20 = zero_vreg;
    vr21 = zero_vreg;
    vr22 = zero_vreg;
    vr23 = zero_vreg;
    vr24 = zero_vreg;
    vr25 = zero_vreg;
    vr26 = zero_vreg;
    vr27 = zero_vreg;
    vr28 = zero_vreg;
    vr29 = zero_vreg;
    vr30 = zero_vreg;
    vr31 = zero_vreg
}

register vstart : xlenbits

register vl : xlenbits

let VLENB : xlenbits = to_bits(sizeof(xlen), $[overloaded { "name" = "/", "is_infix" = true }] quot_positive_round_zero(vlen, 8))

$[undefined_gen "skip"]
$[bitfield]
struct Vtype = {bits : bitvector(xlen)}

val undefined_Vtype : unit -> Vtype

$[complete]
function undefined_Vtype () = struct Vtype { bits = undefined }

val Mk_Vtype : bitvector(xlen) -> Vtype

$[complete]
function Mk_Vtype v = struct Vtype { bits = v }

$[fix_location]
val _get_Vtype_bits : Vtype -> bitvector(xlen)

$[complete]
$[fix_location]
function _get_Vtype_bits v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, sub_atom(sizeof(xlen), 1), 0)

$[fix_location]
val _update_Vtype_bits : (Vtype, bitvector(xlen)) -> Vtype

$[complete]
$[fix_location]
function _update_Vtype_bits (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, sub_atom(sizeof(xlen), 1), 0, x) }

$[fix_location]
overload update_bits = {_update_Vtype_bits}

$[fix_location]
val _set_Vtype_bits : (register(Vtype), bitvector(xlen)) -> unit

$[complete]
$[fix_location]
function _set_Vtype_bits (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Vtype_bits(r, v)
}

overload _mod_bits = {_get_Vtype_bits, _set_Vtype_bits}

$[fix_location]
val _get_Vtype_reserved : Vtype -> bitvector(xlen - 9)

$[complete]
$[fix_location]
function _get_Vtype_reserved v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, sub_atom(sizeof(xlen), 2), 8)

$[fix_location]
val _update_Vtype_reserved : (Vtype, bitvector(xlen - 9)) -> Vtype

$[complete]
$[fix_location]
function _update_Vtype_reserved (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, sub_atom(sizeof(xlen), 2), 8, x) }

$[fix_location]
overload update_reserved = {_update_Vtype_reserved}

$[fix_location]
val _set_Vtype_reserved : (register(Vtype), bitvector(xlen - 9)) -> unit

$[complete]
$[fix_location]
function _set_Vtype_reserved (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Vtype_reserved(r, v)
}

overload _mod_reserved = {_get_Vtype_reserved, _set_Vtype_reserved}

$[fix_location]
val _get_Vtype_vill : Vtype -> bitvector(xlen - 1 - (xlen - 1) + 1)

$[complete]
$[fix_location]
function _get_Vtype_vill v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, sub_atom(sizeof(xlen), 1), sub_atom(sizeof(xlen), 1))

$[fix_location]
val _update_Vtype_vill : (Vtype, bitvector(xlen - 1 - (xlen - 1) + 1)) -> Vtype

$[complete]
$[fix_location]
function _update_Vtype_vill (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, sub_atom(sizeof(xlen), 1), sub_atom(sizeof(xlen), 1), x) }

$[fix_location]
overload update_vill = {_update_Vtype_vill}

$[fix_location]
val _set_Vtype_vill : (register(Vtype), bitvector(xlen - 1 - (xlen - 1) + 1)) -> unit

$[complete]
$[fix_location]
function _set_Vtype_vill (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Vtype_vill(r, v)
}

overload _mod_vill = {_get_Vtype_vill, _set_Vtype_vill}

$[fix_location]
val _get_Vtype_vlmul : Vtype -> bitvector(3)

$[complete]
$[fix_location]
function _get_Vtype_vlmul v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 2, 0)

$[fix_location]
val _update_Vtype_vlmul : (Vtype, bitvector(3)) -> Vtype

$[complete]
$[fix_location]
function _update_Vtype_vlmul (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 2, 0, x) }

$[fix_location]
overload update_vlmul = {_update_Vtype_vlmul}

$[fix_location]
val _set_Vtype_vlmul : (register(Vtype), bitvector(3)) -> unit

$[complete]
$[fix_location]
function _set_Vtype_vlmul (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Vtype_vlmul(r, v)
}

overload _mod_vlmul = {_get_Vtype_vlmul, _set_Vtype_vlmul}

$[fix_location]
val _get_Vtype_vma : Vtype -> bitvector(1)

$[complete]
$[fix_location]
function _get_Vtype_vma v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 7, 7)

$[fix_location]
val _update_Vtype_vma : (Vtype, bitvector(1)) -> Vtype

$[complete]
$[fix_location]
function _update_Vtype_vma (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 7, 7, x) }

$[fix_location]
overload update_vma = {_update_Vtype_vma}

$[fix_location]
val _set_Vtype_vma : (register(Vtype), bitvector(1)) -> unit

$[complete]
$[fix_location]
function _set_Vtype_vma (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Vtype_vma(r, v)
}

overload _mod_vma = {_get_Vtype_vma, _set_Vtype_vma}

$[fix_location]
val _get_Vtype_vsew : Vtype -> bitvector(3)

$[complete]
$[fix_location]
function _get_Vtype_vsew v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 5, 3)

$[fix_location]
val _update_Vtype_vsew : (Vtype, bitvector(3)) -> Vtype

$[complete]
$[fix_location]
function _update_Vtype_vsew (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 5, 3, x) }

$[fix_location]
overload update_vsew = {_update_Vtype_vsew}

$[fix_location]
val _set_Vtype_vsew : (register(Vtype), bitvector(3)) -> unit

$[complete]
$[fix_location]
function _set_Vtype_vsew (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Vtype_vsew(r, v)
}

overload _mod_vsew = {_get_Vtype_vsew, _set_Vtype_vsew}

$[fix_location]
val _get_Vtype_vta : Vtype -> bitvector(1)

$[complete]
$[fix_location]
function _get_Vtype_vta v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 6, 6)

$[fix_location]
val _update_Vtype_vta : (Vtype, bitvector(1)) -> Vtype

$[complete]
$[fix_location]
function _update_Vtype_vta (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 6, 6, x) }

$[fix_location]
overload update_vta = {_update_Vtype_vta}

$[fix_location]
val _set_Vtype_vta : (register(Vtype), bitvector(1)) -> unit

$[complete]
$[fix_location]
function _set_Vtype_vta (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Vtype_vta(r, v)
}

overload _mod_vta = {_get_Vtype_vta, _set_Vtype_vta}

register vtype : Vtype

type SEW_pow = range(3, 6)

val sew_pow_val : bitvector(3) <-> range(3, 6)

mapping sew_pow_val = {
  0b000 <-> 3,
  0b001 <-> 4,
  0b010 <-> 5,
  0b011 <-> 6
}

type LMUL_pow = range(-3, 3)

val lmul_pow_val : bitvector(3) <-> range(-3, 3)

mapping lmul_pow_val = {
  0b101 <-> -3,
  0b110 <-> -2,
  0b111 <-> -1,
  0b000 <-> 0,
  0b001 <-> 1,
  0b010 <-> 2,
  0b011 <-> 3
}

val is_invalid_sew_pow : bitvector(3) -> bool

$[complete]
function is_invalid_sew_pow v : bits(3) = operator >_u(v, 0b011)

val is_invalid_lmul_pow : bitvector(3) -> bool

$[complete]
function is_invalid_lmul_pow v : bits(3) = $[overloaded { "name" = "==", "is_infix" = true }] eq_bits(v, 0b100)

val get_sew_pow : unit -> range(3, 6)

$[complete]
function get_sew_pow () = {
    let sew_pow = _get_Vtype_vsew(vtype);
    sew_pow_val_forwards(sew_pow)
}

type sew_bitsize = {8, 16, 32, 64}

type is_sew_bitsize('n: Int) -> Bool = 'n in {8, 16, 32, 64}

val get_sew : unit -> {8, 16, 32, 64}

$[complete]
function get_sew () = 2 ^ get_sew_pow()

val get_sew_bytes : unit -> {1, 2, 4, 8}

$[complete]
function get_sew_bytes () = $[overloaded { "name" = "/", "is_infix" = true }] quot_positive_round_zero(get_sew(), 8)

val get_lmul_pow : unit -> range(-3, 3)

$[complete]
function get_lmul_pow () = {
    let lmul_pow = _get_Vtype_vlmul(vtype);
    lmul_pow_val_forwards(lmul_pow)
}

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum agtype = {UNDISTURBED, AGNOSTIC}

val undefined_agtype : unit -> agtype

$[complete]
function undefined_agtype () = internal_pick([|UNDISTURBED, AGNOSTIC|])

val agtype_of_num : forall ('e : Int), (0 <= 'e & 'e <= 1). int('e) -> agtype

$[complete]
function agtype_of_num arg# = $[complete] match arg# {
  0 => UNDISTURBED,
  _ => AGNOSTIC
}

val num_of_agtype : agtype -> {('e : Int), (0 <= 'e & 'e <= 1). int('e)}

$[complete]
function num_of_agtype arg# = $[complete] match arg# {
  UNDISTURBED => 0,
  AGNOSTIC => 1
}

val decode_agtype : bitvector(1) -> agtype

$[complete]
function decode_agtype ag = {
    $[complete] match ag {
      0b0 => UNDISTURBED,
      _ : bitvector(1) => AGNOSTIC
    }
}

val get_vtype_vma : unit -> agtype

$[complete]
function get_vtype_vma () = decode_agtype(_get_Vtype_vma(vtype))

val get_vtype_vta : unit -> agtype

$[complete]
function get_vtype_vta () = decode_agtype(_get_Vtype_vta(vtype))

$[undefined_gen "skip"]
$[bitfield]
struct Vcsr = {bits : bitvector(3)}

val undefined_Vcsr : unit -> Vcsr

$[complete]
function undefined_Vcsr () = struct Vcsr { bits = undefined }

val Mk_Vcsr : bitvector(3) -> Vcsr

$[complete]
function Mk_Vcsr v = struct Vcsr { bits = v }

$[fix_location]
val _get_Vcsr_bits : Vcsr -> bitvector(3)

$[complete]
$[fix_location]
function _get_Vcsr_bits v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, sub_atom(3, 1), 0)

$[fix_location]
val _update_Vcsr_bits : (Vcsr, bitvector(3)) -> Vcsr

$[complete]
$[fix_location]
function _update_Vcsr_bits (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, sub_atom(3, 1), 0, x) }

$[fix_location]
overload update_bits = {_update_Vcsr_bits}

$[fix_location]
val _set_Vcsr_bits : (register(Vcsr), bitvector(3)) -> unit

$[complete]
$[fix_location]
function _set_Vcsr_bits (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Vcsr_bits(r, v)
}

overload _mod_bits = {_get_Vcsr_bits, _set_Vcsr_bits}

$[fix_location]
val _get_Vcsr_vxrm : Vcsr -> bitvector(2)

$[complete]
$[fix_location]
function _get_Vcsr_vxrm v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 2, 1)

$[fix_location]
val _update_Vcsr_vxrm : (Vcsr, bitvector(2)) -> Vcsr

$[complete]
$[fix_location]
function _update_Vcsr_vxrm (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 2, 1, x) }

$[fix_location]
overload update_vxrm = {_update_Vcsr_vxrm}

$[fix_location]
val _set_Vcsr_vxrm : (register(Vcsr), bitvector(2)) -> unit

$[complete]
$[fix_location]
function _set_Vcsr_vxrm (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Vcsr_vxrm(r, v)
}

overload _mod_vxrm = {_get_Vcsr_vxrm, _set_Vcsr_vxrm}

$[fix_location]
val _get_Vcsr_vxsat : Vcsr -> bitvector(1)

$[complete]
$[fix_location]
function _get_Vcsr_vxsat v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 0, 0)

$[fix_location]
val _update_Vcsr_vxsat : (Vcsr, bitvector(1)) -> Vcsr

$[complete]
$[fix_location]
function _update_Vcsr_vxsat (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 0, 0, x) }

$[fix_location]
overload update_vxsat = {_update_Vcsr_vxsat}

$[fix_location]
val _set_Vcsr_vxsat : (register(Vcsr), bitvector(1)) -> unit

$[complete]
$[fix_location]
function _set_Vcsr_vxsat (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_Vcsr_vxsat(r, v)
}

overload _mod_vxsat = {_get_Vcsr_vxsat, _set_Vcsr_vxsat}

register vcsr : Vcsr

val set_vstart : bitvector(16) -> unit

$[complete]
function set_vstart value : bits(16) = {
    dirty_v_context();
    vstart = zero_extend(sizeof(xlen), $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(value, $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(vlen_exp, 1), 0));
    $[overloaded { "name" = "csr_write_callback", "is_infix" = false }] csr_name_write_callback("vstart", vstart)
}

val ext_write_vcsr : (bitvector(2), bitvector(1)) -> unit

$[complete]
function ext_write_vcsr (vxrm_val, vxsat_val) = {
    vcsr.bits[2 .. 1] = vxrm_val;
    vcsr.bits[0 .. 0] = vxsat_val;
    dirty_v_context()
}

val get_num_elem : (int, {8, 16, 32, 64}) -> {('n : Int), 'n > 0. int('n)}

$[complete]
function get_num_elem (LMUL_pow, SEW) = {
    let LMUL_pow_reg = if $[overloaded { "name" = "<", "is_infix" = true }] lt_int(LMUL_pow, 0) then
      0
    else
      LMUL_pow;
    let num_elem = $[overloaded { "name" = "/", "is_infix" = true }] quot_positive_round_zero($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(2 ^ LMUL_pow_reg, vlen), SEW);
    assert($[overloaded { "name" = ">", "is_infix" = true }] gt_int(num_elem, 0), "./extensions/V/vext_control.sail:18.21-18.22");
    num_elem
}

val read_single_vreg : forall ('n : Int) ('m : Int), ('n >= 0 & is_sew_bitsize('m)).
  (int('n), int('m), vregidx) -> vector('n, bitvector('m))

$[complete]
function read_single_vreg (num_elem, SEW, vrid) = {
    assert($[overloaded { "name" = "<=", "is_infix" = true }] lteq_int($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(num_elem, SEW), vlen), "./extensions/V/vext_control.sail:26.31-26.32");
    let bv = $[overloaded { "name" = "V", "is_infix" = false }] rV_bits(vrid);
    var result : vector('n, bits('m)) = vector_init($[overloaded { "name" = "__size", "is_infix" = false }] __id(num_elem), zeros($[overloaded { "name" = "__size", "is_infix" = false }] __id(SEW)));
    foreach (i from 0 to sub_atom(num_elem, 1) by 1 in inc) {
        let start_index = $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(i, SEW);
        result[i] = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(bv, $[overloaded { "name" = "-", "is_infix" = true }] sub_atom($[overloaded { "name" = "+", "is_infix" = true }] add_atom(start_index, SEW), 1), start_index)
    };
    result
}

val write_single_vreg : forall ('n : Int) ('m : Int), ('n >= 0 & is_sew_bitsize('m)).
  (int('n), int('m), vregidx, vector('n, bitvector('m))) -> unit

$[complete]
function write_single_vreg (num_elem, SEW, vrid, v) = {
    var r : vlenbits = zeros(2 ^ sizeof(vlen_exp));
    assert($[overloaded { "name" = "<=", "is_infix" = true }] lteq_int(SEW, vlen), "./extensions/V/vext_control.sail:44.20-44.21");
    foreach (i from sub_atom(num_elem, 1) to 0 by 1 in dec) {
        r = $[overloaded { "name" = "<<", "is_infix" = true }] shiftl(r, SEW);
        r = $[overloaded { "name" = "|", "is_infix" = true }] or_vec(r, zero_extend(2 ^ sizeof(vlen_exp), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(v, i)))
    };
    $[overloaded { "name" = "V", "is_infix" = false }] $[setter] wV_bits(vrid, r)
}

val read_vreg : forall ('n : Int) ('m : Int) ('p : Int), ('n >= 0 & is_sew_bitsize('m)).
  (int('n), int('m), int('p), vregidx) -> vector('n, bitvector('m))

$[complete]
function read_vreg (num_elem, SEW, LMUL_pow, vrid) = {
    let vrid_val = unsigned(vregidx_bits(vrid));
    var result : vector('n, bits('m)) = vector_init($[overloaded { "name" = "__size", "is_infix" = false }] __id(num_elem), zeros($[overloaded { "name" = "__size", "is_infix" = false }] __id(SEW)));
    let LMUL_pow_reg = if $[overloaded { "name" = "<", "is_infix" = true }] lt_int(LMUL_pow, 0) then
      0
    else
      LMUL_pow;
    if $[overloaded { "name" = ">", "is_infix" = true }] gt_int($[overloaded { "name" = "+", "is_infix" = true }] add_atom(vrid_val, 2 ^ LMUL_pow_reg), 32) then {
        assert(false, "invalid register group: vrid overflow the largest number")
    } else if $[overloaded { "name" = "!=", "is_infix" = true }] neq_int($[overloaded { "name" = "%", "is_infix" = true }] rem_positive_round_zero(vrid_val, 2 ^ LMUL_pow_reg), 0) then {
        assert(false, "invalid register group: vrid is not a multiple of EMUL")
    } else {
        if $[overloaded { "name" = "<", "is_infix" = true }] lt_int($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(num_elem, SEW), vlen) then {
            result = read_single_vreg($[overloaded { "name" = "__size", "is_infix" = false }] vector_length(result), SEW, vrid)
        } else {
            let 'num_elem_single = $[overloaded { "name" = "/", "is_infix" = true }] quot_positive_round_zero(vlen, SEW);
            assert($[overloaded { "name" = ">=", "is_infix" = true }] gteq_int($[overloaded { "name" = "__size", "is_infix" = false }] __id(num_elem_single), 0), "./extensions/V/vext_control.sail:74.34-74.35");
            foreach (i_lmul from 0 to sub_atom(2 ^ LMUL_pow_reg, 1) by 1 in inc) {
                let r_start_i : int = $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(i_lmul, $[overloaded { "name" = "__size", "is_infix" = false }] __id(num_elem_single));
                let r_end_i : int = $[overloaded { "name" = "-", "is_infix" = true }] sub_atom($[overloaded { "name" = "+", "is_infix" = true }] add_atom(r_start_i, $[overloaded { "name" = "__size", "is_infix" = false }] __id(num_elem_single)), 1);
                let vrid_lmul : vregidx = vregidx_offset(vrid, to_bits_unsafe(5, i_lmul));
                let single_result : vector('num_elem_single, bits('m)) = read_single_vreg($[overloaded { "name" = "__size", "is_infix" = false }] __id(num_elem_single), SEW, vrid_lmul);
                foreach (r_i from r_start_i to r_end_i by 1 in inc) {
                    let s_i : int = $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(r_i, r_start_i);
                    assert($[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "<=", "is_infix" = true }] lteq_int(0, r_i), $[overloaded { "name" = "<", "is_infix" = true }] lt_int(r_i, num_elem)), "./extensions/V/vext_control.sail:82.42-82.43");
                    assert($[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "<=", "is_infix" = true }] lteq_int(0, s_i), $[overloaded { "name" = "<", "is_infix" = true }] lt_int(s_i, $[overloaded { "name" = "__size", "is_infix" = false }] __id(num_elem_single))), "./extensions/V/vext_control.sail:83.50-83.51");
                    result[r_i] = $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(single_result, s_i)
                }
            }
        }
    };
    result
}

val read_single_element : forall ('m : Int), is_sew_bitsize('m).
  (int('m), nat, vregidx) -> bitvector('m)

$[complete]
function read_single_element (EEW, index, vrid) = {
    assert($[overloaded { "name" = "<=", "is_infix" = true }] lteq_int(EEW, vlen), "./extensions/V/vext_control.sail:96.20-96.21");
    let elem_per_reg = $[overloaded { "name" = "/", "is_infix" = true }] quot_positive_round_zero(vlen, EEW);
    let reg_in_group = $[overloaded { "name" = "/", "is_infix" = true }] quot_positive_round_zero(index, elem_per_reg);
    assert($[overloaded { "name" = "<", "is_infix" = true }] lt_int(reg_in_group, 8), "./extensions/V/vext_control.sail:103.25-103.26");
    let vrid = $[overloaded { "name" = "+", "is_infix" = true }] vregidx_offset_range(vrid, reg_in_group);
    let index = $[overloaded { "name" = "%", "is_infix" = true }] rem_positive_round_zero(index, elem_per_reg);
    let offset = $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(index, EEW);
    $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits($[overloaded { "name" = "V", "is_infix" = false }] rV_bits(vrid), $[overloaded { "name" = "-", "is_infix" = true }] sub_atom($[overloaded { "name" = "+", "is_infix" = true }] add_atom(offset, EEW), 1), offset)
}

val write_vreg : forall ('n : Int) ('m : Int) ('p : Int), ('n >= 0 & is_sew_bitsize('m)).
  (int('n), int('m), int('p), vregidx, vector('n, bitvector('m))) -> unit

$[complete]
function write_vreg (num_elem, SEW, LMUL_pow, vrid, vec) = {
    let LMUL_pow_reg = if $[overloaded { "name" = "<", "is_infix" = true }] lt_int(LMUL_pow, 0) then
      0
    else
      LMUL_pow;
    let 'num_elem_single = $[overloaded { "name" = "/", "is_infix" = true }] quot_positive_round_zero(vlen, SEW);
    assert($[overloaded { "name" = ">=", "is_infix" = true }] gteq_int($[overloaded { "name" = "__size", "is_infix" = false }] __id(num_elem_single), 0), "./extensions/V/vext_control.sail:120.30-120.31");
    foreach (i_lmul from 0 to sub_atom(2 ^ LMUL_pow_reg, 1) by 1 in inc) {
        var single_vec : vector('num_elem_single, bits('m)) = vector_init($[overloaded { "name" = "__size", "is_infix" = false }] __id(num_elem_single), zeros($[overloaded { "name" = "__size", "is_infix" = false }] __id(SEW)));
        let vrid_lmul : vregidx = vregidx_offset(vrid, to_bits_unsafe(5, i_lmul));
        let r_start_i : int = $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(i_lmul, $[overloaded { "name" = "__size", "is_infix" = false }] __id(num_elem_single));
        let r_end_i : int = $[overloaded { "name" = "-", "is_infix" = true }] sub_atom($[overloaded { "name" = "+", "is_infix" = true }] add_atom(r_start_i, $[overloaded { "name" = "__size", "is_infix" = false }] __id(num_elem_single)), 1);
        foreach (r_i from r_start_i to r_end_i by 1 in inc) {
            let s_i : int = $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(r_i, r_start_i);
            assert($[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "<=", "is_infix" = true }] lteq_int(0, r_i), $[overloaded { "name" = "<", "is_infix" = true }] lt_int(r_i, num_elem)), "./extensions/V/vext_control.sail:128.38-128.39");
            assert($[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "<=", "is_infix" = true }] lteq_int(0, s_i), $[overloaded { "name" = "<", "is_infix" = true }] lt_int(s_i, $[overloaded { "name" = "__size", "is_infix" = false }] __id(num_elem_single))), "./extensions/V/vext_control.sail:129.46-129.47");
            single_vec[s_i] = $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vec, r_i)
        };
        write_single_vreg($[overloaded { "name" = "__size", "is_infix" = false }] __id(num_elem_single), SEW, vrid_lmul, single_vec)
    }
}

val write_single_element : forall ('m : Int), is_sew_bitsize('m).
  (int('m), nat, vregidx, bitvector('m)) -> unit

$[complete]
function write_single_element (EEW, index, vrid, value) = {
    assert($[overloaded { "name" = "<=", "is_infix" = true }] lteq_int(EEW, vlen), "./extensions/V/vext_control.sail:140.20-140.21");
    let elem_per_reg = $[overloaded { "name" = "/", "is_infix" = true }] quot_positive_round_zero(vlen, EEW);
    let reg_in_group = $[overloaded { "name" = "/", "is_infix" = true }] quot_positive_round_zero(index, elem_per_reg);
    assert($[overloaded { "name" = "<", "is_infix" = true }] lt_int(reg_in_group, 8), "./extensions/V/vext_control.sail:147.25-147.26");
    let vrid = $[overloaded { "name" = "+", "is_infix" = true }] vregidx_offset_range(vrid, reg_in_group);
    let index = $[overloaded { "name" = "%", "is_infix" = true }] rem_positive_round_zero(index, elem_per_reg);
    let offset = $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(index, EEW);
    $[overloaded { "name" = "V", "is_infix" = false }] $[setter] wV_bits(vrid, $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits($[overloaded { "name" = "V", "is_infix" = false }] rV_bits(vrid), $[overloaded { "name" = "-", "is_infix" = true }] sub_atom($[overloaded { "name" = "+", "is_infix" = true }] add_atom(offset, EEW), 1), offset, value))
}

val read_vmask : forall ('n : Int), 'n > 0.
  (int('n), bitvector(1), vregidx) -> bitvector('n)

$[complete]
function read_vmask (num_elem, vm, vrid) = {
    assert($[overloaded { "name" = "<=", "is_infix" = true }] lteq_int(num_elem, vlen), "./extensions/V/vext_control.sail:161.25-161.26");
    let vreg_val = $[overloaded { "name" = "V", "is_infix" = false }] rV_bits(vrid);
    var result : bits('n) = ones($[overloaded { "name" = "__size", "is_infix" = false }] __id(num_elem));
    if $[overloaded { "name" = "==", "is_infix" = true }] eq_bits(vm, 0b1) then {
        return(result)
    };
    foreach (i from 0 to sub_atom(num_elem, 1) by 1 in inc) {
        result[i] = $[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(vreg_val, i)
    };
    result
}

val read_vmask_carry : forall ('n : Int), 'n > 0.
  (int('n), bitvector(1), vregidx) -> bitvector('n)

$[complete]
function read_vmask_carry (num_elem, vm, vrid) = {
    assert($[overloaded { "name" = "<=", "is_infix" = true }] lteq_int(num_elem, vlen), "./extensions/V/vext_control.sail:180.25-180.26");
    let vreg_val = $[overloaded { "name" = "V", "is_infix" = false }] rV_bits(vrid);
    var result : bits('n) = zeros($[overloaded { "name" = "__size", "is_infix" = false }] __id(num_elem));
    if $[overloaded { "name" = "==", "is_infix" = true }] eq_bits(vm, 0b1) then {
        return(result)
    };
    foreach (i from 0 to sub_atom(num_elem, 1) by 1 in inc) {
        result[i] = $[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(vreg_val, i)
    };
    result
}

val write_vmask : forall ('n : Int), 'n > 0.
  (int('n), vregidx, bitvector('n)) -> unit

$[complete]
function write_vmask (num_elem, vrid, v) = {
    assert($[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "<", "is_infix" = true }] lt_int(0, num_elem), $[overloaded { "name" = "<=", "is_infix" = true }] lteq_int(num_elem, vlen)), "./extensions/V/vext_control.sail:199.40-199.41");
    let vreg_val = $[overloaded { "name" = "V", "is_infix" = false }] rV_bits(vrid);
    var result : vlenbits = undefined;
    foreach (i from 0 to sub_atom(num_elem, 1) by 1 in inc) {
        result[i] = $[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(v, i)
    };
    foreach (i from num_elem to sub_atom(vlen, 1) by 1 in inc) {
        result[i] = $[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(vreg_val, i)
    };
    $[overloaded { "name" = "V", "is_infix" = false }] $[setter] wV_bits(vrid, result)
}

val xt2 : bitvector(8) -> bitvector(8)

$[complete]
function xt2 x = {
    $[overloaded { "name" = "^", "is_infix" = true }] xor_vec($[overloaded { "name" = "<<", "is_infix" = true }] shiftl(x, 1), if bit_to_bool($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(x, 7)) then
      0x1b
    else
      0x00)
}

val xt3 : bitvector(8) -> bitvector(8)

$[complete]
function xt3 x = $[overloaded { "name" = "^", "is_infix" = true }] xor_vec(x, xt2(x))

val gfmul : (bitvector(8), bitvector(4)) -> bitvector(8)

$[complete]
function gfmul (x, y) = {
    $[overloaded { "name" = "^", "is_infix" = true }] xor_vec(if bit_to_bool($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(y, 0)) then
      x
    else
      0x00, $[overloaded { "name" = "^", "is_infix" = true }] xor_vec(if bit_to_bool($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(y, 1)) then
      xt2(x)
    else
      0x00, $[overloaded { "name" = "^", "is_infix" = true }] xor_vec(if bit_to_bool($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(y, 2)) then
      xt2(xt2(x))
    else
      0x00, if bit_to_bool($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(y, 3)) then
      xt2(xt2(xt2(x)))
    else
      0x00)))
}

val aes_mixcolumn_byte_fwd : bitvector(8) -> bitvector(32)

$[complete]
function aes_mixcolumn_byte_fwd so = {
    $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(gfmul(so, 0x3), $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(so, $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(so, gfmul(so, 0x2))))
}

val aes_mixcolumn_byte_inv : bitvector(8) -> bitvector(32)

$[complete]
function aes_mixcolumn_byte_inv so = {
    $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(gfmul(so, 0xb), $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(gfmul(so, 0xd), $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(gfmul(so, 0x9), gfmul(so, 0xe))))
}

val aes_mixcolumn_fwd : bitvector(32) -> bitvector(32)

$[complete]
function aes_mixcolumn_fwd x = {
    let s0 : bits(8) = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(x, 7, 0);
    let s1 : bits(8) = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(x, 15, 8);
    let s2 : bits(8) = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(x, 23, 16);
    let s3 : bits(8) = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(x, 31, 24);
    let b0 : bits(8) = $[overloaded { "name" = "^", "is_infix" = true }] xor_vec(xt2(s0), $[overloaded { "name" = "^", "is_infix" = true }] xor_vec(xt3(s1), $[overloaded { "name" = "^", "is_infix" = true }] xor_vec(s2, s3)));
    let b1 : bits(8) = $[overloaded { "name" = "^", "is_infix" = true }] xor_vec(s0, $[overloaded { "name" = "^", "is_infix" = true }] xor_vec(xt2(s1), $[overloaded { "name" = "^", "is_infix" = true }] xor_vec(xt3(s2), s3)));
    let b2 : bits(8) = $[overloaded { "name" = "^", "is_infix" = true }] xor_vec(s0, $[overloaded { "name" = "^", "is_infix" = true }] xor_vec(s1, $[overloaded { "name" = "^", "is_infix" = true }] xor_vec(xt2(s2), xt3(s3))));
    let b3 : bits(8) = $[overloaded { "name" = "^", "is_infix" = true }] xor_vec(xt3(s0), $[overloaded { "name" = "^", "is_infix" = true }] xor_vec(s1, $[overloaded { "name" = "^", "is_infix" = true }] xor_vec(s2, xt2(s3))));
    $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(b3, $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(b2, $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(b1, b0)))
}

val aes_mixcolumn_inv : bitvector(32) -> bitvector(32)

$[complete]
function aes_mixcolumn_inv x = {
    let s0 : bits(8) = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(x, 7, 0);
    let s1 : bits(8) = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(x, 15, 8);
    let s2 : bits(8) = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(x, 23, 16);
    let s3 : bits(8) = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(x, 31, 24);
    let b0 : bits(8) = $[overloaded { "name" = "^", "is_infix" = true }] xor_vec(gfmul(s0, 0xE), $[overloaded { "name" = "^", "is_infix" = true }] xor_vec(gfmul(s1, 0xB), $[overloaded { "name" = "^", "is_infix" = true }] xor_vec(gfmul(s2, 0xD), gfmul(s3, 0x9))));
    let b1 : bits(8) = $[overloaded { "name" = "^", "is_infix" = true }] xor_vec(gfmul(s0, 0x9), $[overloaded { "name" = "^", "is_infix" = true }] xor_vec(gfmul(s1, 0xE), $[overloaded { "name" = "^", "is_infix" = true }] xor_vec(gfmul(s2, 0xB), gfmul(s3, 0xD))));
    let b2 : bits(8) = $[overloaded { "name" = "^", "is_infix" = true }] xor_vec(gfmul(s0, 0xD), $[overloaded { "name" = "^", "is_infix" = true }] xor_vec(gfmul(s1, 0x9), $[overloaded { "name" = "^", "is_infix" = true }] xor_vec(gfmul(s2, 0xE), gfmul(s3, 0xB))));
    let b3 : bits(8) = $[overloaded { "name" = "^", "is_infix" = true }] xor_vec(gfmul(s0, 0xB), $[overloaded { "name" = "^", "is_infix" = true }] xor_vec(gfmul(s1, 0xD), $[overloaded { "name" = "^", "is_infix" = true }] xor_vec(gfmul(s2, 0x9), gfmul(s3, 0xE))));
    $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(b3, $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(b2, $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(b1, b0)))
}

val aes_decode_rcon : bitvector(4) -> bitvector(32)

$[complete]
function aes_decode_rcon r = {
    assert(operator <_u(r, 0xA), "./extensions/K/types_kext.sail:85.18-85.19");
    $[complete] match r {
      0x0 => 0x00000001,
      0x1 => 0x00000002,
      0x2 => 0x00000004,
      0x3 => 0x00000008,
      0x4 => 0x00000010,
      0x5 => 0x00000020,
      0x6 => 0x00000040,
      0x7 => 0x00000080,
      0x8 => 0x0000001b,
      0x9 => 0x00000036,
      _ => internal_error("./extensions/K/types_kext.sail", 97, "Unexpected AES r")
    }
}

let sm4_sbox_table : vector(256, bits(8)) = [0xD6, 0x90, 0xE9, 0xFE, 0xCC, 0xE1, 0x3D, 0xB7, 0x16, 0xB6, 0x14, 0xC2, 0x28, 0xFB, 0x2C, 0x05, 0x2B, 0x67, 0x9A, 0x76, 0x2A, 0xBE, 0x04, 0xC3, 0xAA, 0x44, 0x13, 0x26, 0x49, 0x86, 0x06, 0x99, 0x9C, 0x42, 0x50, 0xF4, 0x91, 0xEF, 0x98, 0x7A, 0x33, 0x54, 0x0B, 0x43, 0xED, 0xCF, 0xAC, 0x62, 0xE4, 0xB3, 0x1C, 0xA9, 0xC9, 0x08, 0xE8, 0x95, 0x80, 0xDF, 0x94, 0xFA, 0x75, 0x8F, 0x3F, 0xA6, 0x47, 0x07, 0xA7, 0xFC, 0xF3, 0x73, 0x17, 0xBA, 0x83, 0x59, 0x3C, 0x19, 0xE6, 0x85, 0x4F, 0xA8, 0x68, 0x6B, 0x81, 0xB2, 0x71, 0x64, 0xDA, 0x8B, 0xF8, 0xEB, 0x0F, 0x4B, 0x70, 0x56, 0x9D, 0x35, 0x1E, 0x24, 0x0E, 0x5E, 0x63, 0x58, 0xD1, 0xA2, 0x25, 0x22, 0x7C, 0x3B, 0x01, 0x21, 0x78, 0x87, 0xD4, 0x00, 0x46, 0x57, 0x9F, 0xD3, 0x27, 0x52, 0x4C, 0x36, 0x02, 0xE7, 0xA0, 0xC4, 0xC8, 0x9E, 0xEA, 0xBF, 0x8A, 0xD2, 0x40, 0xC7, 0x38, 0xB5, 0xA3, 0xF7, 0xF2, 0xCE, 0xF9, 0x61, 0x15, 0xA1, 0xE0, 0xAE, 0x5D, 0xA4, 0x9B, 0x34, 0x1A, 0x55, 0xAD, 0x93, 0x32, 0x30, 0xF5, 0x8C, 0xB1, 0xE3, 0x1D, 0xF6, 0xE2, 0x2E, 0x82, 0x66, 0xCA, 0x60, 0xC0, 0x29, 0x23, 0xAB, 0x0D, 0x53, 0x4E, 0x6F, 0xD5, 0xDB, 0x37, 0x45, 0xDE, 0xFD, 0x8E, 0x2F, 0x03, 0xFF, 0x6A, 0x72, 0x6D, 0x6C, 0x5B, 0x51, 0x8D, 0x1B, 0xAF, 0x92, 0xBB, 0xDD, 0xBC, 0x7F, 0x11, 0xD9, 0x5C, 0x41, 0x1F, 0x10, 0x5A, 0xD8, 0x0A, 0xC1, 0x31, 0x88, 0xA5, 0xCD, 0x7B, 0xBD, 0x2D, 0x74, 0xD0, 0x12, 0xB8, 0xE5, 0xB4, 0xB0, 0x89, 0x69, 0x97, 0x4A, 0x0C, 0x96, 0x77, 0x7E, 0x65, 0xB9, 0xF1, 0x09, 0xC5, 0x6E, 0xC6, 0x84, 0x18, 0xF0, 0x7D, 0xEC, 0x3A, 0xDC, 0x4D, 0x20, 0x79, 0xEE, 0x5F, 0x3E, 0xD7, 0xCB, 0x39, 0x48]

let aes_sbox_fwd_table : vector(256, bits(8)) = [0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76, 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, 0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15, 0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75, 0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84, 0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf, 0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8, 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, 0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73, 0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb, 0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79, 0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08, 0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a, 0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e, 0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf, 0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16]

let aes_sbox_inv_table : vector(256, bits(8)) = [0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb, 0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb, 0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e, 0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25, 0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92, 0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84, 0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06, 0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b, 0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73, 0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e, 0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b, 0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4, 0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f, 0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef, 0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61, 0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d]

val sbox_lookup : (bitvector(8), vector(256, bitvector(8))) -> bitvector(8)

$[complete]
function sbox_lookup (x, table) = {
    $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(table, $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(255, unsigned(x)))
}

val aes_sbox_fwd : bitvector(8) -> bitvector(8)

$[complete]
function aes_sbox_fwd x = sbox_lookup(x, aes_sbox_fwd_table)

val aes_sbox_inv : bitvector(8) -> bitvector(8)

$[complete]
function aes_sbox_inv x = sbox_lookup(x, aes_sbox_inv_table)

val aes_subword_fwd : bitvector(32) -> bitvector(32)

$[complete]
function aes_subword_fwd x = {
    $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(aes_sbox_fwd($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(x, 31, 24)), $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(aes_sbox_fwd($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(x, 23, 16)), $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(aes_sbox_fwd($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(x, 15, 8)), aes_sbox_fwd($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(x, 7, 0)))))
}

val aes_subword_inv : bitvector(32) -> bitvector(32)

$[complete]
function aes_subword_inv x = {
    $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(aes_sbox_inv($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(x, 31, 24)), $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(aes_sbox_inv($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(x, 23, 16)), $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(aes_sbox_inv($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(x, 15, 8)), aes_sbox_inv($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(x, 7, 0)))))
}

val sm4_sbox : bitvector(8) -> bitvector(8)

$[complete]
function sm4_sbox x = sbox_lookup(x, sm4_sbox_table)

val aes_get_column : (bitvector(128), range(0, 3)) -> bitvector(32)

$[complete]
function aes_get_column (state : bits(128), c : range(0, 3)) = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(state, $[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(32, c), 31), $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(32, c))

val aes_apply_fwd_sbox_to_each_byte : bitvector(64) -> bitvector(64)

$[complete]
function aes_apply_fwd_sbox_to_each_byte x = {
    $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(aes_sbox_fwd($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(x, 63, 56)), $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(aes_sbox_fwd($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(x, 55, 48)), $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(aes_sbox_fwd($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(x, 47, 40)), $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(aes_sbox_fwd($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(x, 39, 32)), $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(aes_sbox_fwd($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(x, 31, 24)), $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(aes_sbox_fwd($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(x, 23, 16)), $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(aes_sbox_fwd($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(x, 15, 8)), aes_sbox_fwd($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(x, 7, 0)))))))))
}

val aes_apply_inv_sbox_to_each_byte : bitvector(64) -> bitvector(64)

$[complete]
function aes_apply_inv_sbox_to_each_byte x = {
    $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(aes_sbox_inv($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(x, 63, 56)), $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(aes_sbox_inv($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(x, 55, 48)), $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(aes_sbox_inv($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(x, 47, 40)), $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(aes_sbox_inv($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(x, 39, 32)), $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(aes_sbox_inv($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(x, 31, 24)), $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(aes_sbox_inv($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(x, 23, 16)), $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(aes_sbox_inv($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(x, 15, 8)), aes_sbox_inv($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(x, 7, 0)))))))))
}

val getbyte : (bitvector(64), range(0, 7)) -> bitvector(8)

$[complete]
function getbyte (x : bits(64), i : range(0, 7)) = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(x, $[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(8, i), 7), $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(8, i))

val aes_rv64_shiftrows_fwd : (bitvector(64), bitvector(64)) -> bitvector(64)

$[complete]
function aes_rv64_shiftrows_fwd (rs2, rs1) = {
    $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(getbyte(rs1, 3), $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(getbyte(rs2, 6), $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(getbyte(rs2, 1), $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(getbyte(rs1, 4), $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(getbyte(rs2, 7), $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(getbyte(rs2, 2), $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(getbyte(rs1, 5), getbyte(rs1, 0))))))))
}

val aes_rv64_shiftrows_inv : (bitvector(64), bitvector(64)) -> bitvector(64)

$[complete]
function aes_rv64_shiftrows_inv (rs2, rs1) = {
    $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(getbyte(rs2, 3), $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(getbyte(rs2, 6), $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(getbyte(rs1, 1), $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(getbyte(rs1, 4), $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(getbyte(rs1, 7), $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(getbyte(rs2, 2), $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(getbyte(rs2, 5), getbyte(rs1, 0))))))))
}

val aes_shift_rows_fwd : bitvector(128) -> bitvector(128)

$[complete]
function aes_shift_rows_fwd x = {
    let ic3 : bits(32) = aes_get_column(x, 3);
    let ic2 : bits(32) = aes_get_column(x, 2);
    let ic1 : bits(32) = aes_get_column(x, 1);
    let ic0 : bits(32) = aes_get_column(x, 0);
    let oc0 : bits(32) = $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(ic3, 31, 24), $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(ic2, 23, 16), $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(ic1, 15, 8), $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(ic0, 7, 0))));
    let oc1 : bits(32) = $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(ic0, 31, 24), $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(ic3, 23, 16), $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(ic2, 15, 8), $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(ic1, 7, 0))));
    let oc2 : bits(32) = $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(ic1, 31, 24), $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(ic0, 23, 16), $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(ic3, 15, 8), $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(ic2, 7, 0))));
    let oc3 : bits(32) = $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(ic2, 31, 24), $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(ic1, 23, 16), $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(ic0, 15, 8), $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(ic3, 7, 0))));
    $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(oc3, $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(oc2, $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(oc1, oc0)))
}

val aes_shift_rows_inv : bitvector(128) -> bitvector(128)

$[complete]
function aes_shift_rows_inv x = {
    let ic3 : bits(32) = aes_get_column(x, 3);
    let ic2 : bits(32) = aes_get_column(x, 2);
    let ic1 : bits(32) = aes_get_column(x, 1);
    let ic0 : bits(32) = aes_get_column(x, 0);
    let oc0 : bits(32) = $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(ic1, 31, 24), $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(ic2, 23, 16), $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(ic3, 15, 8), $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(ic0, 7, 0))));
    let oc1 : bits(32) = $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(ic2, 31, 24), $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(ic3, 23, 16), $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(ic0, 15, 8), $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(ic1, 7, 0))));
    let oc2 : bits(32) = $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(ic3, 31, 24), $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(ic0, 23, 16), $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(ic1, 15, 8), $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(ic2, 7, 0))));
    let oc3 : bits(32) = $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(ic0, 31, 24), $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(ic1, 23, 16), $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(ic2, 15, 8), $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(ic3, 7, 0))));
    $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(oc3, $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(oc2, $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(oc1, oc0)))
}

val aes_subbytes_fwd : bitvector(128) -> bitvector(128)

$[complete]
function aes_subbytes_fwd x = {
    let oc0 : bits(32) = aes_subword_fwd(aes_get_column(x, 0));
    let oc1 : bits(32) = aes_subword_fwd(aes_get_column(x, 1));
    let oc2 : bits(32) = aes_subword_fwd(aes_get_column(x, 2));
    let oc3 : bits(32) = aes_subword_fwd(aes_get_column(x, 3));
    $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(oc3, $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(oc2, $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(oc1, oc0)))
}

val aes_subbytes_inv : bitvector(128) -> bitvector(128)

$[complete]
function aes_subbytes_inv x = {
    let oc0 : bits(32) = aes_subword_inv(aes_get_column(x, 0));
    let oc1 : bits(32) = aes_subword_inv(aes_get_column(x, 1));
    let oc2 : bits(32) = aes_subword_inv(aes_get_column(x, 2));
    let oc3 : bits(32) = aes_subword_inv(aes_get_column(x, 3));
    $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(oc3, $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(oc2, $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(oc1, oc0)))
}

val aes_mixcolumns_fwd : bitvector(128) -> bitvector(128)

$[complete]
function aes_mixcolumns_fwd x = {
    let oc0 : bits(32) = aes_mixcolumn_fwd(aes_get_column(x, 0));
    let oc1 : bits(32) = aes_mixcolumn_fwd(aes_get_column(x, 1));
    let oc2 : bits(32) = aes_mixcolumn_fwd(aes_get_column(x, 2));
    let oc3 : bits(32) = aes_mixcolumn_fwd(aes_get_column(x, 3));
    $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(oc3, $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(oc2, $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(oc1, oc0)))
}

val aes_mixcolumns_inv : bitvector(128) -> bitvector(128)

$[complete]
function aes_mixcolumns_inv x = {
    let oc0 : bits(32) = aes_mixcolumn_inv(aes_get_column(x, 0));
    let oc1 : bits(32) = aes_mixcolumn_inv(aes_get_column(x, 1));
    let oc2 : bits(32) = aes_mixcolumn_inv(aes_get_column(x, 2));
    let oc3 : bits(32) = aes_mixcolumn_inv(aes_get_column(x, 3));
    $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(oc3, $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(oc2, $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(oc1, oc0)))
}

val zvk_valid_reg_overlap : (vregidx, vregidx, int) -> bool

$[complete]
function zvk_valid_reg_overlap (rs, rd, emul_pow) = {
    let reg_group_size = if $[overloaded { "name" = ">", "is_infix" = true }] gt_int(emul_pow, 0) then
      2 ^ emul_pow
    else
      1;
    let rs_int = unsigned(vregidx_bits(rs));
    let rd_int = unsigned(vregidx_bits(rd));
    $[overloaded { "name" = "|", "is_infix" = true }] or_bool($[overloaded { "name" = "<=", "is_infix" = true }] lteq_int($[overloaded { "name" = "+", "is_infix" = true }] add_atom(rs_int, reg_group_size), rd_int), $[overloaded { "name" = "<=", "is_infix" = true }] lteq_int($[overloaded { "name" = "+", "is_infix" = true }] add_atom(rd_int, reg_group_size), rs_int))
}

val zvk_check_encdec : (nat, {('n : Int), 'n > 0. int('n)}) -> bool

$[complete]
function zvk_check_encdec (EGW : nat, EGS : nat1) = {
    let LMUL_pow = get_lmul_pow();
    let LMUL_times_VLEN = if $[overloaded { "name" = "<", "is_infix" = true }] lt_int(LMUL_pow, 0) then
      $[overloaded { "name" = "/", "is_infix" = true }] quot_positive_round_zero(vlen, 2 ^ abs_int_atom(LMUL_pow))
    else
      $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(2 ^ LMUL_pow, vlen);
    $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_int($[overloaded { "name" = "%", "is_infix" = true }] rem_positive_round_zero(unsigned(vl), EGS), 0), and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_int($[overloaded { "name" = "%", "is_infix" = true }] rem_positive_round_zero(unsigned(vstart), EGS), 0), $[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(LMUL_times_VLEN, EGW)) : bool)
}

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum zvk_vsha2_funct6 = {ZVK_VSHA2CH_VV, ZVK_VSHA2CL_VV}

val undefined_zvk_vsha2_funct6 : unit -> zvk_vsha2_funct6

$[complete]
function undefined_zvk_vsha2_funct6 () = internal_pick([|ZVK_VSHA2CH_VV, ZVK_VSHA2CL_VV|])

val zvk_vsha2_funct6_of_num : forall ('e : Int), (0 <= 'e & 'e <= 1).
  int('e) -> zvk_vsha2_funct6

$[complete]
function zvk_vsha2_funct6_of_num arg# = $[complete] match arg# {
  0 => ZVK_VSHA2CH_VV,
  _ => ZVK_VSHA2CL_VV
}

val num_of_zvk_vsha2_funct6 : zvk_vsha2_funct6 -> {('e : Int), (0 <= 'e & 'e <= 1). int('e)}

$[complete]
function num_of_zvk_vsha2_funct6 arg# = $[complete] match arg# {
  ZVK_VSHA2CH_VV => 0,
  ZVK_VSHA2CL_VV => 1
}

val zvknhab_check_encdec : (vregidx, vregidx, vregidx) -> bool

$[complete]
function zvknhab_check_encdec (vs2 : vregidx, vs1 : vregidx, vd : vregidx) = {
    let SEW = get_sew();
    let LMUL_pow = get_lmul_pow();
    $[overloaded { "name" = "&", "is_infix" = true }] and_bool(zvk_check_encdec(SEW, 4), $[overloaded { "name" = "&", "is_infix" = true }] and_bool(zvk_valid_reg_overlap(vs1, vd, LMUL_pow), zvk_valid_reg_overlap(vs2, vd, LMUL_pow)))
}

val zvk_sig0 : forall ('n : Int), 'n in {32, 64}.
  (bitvector('n), int('n)) -> bitvector('n)

$[complete]
function zvk_sig0 (x, SEW) = {
    $[complete] match SEW {
      32 => $[overloaded { "name" = "^", "is_infix" = true }] xor_vec($[overloaded { "name" = ">>>", "is_infix" = true }] rotater(x, 7), $[overloaded { "name" = "^", "is_infix" = true }] xor_vec($[overloaded { "name" = ">>>", "is_infix" = true }] rotater(x, 18), $[overloaded { "name" = ">>", "is_infix" = true }] shiftr(x, 3))),
      ($[int_wildcard 64] _) => $[overloaded { "name" = "^", "is_infix" = true }] xor_vec($[overloaded { "name" = ">>>", "is_infix" = true }] rotater(x, 1), $[overloaded { "name" = "^", "is_infix" = true }] xor_vec($[overloaded { "name" = ">>>", "is_infix" = true }] rotater(x, 8), $[overloaded { "name" = ">>", "is_infix" = true }] shiftr(x, 7)))
    }
}

val zvk_sig1 : forall ('n : Int), 'n in {32, 64}.
  (bitvector('n), int('n)) -> bitvector('n)

$[complete]
function zvk_sig1 (x, SEW) = {
    $[complete] match SEW {
      32 => $[overloaded { "name" = "^", "is_infix" = true }] xor_vec($[overloaded { "name" = ">>>", "is_infix" = true }] rotater(x, 17), $[overloaded { "name" = "^", "is_infix" = true }] xor_vec($[overloaded { "name" = ">>>", "is_infix" = true }] rotater(x, 19), $[overloaded { "name" = ">>", "is_infix" = true }] shiftr(x, 10))),
      ($[int_wildcard 64] _) => $[overloaded { "name" = "^", "is_infix" = true }] xor_vec($[overloaded { "name" = ">>>", "is_infix" = true }] rotater(x, 19), $[overloaded { "name" = "^", "is_infix" = true }] xor_vec($[overloaded { "name" = ">>>", "is_infix" = true }] rotater(x, 61), $[overloaded { "name" = ">>", "is_infix" = true }] shiftr(x, 6)))
    }
}

val zvk_sum0 : forall ('n : Int), 'n in {32, 64}.
  (bitvector('n), int('n)) -> bitvector('n)

$[complete]
function zvk_sum0 (x, SEW) = {
    $[complete] match SEW {
      32 => $[overloaded { "name" = "^", "is_infix" = true }] xor_vec($[overloaded { "name" = ">>>", "is_infix" = true }] rotater(x, 2), $[overloaded { "name" = "^", "is_infix" = true }] xor_vec($[overloaded { "name" = ">>>", "is_infix" = true }] rotater(x, 13), $[overloaded { "name" = ">>>", "is_infix" = true }] rotater(x, 22))),
      ($[int_wildcard 64] _) => $[overloaded { "name" = "^", "is_infix" = true }] xor_vec($[overloaded { "name" = ">>>", "is_infix" = true }] rotater(x, 28), $[overloaded { "name" = "^", "is_infix" = true }] xor_vec($[overloaded { "name" = ">>>", "is_infix" = true }] rotater(x, 34), $[overloaded { "name" = ">>>", "is_infix" = true }] rotater(x, 39)))
    }
}

val zvk_sum1 : forall ('n : Int), 'n in {32, 64}.
  (bitvector('n), int('n)) -> bitvector('n)

$[complete]
function zvk_sum1 (x, SEW) = {
    $[complete] match SEW {
      32 => $[overloaded { "name" = "^", "is_infix" = true }] xor_vec($[overloaded { "name" = ">>>", "is_infix" = true }] rotater(x, 6), $[overloaded { "name" = "^", "is_infix" = true }] xor_vec($[overloaded { "name" = ">>>", "is_infix" = true }] rotater(x, 11), $[overloaded { "name" = ">>>", "is_infix" = true }] rotater(x, 25))),
      ($[int_wildcard 64] _) => $[overloaded { "name" = "^", "is_infix" = true }] xor_vec($[overloaded { "name" = ">>>", "is_infix" = true }] rotater(x, 14), $[overloaded { "name" = "^", "is_infix" = true }] xor_vec($[overloaded { "name" = ">>>", "is_infix" = true }] rotater(x, 18), $[overloaded { "name" = ">>>", "is_infix" = true }] rotater(x, 41)))
    }
}

val zvk_ch : forall ('n : Int), 'n >= 0.
  (bitvector('n), bitvector('n), bitvector('n)) -> bitvector('n)

$[complete]
function zvk_ch (x, y, z) = $[overloaded { "name" = "^", "is_infix" = true }] xor_vec($[overloaded { "name" = "&", "is_infix" = true }] and_vec(x, y), $[overloaded { "name" = "&", "is_infix" = true }] and_vec($[overloaded { "name" = "~", "is_infix" = false }] not_vec(x), z))

val zvk_maj : forall ('n : Int), 'n >= 0.
  (bitvector('n), bitvector('n), bitvector('n)) -> bitvector('n)

$[complete]
function zvk_maj (x, y, z) = $[overloaded { "name" = "^", "is_infix" = true }] xor_vec($[overloaded { "name" = "&", "is_infix" = true }] and_vec(x, y), $[overloaded { "name" = "^", "is_infix" = true }] xor_vec($[overloaded { "name" = "&", "is_infix" = true }] and_vec(x, z), $[overloaded { "name" = "&", "is_infix" = true }] and_vec(y, z)))

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum zvk_vsm4r_funct6 = {ZVK_VSM4R_VV, ZVK_VSM4R_VS}

val undefined_zvk_vsm4r_funct6 : unit -> zvk_vsm4r_funct6

$[complete]
function undefined_zvk_vsm4r_funct6 () = internal_pick([|ZVK_VSM4R_VV, ZVK_VSM4R_VS|])

val zvk_vsm4r_funct6_of_num : forall ('e : Int), (0 <= 'e & 'e <= 1).
  int('e) -> zvk_vsm4r_funct6

$[complete]
function zvk_vsm4r_funct6_of_num arg# = $[complete] match arg# {
  0 => ZVK_VSM4R_VV,
  _ => ZVK_VSM4R_VS
}

val num_of_zvk_vsm4r_funct6 : zvk_vsm4r_funct6 -> {('e : Int), (0 <= 'e & 'e <= 1). int('e)}

$[complete]
function num_of_zvk_vsm4r_funct6 arg# = $[complete] match arg# {
  ZVK_VSM4R_VV => 0,
  ZVK_VSM4R_VS => 1
}

val zvk_round_key : (bitvector(32), bitvector(32)) -> bitvector(32)

$[complete]
function zvk_round_key (X, S) = $[overloaded { "name" = "^", "is_infix" = true }] xor_vec(X, $[overloaded { "name" = "^", "is_infix" = true }] xor_vec(S, $[overloaded { "name" = "^", "is_infix" = true }] xor_vec($[overloaded { "name" = "<<<", "is_infix" = true }] rotatel(S, 13), $[overloaded { "name" = "<<<", "is_infix" = true }] rotatel(S, 23))))

val zvk_sm4_round : (bitvector(32), bitvector(32)) -> bitvector(32)

$[complete]
function zvk_sm4_round (X, S) = $[overloaded { "name" = "^", "is_infix" = true }] xor_vec(X, $[overloaded { "name" = "^", "is_infix" = true }] xor_vec(S, $[overloaded { "name" = "^", "is_infix" = true }] xor_vec($[overloaded { "name" = "<<<", "is_infix" = true }] rotatel(S, 2), $[overloaded { "name" = "^", "is_infix" = true }] xor_vec($[overloaded { "name" = "<<<", "is_infix" = true }] rotatel(S, 10), $[overloaded { "name" = "^", "is_infix" = true }] xor_vec($[overloaded { "name" = "<<<", "is_infix" = true }] rotatel(S, 18), $[overloaded { "name" = "<<<", "is_infix" = true }] rotatel(S, 24))))))

let zvksed_ck : vector(32, bits(32)) = [0x00070E15, 0x1C232A31, 0x383F464D, 0x545B6269, 0x70777E85, 0x8C939AA1, 0xA8AFB6BD, 0xC4CBD2D9, 0xE0E7EEF5, 0xFC030A11, 0x181F262D, 0x343B4249, 0x50575E65, 0x6C737A81, 0x888F969D, 0xA4ABB2B9, 0xC0C7CED5, 0xDCE3EAF1, 0xF8FF060D, 0x141B2229, 0x30373E45, 0x4C535A61, 0x686F767D, 0x848B9299, 0xA0A7AEB5, 0xBCC3CAD1, 0xD8DFE6ED, 0xF4FB0209, 0x10171E25, 0x2C333A41, 0x484F565D, 0x646B7279]

val zvksed_box_lookup : (bitvector(5), vector(32, bitvector(32))) -> bitvector(32)

$[complete]
function zvksed_box_lookup (x, table) = {
    $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(table, $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(31, unsigned(x)))
}

val zvk_sm4_sbox : bitvector(5) -> bitvector(32)

$[complete]
function zvk_sm4_sbox x = zvksed_box_lookup(x, zvksed_ck)

val zvk_sm4_subword : bitvector(32) -> bitvector(32)

$[complete]
function zvk_sm4_subword x = {
    $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(sm4_sbox($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(x, 31, 24)), $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(sm4_sbox($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(x, 23, 16)), $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(sm4_sbox($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(x, 15, 8)), sm4_sbox($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(x, 7, 0)))))
}

val zvk_p0 : bitvector(32) -> bitvector(32)

$[complete]
function zvk_p0 X = $[overloaded { "name" = "^", "is_infix" = true }] xor_vec(X, $[overloaded { "name" = "^", "is_infix" = true }] xor_vec($[overloaded { "name" = "<<<", "is_infix" = true }] rotatel(X, 9), $[overloaded { "name" = "<<<", "is_infix" = true }] rotatel(X, 17)))

val zvk_p1 : bitvector(32) -> bitvector(32)

$[complete]
function zvk_p1 X = $[overloaded { "name" = "^", "is_infix" = true }] xor_vec(X, $[overloaded { "name" = "^", "is_infix" = true }] xor_vec($[overloaded { "name" = "<<<", "is_infix" = true }] rotatel(X, 15), $[overloaded { "name" = "<<<", "is_infix" = true }] rotatel(X, 23)))

val zvk_sh_w : (bitvector(32), bitvector(32), bitvector(32), bitvector(32), bitvector(32)) -> bitvector(32)

$[complete]
function zvk_sh_w (A, B, C, D, E) = $[overloaded { "name" = "^", "is_infix" = true }] xor_vec(zvk_p1($[overloaded { "name" = "^", "is_infix" = true }] xor_vec(A, $[overloaded { "name" = "^", "is_infix" = true }] xor_vec(B, $[overloaded { "name" = "<<<", "is_infix" = true }] rotatel(C, 15)))), $[overloaded { "name" = "^", "is_infix" = true }] xor_vec($[overloaded { "name" = "<<<", "is_infix" = true }] rotatel(D, 7), E))

val zvk_ff1 : (bitvector(32), bitvector(32), bitvector(32)) -> bitvector(32)

$[complete]
function zvk_ff1 (X, Y, Z) = $[overloaded { "name" = "^", "is_infix" = true }] xor_vec(X, $[overloaded { "name" = "^", "is_infix" = true }] xor_vec(Y, Z))

val zvk_ff2 : (bitvector(32), bitvector(32), bitvector(32)) -> bitvector(32)

$[complete]
function zvk_ff2 (X, Y, Z) = $[overloaded { "name" = "|", "is_infix" = true }] or_vec($[overloaded { "name" = "&", "is_infix" = true }] and_vec(X, Y), $[overloaded { "name" = "|", "is_infix" = true }] or_vec($[overloaded { "name" = "&", "is_infix" = true }] and_vec(X, Z), $[overloaded { "name" = "&", "is_infix" = true }] and_vec(Y, Z)))

val zvk_ff_j : (bitvector(32), bitvector(32), bitvector(32), nat) -> bitvector(32)

$[complete]
function zvk_ff_j (X, Y, Z, J) = if $[overloaded { "name" = "<=", "is_infix" = true }] lteq_int(J, 15) then
  zvk_ff1(X, Y, Z)
else
  zvk_ff2(X, Y, Z)

val zvk_gg1 : (bitvector(32), bitvector(32), bitvector(32)) -> bitvector(32)

$[complete]
function zvk_gg1 (X, Y, Z) = $[overloaded { "name" = "^", "is_infix" = true }] xor_vec(X, $[overloaded { "name" = "^", "is_infix" = true }] xor_vec(Y, Z))

val zvk_gg2 : (bitvector(32), bitvector(32), bitvector(32)) -> bitvector(32)

$[complete]
function zvk_gg2 (X, Y, Z) = $[overloaded { "name" = "|", "is_infix" = true }] or_vec($[overloaded { "name" = "&", "is_infix" = true }] and_vec(X, Y), $[overloaded { "name" = "&", "is_infix" = true }] and_vec($[overloaded { "name" = "~", "is_infix" = false }] not_vec(X), Z))

val zvk_gg_j : (bitvector(32), bitvector(32), bitvector(32), nat) -> bitvector(32)

$[complete]
function zvk_gg_j (X, Y, Z, J) = if $[overloaded { "name" = "<=", "is_infix" = true }] lteq_int(J, 15) then
  zvk_gg1(X, Y, Z)
else
  zvk_gg2(X, Y, Z)

val zvk_t_j : nat -> bitvector(32)

$[complete]
function zvk_t_j J = if $[overloaded { "name" = "<=", "is_infix" = true }] lteq_int(J, 15) then
  0x79CC4519
else
  0x7A879D8A

val zvk_sm3_round : (vector(8, bitvector(32)), bitvector(32), bitvector(32), nat) -> vector(8, bitvector(32))

$[complete]
function zvk_sm3_round (A_H : vector(8, bits(32)), w : bits(32), x : bits(32), j : nat) = {
    let t_j = $[overloaded { "name" = "<<<", "is_infix" = true }] rotatel(zvk_t_j(j), $[overloaded { "name" = "%", "is_infix" = true }] rem_positive_round_zero(j, 32));
    let ss1 = $[overloaded { "name" = "<<<", "is_infix" = true }] rotatel($[overloaded { "name" = "+", "is_infix" = true }] add_bits($[overloaded { "name" = "+", "is_infix" = true }] add_bits($[overloaded { "name" = "<<<", "is_infix" = true }] rotatel($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(A_H, 0), 12), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(A_H, 4)), t_j), 7);
    let ss2 = $[overloaded { "name" = "^", "is_infix" = true }] xor_vec(ss1, $[overloaded { "name" = "<<<", "is_infix" = true }] rotatel($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(A_H, 0), 12));
    let tt1 = $[overloaded { "name" = "+", "is_infix" = true }] add_bits($[overloaded { "name" = "+", "is_infix" = true }] add_bits($[overloaded { "name" = "+", "is_infix" = true }] add_bits(zvk_ff_j($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(A_H, 0), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(A_H, 1), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(A_H, 2), j), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(A_H, 3)), ss2), x);
    let tt2 = $[overloaded { "name" = "+", "is_infix" = true }] add_bits($[overloaded { "name" = "+", "is_infix" = true }] add_bits($[overloaded { "name" = "+", "is_infix" = true }] add_bits(zvk_gg_j($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(A_H, 4), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(A_H, 5), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(A_H, 6), j), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(A_H, 7)), ss1), w);
    let A1 = tt1;
    let C1 = $[overloaded { "name" = "<<<", "is_infix" = true }] rotatel($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(A_H, 1), 9);
    let E1 = zvk_p0(tt2);
    let G1 = $[overloaded { "name" = "<<<", "is_infix" = true }] rotatel($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(A_H, 5), 19);
    [$[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(A_H, 6), G1, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(A_H, 4), E1, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(A_H, 2), C1, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(A_H, 0), A1]
}

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum zvk_vaesdf_funct6 = {ZVK_VAESDF_VV, ZVK_VAESDF_VS}

val undefined_zvk_vaesdf_funct6 : unit -> zvk_vaesdf_funct6

$[complete]
function undefined_zvk_vaesdf_funct6 () = internal_pick([|ZVK_VAESDF_VV, ZVK_VAESDF_VS|])

val zvk_vaesdf_funct6_of_num : forall ('e : Int), (0 <= 'e & 'e <= 1).
  int('e) -> zvk_vaesdf_funct6

$[complete]
function zvk_vaesdf_funct6_of_num arg# = $[complete] match arg# {
  0 => ZVK_VAESDF_VV,
  _ => ZVK_VAESDF_VS
}

val num_of_zvk_vaesdf_funct6 : zvk_vaesdf_funct6 -> {('e : Int), (0 <= 'e & 'e <= 1). int('e)}

$[complete]
function num_of_zvk_vaesdf_funct6 arg# = $[complete] match arg# {
  ZVK_VAESDF_VV => 0,
  ZVK_VAESDF_VS => 1
}

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum zvk_vaesdm_funct6 = {ZVK_VAESDM_VV, ZVK_VAESDM_VS}

val undefined_zvk_vaesdm_funct6 : unit -> zvk_vaesdm_funct6

$[complete]
function undefined_zvk_vaesdm_funct6 () = internal_pick([|ZVK_VAESDM_VV, ZVK_VAESDM_VS|])

val zvk_vaesdm_funct6_of_num : forall ('e : Int), (0 <= 'e & 'e <= 1).
  int('e) -> zvk_vaesdm_funct6

$[complete]
function zvk_vaesdm_funct6_of_num arg# = $[complete] match arg# {
  0 => ZVK_VAESDM_VV,
  _ => ZVK_VAESDM_VS
}

val num_of_zvk_vaesdm_funct6 : zvk_vaesdm_funct6 -> {('e : Int), (0 <= 'e & 'e <= 1). int('e)}

$[complete]
function num_of_zvk_vaesdm_funct6 arg# = $[complete] match arg# {
  ZVK_VAESDM_VV => 0,
  ZVK_VAESDM_VS => 1
}

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum zvk_vaesef_funct6 = {ZVK_VAESEF_VV, ZVK_VAESEF_VS}

val undefined_zvk_vaesef_funct6 : unit -> zvk_vaesef_funct6

$[complete]
function undefined_zvk_vaesef_funct6 () = internal_pick([|ZVK_VAESEF_VV, ZVK_VAESEF_VS|])

val zvk_vaesef_funct6_of_num : forall ('e : Int), (0 <= 'e & 'e <= 1).
  int('e) -> zvk_vaesef_funct6

$[complete]
function zvk_vaesef_funct6_of_num arg# = $[complete] match arg# {
  0 => ZVK_VAESEF_VV,
  _ => ZVK_VAESEF_VS
}

val num_of_zvk_vaesef_funct6 : zvk_vaesef_funct6 -> {('e : Int), (0 <= 'e & 'e <= 1). int('e)}

$[complete]
function num_of_zvk_vaesef_funct6 arg# = $[complete] match arg# {
  ZVK_VAESEF_VV => 0,
  ZVK_VAESEF_VS => 1
}

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum zvk_vaesem_funct6 = {ZVK_VAESEM_VV, ZVK_VAESEM_VS}

val undefined_zvk_vaesem_funct6 : unit -> zvk_vaesem_funct6

$[complete]
function undefined_zvk_vaesem_funct6 () = internal_pick([|ZVK_VAESEM_VV, ZVK_VAESEM_VS|])

val zvk_vaesem_funct6_of_num : forall ('e : Int), (0 <= 'e & 'e <= 1).
  int('e) -> zvk_vaesem_funct6

$[complete]
function zvk_vaesem_funct6_of_num arg# = $[complete] match arg# {
  0 => ZVK_VAESEM_VV,
  _ => ZVK_VAESEM_VS
}

val num_of_zvk_vaesem_funct6 : zvk_vaesem_funct6 -> {('e : Int), (0 <= 'e & 'e <= 1). int('e)}

$[complete]
function num_of_zvk_vaesem_funct6 arg# = $[complete] match arg# {
  ZVK_VAESEM_VV => 0,
  ZVK_VAESEM_VS => 1
}

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum csrop = {CSRRW, CSRRS, CSRRC}

val undefined_csrop : unit -> csrop

$[complete]
function undefined_csrop () = internal_pick([|CSRRW, CSRRS, CSRRC|])

val csrop_of_num : forall ('e : Int), (0 <= 'e & 'e <= 2). int('e) -> csrop

$[complete]
function csrop_of_num arg# = $[complete] match arg# {
  0 => CSRRW,
  1 => CSRRS,
  _ => CSRRC
}

val num_of_csrop : csrop -> {('e : Int), (0 <= 'e & 'e <= 2). int('e)}

$[complete]
function num_of_csrop arg# = $[complete] match arg# {
  CSRRW => 0,
  CSRRS => 1,
  CSRRC => 2
}

$[undefined_gen "skip"]
$[bitfield]
struct CountSmcntrpmf = {bits : bitvector(64)}

val undefined_CountSmcntrpmf : unit -> CountSmcntrpmf

$[complete]
function undefined_CountSmcntrpmf () = struct CountSmcntrpmf { bits = undefined }

val Mk_CountSmcntrpmf : bitvector(64) -> CountSmcntrpmf

$[complete]
function Mk_CountSmcntrpmf v = struct CountSmcntrpmf { bits = v }

$[fix_location]
val _get_CountSmcntrpmf_bits : CountSmcntrpmf -> bitvector(64)

$[complete]
$[fix_location]
function _get_CountSmcntrpmf_bits v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, sub_atom(64, 1), 0)

$[fix_location]
val _update_CountSmcntrpmf_bits : (CountSmcntrpmf, bitvector(64)) -> CountSmcntrpmf

$[complete]
$[fix_location]
function _update_CountSmcntrpmf_bits (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, sub_atom(64, 1), 0, x) }

$[fix_location]
overload update_bits = {_update_CountSmcntrpmf_bits}

$[fix_location]
val _set_CountSmcntrpmf_bits : (register(CountSmcntrpmf), bitvector(64)) -> unit

$[complete]
$[fix_location]
function _set_CountSmcntrpmf_bits (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_CountSmcntrpmf_bits(r, v)
}

overload _mod_bits = {_get_CountSmcntrpmf_bits, _set_CountSmcntrpmf_bits}

$[fix_location]
val _get_CountSmcntrpmf_MINH : CountSmcntrpmf -> bitvector(1)

$[complete]
$[fix_location]
function _get_CountSmcntrpmf_MINH v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 62, 62)

$[fix_location]
val _update_CountSmcntrpmf_MINH : (CountSmcntrpmf, bitvector(1)) -> CountSmcntrpmf

$[complete]
$[fix_location]
function _update_CountSmcntrpmf_MINH (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 62, 62, x) }

$[fix_location]
overload update_MINH = {_update_CountSmcntrpmf_MINH}

$[fix_location]
val _set_CountSmcntrpmf_MINH : (register(CountSmcntrpmf), bitvector(1)) -> unit

$[complete]
$[fix_location]
function _set_CountSmcntrpmf_MINH (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_CountSmcntrpmf_MINH(r, v)
}

overload _mod_MINH = {_get_CountSmcntrpmf_MINH, _set_CountSmcntrpmf_MINH}

$[fix_location]
val _get_CountSmcntrpmf_SINH : CountSmcntrpmf -> bitvector(1)

$[complete]
$[fix_location]
function _get_CountSmcntrpmf_SINH v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 61, 61)

$[fix_location]
val _update_CountSmcntrpmf_SINH : (CountSmcntrpmf, bitvector(1)) -> CountSmcntrpmf

$[complete]
$[fix_location]
function _update_CountSmcntrpmf_SINH (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 61, 61, x) }

$[fix_location]
overload update_SINH = {_update_CountSmcntrpmf_SINH}

$[fix_location]
val _set_CountSmcntrpmf_SINH : (register(CountSmcntrpmf), bitvector(1)) -> unit

$[complete]
$[fix_location]
function _set_CountSmcntrpmf_SINH (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_CountSmcntrpmf_SINH(r, v)
}

overload _mod_SINH = {_get_CountSmcntrpmf_SINH, _set_CountSmcntrpmf_SINH}

$[fix_location]
val _get_CountSmcntrpmf_UINH : CountSmcntrpmf -> bitvector(1)

$[complete]
$[fix_location]
function _get_CountSmcntrpmf_UINH v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 60, 60)

$[fix_location]
val _update_CountSmcntrpmf_UINH : (CountSmcntrpmf, bitvector(1)) -> CountSmcntrpmf

$[complete]
$[fix_location]
function _update_CountSmcntrpmf_UINH (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 60, 60, x) }

$[fix_location]
overload update_UINH = {_update_CountSmcntrpmf_UINH}

$[fix_location]
val _set_CountSmcntrpmf_UINH : (register(CountSmcntrpmf), bitvector(1)) -> unit

$[complete]
$[fix_location]
function _set_CountSmcntrpmf_UINH (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_CountSmcntrpmf_UINH(r, v)
}

overload _mod_UINH = {_get_CountSmcntrpmf_UINH, _set_CountSmcntrpmf_UINH}

$[fix_location]
val _get_CountSmcntrpmf_VSINH : CountSmcntrpmf -> bitvector(1)

$[complete]
$[fix_location]
function _get_CountSmcntrpmf_VSINH v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 59, 59)

$[fix_location]
val _update_CountSmcntrpmf_VSINH : (CountSmcntrpmf, bitvector(1)) -> CountSmcntrpmf

$[complete]
$[fix_location]
function _update_CountSmcntrpmf_VSINH (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 59, 59, x) }

$[fix_location]
overload update_VSINH = {_update_CountSmcntrpmf_VSINH}

$[fix_location]
val _set_CountSmcntrpmf_VSINH : (register(CountSmcntrpmf), bitvector(1)) -> unit

$[complete]
$[fix_location]
function _set_CountSmcntrpmf_VSINH (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_CountSmcntrpmf_VSINH(r, v)
}

overload _mod_VSINH = {_get_CountSmcntrpmf_VSINH, _set_CountSmcntrpmf_VSINH}

$[fix_location]
val _get_CountSmcntrpmf_VUINH : CountSmcntrpmf -> bitvector(1)

$[complete]
$[fix_location]
function _get_CountSmcntrpmf_VUINH v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 58, 58)

$[fix_location]
val _update_CountSmcntrpmf_VUINH : (CountSmcntrpmf, bitvector(1)) -> CountSmcntrpmf

$[complete]
$[fix_location]
function _update_CountSmcntrpmf_VUINH (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 58, 58, x) }

$[fix_location]
overload update_VUINH = {_update_CountSmcntrpmf_VUINH}

$[fix_location]
val _set_CountSmcntrpmf_VUINH : (register(CountSmcntrpmf), bitvector(1)) -> unit

$[complete]
$[fix_location]
function _set_CountSmcntrpmf_VUINH (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_CountSmcntrpmf_VUINH(r, v)
}

overload _mod_VUINH = {_get_CountSmcntrpmf_VUINH, _set_CountSmcntrpmf_VUINH}

val legalize_smcntrpmf : (CountSmcntrpmf, bitvector(64)) -> CountSmcntrpmf

$[complete]
function legalize_smcntrpmf (c : CountSmcntrpmf, value : bits(64)) = {
    let v = Mk_CountSmcntrpmf(value);
    _update_CountSmcntrpmf_VUINH(_update_CountSmcntrpmf_VSINH(_update_CountSmcntrpmf_UINH(_update_CountSmcntrpmf_SINH(_update_CountSmcntrpmf_MINH(c, _get_CountSmcntrpmf_MINH(v)), if currentlyEnabled(Ext_S) then
      _get_CountSmcntrpmf_SINH(v)
    else
      0b0), if currentlyEnabled(Ext_U) then _get_CountSmcntrpmf_UINH(v) else 0b0), if currentlyEnabled(Ext_H) then
      _get_CountSmcntrpmf_VSINH(v)
    else
      0b0), if currentlyEnabled(Ext_H) then _get_CountSmcntrpmf_VUINH(v) else
      0b0)
}

register mcyclecfg : CountSmcntrpmf

register minstretcfg : CountSmcntrpmf

val counter_priv_filter_bit : (CountSmcntrpmf, Privilege) -> bitvector(1)

$[complete]
function counter_priv_filter_bit (reg : CountSmcntrpmf, priv : Privilege) = $[complete] match priv {
  Machine => _get_CountSmcntrpmf_MINH(reg),
  Supervisor => _get_CountSmcntrpmf_SINH(reg),
  VirtualSupervisor => _get_CountSmcntrpmf_VSINH(reg),
  User => _get_CountSmcntrpmf_UINH(reg),
  VirtualUser => _get_CountSmcntrpmf_VUINH(reg)
}

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum wrsop = {WRS_STO, WRS_NTO}

val undefined_wrsop : unit -> wrsop

$[complete]
function undefined_wrsop () = internal_pick([|WRS_STO, WRS_NTO|])

val wrsop_of_num : forall ('e : Int), (0 <= 'e & 'e <= 1). int('e) -> wrsop

$[complete]
function wrsop_of_num arg# = $[complete] match arg# {
  0 => WRS_STO,
  _ => WRS_NTO
}

val num_of_wrsop : wrsop -> {('e : Int), (0 <= 'e & 'e <= 1). int('e)}

$[complete]
function num_of_wrsop arg# = $[complete] match arg# {
  WRS_STO => 0,
  WRS_NTO => 1
}

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum zicondop = {CZERO_EQZ, CZERO_NEZ}

val undefined_zicondop : unit -> zicondop

$[complete]
function undefined_zicondop () = internal_pick([|CZERO_EQZ, CZERO_NEZ|])

val zicondop_of_num : forall ('e : Int), (0 <= 'e & 'e <= 1).
  int('e) -> zicondop

$[complete]
function zicondop_of_num arg# = $[complete] match arg# {
  0 => CZERO_EQZ,
  _ => CZERO_NEZ
}

val num_of_zicondop : zicondop -> {('e : Int), (0 <= 'e & 'e <= 1). int('e)}

$[complete]
function num_of_zicondop arg# = $[complete] match arg# {
  CZERO_EQZ => 0,
  CZERO_NEZ => 1
}

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum cbop_zicbom = {CBO_CLEAN, CBO_FLUSH, CBO_INVAL}

val undefined_cbop_zicbom : unit -> cbop_zicbom

$[complete]
function undefined_cbop_zicbom () = internal_pick([|CBO_CLEAN, CBO_FLUSH, CBO_INVAL|])

val cbop_zicbom_of_num : forall ('e : Int), (0 <= 'e & 'e <= 2).
  int('e) -> cbop_zicbom

$[complete]
function cbop_zicbom_of_num arg# = $[complete] match arg# {
  0 => CBO_CLEAN,
  1 => CBO_FLUSH,
  _ => CBO_INVAL
}

val num_of_cbop_zicbom : cbop_zicbom -> {('e : Int), (0 <= 'e & 'e <= 2). int('e)}

$[complete]
function num_of_cbop_zicbom arg# = $[complete] match arg# {
  CBO_CLEAN => 0,
  CBO_FLUSH => 1,
  CBO_INVAL => 2
}

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum cbop_zicbop = {PREFETCH_I, PREFETCH_R, PREFETCH_W}

val undefined_cbop_zicbop : unit -> cbop_zicbop

$[complete]
function undefined_cbop_zicbop () = internal_pick([|PREFETCH_I, PREFETCH_R, PREFETCH_W|])

val cbop_zicbop_of_num : forall ('e : Int), (0 <= 'e & 'e <= 2).
  int('e) -> cbop_zicbop

$[complete]
function cbop_zicbop_of_num arg# = $[complete] match arg# {
  0 => PREFETCH_I,
  1 => PREFETCH_R,
  _ => PREFETCH_W
}

val num_of_cbop_zicbop : cbop_zicbop -> {('e : Int), (0 <= 'e & 'e <= 2). int('e)}

$[complete]
function num_of_cbop_zicbop arg# = $[complete] match arg# {
  PREFETCH_I => 0,
  PREFETCH_R => 1,
  PREFETCH_W => 2
}

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum ntl_type = {NTL_P1, NTL_PALL, NTL_S1, NTL_ALL}

val undefined_ntl_type : unit -> ntl_type

$[complete]
function undefined_ntl_type () = internal_pick([|NTL_P1, NTL_PALL, NTL_S1, NTL_ALL|])

val ntl_type_of_num : forall ('e : Int), (0 <= 'e & 'e <= 3).
  int('e) -> ntl_type

$[complete]
function ntl_type_of_num arg# = $[complete] match arg# {
  0 => NTL_P1,
  1 => NTL_PALL,
  2 => NTL_S1,
  _ => NTL_ALL
}

val num_of_ntl_type : ntl_type -> {('e : Int), (0 <= 'e & 'e <= 3). int('e)}

$[complete]
function num_of_ntl_type arg# = $[complete] match arg# {
  NTL_P1 => 0,
  NTL_PALL => 1,
  NTL_S1 => 2,
  NTL_ALL => 3
}

val ntl_name : ntl_type <-> string

mapping ntl_name = {
  NTL_P1 <-> "p1",
  NTL_PALL <-> "pall",
  NTL_S1 <-> "s1",
  NTL_ALL <-> "all"
}

val encdec_ntl : ntl_type <-> bitvector(5)

mapping encdec_ntl = {
  NTL_P1 <-> 0b00010,
  NTL_PALL <-> 0b00011,
  NTL_S1 <-> 0b00100,
  NTL_ALL <-> 0b00101
}

val load_reservation = monadic {interpreter: "Platform.load_reservation", c: "load_reservation", lem: "load_reservation"}: bitvector(if xlen == 32 then 34 else 64) -> unit

val match_reservation = pure {interpreter: "Platform.match_reservation", lem: "match_reservation", c: "match_reservation"}: bitvector(if xlen == 32 then 34 else 64) -> bool

val cancel_reservation = monadic {interpreter: "Platform.cancel_reservation", c: "cancel_reservation", lem: "cancel_reservation"}: unit -> unit

val valid_reservation = pure {interpreter: "Platform.valid_reservation", c: "valid_reservation", lem: "valid_reservation"}: unit -> bool

val effectivePrivilege : (AccessType(unit), Mstatus, Privilege) -> Privilege

$[complete]
function effectivePrivilege (t : AccessType(ext_access_type), m : Mstatus, priv : Privilege) = if $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "!=", "is_infix" = true }] neq_anything(t, InstructionFetch()), $[overloaded { "name" = "==", "is_infix" = true }] eq_bits(_get_Mstatus_MPRV(m), 0b1)) then
  privLevel_bits_forwards((_get_Mstatus_MPP(m), bitzero))
else
  priv

val csrAccess : bitvector(12) -> bitvector(2)

$[complete]
function csrAccess csr : csreg = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(csr, 11, 10)

val csrPriv : bitvector(12) -> bitvector(2)

$[complete]
function csrPriv csr : csreg = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(csr, 9, 8)

val check_CSR_priv : (bitvector(12), Privilege) -> bool

$[complete]
function check_CSR_priv (csr : csreg, p : Privilege) = operator >=_u(privLevel_to_bits(p), csrPriv(csr))

val check_CSR_access : (bitvector(12), bool) -> bool

$[complete]
function check_CSR_access (csr : csreg, isWrite : bool) = not($[overloaded { "name" = "&", "is_infix" = true }] and_bool(isWrite, $[overloaded { "name" = "==", "is_infix" = true }] eq_bits(csrAccess(csr), 0b11)))

val check_CSR : (bitvector(12), Privilege, bool) -> bool

$[complete]
function check_CSR (csr : csreg, p : Privilege, isWrite : bool) = $[overloaded { "name" = "&", "is_infix" = true }] and_bool(check_CSR_priv(csr, p), $[overloaded { "name" = "&", "is_infix" = true }] and_bool(check_CSR_access(csr, isWrite), is_CSR_accessible(csr, p, isWrite)))

val exception_delegatee : (ExceptionType, Privilege) -> Privilege

$[complete]
function exception_delegatee (e : ExceptionType, p : Privilege) = {
    let idx = num_of_ExceptionType(e);
    let super = bit_to_bool($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(medeleg.bits, idx));
    let deleg = if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_S), super) then
      Supervisor
    else
      Machine;
    if operator <_u(privLevel_to_bits(deleg), privLevel_to_bits(p)) then p else
      deleg
}

val findPendingInterrupt : bitvector(xlen) -> option(InterruptType)

$[complete]
function findPendingInterrupt ip : xlenbits = {
    let ip = Mk_Minterrupts(ip);
    if $[overloaded { "name" = "==", "is_infix" = true }] eq_bits(_get_Minterrupts_MEI(ip), 0b1) then
      Some(I_M_External)
    else
      if $[overloaded { "name" = "==", "is_infix" = true }] eq_bits(_get_Minterrupts_MSI(ip), 0b1) then
        Some(I_M_Software)
      else
        if $[overloaded { "name" = "==", "is_infix" = true }] eq_bits(_get_Minterrupts_MTI(ip), 0b1) then
          Some(I_M_Timer)
        else
          if $[overloaded { "name" = "==", "is_infix" = true }] eq_bits(_get_Minterrupts_SEI(ip), 0b1) then
            Some(I_S_External)
          else
            if $[overloaded { "name" = "==", "is_infix" = true }] eq_bits(_get_Minterrupts_SSI(ip), 0b1) then
              Some(I_S_Software)
            else
              if $[overloaded { "name" = "==", "is_infix" = true }] eq_bits(_get_Minterrupts_STI(ip), 0b1) then
                Some(I_S_Timer)
              else
                None()
}

val getPendingSet : Privilege -> option((bitvector(xlen), Privilege))

$[complete]
function getPendingSet priv : Privilege = {
    assert($[overloaded { "name" = "|", "is_infix" = true }] or_bool(currentlyEnabled(Ext_S), $[overloaded { "name" = "==", "is_infix" = true }] eq_bits(mideleg.bits, zeros(sizeof(xlen)))), "./sys/sys_control.sail:70.58-70.59");
    let pending_m = $[overloaded { "name" = "&", "is_infix" = true }] and_vec(mip.bits, $[overloaded { "name" = "&", "is_infix" = true }] and_vec(mie.bits, $[overloaded { "name" = "~", "is_infix" = false }] not_vec(mideleg.bits)));
    let pending_s = $[overloaded { "name" = "&", "is_infix" = true }] and_vec(mip.bits, $[overloaded { "name" = "&", "is_infix" = true }] and_vec(mie.bits, mideleg.bits));
    let mIE = $[overloaded { "name" = "|", "is_infix" = true }] or_bool($[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_anything(priv, Machine), $[overloaded { "name" = "==", "is_infix" = true }] eq_bits(_get_Mstatus_MIE(mstatus), 0b1)), $[overloaded { "name" = "|", "is_infix" = true }] or_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_anything(priv, Supervisor), $[overloaded { "name" = "==", "is_infix" = true }] eq_anything(priv, User)));
    let sIE = $[overloaded { "name" = "|", "is_infix" = true }] or_bool($[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_anything(priv, Supervisor), $[overloaded { "name" = "==", "is_infix" = true }] eq_bits(_get_Mstatus_SIE(mstatus), 0b1)), $[overloaded { "name" = "==", "is_infix" = true }] eq_anything(priv, User));
    if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(mIE, $[overloaded { "name" = "!=", "is_infix" = true }] neq_bits(pending_m, zeros(sizeof(xlen)))) then
      Some((pending_m, Machine))
    else
      if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(sIE, $[overloaded { "name" = "!=", "is_infix" = true }] neq_bits(pending_s, zeros(sizeof(xlen)))) then
        Some((pending_s, Supervisor))
      else
        None()
}

val shouldWakeForInterrupt : unit -> bool

$[complete]
function shouldWakeForInterrupt () = {
    $[overloaded { "name" = "!=", "is_infix" = true }] neq_bits($[overloaded { "name" = "&", "is_infix" = true }] and_vec(mip.bits, mie.bits), zeros(sizeof(xlen)))
}

val dispatchInterrupt : Privilege -> option((InterruptType, Privilege))

$[complete]
function dispatchInterrupt priv : Privilege = {
    $[complete] match getPendingSet(priv) {
      None(()) => None(),
      Some((ip, p)) => $[complete] match findPendingInterrupt(ip) {
        None(()) => None(),
        Some(i) => Some((i, p))
      }
    }
}

union ctl_result = {CTL_TRAP : sync_exception, CTL_SRET : unit, CTL_MRET : unit}

val tval : option(bitvector(xlen)) -> bitvector(xlen)

$[complete]
function tval excinfo : option(xlenbits) = {
    $[complete] match excinfo {
      Some(e) => e,
      None(()) => zeros(sizeof(xlen))
    }
}

val track_trap : Privilege -> unit

$[complete]
function track_trap p : Privilege = {
    long_csr_write_callback("mstatus", "mstatush", mstatus.bits);
    $[complete] match p {
      Machine => {
          $[overloaded { "name" = "csr_write_callback", "is_infix" = false }] csr_name_write_callback("mcause", mcause.bits);
          $[overloaded { "name" = "csr_write_callback", "is_infix" = false }] csr_name_write_callback("mtval", mtval);
          $[overloaded { "name" = "csr_write_callback", "is_infix" = false }] csr_name_write_callback("mepc", mepc)
      },
      Supervisor => {
          $[overloaded { "name" = "csr_write_callback", "is_infix" = false }] csr_name_write_callback("scause", scause.bits);
          $[overloaded { "name" = "csr_write_callback", "is_infix" = false }] csr_name_write_callback("stval", stval);
          $[overloaded { "name" = "csr_write_callback", "is_infix" = false }] csr_name_write_callback("sepc", sepc)
      },
      User => internal_error("./sys/sys_control.sail", 148, "Invalid privilege level"),
      VirtualUser => internal_error("./sys/sys_control.sail", 149, "Hypervisor extension not supported"),
      VirtualSupervisor => internal_error("./sys/sys_control.sail", 150, "Hypervisor extension not supported")
    }
}

val trap_handler : (Privilege, bool, bitvector(8), bitvector(xlen), option(bitvector(xlen)), option(unit)) -> bitvector(xlen)

$[complete]
function trap_handler (del_priv : Privilege, intr : bool, c : exc_code, pc : xlenbits, info : option(xlenbits), ext : option(ext_exception)) = {
    trap_callback();
    if get_config_print_platform() then print_log($[overloaded { "name" = "^", "is_infix" = true }] concat_str("handling ", $[overloaded { "name" = "^", "is_infix" = true }] concat_str(if intr then
      "int#"
    else
      "exc#", $[overloaded { "name" = "^", "is_infix" = true }] concat_str(bits_str(c), $[overloaded { "name" = "^", "is_infix" = true }] concat_str(" at priv ", $[overloaded { "name" = "^", "is_infix" = true }] concat_str($[overloaded { "name" = "to_str", "is_infix" = false }] privLevel_to_str(del_priv), $[overloaded { "name" = "^", "is_infix" = true }] concat_str(" with tval ", bits_str(tval(info)))))))));
    $[complete] match del_priv {
      Machine => {
          mcause.bits[sub_atom(sizeof(xlen), 1) .. sub_atom(sizeof(xlen), 1)] = bool_to_bits(intr);
          mcause.bits[sub_atom(sizeof(xlen), 2) .. 0] = zero_extend(sub_atom(sizeof(xlen), 1), c);
          mstatus.bits[7 .. 7] = _get_Mstatus_MIE(mstatus);
          mstatus.bits[3 .. 3] = 0b0;
          mstatus.bits[12 .. 11] = privLevel_to_bits(cur_privilege);
          mtval = tval(info);
          mepc = pc;
          cur_privilege = del_priv;
          handle_trap_extension(del_priv, pc, ext);
          track_trap(del_priv);
          prepare_trap_vector(del_priv, mcause)
      },
      Supervisor => {
          assert(currentlyEnabled(Ext_S), "no supervisor mode present for delegation");
          scause.bits[sub_atom(sizeof(xlen), 1) .. sub_atom(sizeof(xlen), 1)] = bool_to_bits(intr);
          scause.bits[sub_atom(sizeof(xlen), 2) .. 0] = zero_extend(sub_atom(sizeof(xlen), 1), c);
          mstatus.bits[5 .. 5] = _get_Mstatus_SIE(mstatus);
          mstatus.bits[1 .. 1] = 0b0;
          mstatus.bits[8 .. 8] = $[complete] match cur_privilege {
            User => 0b0,
            Supervisor => 0b1,
            Machine => internal_error("./sys/sys_control.sail", 193, "invalid privilege for s-mode trap"),
            VirtualUser => internal_error("./sys/sys_control.sail", 194, "Hypervisor extension not supported"),
            VirtualSupervisor => internal_error("./sys/sys_control.sail", 195, "Hypervisor extension not supported")
          };
          stval = tval(info);
          sepc = pc;
          cur_privilege = del_priv;
          handle_trap_extension(del_priv, pc, ext);
          track_trap(del_priv);
          prepare_trap_vector(del_priv, scause)
      },
      User => internal_error("./sys/sys_control.sail", 208, "Invalid privilege level"),
      VirtualUser => internal_error("./sys/sys_control.sail", 209, "Hypervisor extension not supported"),
      VirtualSupervisor => internal_error("./sys/sys_control.sail", 210, "Hypervisor extension not supported")
    }
}

val exception_handler : (Privilege, ctl_result, bitvector(xlen)) -> bitvector(xlen)

$[complete]
function exception_handler (cur_priv : Privilege, ctl : ctl_result, pc : xlenbits) = {
    $[complete] match ctl {
      CTL_TRAP(e) => {
          let del_priv = exception_delegatee(e.trap, cur_priv);
          if get_config_print_platform() then print_log($[overloaded { "name" = "^", "is_infix" = true }] concat_str("trapping from ", $[overloaded { "name" = "^", "is_infix" = true }] concat_str($[overloaded { "name" = "to_str", "is_infix" = false }] privLevel_to_str(cur_priv), $[overloaded { "name" = "^", "is_infix" = true }] concat_str(" to ", $[overloaded { "name" = "^", "is_infix" = true }] concat_str($[overloaded { "name" = "to_str", "is_infix" = false }] privLevel_to_str(del_priv), $[overloaded { "name" = "^", "is_infix" = true }] concat_str(" to handle ", $[overloaded { "name" = "to_str", "is_infix" = false }] exceptionType_to_str(e.trap)))))));
          trap_handler(del_priv, false, exceptionType_to_bits(e.trap), pc, e.excinfo, e.ext)
      },
      CTL_MRET(()) => {
          let prev_priv = cur_privilege;
          mstatus.bits[3 .. 3] = _get_Mstatus_MPIE(mstatus);
          mstatus.bits[7 .. 7] = 0b1;
          cur_privilege = privLevel_bits_forwards((_get_Mstatus_MPP(mstatus), bitzero));
          mstatus.bits[12 .. 11] = privLevel_to_bits(if currentlyEnabled(Ext_U) then
            User
          else
            Machine);
          if $[overloaded { "name" = "!=", "is_infix" = true }] neq_anything(cur_privilege, Machine) then mstatus.bits[17 .. 17] = 0b0;
          long_csr_write_callback("mstatus", "mstatush", mstatus.bits);
          if get_config_print_platform() then print_log($[overloaded { "name" = "^", "is_infix" = true }] concat_str("ret-ing from ", $[overloaded { "name" = "^", "is_infix" = true }] concat_str($[overloaded { "name" = "to_str", "is_infix" = false }] privLevel_to_str(prev_priv), $[overloaded { "name" = "^", "is_infix" = true }] concat_str(" to ", $[overloaded { "name" = "to_str", "is_infix" = false }] privLevel_to_str(cur_privilege)))));
          prepare_xret_target(Machine)
      },
      CTL_SRET(()) => {
          let prev_priv = cur_privilege;
          mstatus.bits[1 .. 1] = _get_Mstatus_SPIE(mstatus);
          mstatus.bits[5 .. 5] = 0b1;
          cur_privilege = if $[overloaded { "name" = "==", "is_infix" = true }] eq_bits(_get_Mstatus_SPP(mstatus), 0b1) then
            Supervisor
          else
            User;
          mstatus.bits[8 .. 8] = 0b0;
          if $[overloaded { "name" = "!=", "is_infix" = true }] neq_anything(cur_privilege, Machine) then mstatus.bits[17 .. 17] = 0b0;
          long_csr_write_callback("mstatus", "mstatush", mstatus.bits);
          if get_config_print_platform() then print_log($[overloaded { "name" = "^", "is_infix" = true }] concat_str("ret-ing from ", $[overloaded { "name" = "^", "is_infix" = true }] concat_str($[overloaded { "name" = "to_str", "is_infix" = false }] privLevel_to_str(prev_priv), $[overloaded { "name" = "^", "is_infix" = true }] concat_str(" to ", $[overloaded { "name" = "to_str", "is_infix" = false }] privLevel_to_str(cur_privilege)))));
          prepare_xret_target(Supervisor)
      }
    }
}

val xtval_exception_value : (ExceptionType, bitvector(xlen)) -> option(bitvector(xlen))

$[complete]
function xtval_exception_value (e : ExceptionType, excinfo : xlenbits) = {
    if $[complete] match e {
      E_Breakpoint(()) => config base.xtval_nonzero.breakpoint,
      E_Load_Addr_Align(()) => config base.xtval_nonzero.load_address_misaligned,
      E_Load_Access_Fault(()) => config base.xtval_nonzero.load_access_fault,
      E_SAMO_Addr_Align(()) => config base.xtval_nonzero.samo_address_misaligned,
      E_SAMO_Access_Fault(()) => config base.xtval_nonzero.samo_access_fault,
      E_Fetch_Addr_Align(()) => config base.xtval_nonzero.fetch_address_misaligned,
      E_Fetch_Access_Fault(()) => config base.xtval_nonzero.fetch_access_fault,
      E_Illegal_Instr(()) => config base.xtval_nonzero.illegal_instruction,
      _ => true
    } then
      Some(excinfo)
    else
      None()
}

val handle_exception : (bitvector(xlen), ExceptionType) -> unit

$[complete]
function handle_exception (xtval : xlenbits, e : ExceptionType) = {
    let t : sync_exception = struct sync_exception { trap = e, excinfo = xtval_exception_value(e, xtval), ext = None() };
    set_next_pc(exception_handler(cur_privilege, CTL_TRAP(t), PC))
}

val handle_interrupt : (InterruptType, Privilege) -> unit

$[complete]
function handle_interrupt (i : InterruptType, del_priv : Privilege) = set_next_pc(trap_handler(del_priv, true, interruptType_to_bits(i), PC, None(), None()))

val reset_misa : unit -> unit

$[complete]
function reset_misa () = {
    misa.bits[0 .. 0] = bool_to_bits(hartSupports(Ext_A));
    misa.bits[2 .. 2] = bool_to_bits(hartSupports(Ext_C));
    misa.bits[1 .. 1] = bool_to_bits(hartSupports(Ext_B));
    misa.bits[12 .. 12] = bool_to_bits(hartSupports(Ext_M));
    misa.bits[20 .. 20] = bool_to_bits(hartSupports(Ext_U));
    misa.bits[18 .. 18] = bool_to_bits(hartSupports(Ext_S));
    misa.bits[21 .. 21] = bool_to_bits(hartSupports(Ext_V));
    misa.bits[4 .. 4] = bool_to_bits(base_E_enabled);
    misa.bits[8 .. 8] = $[overloaded { "name" = "~", "is_infix" = false }] not_vec(_get_Misa_E(misa));
    if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(hartSupports(Ext_F), hartSupports(Ext_Zfinx)) then internal_error("./sys/sys_control.sail", 300, "F and Zfinx cannot both be enabled!");
    misa.bits[5 .. 5] = bool_to_bits(hartSupports(Ext_F));
    misa.bits[3 .. 3] = if $[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(flen, 64) then
      bool_to_bits(hartSupports(Ext_D))
    else
      0b0;
    $[overloaded { "name" = "csr_write_callback", "is_infix" = false }] csr_name_write_callback("misa", misa.bits)
}

register pc_reset_address : xlenbits = zeros(sizeof(xlen))

val set_pc_reset_address : bitvector(64) -> unit

$[complete]
function set_pc_reset_address addr : bits(64) = pc_reset_address = trunc(sizeof(xlen), addr)

val reset_sys : unit -> unit

$[complete]
function reset_sys () = {
    cur_privilege = Machine;
    mstatus.bits[3 .. 3] = 0b0;
    mstatus.bits[17 .. 17] = 0b0;
    long_csr_write_callback("mstatus", "mstatush", mstatus.bits);
    reset_misa();
    cancel_reservation();
    PC = pc_reset_address;
    nextPC = pc_reset_address;
    mcause.bits = zeros(sizeof(xlen));
    $[overloaded { "name" = "csr_write_callback", "is_infix" = false }] csr_name_write_callback("mcause", mcause.bits);
    reset_pmp();
    mseccfg.bits[9 .. 9] = bool_to_bits(config extensions.Zkr.sseed_reset_value : bool);
    mseccfg.bits[8 .. 8] = bool_to_bits(config extensions.Zkr.useed_reset_value : bool);
    vstart = zeros(sizeof(xlen));
    vl = zeros(sizeof(xlen));
    vcsr.bits[2 .. 1] = 0b00;
    vcsr.bits[0 .. 0] = 0b0;
    vtype.bits[sub_atom(sizeof(xlen), 1) .. sub_atom(sizeof(xlen), 1)] = 0b1;
    vtype.bits[sub_atom(sizeof(xlen), 2) .. 8] = zeros(sub_atom(sizeof(xlen), 9));
    vtype.bits[7 .. 7] = 0b0;
    vtype.bits[6 .. 6] = 0b0;
    vtype.bits[5 .. 3] = 0b000;
    vtype.bits[2 .. 0] = 0b000
}

type MemoryOpResult('a: Type) = result('a, ExceptionType)

val MemoryOpResult_add_meta : forall ('t : Type).
  (result('t, ExceptionType), unit) -> result(('t, unit), ExceptionType)

$[complete]
function MemoryOpResult_add_meta (r, m) = $[complete] match r {
  Ok(v) => Ok((v, m)),
  Err(e) => Err(e)
}

val MemoryOpResult_drop_meta : forall ('t : Type).
  result(('t, unit), ExceptionType) -> result('t, ExceptionType)

$[complete]
function MemoryOpResult_drop_meta r = $[complete] match r {
  Ok((v, m)) => Ok(v),
  Err(e) => Err(e)
}

let plat_cache_block_size_exp : range(0, 12) = config platform.cache_block_size_exp

register plat_ram_base : physaddrbits = to_bits_checked(if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(sizeof(xlen), 32) then
  34
else
  64, config platform.ram.base : int)

register plat_ram_size : physaddrbits = to_bits_checked(if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(sizeof(xlen), 32) then
  34
else
  64, config platform.ram.size : int)

let plat_enable_dirty_update : bool = config memory.translation.dirty_update

let plat_enable_misaligned_access : bool = config memory.misaligned.supported

register plat_rom_base : physaddrbits = to_bits_checked(if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(sizeof(xlen), 32) then
  34
else
  64, config platform.rom.base : int)

register plat_rom_size : physaddrbits = to_bits_checked(if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(sizeof(xlen), 32) then
  34
else
  64, config platform.rom.size : int)

register plat_clint_base : physaddrbits = to_bits_checked(if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(sizeof(xlen), 32) then
  34
else
  64, config platform.clint.base : int)

register plat_clint_size : physaddrbits = to_bits_checked(if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(sizeof(xlen), 32) then
  34
else
  64, config platform.clint.size : int)

register htif_tohost_base : option(physaddrbits) = None()

let htif_tohost_size = 8

val enable_htif : bitvector(64) -> unit

$[complete]
function enable_htif tohost_addr : bits(64) = htif_tohost_base = Some(trunc(if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(sizeof(xlen), 32) then
  34
else
  64, tohost_addr))

val within_phys_mem : forall ('n : Int), 'n <= max_mem_access.
  (physaddr, int('n)) -> bool

$[complete]
function within_phys_mem (Physaddr(addr) : physaddr, width : int('n)) = {
    let addr_int = unsigned(addr);
    let ram_base_int = unsigned(plat_ram_base);
    let rom_base_int = unsigned(plat_rom_base);
    let ram_size_int = unsigned(plat_ram_size);
    let rom_size_int = unsigned(plat_rom_size);
    if $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "<=", "is_infix" = true }] lteq_int(ram_base_int, addr_int), $[overloaded { "name" = "<=", "is_infix" = true }] lteq_int($[overloaded { "name" = "+", "is_infix" = true }] add_atom(addr_int, $[overloaded { "name" = "__size", "is_infix" = false }] __id(width)), $[overloaded { "name" = "+", "is_infix" = true }] add_atom(ram_base_int, ram_size_int))) then
      true
    else
      if $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "<=", "is_infix" = true }] lteq_int(rom_base_int, addr_int), $[overloaded { "name" = "<=", "is_infix" = true }] lteq_int($[overloaded { "name" = "+", "is_infix" = true }] add_atom(addr_int, $[overloaded { "name" = "__size", "is_infix" = false }] __id(width)), $[overloaded { "name" = "+", "is_infix" = true }] add_atom(rom_base_int, rom_size_int))) then
        true
      else {
          if get_config_print_platform() then {
              print_log($[overloaded { "name" = "^", "is_infix" = true }] concat_str("within_phys_mem: ", $[overloaded { "name" = "^", "is_infix" = true }] concat_str(bits_str(addr), " not within phys-mem:")));
              print_log($[overloaded { "name" = "^", "is_infix" = true }] concat_str("  plat_rom_base: ", bits_str(plat_rom_base)));
              print_log($[overloaded { "name" = "^", "is_infix" = true }] concat_str("  plat_rom_size: ", bits_str(plat_rom_size)));
              print_log($[overloaded { "name" = "^", "is_infix" = true }] concat_str("  plat_ram_base: ", bits_str(plat_ram_base)));
              print_log($[overloaded { "name" = "^", "is_infix" = true }] concat_str("  plat_ram_size: ", bits_str(plat_ram_size)))
          };
          false
      }
}

val within_clint : forall ('n : Int), (0 < 'n & 'n <= max_mem_access).
  (physaddr, int('n)) -> bool

$[complete]
function within_clint (Physaddr(addr) : physaddr, width : int('n)) = {
    let addr_int = unsigned(addr);
    let clint_base_int = unsigned(plat_clint_base);
    let clint_size_int = unsigned(plat_clint_size);
    $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "<=", "is_infix" = true }] lteq_int(clint_base_int, addr_int), $[overloaded { "name" = "<=", "is_infix" = true }] lteq_int($[overloaded { "name" = "+", "is_infix" = true }] add_atom(addr_int, $[overloaded { "name" = "__size", "is_infix" = false }] __id(width)), $[overloaded { "name" = "+", "is_infix" = true }] add_atom(clint_base_int, clint_size_int)))
}

val within_htif_writable : forall ('n : Int), (0 < 'n & 'n <= max_mem_access).
  (physaddr, int('n)) -> bool

$[complete]
function within_htif_writable (Physaddr(addr) : physaddr, width : int('n)) = $[complete] match htif_tohost_base {
  None(()) => false,
  Some(base) => $[overloaded { "name" = "&", "is_infix" = true }] and_bool(operator <_u(addr, $[overloaded { "name" = "+", "is_infix" = true }] add_bits_int(base, htif_tohost_size)), operator >=_u($[overloaded { "name" = "+", "is_infix" = true }] add_bits_int(addr, width), base))
}

val within_htif_readable : forall ('n : Int), (0 < 'n & 'n <= max_mem_access).
  (physaddr, int('n)) -> bool

$[complete]
function within_htif_readable (addr : physaddr, width : int('n)) = within_htif_writable(addr, width)

let plat_insns_per_tick : nat1 = config platform.instructions_per_tick

register mtimecmp : bits(64)

register stimecmp : bits(64)

let MSIP_BASE : physaddrbits = zero_extend(if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(sizeof(xlen), 32) then
  34
else
  64, 0x00000)

let MTIMECMP_BASE : physaddrbits = zero_extend(if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(sizeof(xlen), 32) then
  34
else
  64, 0x04000)

let MTIMECMP_BASE_HI : physaddrbits = zero_extend(if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(sizeof(xlen), 32) then
  34
else
  64, 0x04004)

let MTIME_BASE : physaddrbits = zero_extend(if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(sizeof(xlen), 32) then
  34
else
  64, 0x0bff8)

let MTIME_BASE_HI : physaddrbits = zero_extend(if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(sizeof(xlen), 32) then
  34
else
  64, 0x0bffc)

val clint_load : forall ('n : Int), 'n > 0.
  (AccessType(unit), physaddr, int('n)) -> result(bitvector(8 * 'n), ExceptionType)

$[complete]
function clint_load (t, Physaddr(addr), width) = {
    let addr = $[overloaded { "name" = "-", "is_infix" = true }] sub_vec(addr, plat_clint_base);
    if $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_bits(addr, MSIP_BASE), $[overloaded { "name" = "|", "is_infix" = true }] or_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_int($[overloaded { "name" = "__size", "is_infix" = false }] __id(width), 8), $[overloaded { "name" = "==", "is_infix" = true }] eq_int($[overloaded { "name" = "__size", "is_infix" = false }] __id(width), 4))) then {
        if get_config_print_platform() then print_log($[overloaded { "name" = "^", "is_infix" = true }] concat_str("clint[", $[overloaded { "name" = "^", "is_infix" = true }] concat_str(bits_str(addr), $[overloaded { "name" = "^", "is_infix" = true }] concat_str("] -> ", bits_str(_get_Minterrupts_MSI(mip))))));
        Ok(zero_extend(mult_atom(8, $[overloaded { "name" = "__size", "is_infix" = false }] __id(width)), _get_Minterrupts_MSI(mip)))
    } else if $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_bits(addr, MTIMECMP_BASE), $[overloaded { "name" = "==", "is_infix" = true }] eq_int($[overloaded { "name" = "__size", "is_infix" = false }] __id(width), 4)) then {
        if get_config_print_platform() then print_log($[overloaded { "name" = "^", "is_infix" = true }] concat_str("clint<4>[", $[overloaded { "name" = "^", "is_infix" = true }] concat_str(bits_str(addr), $[overloaded { "name" = "^", "is_infix" = true }] concat_str("] -> ", bits_str($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(mtimecmp, 31, 0))))));
        Ok(zero_extend(32, $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(mtimecmp, 31, 0)))
    } else if $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_bits(addr, MTIMECMP_BASE), $[overloaded { "name" = "==", "is_infix" = true }] eq_int($[overloaded { "name" = "__size", "is_infix" = false }] __id(width), 8)) then {
        if get_config_print_platform() then print_log($[overloaded { "name" = "^", "is_infix" = true }] concat_str("clint<8>[", $[overloaded { "name" = "^", "is_infix" = true }] concat_str(bits_str(addr), $[overloaded { "name" = "^", "is_infix" = true }] concat_str("] -> ", bits_str(mtimecmp)))));
        Ok(zero_extend(64, mtimecmp))
    } else if $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_bits(addr, MTIMECMP_BASE_HI), $[overloaded { "name" = "==", "is_infix" = true }] eq_int($[overloaded { "name" = "__size", "is_infix" = false }] __id(width), 4)) then {
        if get_config_print_platform() then print_log($[overloaded { "name" = "^", "is_infix" = true }] concat_str("clint-hi<4>[", $[overloaded { "name" = "^", "is_infix" = true }] concat_str(bits_str(addr), $[overloaded { "name" = "^", "is_infix" = true }] concat_str("] -> ", bits_str($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(mtimecmp, 63, 32))))));
        Ok(zero_extend(32, $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(mtimecmp, 63, 32)))
    } else if $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_bits(addr, MTIME_BASE), $[overloaded { "name" = "==", "is_infix" = true }] eq_int($[overloaded { "name" = "__size", "is_infix" = false }] __id(width), 4)) then {
        if get_config_print_platform() then print_log($[overloaded { "name" = "^", "is_infix" = true }] concat_str("clint[", $[overloaded { "name" = "^", "is_infix" = true }] concat_str(bits_str(addr), $[overloaded { "name" = "^", "is_infix" = true }] concat_str("] -> ", bits_str(mtime)))));
        Ok(zero_extend(32, $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(mtime, 31, 0)))
    } else if $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_bits(addr, MTIME_BASE), $[overloaded { "name" = "==", "is_infix" = true }] eq_int($[overloaded { "name" = "__size", "is_infix" = false }] __id(width), 8)) then {
        if get_config_print_platform() then print_log($[overloaded { "name" = "^", "is_infix" = true }] concat_str("clint[", $[overloaded { "name" = "^", "is_infix" = true }] concat_str(bits_str(addr), $[overloaded { "name" = "^", "is_infix" = true }] concat_str("] -> ", bits_str(mtime)))));
        Ok(zero_extend(64, mtime))
    } else if $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_bits(addr, MTIME_BASE_HI), $[overloaded { "name" = "==", "is_infix" = true }] eq_int($[overloaded { "name" = "__size", "is_infix" = false }] __id(width), 4)) then {
        if get_config_print_platform() then print_log($[overloaded { "name" = "^", "is_infix" = true }] concat_str("clint[", $[overloaded { "name" = "^", "is_infix" = true }] concat_str(bits_str(addr), $[overloaded { "name" = "^", "is_infix" = true }] concat_str("] -> ", bits_str(mtime)))));
        Ok(zero_extend(32, $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(mtime, 63, 32)))
    } else {
        if get_config_print_platform() then print_log($[overloaded { "name" = "^", "is_infix" = true }] concat_str("clint[", $[overloaded { "name" = "^", "is_infix" = true }] concat_str(bits_str(addr), "] -> <not-mapped>")));
        $[complete] match t {
          InstructionFetch(()) => Err(E_Fetch_Access_Fault()),
          Read(Data) => Err(E_Load_Access_Fault()),
          _ => Err(E_SAMO_Access_Fault())
        }
    }
}

val clint_dispatch : unit -> unit

$[complete]
function clint_dispatch () = {
    mip.bits[7 .. 7] = bool_to_bits(operator <=_u(mtimecmp, mtime));
    if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Sstc), $[overloaded { "name" = "==", "is_infix" = true }] eq_bits(_get_MEnvcfg_STCE(menvcfg), 0b1)) then {
        mip.bits[5 .. 5] = bool_to_bits(operator <=_u(stimecmp, mtime))
    };
    if get_config_print_platform() then print_log($[overloaded { "name" = "^", "is_infix" = true }] concat_str("clint mtime ", $[overloaded { "name" = "^", "is_infix" = true }] concat_str(bits_str(mtime), $[overloaded { "name" = "^", "is_infix" = true }] concat_str(" (mip.MTI <- ", $[overloaded { "name" = "^", "is_infix" = true }] concat_str(bits_str(_get_Minterrupts_MTI(mip)), $[overloaded { "name" = "^", "is_infix" = true }] concat_str(if currentlyEnabled(Ext_Sstc) then
      $[overloaded { "name" = "^", "is_infix" = true }] concat_str(", mip.STI <- ", bits_str(_get_Minterrupts_STI(mip)))
    else
      "", ")"))))));
    ()
}

val clint_store : forall ('n : Int), 'n > 0.
  (physaddr, int('n), bitvector(8 * 'n)) -> result(bool, ExceptionType)

$[complete]
function clint_store (Physaddr(addr), width, data) = {
    let addr = $[overloaded { "name" = "-", "is_infix" = true }] sub_vec(addr, plat_clint_base);
    if $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_bits(addr, MSIP_BASE), $[overloaded { "name" = "|", "is_infix" = true }] or_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_int($[overloaded { "name" = "__size", "is_infix" = false }] __id(width), 8), $[overloaded { "name" = "==", "is_infix" = true }] eq_int($[overloaded { "name" = "__size", "is_infix" = false }] __id(width), 4))) then {
        if get_config_print_platform() then print_log($[overloaded { "name" = "^", "is_infix" = true }] concat_str("clint[", $[overloaded { "name" = "^", "is_infix" = true }] concat_str(bits_str(addr), $[overloaded { "name" = "^", "is_infix" = true }] concat_str("] <- ", $[overloaded { "name" = "^", "is_infix" = true }] concat_str(bits_str(data), $[overloaded { "name" = "^", "is_infix" = true }] concat_str(" (mip.MSI <- ", $[overloaded { "name" = "^", "is_infix" = true }] concat_str(bits_str($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(data, 0, 0)), ")")))))));
        mip.bits[3 .. 3] = [$[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(data, 0)];
        clint_dispatch();
        Ok(true)
    } else if $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_bits(addr, MTIMECMP_BASE), $[overloaded { "name" = "==", "is_infix" = true }] eq_int($[overloaded { "name" = "__size", "is_infix" = false }] __id(width), 8)) then {
        if get_config_print_platform() then print_log($[overloaded { "name" = "^", "is_infix" = true }] concat_str("clint<8>[", $[overloaded { "name" = "^", "is_infix" = true }] concat_str(bits_str(addr), $[overloaded { "name" = "^", "is_infix" = true }] concat_str("] <- ", $[overloaded { "name" = "^", "is_infix" = true }] concat_str(bits_str(data), " (mtimecmp)")))));
        mtimecmp = zero_extend(64, data);
        clint_dispatch();
        Ok(true)
    } else if $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_bits(addr, MTIMECMP_BASE), $[overloaded { "name" = "==", "is_infix" = true }] eq_int($[overloaded { "name" = "__size", "is_infix" = false }] __id(width), 4)) then {
        if get_config_print_platform() then print_log($[overloaded { "name" = "^", "is_infix" = true }] concat_str("clint<4>[", $[overloaded { "name" = "^", "is_infix" = true }] concat_str(bits_str(addr), $[overloaded { "name" = "^", "is_infix" = true }] concat_str("] <- ", $[overloaded { "name" = "^", "is_infix" = true }] concat_str(bits_str(data), " (mtimecmp)")))));
        mtimecmp = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(mtimecmp, 31, 0, zero_extend(32, data));
        clint_dispatch();
        Ok(true)
    } else if $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_bits(addr, MTIMECMP_BASE_HI), $[overloaded { "name" = "==", "is_infix" = true }] eq_int($[overloaded { "name" = "__size", "is_infix" = false }] __id(width), 4)) then {
        if get_config_print_platform() then print_log($[overloaded { "name" = "^", "is_infix" = true }] concat_str("clint<4>[", $[overloaded { "name" = "^", "is_infix" = true }] concat_str(bits_str(addr), $[overloaded { "name" = "^", "is_infix" = true }] concat_str("] <- ", $[overloaded { "name" = "^", "is_infix" = true }] concat_str(bits_str(data), " (mtimecmp)")))));
        mtimecmp = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(mtimecmp, 63, 32, zero_extend(32, data));
        clint_dispatch();
        Ok(true)
    } else if $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_bits(addr, MTIME_BASE), $[overloaded { "name" = "==", "is_infix" = true }] eq_int($[overloaded { "name" = "__size", "is_infix" = false }] __id(width), 8)) then {
        if get_config_print_platform() then print_log($[overloaded { "name" = "^", "is_infix" = true }] concat_str("clint<8>[", $[overloaded { "name" = "^", "is_infix" = true }] concat_str(bits_str(addr), $[overloaded { "name" = "^", "is_infix" = true }] concat_str("] <- ", $[overloaded { "name" = "^", "is_infix" = true }] concat_str(bits_str(data), " (mtime)")))));
        mtime = data;
        clint_dispatch();
        Ok(true)
    } else if $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_bits(addr, MTIME_BASE), $[overloaded { "name" = "==", "is_infix" = true }] eq_int($[overloaded { "name" = "__size", "is_infix" = false }] __id(width), 4)) then {
        if get_config_print_platform() then print_log($[overloaded { "name" = "^", "is_infix" = true }] concat_str("clint<4>[", $[overloaded { "name" = "^", "is_infix" = true }] concat_str(bits_str(addr), $[overloaded { "name" = "^", "is_infix" = true }] concat_str("] <- ", $[overloaded { "name" = "^", "is_infix" = true }] concat_str(bits_str(data), " (mtime)")))));
        mtime[31 .. 0] = data;
        clint_dispatch();
        Ok(true)
    } else if $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_bits(addr, MTIME_BASE_HI), $[overloaded { "name" = "==", "is_infix" = true }] eq_int($[overloaded { "name" = "__size", "is_infix" = false }] __id(width), 4)) then {
        if get_config_print_platform() then print_log($[overloaded { "name" = "^", "is_infix" = true }] concat_str("clint<4>[", $[overloaded { "name" = "^", "is_infix" = true }] concat_str(bits_str(addr), $[overloaded { "name" = "^", "is_infix" = true }] concat_str("] <- ", $[overloaded { "name" = "^", "is_infix" = true }] concat_str(bits_str(data), " (mtime)")))));
        mtime[63 .. 32] = data;
        clint_dispatch();
        Ok(true)
    } else {
        if get_config_print_platform() then print_log($[overloaded { "name" = "^", "is_infix" = true }] concat_str("clint[", $[overloaded { "name" = "^", "is_infix" = true }] concat_str(bits_str(addr), $[overloaded { "name" = "^", "is_infix" = true }] concat_str("] <- ", $[overloaded { "name" = "^", "is_infix" = true }] concat_str(bits_str(data), " (<unmapped>)")))));
        Err(E_SAMO_Access_Fault())
    }
}

val should_inc_mcycle : Privilege -> bool

$[complete]
function should_inc_mcycle priv : Privilege = $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_bits(_get_Counterin_CY(mcountinhibit), 0b0), $[overloaded { "name" = "==", "is_infix" = true }] eq_bits(counter_priv_filter_bit(mcyclecfg, priv), 0b0))

val should_inc_minstret : Privilege -> bool

$[complete]
function should_inc_minstret priv : Privilege = $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_bits(_get_Counterin_IR(mcountinhibit), 0b0), $[overloaded { "name" = "==", "is_infix" = true }] eq_bits(counter_priv_filter_bit(minstretcfg, priv), 0b0))

val tick_clock : unit -> unit

$[complete]
function tick_clock () = {
    if should_inc_mcycle(cur_privilege) then mcycle = $[overloaded { "name" = "+", "is_infix" = true }] add_bits_int(mcycle, 1);
    mtime = $[overloaded { "name" = "+", "is_infix" = true }] add_bits_int(mtime, 1);
    clint_dispatch()
}

val plat_term_write = monadic {c: "plat_term_write", lem: "plat_term_write"}: bitvector(8) -> unit

val plat_term_read = monadic {c: "plat_term_read", lem: "plat_term_read"}: unit -> bitvector(8)

$[undefined_gen "skip"]
$[bitfield]
struct htif_cmd = {bits : bitvector(64)}

val undefined_htif_cmd : unit -> htif_cmd

$[complete]
function undefined_htif_cmd () = struct htif_cmd { bits = undefined }

val Mk_htif_cmd : bitvector(64) -> htif_cmd

$[complete]
function Mk_htif_cmd v = struct htif_cmd { bits = v }

$[fix_location]
val _get_htif_cmd_bits : htif_cmd -> bitvector(64)

$[complete]
$[fix_location]
function _get_htif_cmd_bits v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, sub_atom(64, 1), 0)

$[fix_location]
val _update_htif_cmd_bits : (htif_cmd, bitvector(64)) -> htif_cmd

$[complete]
$[fix_location]
function _update_htif_cmd_bits (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, sub_atom(64, 1), 0, x) }

$[fix_location]
overload update_bits = {_update_htif_cmd_bits}

$[fix_location]
val _set_htif_cmd_bits : (register(htif_cmd), bitvector(64)) -> unit

$[complete]
$[fix_location]
function _set_htif_cmd_bits (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_htif_cmd_bits(r, v)
}

overload _mod_bits = {_get_htif_cmd_bits, _set_htif_cmd_bits}

$[fix_location]
val _get_htif_cmd_cmd : htif_cmd -> bitvector(8)

$[complete]
$[fix_location]
function _get_htif_cmd_cmd v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 55, 48)

$[fix_location]
val _update_htif_cmd_cmd : (htif_cmd, bitvector(8)) -> htif_cmd

$[complete]
$[fix_location]
function _update_htif_cmd_cmd (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 55, 48, x) }

$[fix_location]
overload update_cmd = {_update_htif_cmd_cmd}

$[fix_location]
val _set_htif_cmd_cmd : (register(htif_cmd), bitvector(8)) -> unit

$[complete]
$[fix_location]
function _set_htif_cmd_cmd (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_htif_cmd_cmd(r, v)
}

overload _mod_cmd = {_get_htif_cmd_cmd, _set_htif_cmd_cmd}

$[fix_location]
val _get_htif_cmd_device : htif_cmd -> bitvector(8)

$[complete]
$[fix_location]
function _get_htif_cmd_device v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 63, 56)

$[fix_location]
val _update_htif_cmd_device : (htif_cmd, bitvector(8)) -> htif_cmd

$[complete]
$[fix_location]
function _update_htif_cmd_device (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 63, 56, x) }

$[fix_location]
overload update_device = {_update_htif_cmd_device}

$[fix_location]
val _set_htif_cmd_device : (register(htif_cmd), bitvector(8)) -> unit

$[complete]
$[fix_location]
function _set_htif_cmd_device (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_htif_cmd_device(r, v)
}

overload _mod_device = {_get_htif_cmd_device, _set_htif_cmd_device}

$[fix_location]
val _get_htif_cmd_payload : htif_cmd -> bitvector(48)

$[complete]
$[fix_location]
function _get_htif_cmd_payload v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 47, 0)

$[fix_location]
val _update_htif_cmd_payload : (htif_cmd, bitvector(48)) -> htif_cmd

$[complete]
$[fix_location]
function _update_htif_cmd_payload (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 47, 0, x) }

$[fix_location]
overload update_payload = {_update_htif_cmd_payload}

$[fix_location]
val _set_htif_cmd_payload : (register(htif_cmd), bitvector(48)) -> unit

$[complete]
$[fix_location]
function _set_htif_cmd_payload (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_htif_cmd_payload(r, v)
}

overload _mod_payload = {_get_htif_cmd_payload, _set_htif_cmd_payload}

register htif_tohost : bits(64)

register htif_done : bool

register htif_exit_code : bits(64)

register htif_cmd_write : bit

register htif_payload_writes : bits(4)

val reset_htif : unit -> unit

$[complete]
function reset_htif () = {
    htif_cmd_write = bitzero;
    htif_payload_writes = 0x0;
    htif_tohost = zeros(64)
}

val htif_load : forall ('n : Int), (0 < 'n & 'n <= max_mem_access).
  (AccessType(unit), physaddr, int('n)) -> result(bitvector(8 * 'n), ExceptionType)

$[complete]
function htif_load (acc, Physaddr(paddr), width) = {
    if get_config_print_platform() then print_log($[overloaded { "name" = "^", "is_infix" = true }] concat_str("htif[", $[overloaded { "name" = "^", "is_infix" = true }] concat_str(hex_bits_str(paddr), $[overloaded { "name" = "^", "is_infix" = true }] concat_str("] -> ", bits_str(htif_tohost)))));
    let base : physaddrbits = $[complete] match htif_tohost_base {
      Some(base) => base,
      None(()) => internal_error("./sys/platform.sail", 321, "HTIF load while HTIF isn't enabled")
    };
    if $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_int(width, 8), $[overloaded { "name" = "==", "is_infix" = true }] eq_bits(paddr, base)) then
      Ok(zero_extend(64, htif_tohost))
    else
      if $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_int(width, 4), $[overloaded { "name" = "==", "is_infix" = true }] eq_bits(paddr, base)) then
        Ok(zero_extend(32, $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(htif_tohost, 31, 0)))
      else
        if $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_int(width, 4), $[overloaded { "name" = "==", "is_infix" = true }] eq_bits(paddr, $[overloaded { "name" = "+", "is_infix" = true }] add_bits_int(base, 4))) then
          Ok(zero_extend(32, $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(htif_tohost, 63, 32)))
        else
          $[complete] match acc {
            InstructionFetch(()) => Err(E_Fetch_Access_Fault()),
            Read(Data) => Err(E_Load_Access_Fault()),
            _ => Err(E_SAMO_Access_Fault())
          }
}

val htif_store : forall ('n : Int), (0 < 'n & 'n <= max_mem_access).
  (physaddr, int('n), bitvector(8 * 'n)) -> result(bool, ExceptionType)

$[complete]
function htif_store (Physaddr(paddr), width, data) = {
    if get_config_print_platform() then print_log($[overloaded { "name" = "^", "is_infix" = true }] concat_str("htif[", $[overloaded { "name" = "^", "is_infix" = true }] concat_str(hex_bits_str(paddr), $[overloaded { "name" = "^", "is_infix" = true }] concat_str("] <- ", bits_str(data)))));
    let base : physaddrbits = $[complete] match htif_tohost_base {
      Some(base) => base,
      None(()) => internal_error("./sys/platform.sail", 345, "HTIF store while HTIF isn't enabled")
    };
    if $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_int(width, 8), $[overloaded { "name" = "==", "is_infix" = true }] eq_bits(paddr, base)) then {
        htif_cmd_write = bitone;
        htif_payload_writes = $[overloaded { "name" = "+", "is_infix" = true }] add_bits_int(htif_payload_writes, 1);
        htif_tohost = zero_extend(64, data)
    } else if $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_int(width, 4), $[overloaded { "name" = "==", "is_infix" = true }] eq_bits(paddr, base)) then {
        if $[overloaded { "name" = "==", "is_infix" = true }] eq_bits(data, $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(htif_tohost, 31, 0)) then
          htif_payload_writes = $[overloaded { "name" = "+", "is_infix" = true }] add_bits_int(htif_payload_writes, 1)
        else htif_payload_writes = 0x1;
        htif_tohost = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(htif_tohost, 31, 0, data)
    } else if $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_int(width, 4), $[overloaded { "name" = "==", "is_infix" = true }] eq_bits(paddr, $[overloaded { "name" = "+", "is_infix" = true }] add_bits_int(base, 4))) then {
        if $[overloaded { "name" = "==", "is_infix" = true }] eq_bits($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(data, 15, 0), $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(htif_tohost, 47, 32)) then
          htif_payload_writes = $[overloaded { "name" = "+", "is_infix" = true }] add_bits_int(htif_payload_writes, 1)
        else htif_payload_writes = 0x1;
        htif_cmd_write = bitone;
        htif_tohost = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(htif_tohost, 63, 32, data)
    } else return(Err(E_SAMO_Access_Fault()));
    if $[overloaded { "name" = "|", "is_infix" = true }] or_bool($[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_bit(htif_cmd_write, bitone), gt_int(unsigned(htif_payload_writes), 0) : bool), gt_int(unsigned(htif_payload_writes), 2) : bool) then {
        let cmd = Mk_htif_cmd(htif_tohost);
        $[complete] match _get_htif_cmd_device(cmd) {
          0x00 => {
              if get_config_print_platform() then print_log($[overloaded { "name" = "^", "is_infix" = true }] concat_str("htif-syscall-proxy cmd: ", bits_str(_get_htif_cmd_payload(cmd))));
              if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(_get_htif_cmd_payload(cmd), 0), bitone) then {
                  htif_done = true;
                  htif_exit_code = $[overloaded { "name" = ">>", "is_infix" = true }] shiftr(zero_extend(64, _get_htif_cmd_payload(cmd)), 1)
              };
              ()
          },
          0x01 => {
              if get_config_print_platform() then print_log($[overloaded { "name" = "^", "is_infix" = true }] concat_str("htif-term cmd: ", bits_str(_get_htif_cmd_payload(cmd))));
              $[complete] match _get_htif_cmd_cmd(cmd) {
                0x00 => (),
                0x01 => plat_term_write($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(_get_htif_cmd_payload(cmd), 7, 0)),
                c => print($[overloaded { "name" = "^", "is_infix" = true }] concat_str("Unknown term cmd: ", bits_str(c)))
              };
              reset_htif()
          },
          d => print($[overloaded { "name" = "^", "is_infix" = true }] concat_str("htif-???? cmd: ", bits_str(data)))
        }
    };
    Ok(true)
}

val within_mmio_readable : forall ('n : Int), (0 < 'n & 'n <= max_mem_access).
  (physaddr, int('n)) -> bool

$[complete]
function within_mmio_readable (addr : physaddr, width : int('n)) = if get_config_rvfi() then
  false
else
  $[overloaded { "name" = "|", "is_infix" = true }] or_bool(within_clint(addr, width), $[overloaded { "name" = "&", "is_infix" = true }] and_bool(within_htif_readable(addr, width), $[overloaded { "name" = "<=", "is_infix" = true }] lteq_int(1, $[overloaded { "name" = "__size", "is_infix" = false }] __id(width))))

val within_mmio_writable : forall ('n : Int), (0 < 'n & 'n <= max_mem_access).
  (physaddr, int('n)) -> bool

$[complete]
function within_mmio_writable (addr : physaddr, width : int('n)) = if get_config_rvfi() then
  false
else
  $[overloaded { "name" = "|", "is_infix" = true }] or_bool(within_clint(addr, width), $[overloaded { "name" = "&", "is_infix" = true }] and_bool(within_htif_writable(addr, width), $[overloaded { "name" = "<=", "is_infix" = true }] lteq_int($[overloaded { "name" = "__size", "is_infix" = false }] __id(width), 8)))

val mmio_read : forall ('n : Int), (0 < 'n & 'n <= max_mem_access).
  (AccessType(unit), physaddr, int('n)) -> result(bitvector(8 * 'n), ExceptionType)

$[complete]
function mmio_read (t : AccessType(ext_access_type), paddr : physaddr, width : int('n)) = if within_clint(paddr, width) then
  clint_load(t, paddr, width)
else
  if within_htif_readable(paddr, width) then htif_load(t, paddr, width) else
    $[complete] match t {
      InstructionFetch(()) => Err(E_Fetch_Access_Fault()),
      Read(Data) => Err(E_Load_Access_Fault()),
      _ => Err(E_SAMO_Access_Fault())
    }

val mmio_write : forall ('n : Int), (0 < 'n & 'n <= max_mem_access).
  (physaddr, int('n), bitvector(8 * 'n)) -> result(bool, ExceptionType)

$[complete]
function mmio_write (paddr : physaddr, width : int('n), data : bits(8 * 'n)) = if within_clint(paddr, width) then
  clint_store(paddr, width, data)
else
  if within_htif_writable(paddr, width) then htif_store(paddr, width, data) else
    Err(E_SAMO_Access_Fault())

val init_platform : unit -> unit

$[complete]
function init_platform () = {
    htif_tohost = zeros(64);
    htif_done = false;
    htif_exit_code = zeros(64);
    htif_cmd_write = bitzero;
    htif_payload_writes = zeros(4)
}

val platform_wfi : unit -> unit

$[complete]
function platform_wfi () = ()

val is_aligned_paddr : (physaddr, {('n : Int), 'n > 0. int('n)}) -> bool

$[complete]
function is_aligned_paddr (Physaddr(addr) : physaddr, width : nat1) = $[overloaded { "name" = "==", "is_infix" = true }] eq_int($[overloaded { "name" = "%", "is_infix" = true }] rem_positive_round_zero(unsigned(addr), width), 0)

val is_aligned_vaddr : (virtaddr, {('n : Int), 'n > 0. int('n)}) -> bool

$[complete]
function is_aligned_vaddr (Virtaddr(addr) : virtaddr, width : nat1) = $[overloaded { "name" = "==", "is_infix" = true }] eq_int($[overloaded { "name" = "%", "is_infix" = true }] rem_positive_round_zero(unsigned(addr), width), 0)

val is_aligned_bits : (bitvector(xlen), {1, 2, 4, 8}) -> bool

$[complete]
function is_aligned_bits (vaddr : xlenbits, width : word_width) = $[complete] match width {
  1 => true,
  2 => $[overloaded { "name" = "==", "is_infix" = true }] eq_bits($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(vaddr, 0, 0), zeros(add_atom(sub_atom(0, 0), 1))),
  4 => $[overloaded { "name" = "==", "is_infix" = true }] eq_bits($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(vaddr, 1, 0), zeros(add_atom(sub_atom(1, 0), 1))),
  ($[int_wildcard 8] _) => $[overloaded { "name" = "==", "is_infix" = true }] eq_bits($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(vaddr, 2, 0), zeros(add_atom(sub_atom(2, 0), 1)))
}

overload is_aligned_addr = {is_aligned_paddr, is_aligned_vaddr, is_aligned_bits}

val read_kind_of_flags : (bool, bool, bool) -> option(read_kind)

$[complete]
function read_kind_of_flags (aq : bool, rl : bool, res : bool) = $[complete] match (aq, rl, res) {
  (false, false, false) => Some(Read_plain),
  (true, false, false) => Some(Read_RISCV_acquire),
  (true, true, false) => Some(Read_RISCV_strong_acquire),
  (false, false, true) => Some(Read_RISCV_reserved),
  (true, false, true) => Some(Read_RISCV_reserved_acquire),
  (true, true, true) => Some(Read_RISCV_reserved_strong_acquire),
  (false, true, false) => None(),
  (false, true, true) => None()
}

val write_kind_of_flags : (bool, bool, bool) -> write_kind

$[complete]
function write_kind_of_flags (aq : bool, rl : bool, con : bool) = $[complete] match (aq, rl, con) {
  (false, false, false) => Write_plain,
  (false, true, false) => Write_RISCV_release,
  (false, false, true) => Write_RISCV_conditional,
  (false, true, true) => Write_RISCV_conditional_release,
  (true, true, false) => Write_RISCV_strong_release,
  (true, true, true) => Write_RISCV_conditional_strong_release,
  (true, false, false) => throw(Error_not_implemented("store.aq")),
  (true, false, true) => throw(Error_not_implemented("sc.aq"))
}

val phys_mem_read : forall ('n : Int), (0 < 'n & 'n <= max_mem_access).
  (AccessType(unit), physaddr, int('n), bool, bool, bool, bool) -> result((bitvector(8 * 'n), unit), ExceptionType)

$[complete]
function phys_mem_read (t : AccessType(ext_access_type), paddr : physaddr, width : int('n), aq : bool, rl : bool, res : bool, meta : bool) = {
    let result = ($[complete] match read_kind_of_flags(aq, rl, res) {
      Some(rk) => Some(read_ram(rk, paddr, width, meta)),
      None(()) => None()
    }) : option((bits(8 * 'n), mem_meta));
    $[complete] match (t, result) {
      (InstructionFetch(()), None(())) => Err(E_Fetch_Access_Fault()),
      (Read(Data), None(())) => Err(E_Load_Access_Fault()),
      (_, None(())) => Err(E_SAMO_Access_Fault()),
      (_, Some((v, m))) => Ok((v, m))
    }
}

val phys_access_check : forall ('n : Int), (0 < 'n & 'n <= max_mem_access).
  (AccessType(unit), Privilege, physaddr, int('n)) -> option(ExceptionType)

$[complete]
function phys_access_check (t, p, paddr, width) = {
    let pmpError : option(ExceptionType) = if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(sys_pmp_count, 0) then
      None()
    else
      pmpCheck(paddr, width, t, p);
    pmpError
}

val checked_mem_read : forall ('n : Int), (0 < 'n & 'n <= max_mem_access).
  (AccessType(unit), Privilege, physaddr, int('n), bool, bool, bool, bool) -> result((bitvector(8 * 'n), unit), ExceptionType)

$[complete]
function checked_mem_read (t : AccessType(ext_access_type), priv : Privilege, paddr : physaddr, width : int('n), aq : bool, rl : bool, res : bool, meta : bool) = $[complete] match phys_access_check(t, priv, paddr, width) {
  Some(e) => Err(e),
  None(()) => {
      if within_mmio_readable(paddr, width) then
        MemoryOpResult_add_meta(mmio_read(t, paddr, width), default_meta)
      else
        if within_phys_mem(paddr, width) then
          phys_mem_read(t, paddr, width, aq, rl, res, meta)
        else
          $[complete] match t {
            InstructionFetch(()) => Err(E_Fetch_Access_Fault()),
            Read(Data) => Err(E_Load_Access_Fault()),
            _ => Err(E_SAMO_Access_Fault())
          }
  }
}

val mem_read : forall ('n : Int), (0 < 'n & 'n <= max_mem_access).
  (AccessType(unit), physaddr, int('n), bool, bool, bool) -> result(bitvector(8 * 'n), ExceptionType)

val mem_read_priv : forall ('n : Int), (0 < 'n & 'n <= max_mem_access).
  (AccessType(unit), Privilege, physaddr, int('n), bool, bool, bool) -> result(bitvector(8 * 'n), ExceptionType)

val mem_read_meta : forall ('n : Int), (0 < 'n & 'n <= max_mem_access).
  (AccessType(unit), physaddr, int('n), bool, bool, bool, bool) -> result((bitvector(8 * 'n), unit), ExceptionType)

val mem_read_priv_meta : forall ('n : Int), (0 < 'n & 'n <= max_mem_access).
  (AccessType(unit), Privilege, physaddr, int('n), bool, bool, bool, bool) -> result((bitvector(8 * 'n), unit), ExceptionType)

$[complete]
function mem_read_priv_meta (typ, priv, paddr, width, aq, rl, res, meta) = {
    let result : MemoryOpResult((bits(8 * 'n), mem_meta)) = if $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "|", "is_infix" = true }] or_bool(aq, res), not($[overloaded { "name" = "is_aligned_addr", "is_infix" = false }] is_aligned_paddr(paddr, width))) then
      Err(E_Load_Addr_Align())
    else
      $[complete] match (aq, rl, res) {
        (false, true, false) => throw(Error_not_implemented("load.rl")),
        (false, true, true) => throw(Error_not_implemented("lr.rl")),
        (_, _, _) => checked_mem_read(typ, priv, paddr, width, aq, rl, res, meta)
      };
    $[complete] match result {
      Ok((value, _)) => mem_read_callback($[overloaded { "name" = "to_str", "is_infix" = false }] accessType_to_str(typ), $[overloaded { "name" = "bits_of", "is_infix" = false }] bits_of_physaddr(paddr), width, value),
      Err(e) => mem_exception_callback($[overloaded { "name" = "bits_of", "is_infix" = false }] bits_of_physaddr(paddr), num_of_ExceptionType(e))
    };
    result
}

$[complete]
function mem_read_meta (typ, paddr, width, aq, rl, res, meta) = mem_read_priv_meta(typ, effectivePrivilege(typ, mstatus, cur_privilege), paddr, width, aq, rl, res, meta)

$[complete]
function mem_read_priv (typ, priv, paddr, width, aq, rl, res) = MemoryOpResult_drop_meta(mem_read_priv_meta(typ, priv, paddr, width, aq, rl, res, false))

$[complete]
function mem_read (typ, paddr, width, aq, rel, res) = mem_read_priv(typ, effectivePrivilege(typ, mstatus, cur_privilege), paddr, width, aq, rel, res)

val mem_write_ea : forall ('n : Int), (0 < 'n & 'n <= max_mem_access).
  (physaddr, int('n), bool, bool, bool) -> result(unit, ExceptionType)

$[complete]
function mem_write_ea (addr, width, aq, rl, con) = if $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "|", "is_infix" = true }] or_bool(rl, con), not($[overloaded { "name" = "is_aligned_addr", "is_infix" = false }] is_aligned_paddr(addr, width))) then
  Err(E_SAMO_Addr_Align())
else
  Ok(write_ram_ea(write_kind_of_flags(aq, rl, con), addr, width))

val phys_mem_write : forall ('n : Int), (0 < 'n & 'n <= max_mem_access).
  (write_kind, physaddr, int('n), bitvector(8 * 'n), unit) -> result(bool, ExceptionType)

$[complete]
function phys_mem_write (wk : write_kind, paddr : physaddr, width : int('n), data : bits(8 * 'n), meta : mem_meta) = Ok(write_ram(wk, paddr, width, data, meta))

val checked_mem_write : forall ('n : Int), (0 < 'n & 'n <= max_mem_access).
  (physaddr, int('n), bitvector(8 * 'n), AccessType(unit), Privilege, unit, bool, bool, bool) -> result(bool, ExceptionType)

$[complete]
function checked_mem_write (paddr : physaddr, width : int('n), data : bits(8 * 'n), typ : AccessType(ext_access_type), priv : Privilege, meta : mem_meta, aq : bool, rl : bool, con : bool) = $[complete] match phys_access_check(typ, priv, paddr, width) {
  Some(e) => Err(e),
  None(()) => {
      if within_mmio_writable(paddr, width) then mmio_write(paddr, width, data)
      else
        if within_phys_mem(paddr, width) then {
            let wk = write_kind_of_flags(aq, rl, con);
            phys_mem_write(wk, paddr, width, data, meta)
        } else Err(E_SAMO_Access_Fault())
  }
}

val mem_write_value_priv_meta : forall ('n : Int), (0 < 'n & 'n <= max_mem_access).
  (physaddr, int('n), bitvector(8 * 'n), AccessType(unit), Privilege, unit, bool, bool, bool) -> result(bool, ExceptionType)

$[complete]
function mem_write_value_priv_meta (paddr, width, value, typ, priv, meta, aq, rl, con) = {
    if $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "|", "is_infix" = true }] or_bool(rl, con), not($[overloaded { "name" = "is_aligned_addr", "is_infix" = false }] is_aligned_paddr(paddr, width))) then
      Err(E_SAMO_Addr_Align())
    else {
        let result = checked_mem_write(paddr, width, value, typ, priv, meta, aq, rl, con);
        $[complete] match result {
          Ok(_) => mem_write_callback($[overloaded { "name" = "to_str", "is_infix" = false }] accessType_to_str(typ), $[overloaded { "name" = "bits_of", "is_infix" = false }] bits_of_physaddr(paddr), width, value),
          Err(e) => mem_exception_callback($[overloaded { "name" = "bits_of", "is_infix" = false }] bits_of_physaddr(paddr), num_of_ExceptionType(e))
        };
        result
    }
}

val mem_write_value_priv : forall ('n : Int), (0 < 'n & 'n <= max_mem_access).
  (physaddr, int('n), bitvector(8 * 'n), Privilege, bool, bool, bool) -> result(bool, ExceptionType)

$[complete]
function mem_write_value_priv (paddr, width, value, priv, aq, rl, con) = mem_write_value_priv_meta(paddr, width, value, Write(default_write_acc), priv, default_meta, aq, rl, con)

val mem_write_value_meta : forall ('n : Int), (0 < 'n & 'n <= max_mem_access).
  (physaddr, int('n), bitvector(8 * 'n), unit, unit, bool, bool, bool) -> result(bool, ExceptionType)

$[complete]
function mem_write_value_meta (paddr, width, value, ext_acc, meta, aq, rl, con) = {
    let typ = Write(ext_acc);
    let ep = effectivePrivilege(typ, mstatus, cur_privilege);
    mem_write_value_priv_meta(paddr, width, value, typ, ep, meta, aq, rl, con)
}

val mem_write_value : forall ('n : Int), (0 < 'n & 'n <= max_mem_access).
  (physaddr, int('n), bitvector(8 * 'n), bool, bool, bool) -> result(bool, ExceptionType)

$[complete]
function mem_write_value (paddr, width, value, aq, rl, con) = {
    mem_write_value_meta(paddr, width, value, default_write_acc, default_meta, aq, rl, con)
}

union ExecutionResult = {
  Retire_Success : unit,
  Enter_Wait : WaitReason,
  Illegal_Instruction : unit,
  Trap : (Privilege, ctl_result, xlenbits),
  Memory_Exception : (virtaddr, ExceptionType),
  Ext_CSR_Check_Failure : unit,
  Ext_ControlAddr_Check_Failure : ext_control_addr_error,
  Ext_DataAddr_Check_Failure : ext_data_addr_error,
  Ext_XRET_Priv_Failure : unit
}

let RETIRE_SUCCESS : ExecutionResult = Retire_Success()

type pte_flags_bits = bits(8)

type pte_ext_bits = bits(10)

$[undefined_gen "skip"]
$[bitfield]
struct PTE_Ext = {bits : bitvector(10)}

val undefined_PTE_Ext : unit -> PTE_Ext

$[complete]
function undefined_PTE_Ext () = struct PTE_Ext { bits = undefined }

val Mk_PTE_Ext : bitvector(10) -> PTE_Ext

$[complete]
function Mk_PTE_Ext v = struct PTE_Ext { bits = v }

$[fix_location]
val _get_PTE_Ext_bits : PTE_Ext -> bitvector(10)

$[complete]
$[fix_location]
function _get_PTE_Ext_bits v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, sub_atom(10, 1), 0)

$[fix_location]
val _update_PTE_Ext_bits : (PTE_Ext, bitvector(10)) -> PTE_Ext

$[complete]
$[fix_location]
function _update_PTE_Ext_bits (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, sub_atom(10, 1), 0, x) }

$[fix_location]
overload update_bits = {_update_PTE_Ext_bits}

$[fix_location]
val _set_PTE_Ext_bits : (register(PTE_Ext), bitvector(10)) -> unit

$[complete]
$[fix_location]
function _set_PTE_Ext_bits (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_PTE_Ext_bits(r, v)
}

overload _mod_bits = {_get_PTE_Ext_bits, _set_PTE_Ext_bits}

$[fix_location]
val _get_PTE_Ext_N : PTE_Ext -> bitvector(1)

$[complete]
$[fix_location]
function _get_PTE_Ext_N v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 9, 9)

$[fix_location]
val _update_PTE_Ext_N : (PTE_Ext, bitvector(1)) -> PTE_Ext

$[complete]
$[fix_location]
function _update_PTE_Ext_N (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 9, 9, x) }

$[fix_location]
overload update_N = {_update_PTE_Ext_N}

$[fix_location]
val _set_PTE_Ext_N : (register(PTE_Ext), bitvector(1)) -> unit

$[complete]
$[fix_location]
function _set_PTE_Ext_N (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_PTE_Ext_N(r, v)
}

overload _mod_N = {_get_PTE_Ext_N, _set_PTE_Ext_N}

$[fix_location]
val _get_PTE_Ext_PBMT : PTE_Ext -> bitvector(2)

$[complete]
$[fix_location]
function _get_PTE_Ext_PBMT v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 8, 7)

$[fix_location]
val _update_PTE_Ext_PBMT : (PTE_Ext, bitvector(2)) -> PTE_Ext

$[complete]
$[fix_location]
function _update_PTE_Ext_PBMT (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 8, 7, x) }

$[fix_location]
overload update_PBMT = {_update_PTE_Ext_PBMT}

$[fix_location]
val _set_PTE_Ext_PBMT : (register(PTE_Ext), bitvector(2)) -> unit

$[complete]
$[fix_location]
function _set_PTE_Ext_PBMT (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_PTE_Ext_PBMT(r, v)
}

overload _mod_PBMT = {_get_PTE_Ext_PBMT, _set_PTE_Ext_PBMT}

$[fix_location]
val _get_PTE_Ext_RSW_60t59b : PTE_Ext -> bitvector(2)

$[complete]
$[fix_location]
function _get_PTE_Ext_RSW_60t59b v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 6, 5)

$[fix_location]
val _update_PTE_Ext_RSW_60t59b : (PTE_Ext, bitvector(2)) -> PTE_Ext

$[complete]
$[fix_location]
function _update_PTE_Ext_RSW_60t59b (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 6, 5, x) }

$[fix_location]
overload update_RSW_60t59b = {_update_PTE_Ext_RSW_60t59b}

$[fix_location]
val _set_PTE_Ext_RSW_60t59b : (register(PTE_Ext), bitvector(2)) -> unit

$[complete]
$[fix_location]
function _set_PTE_Ext_RSW_60t59b (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_PTE_Ext_RSW_60t59b(r, v)
}

overload _mod_RSW_60t59b = {_get_PTE_Ext_RSW_60t59b, _set_PTE_Ext_RSW_60t59b}

$[fix_location]
val _get_PTE_Ext_reserved : PTE_Ext -> bitvector(5)

$[complete]
$[fix_location]
function _get_PTE_Ext_reserved v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 4, 0)

$[fix_location]
val _update_PTE_Ext_reserved : (PTE_Ext, bitvector(5)) -> PTE_Ext

$[complete]
$[fix_location]
function _update_PTE_Ext_reserved (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 4, 0, x) }

$[fix_location]
overload update_reserved = {_update_PTE_Ext_reserved}

$[fix_location]
val _set_PTE_Ext_reserved : (register(PTE_Ext), bitvector(5)) -> unit

$[complete]
$[fix_location]
function _set_PTE_Ext_reserved (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_PTE_Ext_reserved(r, v)
}

overload _mod_reserved = {_get_PTE_Ext_reserved, _set_PTE_Ext_reserved}

let default_sv32_ext_pte : pte_ext_bits = zeros(10)

val ext_bits_of_PTE : forall ('pte_size : Int), 'pte_size in {32, 64}.
  bitvector('pte_size) -> PTE_Ext

$[complete]
function ext_bits_of_PTE pte = Mk_PTE_Ext(if $[overloaded { "name" = "==", "is_infix" = true }] eq_int($[overloaded { "name" = "__size", "is_infix" = false }] bitvector_length(pte), 64) then
  $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(pte, 63, 54)
else
  default_sv32_ext_pte)

val PPN_of_PTE : forall ('pte_size : Int), 'pte_size in {32, 64}.
  bitvector('pte_size) -> bitvector(if 'pte_size == 32 then 22 else 44)

$[complete]
function PPN_of_PTE pte = if $[overloaded { "name" = "==", "is_infix" = true }] eq_int($[overloaded { "name" = "__size", "is_infix" = false }] bitvector_length(pte), 32) then
  $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(pte, 31, 10)
else
  $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(pte, 53, 10)

$[undefined_gen "skip"]
$[bitfield]
struct PTE_Flags = {bits : bitvector(8)}

val undefined_PTE_Flags : unit -> PTE_Flags

$[complete]
function undefined_PTE_Flags () = struct PTE_Flags { bits = undefined }

val Mk_PTE_Flags : bitvector(8) -> PTE_Flags

$[complete]
function Mk_PTE_Flags v = struct PTE_Flags { bits = v }

$[fix_location]
val _get_PTE_Flags_bits : PTE_Flags -> bitvector(8)

$[complete]
$[fix_location]
function _get_PTE_Flags_bits v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, sub_atom(8, 1), 0)

$[fix_location]
val _update_PTE_Flags_bits : (PTE_Flags, bitvector(8)) -> PTE_Flags

$[complete]
$[fix_location]
function _update_PTE_Flags_bits (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, sub_atom(8, 1), 0, x) }

$[fix_location]
overload update_bits = {_update_PTE_Flags_bits}

$[fix_location]
val _set_PTE_Flags_bits : (register(PTE_Flags), bitvector(8)) -> unit

$[complete]
$[fix_location]
function _set_PTE_Flags_bits (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_PTE_Flags_bits(r, v)
}

overload _mod_bits = {_get_PTE_Flags_bits, _set_PTE_Flags_bits}

$[fix_location]
val _get_PTE_Flags_A : PTE_Flags -> bitvector(1)

$[complete]
$[fix_location]
function _get_PTE_Flags_A v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 6, 6)

$[fix_location]
val _update_PTE_Flags_A : (PTE_Flags, bitvector(1)) -> PTE_Flags

$[complete]
$[fix_location]
function _update_PTE_Flags_A (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 6, 6, x) }

$[fix_location]
overload update_A = {_update_PTE_Flags_A}

$[fix_location]
val _set_PTE_Flags_A : (register(PTE_Flags), bitvector(1)) -> unit

$[complete]
$[fix_location]
function _set_PTE_Flags_A (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_PTE_Flags_A(r, v)
}

overload _mod_A = {_get_PTE_Flags_A, _set_PTE_Flags_A}

$[fix_location]
val _get_PTE_Flags_D : PTE_Flags -> bitvector(1)

$[complete]
$[fix_location]
function _get_PTE_Flags_D v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 7, 7)

$[fix_location]
val _update_PTE_Flags_D : (PTE_Flags, bitvector(1)) -> PTE_Flags

$[complete]
$[fix_location]
function _update_PTE_Flags_D (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 7, 7, x) }

$[fix_location]
overload update_D = {_update_PTE_Flags_D}

$[fix_location]
val _set_PTE_Flags_D : (register(PTE_Flags), bitvector(1)) -> unit

$[complete]
$[fix_location]
function _set_PTE_Flags_D (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_PTE_Flags_D(r, v)
}

overload _mod_D = {_get_PTE_Flags_D, _set_PTE_Flags_D}

$[fix_location]
val _get_PTE_Flags_G : PTE_Flags -> bitvector(1)

$[complete]
$[fix_location]
function _get_PTE_Flags_G v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 5, 5)

$[fix_location]
val _update_PTE_Flags_G : (PTE_Flags, bitvector(1)) -> PTE_Flags

$[complete]
$[fix_location]
function _update_PTE_Flags_G (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 5, 5, x) }

$[fix_location]
overload update_G = {_update_PTE_Flags_G}

$[fix_location]
val _set_PTE_Flags_G : (register(PTE_Flags), bitvector(1)) -> unit

$[complete]
$[fix_location]
function _set_PTE_Flags_G (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_PTE_Flags_G(r, v)
}

overload _mod_G = {_get_PTE_Flags_G, _set_PTE_Flags_G}

$[fix_location]
val _get_PTE_Flags_R : PTE_Flags -> bitvector(1)

$[complete]
$[fix_location]
function _get_PTE_Flags_R v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 1, 1)

$[fix_location]
val _update_PTE_Flags_R : (PTE_Flags, bitvector(1)) -> PTE_Flags

$[complete]
$[fix_location]
function _update_PTE_Flags_R (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 1, 1, x) }

$[fix_location]
overload update_R = {_update_PTE_Flags_R}

$[fix_location]
val _set_PTE_Flags_R : (register(PTE_Flags), bitvector(1)) -> unit

$[complete]
$[fix_location]
function _set_PTE_Flags_R (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_PTE_Flags_R(r, v)
}

overload _mod_R = {_get_PTE_Flags_R, _set_PTE_Flags_R}

$[fix_location]
val _get_PTE_Flags_U : PTE_Flags -> bitvector(1)

$[complete]
$[fix_location]
function _get_PTE_Flags_U v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 4, 4)

$[fix_location]
val _update_PTE_Flags_U : (PTE_Flags, bitvector(1)) -> PTE_Flags

$[complete]
$[fix_location]
function _update_PTE_Flags_U (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 4, 4, x) }

$[fix_location]
overload update_U = {_update_PTE_Flags_U}

$[fix_location]
val _set_PTE_Flags_U : (register(PTE_Flags), bitvector(1)) -> unit

$[complete]
$[fix_location]
function _set_PTE_Flags_U (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_PTE_Flags_U(r, v)
}

overload _mod_U = {_get_PTE_Flags_U, _set_PTE_Flags_U}

$[fix_location]
val _get_PTE_Flags_V : PTE_Flags -> bitvector(1)

$[complete]
$[fix_location]
function _get_PTE_Flags_V v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 0, 0)

$[fix_location]
val _update_PTE_Flags_V : (PTE_Flags, bitvector(1)) -> PTE_Flags

$[complete]
$[fix_location]
function _update_PTE_Flags_V (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 0, 0, x) }

$[fix_location]
overload update_V = {_update_PTE_Flags_V}

$[fix_location]
val _set_PTE_Flags_V : (register(PTE_Flags), bitvector(1)) -> unit

$[complete]
$[fix_location]
function _set_PTE_Flags_V (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_PTE_Flags_V(r, v)
}

overload _mod_V = {_get_PTE_Flags_V, _set_PTE_Flags_V}

$[fix_location]
val _get_PTE_Flags_W : PTE_Flags -> bitvector(1)

$[complete]
$[fix_location]
function _get_PTE_Flags_W v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 2, 2)

$[fix_location]
val _update_PTE_Flags_W : (PTE_Flags, bitvector(1)) -> PTE_Flags

$[complete]
$[fix_location]
function _update_PTE_Flags_W (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 2, 2, x) }

$[fix_location]
overload update_W = {_update_PTE_Flags_W}

$[fix_location]
val _set_PTE_Flags_W : (register(PTE_Flags), bitvector(1)) -> unit

$[complete]
$[fix_location]
function _set_PTE_Flags_W (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_PTE_Flags_W(r, v)
}

overload _mod_W = {_get_PTE_Flags_W, _set_PTE_Flags_W}

$[fix_location]
val _get_PTE_Flags_X : PTE_Flags -> bitvector(1)

$[complete]
$[fix_location]
function _get_PTE_Flags_X v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 3, 3)

$[fix_location]
val _update_PTE_Flags_X : (PTE_Flags, bitvector(1)) -> PTE_Flags

$[complete]
$[fix_location]
function _update_PTE_Flags_X (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 3, 3, x) }

$[fix_location]
overload update_X = {_update_PTE_Flags_X}

$[fix_location]
val _set_PTE_Flags_X : (register(PTE_Flags), bitvector(1)) -> unit

$[complete]
$[fix_location]
function _set_PTE_Flags_X (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_PTE_Flags_X(r, v)
}

overload _mod_X = {_get_PTE_Flags_X, _set_PTE_Flags_X}

val pte_is_non_leaf : PTE_Flags -> bool

$[complete]
function pte_is_non_leaf pte_flags : PTE_Flags = $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_bits(_get_PTE_Flags_X(pte_flags), 0b0), $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_bits(_get_PTE_Flags_W(pte_flags), 0b0), $[overloaded { "name" = "==", "is_infix" = true }] eq_bits(_get_PTE_Flags_R(pte_flags), 0b0)))

val pte_is_invalid : (PTE_Flags, PTE_Ext) -> bool

$[complete]
function pte_is_invalid (pte_flags : PTE_Flags, pte_ext : PTE_Ext) = $[overloaded { "name" = "|", "is_infix" = true }] or_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_bits(_get_PTE_Flags_V(pte_flags), 0b0), $[overloaded { "name" = "|", "is_infix" = true }] or_bool($[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_bits(_get_PTE_Flags_W(pte_flags), 0b1), $[overloaded { "name" = "==", "is_infix" = true }] eq_bits(_get_PTE_Flags_R(pte_flags), 0b0)), $[overloaded { "name" = "|", "is_infix" = true }] or_bool($[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "!=", "is_infix" = true }] neq_bits(_get_PTE_Ext_N(pte_ext), 0b0), not(currentlyEnabled(Ext_Svnapot))), $[overloaded { "name" = "|", "is_infix" = true }] or_bool($[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "!=", "is_infix" = true }] neq_bits(_get_PTE_Ext_PBMT(pte_ext), zeros(2)), not(currentlyEnabled(Ext_Svpbmt))), $[overloaded { "name" = "|", "is_infix" = true }] or_bool($[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "!=", "is_infix" = true }] neq_bits(_get_PTE_Ext_RSW_60t59b(pte_ext), zeros(2)), not(currentlyEnabled(Ext_Svrsw60t59b))), $[overloaded { "name" = "!=", "is_infix" = true }] neq_bits(_get_PTE_Ext_reserved(pte_ext), zeros(5)))))))

union PTE_Check = {
  PTE_Check_Success : ext_ptw,
  PTE_Check_Failure : (ext_ptw, ext_ptw_fail)
}

val check_PTE_permission : (AccessType(unit), Privilege, bool, bool, PTE_Flags, PTE_Ext, unit) -> PTE_Check

$[complete]
function check_PTE_permission (ac : AccessType(ext_access_type), priv : Privilege, mxr : bool, do_sum : bool, pte_flags : PTE_Flags, ext : PTE_Ext, ext_ptw : ext_ptw) = {
    let pte_U = bits_to_bool(_get_PTE_Flags_U(pte_flags));
    let pte_R = bits_to_bool(_get_PTE_Flags_R(pte_flags));
    let pte_W = bits_to_bool(_get_PTE_Flags_W(pte_flags));
    let pte_X = bits_to_bool(_get_PTE_Flags_X(pte_flags));
    let access_ok : bool = $[complete] match ac {
      Read(_) => $[overloaded { "name" = "|", "is_infix" = true }] or_bool(pte_R, $[overloaded { "name" = "&", "is_infix" = true }] and_bool(pte_X, mxr)),
      Write(_) => pte_W,
      ReadWrite((_, _)) => $[overloaded { "name" = "&", "is_infix" = true }] and_bool(pte_W, $[overloaded { "name" = "|", "is_infix" = true }] or_bool(pte_R, $[overloaded { "name" = "&", "is_infix" = true }] and_bool(pte_X, mxr))),
      InstructionFetch(_) => pte_X
    };
    let priv_ok : bool = $[complete] match priv {
      User => pte_U,
      Supervisor => $[overloaded { "name" = "|", "is_infix" = true }] or_bool(not(pte_U), $[overloaded { "name" = "&", "is_infix" = true }] and_bool(do_sum, is_load_store(ac))),
      Machine => internal_error("./sys/vmem_pte.sail", 133, "m-mode mem perm check"),
      VirtualUser => internal_error("./sys/vmem_pte.sail", 134, "Hypervisor extension not supported"),
      VirtualSupervisor => internal_error("./sys/vmem_pte.sail", 135, "Hypervisor extension not supported")
    };
    if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(access_ok, priv_ok) then
      PTE_Check_Success()
    else
      PTE_Check_Failure(((), ()))
}

val update_PTE_Bits : forall ('pte_size : Int), 'pte_size in {32, 64}.
  (bitvector('pte_size), AccessType(unit)) -> option(bitvector('pte_size))

$[complete]
function update_PTE_Bits (pte : bits('pte_size), a : AccessType(ext_access_type)) = {
    let pte_flags = Mk_PTE_Flags($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(pte, 7, 0));
    let update_d : bool = $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_bits(_get_PTE_Flags_D(pte_flags), 0b0), ($[complete] match a {
      InstructionFetch(()) => false,
      Read(_) => false,
      Write(_) => true,
      ReadWrite((_, _)) => true
    }) : bool);
    let update_a = $[overloaded { "name" = "==", "is_infix" = true }] eq_bits(_get_PTE_Flags_A(pte_flags), 0b0);
    if $[overloaded { "name" = "|", "is_infix" = true }] or_bool(update_d, update_a) then {
        let pte_flags = _update_PTE_Flags_D(_update_PTE_Flags_A(pte_flags, 0b1), if update_d then
          0b1
        else
          _get_PTE_Flags_D(pte_flags));
        Some($[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(pte, 7, 0, pte_flags.bits))
    } else {
        None()
    }
}

union PTW_Error = {
  PTW_Invalid_Addr : unit,
  PTW_Access : unit,
  PTW_Invalid_PTE : unit,
  PTW_No_Permission : unit,
  PTW_Misaligned : unit,
  PTW_PTE_Update : unit,
  PTW_Ext_Error : ext_ptw_error
}

val ptw_error_to_str : PTW_Error -> string

$[complete]
function ptw_error_to_str e : PTW_Error = {
    $[complete] match e {
      PTW_Invalid_Addr(()) => "invalid-source-addr",
      PTW_Access(()) => "mem-access-error",
      PTW_Invalid_PTE(()) => "invalid-pte",
      PTW_No_Permission(()) => "no-permission",
      PTW_Misaligned(()) => "misaligned-superpage",
      PTW_PTE_Update(()) => "pte-update-needed",
      PTW_Ext_Error(e) => "extension-error"
    }
}

overload to_str = {ptw_error_to_str}

val ext_get_ptw_error : unit -> PTW_Error

$[complete]
function ext_get_ptw_error eptwf : ext_ptw_fail = PTW_No_Permission()

val translationException : (AccessType(unit), PTW_Error) -> ExceptionType

$[complete]
function translationException (a : AccessType(ext_access_type), f : PTW_Error) = {
    $[complete] match (a, f) {
      (_, PTW_Ext_Error(e)) => E_Extension(ext_translate_exception(e)),
      (ReadWrite(_), PTW_Access(())) => E_SAMO_Access_Fault(),
      (ReadWrite(_), _) => E_SAMO_Page_Fault(),
      (Read(_), PTW_Access(())) => E_Load_Access_Fault(),
      (Read(_), _) => E_Load_Page_Fault(),
      (Write(_), PTW_Access(())) => E_SAMO_Access_Fault(),
      (Write(_), _) => E_SAMO_Page_Fault(),
      (InstructionFetch(()), PTW_Access(())) => E_Fetch_Access_Fault(),
      (InstructionFetch(()), _) => E_Fetch_Page_Fault()
    }
}

type tlb_vpn_bits : Int = 57 - pagesize_bits

let tlb_vpn_bits = sub_atom(57, 12)

type tlb_ppn_bits : Int = 44

let tlb_ppn_bits = 44

$[undefined_gen "forbid"]
struct TLB_Entry = {
  asid : asidbits,
  global : bool,
  vpn : bits(tlb_vpn_bits),
  levelMask : bits(tlb_vpn_bits),
  ppn : bits(tlb_ppn_bits),
  pte : bits(64),
  pteAddr : physaddr
}

val tlb_get_pte : forall ('n : Int), 'n in {4, 8}.
  (int('n), TLB_Entry) -> bitvector('n * 8)

$[complete]
function tlb_get_pte (pte_size : int('n), ent : TLB_Entry) = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(ent.pte, $[overloaded { "name" = "-", "is_infix" = true }] sub_atom($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(pte_size, 8), 1), 0)

val tlb_set_pte : forall ('n : Int), 'n in {4, 8}.
  (TLB_Entry, bitvector('n * 8)) -> TLB_Entry

$[complete]
function tlb_set_pte (ent : TLB_Entry, pte : bits('n * 8)) = { ent with pte = zero_extend(64, pte) }

val tlb_get_ppn : forall ('v : Int), is_sv_mode('v).
  (int('v), TLB_Entry, bitvector('v - 12)) -> bitvector(if 'v == 32 then 22 else 44)

$[complete]
function tlb_get_ppn (sv_width : int('v), ent : TLB_Entry, vpn : vpn_bits('v)) = {
    let vpn : bits(64) = sign_extend(64, vpn);
    let levelMask : bits(64) = zero_extend(64, ent.levelMask);
    let ppn : bits(64) = zero_extend(64, ent.ppn);
    trunc(if $[overloaded { "name" = "==", "is_infix" = true }] eq_int($[overloaded { "name" = "__size", "is_infix" = false }] __id(sv_width), 32) then
      22
    else
      44, $[overloaded { "name" = "|", "is_infix" = true }] or_vec(ppn, $[overloaded { "name" = "&", "is_infix" = true }] and_vec(vpn, levelMask)))
}

type num_tlb_entries : Int = 64

type tlb_index_range = range(0, num_tlb_entries - 1)

register tlb : vector(num_tlb_entries, option(TLB_Entry)) = vector_init(64, None())

val tlb_hash : forall ('v : Int), is_sv_mode('v).
  (int('v), bitvector('v - 12)) -> range(0, 64 - 1)

$[complete]
function tlb_hash (sv_mode : int('v), vpn : vpn_bits('v)) = unsigned($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(vpn, 5, 0))

val reset_TLB : unit -> unit

$[complete]
function reset_TLB () = tlb = vector_init(64, None())

val write_TLB : (range(0, 64 - 1), TLB_Entry) -> unit

$[complete]
function write_TLB (index : tlb_index_range, entry : TLB_Entry) = tlb[index] = Some(entry)

val match_TLB_Entry : (TLB_Entry, bitvector(if xlen == 32 then 9 else 16), bitvector(57 - 12)) -> bool

$[complete]
function match_TLB_Entry (ent : TLB_Entry, asid : asidbits, vpn : bits(tlb_vpn_bits)) = $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "|", "is_infix" = true }] or_bool(ent.global, $[overloaded { "name" = "==", "is_infix" = true }] eq_bits(ent.asid, asid)), $[overloaded { "name" = "==", "is_infix" = true }] eq_bits(ent.vpn, $[overloaded { "name" = "&", "is_infix" = true }] and_vec(vpn, $[overloaded { "name" = "~", "is_infix" = false }] not_vec(ent.levelMask))))

val flush_TLB_Entry : (TLB_Entry, option(bitvector(if xlen == 32 then 9 else 16)), option(bitvector(xlen))) -> bool

$[complete]
function flush_TLB_Entry (ent : TLB_Entry, asid : option(asidbits), vaddr : option(xlenbits)) = {
    let asid_matches : bool = $[complete] match asid {
      Some(asid) => $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_bits(ent.asid, asid), not(ent.global)),
      None(()) => true
    };
    let addr_matches : bool = $[complete] match vaddr {
      Some(vaddr) => {
          let vaddr : bits(64) = sign_extend(64, vaddr);
          $[overloaded { "name" = "==", "is_infix" = true }] eq_bits(ent.vpn, $[overloaded { "name" = "&", "is_infix" = true }] and_vec($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(vaddr, 56, pagesize_bits), $[overloaded { "name" = "~", "is_infix" = false }] not_vec(ent.levelMask)))
      },
      None(()) => true
    };
    $[overloaded { "name" = "&", "is_infix" = true }] and_bool(asid_matches, addr_matches)
}

val lookup_TLB : forall ('v : Int), is_sv_mode('v).
  (int('v), bitvector(if xlen == 32 then 9 else 16), bitvector('v - 12)) -> option((range(0, 64 - 1), TLB_Entry))

$[complete]
function lookup_TLB (sv_width : int('v), asid : asidbits, vpn : vpn_bits('v)) = {
    let index = tlb_hash($[overloaded { "name" = "__size", "is_infix" = false }] __id(sv_width), vpn);
    $[complete] match $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(tlb, index) {
      None(()) => None(),
      Some(entry) => {
          if match_TLB_Entry(entry, asid, sign_extend(sub_atom(57, 12), vpn)) then
            Some((index, entry))
          else
            None()
      }
    }
}

val add_to_TLB : forall ('v : Int), is_sv_mode('v).
  (int('v), bitvector(if xlen == 32 then 9 else 16), bitvector('v - 12), bitvector(if 'v == 32 then 22 else 44), bitvector(if 'v == 32 then 32 else 64), physaddr, range(0, if 'v == 32 then 1 else (if 'v == 39 then 2 else (if 'v == 48 then 3 else 4))), bool) -> unit

$[complete]
function add_to_TLB (sv_width : int('v), asid : asidbits, vpn : vpn_bits('v), ppn : ppn_bits('v), pte : pte_bits('v), pteAddr : physaddr, level : level_range('v), global : bool) = {
    let shift = $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(level, if $[overloaded { "name" = "==", "is_infix" = true }] eq_int($[overloaded { "name" = "__size", "is_infix" = false }] __id(sv_width), 32) then
      10
    else
      9);
    let levelMask = ones(shift);
    let vpn = $[overloaded { "name" = "&", "is_infix" = true }] and_vec(vpn, $[overloaded { "name" = "~", "is_infix" = false }] not_vec(zero_extend(sub_atom($[overloaded { "name" = "__size", "is_infix" = false }] __id(sv_width), 12), levelMask)));
    let ppn = $[overloaded { "name" = "&", "is_infix" = true }] and_vec(ppn, $[overloaded { "name" = "~", "is_infix" = false }] not_vec(zero_extend(if $[overloaded { "name" = "==", "is_infix" = true }] eq_int($[overloaded { "name" = "__size", "is_infix" = false }] __id(sv_width), 32) then
      22
    else
      44, levelMask)));
    let entry : TLB_Entry = struct TLB_Entry { asid = asid, global = global, pte = zero_extend(64, pte), pteAddr = pteAddr, levelMask = zero_extend(sub_atom(57, 12), levelMask), vpn = sign_extend(sub_atom(57, 12), vpn), ppn = zero_extend(44, ppn) };
    let index = tlb_hash($[overloaded { "name" = "__size", "is_infix" = false }] __id(sv_width), vpn);
    tlb[index] = Some(entry)
}

val flush_TLB : (option(bitvector(if xlen == 32 then 9 else 16)), option(bitvector(xlen))) -> unit

$[complete]
function flush_TLB (asid : option(asidbits), addr : option(xlenbits)) = {
    foreach (i
    from 0
    to sub_atom($[overloaded { "name" = "length", "is_infix" = false }] vector_length(tlb), 1)
    by 1
    in inc) {
        $[complete] match $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(tlb, i) {
          None(()) => (),
          Some(entry) => if flush_TLB_Entry(entry, asid, addr) then {
              tlb[i] = None()
          } else ()
        }
    }
}

$[undefined_gen "forbid"]
struct PTW_Output ('v: Int) constraint is_sv_mode('v) = {
  ppn : ppn_bits('v),
  pte : pte_bits('v),
  pteAddr : physaddr,
  level : level_range('v),
  global : bool
}

type PTW_Result('v: Int) constraint is_sv_mode('v) =
  result((PTW_Output('v), ext_ptw), (PTW_Error, ext_ptw))

val write_pte : forall ('n : Int), 'n in {4, 8}.
  (physaddr, int('n), bitvector('n * 8)) -> result(bool, ExceptionType)

$[complete]
function write_pte (paddr : physaddr, pte_size : int('n), pte : bits('n * 8)) = mem_write_value_priv(paddr, pte_size, pte, Supervisor, false, false, false)

val read_pte : forall ('n : Int), 'n in {4, 8}.
  (physaddr, int('n)) -> result(bitvector(8 * 'n), ExceptionType)

$[complete]
function read_pte (paddr : physaddr, pte_size : int('n)) = mem_read_priv(Read(Data), Supervisor, paddr, pte_size, false, false, false)

val pt_walk : forall ('v : Int), is_sv_mode('v).
  (int('v), bitvector('v - 12), AccessType(unit), Privilege, bool, bool, bitvector(if 'v == 32 then 22 else 44), range(0, if 'v == 32 then 1 else (if 'v == 39 then 2 else (if 'v == 48 then 3 else 4))), bool, unit) -> result((PTW_Output('v), unit), (PTW_Error, unit))

$[complete]
function pt_walk (sv_width, vpn, ac, priv, mxr, do_sum, pt_base, level, global, ext_ptw) = {
    let 'vpn_i_size = if $[overloaded { "name" = "==", "is_infix" = true }] eq_int($[overloaded { "name" = "__size", "is_infix" = false }] __id(sv_width), 32) then
      10
    else
      9;
    let vpn_i = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(vpn, $[overloaded { "name" = "-", "is_infix" = true }] sub_atom($[overloaded { "name" = "*", "is_infix" = true }] mult_atom($[overloaded { "name" = "+", "is_infix" = true }] add_atom(level, 1), vpn_i_size), 1), $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(level, vpn_i_size));
    let 'log_pte_size_bytes = if $[overloaded { "name" = "==", "is_infix" = true }] eq_int($[overloaded { "name" = "__size", "is_infix" = false }] __id(sv_width), 32) then
      2
    else
      3;
    let pte_addr = $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(pt_base, $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(vpn_i, zeros($[overloaded { "name" = "__size", "is_infix" = false }] __id(log_pte_size_bytes))));
    assert($[overloaded { "name" = "|", "is_infix" = true }] or_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_int(sv_width, 32), $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64)), "./sys/vmem.sail:103.36-103.37");
    let pte_addr = Physaddr(zero_extend(if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(sizeof(xlen), 32) then
      34
    else
      64, pte_addr));
    $[complete] match read_pte(pte_addr, 2 ^ log_pte_size_bytes) {
      Err(_) => Err((PTW_Access(), ext_ptw)),
      Ok(pte) => {
          let pte_flags = Mk_PTE_Flags($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(pte, 7, 0));
          let pte_ext = ext_bits_of_PTE(pte);
          if pte_is_invalid(pte_flags, pte_ext) then
            Err((PTW_Invalid_PTE(), ext_ptw))
          else {
              let ppn = PPN_of_PTE(pte);
              let global = $[overloaded { "name" = "|", "is_infix" = true }] or_bool(global, $[overloaded { "name" = "==", "is_infix" = true }] eq_bits(_get_PTE_Flags_G(pte_flags), 0b1));
              if pte_is_non_leaf(pte_flags) then {
                  if $[overloaded { "name" = ">", "is_infix" = true }] gt_int(level, 0) then
                    pt_walk(sv_width, vpn, ac, priv, mxr, do_sum, ppn, $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(level, 1), global, ext_ptw)
                  else
                    Err((PTW_Invalid_PTE(), ext_ptw))
              } else {
                  let ppn_size_bits = if $[overloaded { "name" = "==", "is_infix" = true }] eq_int($[overloaded { "name" = "__size", "is_infix" = false }] __id(sv_width), 32) then
                    10
                  else
                    9;
                  if $[overloaded { "name" = ">", "is_infix" = true }] gt_int(level, 0) then {
                      let low_bits = $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(ppn_size_bits, level);
                      if $[overloaded { "name" = "!=", "is_infix" = true }] neq_bits($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(ppn, $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(low_bits, 1), 0), zeros(add_atom(sub_atom(sub_atom(mult_atom(if $[overloaded { "name" = "==", "is_infix" = true }] eq_int($[overloaded { "name" = "__size", "is_infix" = false }] __id(sv_width), 32) then
                        10
                      else
                        9, $[overloaded { "name" = "__size", "is_infix" = false }] __id(level)), 1), 0), 1))) then return(Err((PTW_Misaligned(), ext_ptw)));
                      ()
                  };
                  $[complete] match check_PTE_permission(ac, priv, mxr, do_sum, pte_flags, pte_ext, ext_ptw) {
                    PTE_Check_Failure((ext_ptw, ext_ptw_fail)) => Err((ext_get_ptw_error(ext_ptw_fail), ext_ptw)),
                    PTE_Check_Success(ext_ptw) => {
                        let ppn = if $[overloaded { "name" = ">", "is_infix" = true }] gt_int(level, 0) then {
                            let low_bits = $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(ppn_size_bits, level);
                            $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(ppn, $[overloaded { "name" = "-", "is_infix" = true }] sub_atom($[overloaded { "name" = "length", "is_infix" = false }] bitvector_length(ppn), 1), low_bits), $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(vpn, $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(low_bits, 1), 0))
                        } else {
                            ppn
                        };
                        Ok((struct PTW_Output { ppn = ppn, pte = pte, pteAddr = pte_addr, level = level, global = global }, ext_ptw))
                    }
                  }
              }
          }
      }
    }
}

register satp : xlenbits

val satp_to_asid : forall ('n : Int), 'n in {32, 64}.
  bitvector('n) -> bitvector(if 'n == 32 then 9 else 16)

$[complete]
function satp_to_asid satp_val = if $[overloaded { "name" = "==", "is_infix" = true }] eq_int($[overloaded { "name" = "__size", "is_infix" = false }] bitvector_length(satp_val), 32) then
  _get_Satp32_Asid(Mk_Satp32(satp_val))
else
  _get_Satp64_Asid(Mk_Satp64(satp_val))

val satp_to_ppn : forall ('n : Int), 'n in {32, 64}.
  bitvector('n) -> bitvector(if 'n == 32 then 22 else 44)

$[complete]
function satp_to_ppn satp_val = if $[overloaded { "name" = "==", "is_infix" = true }] eq_int($[overloaded { "name" = "__size", "is_infix" = false }] bitvector_length(satp_val), 32) then
  _get_Satp32_PPN(Mk_Satp32(satp_val))
else
  _get_Satp64_PPN(Mk_Satp64(satp_val))

val translationMode : Privilege -> SATPMode

$[complete]
function translationMode priv : Privilege = {
    if $[overloaded { "name" = "==", "is_infix" = true }] eq_anything(priv, Machine) then
      Bare
    else {
        let arch = architecture_backwards(get_mstatus_SXL(mstatus));
        let mbits : satp_mode = $[complete] match arch {
          RV64 => {
              assert($[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(xlen, 64), "./sys/vmem.sail:192.25-192.26");
              _get_Satp64_Mode(Mk_Satp64(satp))
          },
          RV32 => $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(0b000, _get_Satp32_Mode(Mk_Satp32($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(satp, 31, 0)))),
          RV128 => internal_error("./sys/vmem.sail", 196, "RV128 not supported")
        };
        $[complete] match satpMode_of_bits(arch, mbits) {
          Some(m) => m,
          None(()) => internal_error("./sys/vmem.sail", 201, "invalid translation mode in satp")
        }
    }
}

type TR_Result('paddr: Type, 'failure: Type) =
  result(('paddr, ext_ptw), ('failure, ext_ptw))

val translate_TLB_hit : forall ('v : Int), is_sv_mode('v).
  (int('v), bitvector(if xlen == 32 then 9 else 16), bitvector('v - 12), AccessType(unit), Privilege, bool, bool, unit, range(0, 64 - 1), TLB_Entry) -> result((bitvector(if 'v == 32 then 22 else 44), unit), (PTW_Error, unit))

$[complete]
function translate_TLB_hit (sv_width : int('v), asid : asidbits, vpn : vpn_bits('v), ac : AccessType(ext_access_type), priv : Privilege, mxr : bool, do_sum : bool, ext_ptw : ext_ptw, tlb_index : tlb_index_range, ent : TLB_Entry) = {
    let pte_size = if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(sv_width, 32) then
      4
    else
      8;
    let pte = tlb_get_pte(pte_size, ent);
    let ext_pte = ext_bits_of_PTE(pte);
    let pte_flags = Mk_PTE_Flags($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(pte, 7, 0));
    let pte_check = check_PTE_permission(ac, priv, mxr, do_sum, pte_flags, ext_pte, ext_ptw);
    $[complete] match pte_check {
      PTE_Check_Failure((ext_ptw, ext_ptw_fail)) => Err((ext_get_ptw_error(ext_ptw_fail), ext_ptw)),
      PTE_Check_Success(ext_ptw) => $[complete] match update_PTE_Bits(pte, ac) {
        None(()) => Ok((tlb_get_ppn(sv_width, ent, vpn), ext_ptw)),
        Some(pte') => if not(plat_enable_dirty_update) then
          Err((PTW_PTE_Update(), ext_ptw))
        else {
            write_TLB(tlb_index, tlb_set_pte(ent, pte'));
            $[complete] match write_pte(ent.pteAddr, pte_size, pte') {
              Ok(_) => (),
              Err(e) => internal_error("./sys/vmem.sail", 253, "invalid physical address in TLB")
            };
            Ok((tlb_get_ppn(sv_width, ent, vpn), ext_ptw))
        }
      }
    }
}

val translate_TLB_miss : forall ('v : Int), is_sv_mode('v).
  (int('v), bitvector(if xlen == 32 then 9 else 16), bitvector(if 'v == 32 then 22 else 44), bitvector('v - 12), AccessType(unit), Privilege, bool, bool, unit) -> result((bitvector(if 'v == 32 then 22 else 44), unit), (PTW_Error, unit))

$[complete]
function translate_TLB_miss (sv_width : int('v), asid : asidbits, base_ppn : ppn_bits('v), vpn : vpn_bits('v), ac : AccessType(ext_access_type), priv : Privilege, mxr : bool, do_sum : bool, ext_ptw : ext_ptw) = {
    let initial_level = if $[overloaded { "name" = "==", "is_infix" = true }] eq_int($[overloaded { "name" = "__size", "is_infix" = false }] __id(sv_width), 32) then
      1
    else
      if $[overloaded { "name" = "==", "is_infix" = true }] eq_int($[overloaded { "name" = "__size", "is_infix" = false }] __id(sv_width), 39) then
        2
      else
        if $[overloaded { "name" = "==", "is_infix" = true }] eq_int($[overloaded { "name" = "__size", "is_infix" = false }] __id(sv_width), 48) then
          3
        else
          4;
    let 'pte_size = if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(sv_width, 32) then
      4
    else
      8;
    let ptw_result = pt_walk(sv_width, vpn, ac, priv, mxr, do_sum, base_ppn, initial_level, false, ext_ptw);
    $[complete] match ptw_result {
      Err((f, ext_ptw)) => Err((f, ext_ptw)),
      Ok((struct PTW_Output { ppn = ppn, pte = pte, pteAddr = pteAddr, level = level, global = global }, ext_ptw)) => {
          let ext_pte = ext_bits_of_PTE(pte);
          $[complete] match update_PTE_Bits(pte, ac) {
            None(()) => {
                add_to_TLB(sv_width, asid, vpn, ppn, pte, pteAddr, level, global);
                Ok((ppn, ext_ptw))
            },
            Some(pte) => if not(plat_enable_dirty_update) then
              Err((PTW_PTE_Update(), ext_ptw))
            else {
                $[complete] match write_pte(pteAddr, pte_size, pte) {
                  Ok(_) => {
                      add_to_TLB(sv_width, asid, vpn, ppn, pte, pteAddr, level, global);
                      Ok((ppn, ext_ptw))
                  },
                  Err(e) => Err((PTW_Access(), ext_ptw))
                }
            }
          }
      }
    }
}

val satp_mode_width : SATPMode <-> {32, 39, 48, 57}

mapping satp_mode_width = {
  Sv32 <-> 32,
  Sv39 <-> 39,
  Sv48 <-> 48,
  Sv57 <-> 57
}

val translate : forall ('v : Int), is_sv_mode('v).
  (int('v), bitvector(if xlen == 32 then 9 else 16), bitvector(if 'v == 32 then 22 else 44), bitvector('v - 12), AccessType(unit), Privilege, bool, bool, unit) -> result((bitvector(if 'v == 32 then 22 else 44), unit), (PTW_Error, unit))

$[complete]
function translate (sv_width : int('v), asid : asidbits, base_ppn : ppn_bits('v), vpn : vpn_bits('v), ac : AccessType(ext_access_type), priv : Privilege, mxr : bool, do_sum : bool, ext_ptw : ext_ptw) = {
    $[complete] match lookup_TLB(sv_width, asid, vpn) {
      Some((index, ent)) => translate_TLB_hit(sv_width, asid, vpn, ac, priv, mxr, do_sum, ext_ptw, index, ent),
      None(()) => translate_TLB_miss(sv_width, asid, base_ppn, vpn, ac, priv, mxr, do_sum, ext_ptw)
    }
}

val get_satp : forall ('v : Int), is_sv_mode('v).
  int('v) -> bitvector(if 'v == 32 then 32 else 64)

$[complete]
function get_satp sv_width : int('v) = {
    assert($[overloaded { "name" = "|", "is_infix" = true }] or_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_int($[overloaded { "name" = "__size", "is_infix" = false }] __id(sv_width), 32), $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64)), "./sys/vmem.sail:350.30-350.31");
    if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(sv_width, 32) then
      $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(satp, 31, 0)
    else
      satp
}

val translateAddr : (virtaddr, AccessType(unit)) -> result((physaddr, unit), (ExceptionType, unit))

$[complete]
function translateAddr (vAddr : virtaddr, ac : AccessType(ext_access_type)) = {
    let effPriv = effectivePrivilege(ac, mstatus, cur_privilege);
    let mode = translationMode(effPriv);
    if $[overloaded { "name" = "==", "is_infix" = true }] eq_anything(mode, Bare) then return(Ok((Physaddr(zero_extend(if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(sizeof(xlen), 32) then
      34
    else
      64, $[overloaded { "name" = "bits_of", "is_infix" = false }] bits_of_virtaddr(vAddr))), init_ext_ptw)));
    let sv_width = satp_mode_width_forwards(mode);
    let satp_sxlen = get_satp(sv_width);
    assert($[overloaded { "name" = "|", "is_infix" = true }] or_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_int(sv_width, 32), $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64)), "./sys/vmem.sail:376.36-376.37");
    let svAddr = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits($[overloaded { "name" = "bits_of", "is_infix" = false }] bits_of_virtaddr(vAddr), $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(sv_width, 1), 0);
    if $[overloaded { "name" = "!=", "is_infix" = true }] neq_bits($[overloaded { "name" = "bits_of", "is_infix" = false }] bits_of_virtaddr(vAddr), sign_extend(sizeof(xlen), svAddr)) then {
        Err((translationException(ac, PTW_Invalid_Addr()), init_ext_ptw))
    } else {
        let mxr = $[overloaded { "name" = "==", "is_infix" = true }] eq_bits(_get_Mstatus_MXR(mstatus), 0b1);
        let do_sum = $[overloaded { "name" = "==", "is_infix" = true }] eq_bits(_get_Mstatus_SUM(mstatus), 0b1);
        let asid = satp_to_asid(satp_sxlen);
        let base_ppn = satp_to_ppn(satp_sxlen);
        let res = translate(sv_width, zero_extend(if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(sizeof(xlen), 32) then
          9
        else
          16, asid), base_ppn, $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(svAddr, $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(sv_width, 1), pagesize_bits), ac, effPriv, mxr, do_sum, init_ext_ptw);
        $[complete] match res {
          Ok((ppn, ext_ptw)) => {
              let paddr = $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(ppn, $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits($[overloaded { "name" = "bits_of", "is_infix" = false }] bits_of_virtaddr(vAddr), $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(pagesize_bits, 1), 0));
              Ok((Physaddr(zero_extend(if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(sizeof(xlen), 32) then
                34
              else
                64, paddr)), ext_ptw))
          },
          Err((f, ext_ptw)) => Err((translationException(ac, f), ext_ptw))
        }
    }
}

val reset_vmem : unit -> unit

$[complete]
function reset_vmem () = reset_TLB()

let sys_misaligned_order_decreasing : bool = config memory.misaligned.order_decreasing

let sys_misaligned_byte_by_byte : bool = config memory.misaligned.byte_by_byte

let sys_misaligned_allowed_within_exp : range(0, 11) = config memory.misaligned.allowed_within_exp

val access_within : forall ('width : Int) ('n : Int) ('r : Int), ('r >= 0 & 'r <= 'width & 1 <= 'n & 'n <= 2 ^ 'r).
  (bitvector('width), int('n), int('r)) -> bool

$[complete]
function access_within (addr, bytes, region_width_exp) = {
    let mask : bits('width) = $[overloaded { "name" = "~", "is_infix" = false }] not_vec(zero_extend($[overloaded { "name" = "__size", "is_infix" = false }] bitvector_length(addr), ones(region_width_exp)));
    $[overloaded { "name" = "==", "is_infix" = true }] eq_bits($[overloaded { "name" = "&", "is_infix" = true }] and_vec(addr, mask), $[overloaded { "name" = "&", "is_infix" = true }] and_vec($[overloaded { "name" = "+", "is_infix" = true }] add_bits_int(addr, $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(bytes, 1)), mask))
}

$[property]
val prop_access_within_is_aligned : (bitvector(32), bitvector(4)) -> bool

$[complete]
$[property]
function prop_access_within_is_aligned (addr : bits(32), region_width_exp : bits(4)) = {
    let region_width_exp = unsigned(region_width_exp);
    let bytes = 2 ^ region_width_exp;
    $[overloaded { "name" = "==", "is_infix" = true }] eq_bool(access_within(addr, bytes, region_width_exp), $[overloaded { "name" = "==", "is_infix" = true }] eq_int($[overloaded { "name" = "%", "is_infix" = true }] rem_positive_round_zero(unsigned(addr), bytes), 0))
}

$[property]
val prop_access_within_single : bitvector(32) -> bool

$[complete]
$[property]
function prop_access_within_single addr : bits(32) = {
    access_within(addr, 1, 0)
}

val allowed_misaligned : forall ('width : Int), 'width > 0.
  (bitvector(xlen), int('width)) -> bool

$[complete]
function allowed_misaligned (vaddr, width) = {
    let region_width_exp = sys_misaligned_allowed_within_exp;
    let region_width = 2 ^ region_width_exp;
    if $[overloaded { "name" = ">", "is_infix" = true }] gt_int(width, region_width) then return(false);
    access_within(vaddr, width, region_width_exp)
}

val split_misaligned : forall ('width : Int), 'width > 0.
  (virtaddr, int('width)) -> {('n : Int) ('bytes : Int), ('width == 'n * 'bytes & 'bytes > 0). (int('n), int('bytes))}

$[complete]
function split_misaligned (vaddr, width) = {
    let vaddr_bits = $[overloaded { "name" = "bits_of", "is_infix" = false }] bits_of_virtaddr(vaddr);
    if $[overloaded { "name" = "|", "is_infix" = true }] or_bool($[overloaded { "name" = "is_aligned_addr", "is_infix" = false }] is_aligned_vaddr(vaddr, width), allowed_misaligned(vaddr_bits, width)) then
      (1, width)
    else
      if sys_misaligned_byte_by_byte then (width, 1) else {
          let bytes_per_access = 2 ^ count_trailing_zeros(vaddr_bits);
          let num_accesses = $[overloaded { "name" = "/", "is_infix" = true }] quot_positive_round_zero(width, bytes_per_access);
          assert($[overloaded { "name" = "==", "is_infix" = true }] eq_int(width, $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(num_accesses, bytes_per_access)), "./sys/vmem_utils.sail:89.51-89.52");
          (num_accesses, bytes_per_access)
      }
}

type valid_misaligned_order('n: Int, 'first: Int, 'last: Int, 'step: Int) -> Bool =
  ('first == 0 & 'last == 'n - 1 & 'step == 1 | 'first == 'n - 1 & 'last == 0 & 'step == -1)

val misaligned_order : forall ('n : Int).
  int('n) -> {('first : Int) ('last : Int) ('step : Int), ('first == 0 & 'last == 'n - 1 & 'step == 1 | 'first == 'n - 1 & 'last == 0 & 'step == -1). (int('first), int('last), int('step))}

$[complete]
function misaligned_order n = {
    if sys_misaligned_order_decreasing then {
        ($[overloaded { "name" = "-", "is_infix" = true }] sub_atom(n, 1), 0, -1)
    } else {
        (0, $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(n, 1), 1)
    }
}

val vmem_write_addr : forall ('width : Int), is_mem_width('width).
  (virtaddr, int('width), bitvector(8 * 'width), AccessType(unit), bool, bool, bool) -> result(bool, ExecutionResult)

$[complete]
function vmem_write_addr (vaddr, width, data, acc, aq, rl, res) = {
    let ('n, 'bytes) = split_misaligned(vaddr, width);
    let (first, last, step) = misaligned_order(n);
    var i : range(0, 'n - 1) = first;
    var finished : bool = false;
    var write_success : bool = true;
    let vaddr = $[overloaded { "name" = "bits_of", "is_infix" = false }] bits_of_virtaddr(vaddr);
    repeat {
        let offset = i;
        let vaddr = $[overloaded { "name" = "+", "is_infix" = true }] add_bits_int(vaddr, $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(offset, bytes));
        $[complete] match translateAddr(Virtaddr(vaddr), acc) {
          Err((e, _)) => return(Err(Memory_Exception((Virtaddr(vaddr), e)))),
          Ok((paddr, _)) => {
              if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(res, not(match_reservation($[overloaded { "name" = "bits_of", "is_infix" = false }] bits_of_physaddr(paddr)))) then {
                  write_success = false
              } else
                $[complete] match mem_write_ea(paddr, bytes, aq, rl, res) {
                  Err(e) => return(Err(Memory_Exception((Virtaddr(vaddr), e)))),
                  Ok(()) => {
                      let write_value = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(data, $[overloaded { "name" = "-", "is_infix" = true }] sub_atom($[overloaded { "name" = "*", "is_infix" = true }] mult_atom($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(8, $[overloaded { "name" = "+", "is_infix" = true }] add_atom(offset, 1)), bytes), 1), $[overloaded { "name" = "*", "is_infix" = true }] mult_atom($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(8, offset), bytes));
                      $[complete] match mem_write_value(paddr, bytes, write_value, aq, rl, res) {
                        Err(e) => return(Err(Memory_Exception((Virtaddr(vaddr), e)))),
                        Ok(s) => write_success = $[overloaded { "name" = "&", "is_infix" = true }] and_bool(write_success, s)
                      }
                  }
                }
          }
        };
        if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(offset, last) then {
            finished = true
        } else {
            i = $[overloaded { "name" = "+", "is_infix" = true }] add_atom(offset, step)
        }
    } until finished;
    Ok(write_success)
}

val check_misaligned : (virtaddr, {1, 2, 4, 8}) -> bool

$[complete]
function check_misaligned (vaddr : virtaddr, width : word_width) = {
    if plat_enable_misaligned_access then {
        false
    } else {
        not($[overloaded { "name" = "is_aligned_addr", "is_infix" = false }] is_aligned_vaddr(vaddr, width))
    }
}

val vmem_read : forall ('width : Int), is_mem_width('width).
  (regidx, bitvector(xlen), int('width), AccessType(unit), bool, bool, bool) -> result(bitvector(8 * 'width), ExecutionResult)

$[complete]
function vmem_read (rs, offset, width, acc, aq, rl, res) = {
    let vaddr : virtaddr = $[complete] match ext_data_get_addr(rs, offset, acc, width) {
      Ext_DataAddr_OK(vaddr) => vaddr,
      Ext_DataAddr_Error(e) => return(Err(Ext_DataAddr_Check_Failure(e)))
    };
    if res then {
        if not($[overloaded { "name" = "is_aligned_addr", "is_infix" = false }] is_aligned_vaddr(vaddr, width)) then return(Err(Memory_Exception((vaddr, E_Load_Addr_Align()))));
        ()
    } else {
        if check_misaligned(vaddr, width) then return(Err(Memory_Exception((vaddr, E_Load_Addr_Align()))));
        ()
    };
    let ('n, 'bytes) = split_misaligned(vaddr, width);
    var data = zeros($[overloaded { "name" = "*", "is_infix" = true }] mult_atom($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(8, n), bytes));
    let (first, last, step) = misaligned_order(n);
    var i : range(0, 'n - 1) = first;
    var finished : bool = false;
    let vaddr = $[overloaded { "name" = "bits_of", "is_infix" = false }] bits_of_virtaddr(vaddr);
    repeat {
        let offset = i;
        let vaddr = $[overloaded { "name" = "+", "is_infix" = true }] add_bits_int(vaddr, $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(offset, bytes));
        $[complete] match translateAddr(Virtaddr(vaddr), acc) {
          Err((e, _)) => return(Err(Memory_Exception((Virtaddr(vaddr), e)))),
          Ok((paddr, _)) => $[complete] match mem_read(acc, paddr, bytes, aq, rl, res) {
            Err(e) => return(Err(Memory_Exception((Virtaddr(vaddr), e)))),
            Ok(v) => {
                if res then {
                    load_reservation($[overloaded { "name" = "bits_of", "is_infix" = false }] bits_of_physaddr(paddr))
                };
                data[$[overloaded { "name" = "-", "is_infix" = true }] sub_atom($[overloaded { "name" = "*", "is_infix" = true }] mult_atom($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(8, $[overloaded { "name" = "+", "is_infix" = true }] add_atom(offset, 1)), bytes), 1) .. $[overloaded { "name" = "*", "is_infix" = true }] mult_atom($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(8, offset), bytes)] = v
            }
          }
        };
        if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(offset, last) then {
            finished = true
        } else {
            i = $[overloaded { "name" = "+", "is_infix" = true }] add_atom(offset, step)
        }
    } until finished;
    Ok(data)
}

val vmem_write : forall ('width : Int), is_mem_width('width).
  (regidx, bitvector(xlen), int('width), bitvector(8 * 'width), AccessType(unit), bool, bool, bool) -> result(bool, ExecutionResult)

$[complete]
function vmem_write (rs_addr, offset, width, data, acc, aq, rl, res) = {
    let vaddr : virtaddr = $[complete] match ext_data_get_addr(rs_addr, offset, acc, width) {
      Ext_DataAddr_OK(vaddr) => vaddr,
      Ext_DataAddr_Error(e) => return(Err(Ext_DataAddr_Check_Failure(e)))
    };
    if check_misaligned(vaddr, width) then return(Err(Memory_Exception((vaddr, E_SAMO_Addr_Align()))));
    vmem_write_addr(vaddr, width, data, acc, aq, rl, res)
}

union instruction = {
  ILLEGAL : word,
  C_ILLEGAL : half,
  ZICBOP : (cbop_zicbop, regidx, bits(12)),
  NTL : ntl_type,
  C_NTL : ntl_type,
  PAUSE : unit,
  UTYPE : (bits(20), regidx, uop),
  JAL : (bits(21), regidx),
  JALR : (bits(12), regidx, regidx),
  BTYPE : (bits(13), regidx, regidx, bop),
  ITYPE : (bits(12), regidx, regidx, iop),
  SHIFTIOP : (bits(6), regidx, regidx, sop),
  RTYPE : (regidx, regidx, regidx, rop),
  LOAD : (bits(12), regidx, regidx, bool, word_width),
  STORE : (bits(12), regidx, regidx, word_width),
  ADDIW : (bits(12), regidx, regidx),
  RTYPEW : (regidx, regidx, regidx, ropw),
  SHIFTIWOP : (bits(5), regidx, regidx, sopw),
  FENCE : (bits(4), bits(4)),
  FENCE_TSO : unit,
  ECALL : unit,
  MRET : unit,
  SRET : unit,
  EBREAK : unit,
  WFI : unit,
  SFENCE_VMA : (regidx, regidx),
  FENCE_RESERVED : (bits(4), bits(4), bits(4), regidx, regidx),
  FENCEI_RESERVED : (bits(12), regidx, regidx),
  AMO : (amoop, bool, bool, regidx, regidx, word_width_wide, regidx),
  LOADRES : (bool, bool, regidx, word_width, regidx),
  STORECON : (bool, bool, regidx, regidx, word_width, regidx),
  MUL : (regidx, regidx, regidx, mul_op),
  DIV : (regidx, regidx, regidx, bool),
  REM : (regidx, regidx, regidx, bool),
  MULW : (regidx, regidx, regidx),
  DIVW : (regidx, regidx, regidx, bool),
  REMW : (regidx, regidx, regidx, bool),
  SLLIUW : (bits(6), regidx, regidx),
  ZBA_RTYPEUW : (regidx, regidx, regidx, shamt_zba),
  ZBA_RTYPE : (regidx, regidx, regidx, shamt_zba),
  RORIW : (bits(5), regidx, regidx),
  RORI : (bits(6), regidx, regidx),
  ZBB_RTYPEW : (regidx, regidx, regidx, bropw_zbb),
  ZBB_RTYPE : (regidx, regidx, regidx, brop_zbb),
  ZBB_EXTOP : (regidx, regidx, extop_zbb),
  REV8 : (regidx, regidx),
  ORCB : (regidx, regidx),
  CPOP : (regidx, regidx),
  CPOPW : (regidx, regidx),
  CLZ : (regidx, regidx),
  CLZW : (regidx, regidx),
  CTZ : (regidx, regidx),
  CTZW : (regidx, regidx),
  CLMUL : (regidx, regidx, regidx),
  CLMULH : (regidx, regidx, regidx),
  CLMULR : (regidx, regidx, regidx),
  ZBS_IOP : (bits(6), regidx, regidx, biop_zbs),
  ZBS_RTYPE : (regidx, regidx, regidx, brop_zbs),
  C_NOP : bits(6),
  C_ADDI4SPN : (cregidx, bits(8)),
  C_LW : (bits(5), cregidx, cregidx),
  C_LD : (bits(5), cregidx, cregidx),
  C_SW : (bits(5), cregidx, cregidx),
  C_SD : (bits(5), cregidx, cregidx),
  C_ADDI : (bits(6), regidx),
  C_JAL : bits(11),
  C_ADDIW : (bits(6), regidx),
  C_LI : (bits(6), regidx),
  C_ADDI16SP : bits(6),
  C_LUI : (bits(6), regidx),
  C_SRLI : (bits(6), cregidx),
  C_SRAI : (bits(6), cregidx),
  C_ANDI : (bits(6), cregidx),
  C_SUB : (cregidx, cregidx),
  C_XOR : (cregidx, cregidx),
  C_OR : (cregidx, cregidx),
  C_AND : (cregidx, cregidx),
  C_SUBW : (cregidx, cregidx),
  C_ADDW : (cregidx, cregidx),
  C_J : bits(11),
  C_BEQZ : (bits(8), cregidx),
  C_BNEZ : (bits(8), cregidx),
  C_SLLI : (bits(6), regidx),
  C_LWSP : (bits(6), regidx),
  C_LDSP : (bits(6), regidx),
  C_SWSP : (bits(6), regidx),
  C_SDSP : (bits(6), regidx),
  C_JR : regidx,
  C_JALR : regidx,
  C_MV : (regidx, regidx),
  C_EBREAK : unit,
  C_ADD : (regidx, regidx),
  C_LBU : (bits(2), cregidx, cregidx),
  C_LHU : (bits(2), cregidx, cregidx),
  C_LH : (bits(2), cregidx, cregidx),
  C_SB : (bits(2), cregidx, cregidx),
  C_SH : (bits(2), cregidx, cregidx),
  C_ZEXT_B : cregidx,
  C_SEXT_B : cregidx,
  C_ZEXT_H : cregidx,
  C_SEXT_H : cregidx,
  C_ZEXT_W : cregidx,
  C_NOT : cregidx,
  C_MUL : (cregidx, cregidx),
  LOAD_FP : (bits(12), regidx, fregidx, word_width),
  STORE_FP : (bits(12), fregidx, regidx, word_width),
  F_MADD_TYPE_S : (fregidx, fregidx, fregidx, rounding_mode, fregidx, f_madd_op_S),
  F_BIN_RM_TYPE_S : (fregidx, fregidx, rounding_mode, fregidx, f_bin_rm_op_S),
  F_UN_RM_FF_TYPE_S : (fregidx, rounding_mode, fregidx, f_un_rm_ff_op_S),
  F_UN_RM_FX_TYPE_S : (fregidx, rounding_mode, regidx, f_un_rm_fx_op_S),
  F_UN_RM_XF_TYPE_S : (regidx, rounding_mode, fregidx, f_un_rm_xf_op_S),
  F_BIN_TYPE_F_S : (fregidx, fregidx, fregidx, f_bin_op_f_S),
  F_BIN_TYPE_X_S : (fregidx, fregidx, regidx, f_bin_op_x_S),
  F_UN_TYPE_F_S : (regidx, fregidx, f_un_op_f_S),
  F_UN_TYPE_X_S : (fregidx, regidx, f_un_op_x_S),
  C_FLWSP : (bits(6), fregidx),
  C_FSWSP : (bits(6), fregidx),
  C_FLW : (bits(5), cregidx, cfregidx),
  C_FSW : (bits(5), cregidx, cfregidx),
  F_MADD_TYPE_D : (fregidx, fregidx, fregidx, rounding_mode, fregidx, f_madd_op_D),
  F_BIN_RM_TYPE_D : (fregidx, fregidx, rounding_mode, fregidx, f_bin_rm_op_D),
  F_UN_RM_FF_TYPE_D : (fregidx, rounding_mode, fregidx, f_un_rm_ff_op_D),
  F_UN_RM_XF_TYPE_D : (regidx, rounding_mode, fregidx, f_un_rm_xf_op_D),
  F_UN_RM_FX_TYPE_D : (fregidx, rounding_mode, regidx, f_un_rm_fx_op_D),
  F_BIN_F_TYPE_D : (fregidx, fregidx, fregidx, f_bin_f_op_D),
  F_BIN_X_TYPE_D : (fregidx, fregidx, regidx, f_bin_x_op_D),
  F_UN_X_TYPE_D : (fregidx, regidx, f_un_x_op_D),
  F_UN_F_TYPE_D : (regidx, fregidx, f_un_f_op_D),
  C_FLDSP : (bits(6), fregidx),
  C_FSDSP : (bits(6), fregidx),
  C_FLD : (bits(5), cregidx, cfregidx),
  C_FSD : (bits(5), cregidx, cfregidx),
  F_BIN_RM_TYPE_H : (fregidx, fregidx, rounding_mode, fregidx, f_bin_rm_op_H),
  F_MADD_TYPE_H : (fregidx, fregidx, fregidx, rounding_mode, fregidx, f_madd_op_H),
  F_BIN_F_TYPE_H : (fregidx, fregidx, fregidx, f_bin_f_op_H),
  F_BIN_X_TYPE_H : (fregidx, fregidx, regidx, f_bin_x_op_H),
  F_UN_RM_FF_TYPE_H : (fregidx, rounding_mode, fregidx, f_un_rm_ff_op_H),
  F_UN_RM_FX_TYPE_H : (fregidx, rounding_mode, regidx, f_un_rm_fx_op_H),
  F_UN_RM_XF_TYPE_H : (regidx, rounding_mode, fregidx, f_un_rm_xf_op_H),
  F_UN_F_TYPE_H : (regidx, fregidx, f_un_f_op_H),
  F_UN_X_TYPE_H : (fregidx, regidx, f_un_x_op_H),
  FLI_H : (bits(5), fregidx),
  FLI_S : (bits(5), fregidx),
  FLI_D : (bits(5), fregidx),
  FMINM_H : (fregidx, fregidx, fregidx),
  FMAXM_H : (fregidx, fregidx, fregidx),
  FMINM_S : (fregidx, fregidx, fregidx),
  FMAXM_S : (fregidx, fregidx, fregidx),
  FMINM_D : (fregidx, fregidx, fregidx),
  FMAXM_D : (fregidx, fregidx, fregidx),
  FROUND_H : (fregidx, rounding_mode, fregidx),
  FROUNDNX_H : (fregidx, rounding_mode, fregidx),
  FROUND_S : (fregidx, rounding_mode, fregidx),
  FROUNDNX_S : (fregidx, rounding_mode, fregidx),
  FROUND_D : (fregidx, rounding_mode, fregidx),
  FROUNDNX_D : (fregidx, rounding_mode, fregidx),
  FMVH_X_D : (fregidx, regidx),
  FMVP_D_X : (regidx, regidx, fregidx),
  FLEQ_H : (fregidx, fregidx, regidx),
  FLTQ_H : (fregidx, fregidx, regidx),
  FLEQ_S : (fregidx, fregidx, regidx),
  FLTQ_S : (fregidx, fregidx, regidx),
  FLEQ_D : (fregidx, fregidx, regidx),
  FLTQ_D : (fregidx, fregidx, regidx),
  FCVTMOD_W_D : (fregidx, regidx),
  VSETVLI : (bits(1), bits(1), bits(3), bits(3), regidx, regidx),
  VSETVL : (regidx, regidx, regidx),
  VSETIVLI : (bits(1), bits(1), bits(3), bits(3), bits(5), regidx),
  VVTYPE : (vvfunct6, bits(1), vregidx, vregidx, vregidx),
  NVSTYPE : (nvsfunct6, bits(1), vregidx, vregidx, vregidx),
  NVTYPE : (nvfunct6, bits(1), vregidx, vregidx, vregidx),
  MASKTYPEV : (vregidx, vregidx, vregidx),
  MOVETYPEV : (vregidx, vregidx),
  VXTYPE : (vxfunct6, bits(1), vregidx, regidx, vregidx),
  NXSTYPE : (nxsfunct6, bits(1), vregidx, regidx, vregidx),
  NXTYPE : (nxfunct6, bits(1), vregidx, regidx, vregidx),
  VXSG : (vxsgfunct6, bits(1), vregidx, regidx, vregidx),
  MASKTYPEX : (vregidx, regidx, vregidx),
  MOVETYPEX : (regidx, vregidx),
  VITYPE : (vifunct6, bits(1), vregidx, bits(5), vregidx),
  NISTYPE : (nisfunct6, bits(1), vregidx, bits(5), vregidx),
  NITYPE : (nifunct6, bits(1), vregidx, bits(5), vregidx),
  VISG : (visgfunct6, bits(1), vregidx, bits(5), vregidx),
  MASKTYPEI : (vregidx, bits(5), vregidx),
  MOVETYPEI : (vregidx, bits(5)),
  VMVRTYPE : (vregidx, {1, 2, 4, 8}, vregidx),
  MVVTYPE : (mvvfunct6, bits(1), vregidx, vregidx, vregidx),
  MVVMATYPE : (mvvmafunct6, bits(1), vregidx, vregidx, vregidx),
  WVVTYPE : (wvvfunct6, bits(1), vregidx, vregidx, vregidx),
  WVTYPE : (wvfunct6, bits(1), vregidx, vregidx, vregidx),
  WMVVTYPE : (wmvvfunct6, bits(1), vregidx, vregidx, vregidx),
  VEXTTYPE : (vextfunct6, bits(1), vregidx, vregidx),
  VMVXS : (vregidx, regidx),
  MVVCOMPRESS : (vregidx, vregidx, vregidx),
  MVXTYPE : (mvxfunct6, bits(1), vregidx, regidx, vregidx),
  MVXMATYPE : (mvxmafunct6, bits(1), vregidx, regidx, vregidx),
  WVXTYPE : (wvxfunct6, bits(1), vregidx, regidx, vregidx),
  WXTYPE : (wxfunct6, bits(1), vregidx, regidx, vregidx),
  WMVXTYPE : (wmvxfunct6, bits(1), vregidx, regidx, vregidx),
  VMVSX : (regidx, vregidx),
  FVVTYPE : (fvvfunct6, bits(1), vregidx, vregidx, vregidx),
  FVVMATYPE : (fvvmafunct6, bits(1), vregidx, vregidx, vregidx),
  FWVVTYPE : (fwvvfunct6, bits(1), vregidx, vregidx, vregidx),
  FWVVMATYPE : (fwvvmafunct6, bits(1), vregidx, vregidx, vregidx),
  FWVTYPE : (fwvfunct6, bits(1), vregidx, vregidx, vregidx),
  VFUNARY0 : (bits(1), vregidx, vfunary0, vregidx),
  VFWUNARY0 : (bits(1), vregidx, vfwunary0, vregidx),
  VFNUNARY0 : (bits(1), vregidx, vfnunary0, vregidx),
  VFUNARY1 : (bits(1), vregidx, vfunary1, vregidx),
  VFMVFS : (vregidx, fregidx),
  FVFTYPE : (fvffunct6, bits(1), vregidx, fregidx, vregidx),
  FVFMATYPE : (fvfmafunct6, bits(1), vregidx, fregidx, vregidx),
  FWVFTYPE : (fwvffunct6, bits(1), vregidx, fregidx, vregidx),
  FWVFMATYPE : (fwvfmafunct6, bits(1), fregidx, vregidx, vregidx),
  FWFTYPE : (fwffunct6, bits(1), vregidx, fregidx, vregidx),
  VFMERGE : (vregidx, fregidx, vregidx),
  VFMV : (fregidx, vregidx),
  VFMVSF : (fregidx, vregidx),
  VLSEGTYPE : (nfields, bits(1), regidx, vlewidth, vregidx),
  VLSEGFFTYPE : (nfields, bits(1), regidx, vlewidth, vregidx),
  VSSEGTYPE : (nfields, bits(1), regidx, vlewidth, vregidx),
  VLSSEGTYPE : (nfields, bits(1), regidx, regidx, vlewidth, vregidx),
  VSSSEGTYPE : (nfields, bits(1), regidx, regidx, vlewidth, vregidx),
  VLUXSEGTYPE : (nfields, bits(1), vregidx, regidx, vlewidth, vregidx),
  VLOXSEGTYPE : (nfields, bits(1), vregidx, regidx, vlewidth, vregidx),
  VSUXSEGTYPE : (nfields, bits(1), vregidx, regidx, vlewidth, vregidx),
  VSOXSEGTYPE : (nfields, bits(1), vregidx, regidx, vlewidth, vregidx),
  VLRETYPE : (nfields_pow2, regidx, vlewidth, vregidx),
  VSRETYPE : (nfields_pow2, regidx, vregidx),
  VMTYPE : (regidx, vregidx, vmlsop),
  MMTYPE : (mmfunct6, vregidx, vregidx, vregidx),
  VCPOP_M : (bits(1), vregidx, regidx),
  VFIRST_M : (bits(1), vregidx, regidx),
  VMSBF_M : (bits(1), vregidx, vregidx),
  VMSIF_M : (bits(1), vregidx, vregidx),
  VMSOF_M : (bits(1), vregidx, vregidx),
  VIOTA_M : (bits(1), vregidx, vregidx),
  VID_V : (bits(1), vregidx),
  VVMTYPE : (vvmfunct6, vregidx, vregidx, vregidx),
  VVMCTYPE : (vvmcfunct6, vregidx, vregidx, vregidx),
  VVMSTYPE : (vvmsfunct6, vregidx, vregidx, vregidx),
  VVCMPTYPE : (vvcmpfunct6, bits(1), vregidx, vregidx, vregidx),
  VXMTYPE : (vxmfunct6, vregidx, regidx, vregidx),
  VXMCTYPE : (vxmcfunct6, vregidx, regidx, vregidx),
  VXMSTYPE : (vxmsfunct6, vregidx, regidx, vregidx),
  VXCMPTYPE : (vxcmpfunct6, bits(1), vregidx, regidx, vregidx),
  VIMTYPE : (vimfunct6, vregidx, bits(5), vregidx),
  VIMCTYPE : (vimcfunct6, vregidx, bits(5), vregidx),
  VIMSTYPE : (vimsfunct6, vregidx, bits(5), vregidx),
  VICMPTYPE : (vicmpfunct6, bits(1), vregidx, bits(5), vregidx),
  FVVMTYPE : (fvvmfunct6, bits(1), vregidx, vregidx, vregidx),
  FVFMTYPE : (fvfmfunct6, bits(1), vregidx, fregidx, vregidx),
  RIVVTYPE : (rivvfunct6, bits(1), vregidx, vregidx, vregidx),
  RMVVTYPE : (rmvvfunct6, bits(1), vregidx, vregidx, vregidx),
  RFVVTYPE : (rfvvfunct6, bits(1), vregidx, vregidx, vregidx),
  SHA256SIG0 : (regidx, regidx),
  SHA256SIG1 : (regidx, regidx),
  SHA256SUM0 : (regidx, regidx),
  SHA256SUM1 : (regidx, regidx),
  AES32ESMI : (bits(2), regidx, regidx, regidx),
  AES32ESI : (bits(2), regidx, regidx, regidx),
  AES32DSMI : (bits(2), regidx, regidx, regidx),
  AES32DSI : (bits(2), regidx, regidx, regidx),
  SHA512SIG0L : (regidx, regidx, regidx),
  SHA512SIG0H : (regidx, regidx, regidx),
  SHA512SIG1L : (regidx, regidx, regidx),
  SHA512SIG1H : (regidx, regidx, regidx),
  SHA512SUM0R : (regidx, regidx, regidx),
  SHA512SUM1R : (regidx, regidx, regidx),
  AES64KS1I : (bits(4), regidx, regidx),
  AES64KS2 : (regidx, regidx, regidx),
  AES64IM : (regidx, regidx),
  AES64ESM : (regidx, regidx, regidx),
  AES64ES : (regidx, regidx, regidx),
  AES64DSM : (regidx, regidx, regidx),
  AES64DS : (regidx, regidx, regidx),
  SHA512SIG0 : (regidx, regidx),
  SHA512SIG1 : (regidx, regidx),
  SHA512SUM0 : (regidx, regidx),
  SHA512SUM1 : (regidx, regidx),
  SM3P0 : (regidx, regidx),
  SM3P1 : (regidx, regidx),
  SM4ED : (bits(2), regidx, regidx, regidx),
  SM4KS : (bits(2), regidx, regidx, regidx),
  ZBKB_RTYPE : (regidx, regidx, regidx, brop_zbkb),
  ZBKB_PACKW : (regidx, regidx, regidx),
  ZIP : (regidx, regidx),
  UNZIP : (regidx, regidx),
  BREV8 : (regidx, regidx),
  XPERM8 : (regidx, regidx, regidx),
  XPERM4 : (regidx, regidx, regidx),
  VANDN_VV : (bits(1), vregidx, vregidx, vregidx),
  VANDN_VX : (bits(1), vregidx, regidx, vregidx),
  VBREV_V : (bits(1), vregidx, vregidx),
  VBREV8_V : (bits(1), vregidx, vregidx),
  VREV8_V : (bits(1), vregidx, vregidx),
  VCLZ_V : (bits(1), vregidx, vregidx),
  VCTZ_V : (bits(1), vregidx, vregidx),
  VCPOP_V : (bits(1), vregidx, vregidx),
  VROL_VV : (bits(1), vregidx, vregidx, vregidx),
  VROL_VX : (bits(1), vregidx, regidx, vregidx),
  VROR_VV : (bits(1), vregidx, vregidx, vregidx),
  VROR_VX : (bits(1), vregidx, regidx, vregidx),
  VROR_VI : (bits(1), vregidx, bits(6), vregidx),
  VWSLL_VV : (bits(1), vregidx, vregidx, vregidx),
  VWSLL_VX : (bits(1), vregidx, regidx, vregidx),
  VWSLL_VI : (bits(1), vregidx, bits(5), vregidx),
  VCLMUL_VV : (bits(1), vregidx, vregidx, vregidx),
  VCLMUL_VX : (bits(1), vregidx, regidx, vregidx),
  VCLMULH_VV : (bits(1), vregidx, vregidx, vregidx),
  VCLMULH_VX : (bits(1), vregidx, regidx, vregidx),
  VGHSH_VV : (vregidx, vregidx, vregidx),
  VGMUL_VV : (vregidx, vregidx),
  VAESDF : (zvk_vaesdf_funct6, vregidx, vregidx),
  VAESDM : (zvk_vaesdm_funct6, vregidx, vregidx),
  VAESEF : (zvk_vaesef_funct6, vregidx, vregidx),
  VAESEM : (zvk_vaesem_funct6, vregidx, vregidx),
  VAESKF1_VI : (vregidx, bits(5), vregidx),
  VAESKF2_VI : (vregidx, bits(5), vregidx),
  VAESZ_VS : (vregidx, vregidx),
  VSM4K_VI : (vregidx, bits(5), vregidx),
  ZVKSM4RTYPE : (zvk_vsm4r_funct6, vregidx, vregidx),
  VSHA2MS_VV : (vregidx, vregidx, vregidx),
  ZVKSHA2TYPE : (zvk_vsha2_funct6, vregidx, vregidx, vregidx),
  VSM3ME_VV : (vregidx, vregidx, vregidx),
  VSM3C_VI : (vregidx, bits(5), vregidx),
  CSRReg : (csreg, regidx, regidx, csrop),
  CSRImm : (csreg, bits(5), regidx, csrop),
  SINVAL_VMA : (regidx, regidx),
  SFENCE_W_INVAL : unit,
  SFENCE_INVAL_IR : unit,
  WRS : wrsop,
  ZICOND_RTYPE : (regidx, regidx, regidx, zicondop),
  ZICBOM : (cbop_zicbom, regidx),
  ZICBOZ : regidx,
  FENCEI : unit,
  FCVT_BF16_S : (fregidx, rounding_mode, fregidx),
  FCVT_S_BF16 : (fregidx, rounding_mode, fregidx),
  ZIMOP_MOP_R : (bits(5), regidx, regidx),
  ZIMOP_MOP_RR : (bits(3), regidx, regidx, regidx),
  ZCMOP : bits(3)
}

val execute : instruction -> ExecutionResult

val assembly : instruction <-> string

val encdec : instruction <-> bitvector(32)

val encdec_compressed : instruction <-> bitvector(16)

val encdec_cbop_zicbop : cbop_zicbop <-> bitvector(5)

mapping encdec_cbop_zicbop = {
  PREFETCH_I <-> 0b00000,
  PREFETCH_R <-> 0b00001,
  PREFETCH_W <-> 0b00011
}

val prefetch_mnemonic : cbop_zicbop <-> string

mapping prefetch_mnemonic = {
  PREFETCH_I <-> "prefetch.i",
  PREFETCH_R <-> "prefetch.r",
  PREFETCH_W <-> "prefetch.w"
}

val encdec_uop : uop <-> bitvector(7)

mapping encdec_uop = {
  LUI <-> 0b0110111,
  AUIPC <-> 0b0010111
}

val utype_mnemonic : uop <-> string

mapping utype_mnemonic = {
  LUI <-> "lui",
  AUIPC <-> "auipc"
}

val jump_to : bitvector(xlen) -> ExecutionResult

$[complete]
function jump_to target : xlenbits = {
    $[complete] match ext_control_check_pc(target) {
      Some(e) => return(Ext_ControlAddr_Check_Failure(e)),
      None(()) => ()
    };
    assert($[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(target, 0), bitzero), "./extensions/I/base_insts.sail:59.29-59.30");
    if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(bit_to_bool($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(target, 1)), not(currentlyEnabled(Ext_Zca))) then return(Memory_Exception((Virtaddr(target), E_Fetch_Addr_Align())));
    set_next_pc(target);
    RETIRE_SUCCESS
}

val encdec_bop : bop <-> bitvector(3)

mapping encdec_bop = {
  BEQ <-> 0b000,
  BNE <-> 0b001,
  BLT <-> 0b100,
  BGE <-> 0b101,
  BLTU <-> 0b110,
  BGEU <-> 0b111
}

val btype_mnemonic : bop <-> string

mapping btype_mnemonic = {
  BEQ <-> "beq",
  BNE <-> "bne",
  BLT <-> "blt",
  BGE <-> "bge",
  BLTU <-> "bltu",
  BGEU <-> "bgeu"
}

val encdec_iop : iop <-> bitvector(3)

mapping encdec_iop = {
  ADDI <-> 0b000,
  SLTI <-> 0b010,
  SLTIU <-> 0b011,
  ANDI <-> 0b111,
  ORI <-> 0b110,
  XORI <-> 0b100
}

val itype_mnemonic : iop <-> string

mapping itype_mnemonic = {
  ADDI <-> "addi",
  SLTI <-> "slti",
  SLTIU <-> "sltiu",
  XORI <-> "xori",
  ORI <-> "ori",
  ANDI <-> "andi"
}

val encdec_sop : sop <-> bitvector(3)

mapping encdec_sop = {
  SLLI <-> 0b001,
  SRLI <-> 0b101,
  SRAI <-> 0b101
}

val shiftiop_mnemonic : sop <-> string

mapping shiftiop_mnemonic = {
  SLLI <-> "slli",
  SRLI <-> "srli",
  SRAI <-> "srai"
}

val rtype_mnemonic : rop <-> string

mapping rtype_mnemonic = {
  ADD <-> "add",
  SLT <-> "slt",
  SLTU <-> "sltu",
  AND <-> "and",
  OR <-> "or",
  XOR <-> "xor",
  SLL <-> "sll",
  SRL <-> "srl",
  SUB <-> "sub",
  SRA <-> "sra"
}

val valid_load_encdec : ({1, 2, 4, 8}, bool) -> bool

$[complete]
function valid_load_encdec (width : word_width, is_unsigned : bool) = $[overloaded { "name" = "|", "is_infix" = true }] or_bool($[overloaded { "name" = "<", "is_infix" = true }] lt_int(width, xlen_bytes), $[overloaded { "name" = "&", "is_infix" = true }] and_bool(not(is_unsigned), $[overloaded { "name" = "<=", "is_infix" = true }] lteq_int(width, xlen_bytes)))

val extend_value : forall ('n : Int), (0 < 'n & 'n <= xlen).
  (bool, bitvector('n)) -> bitvector(xlen)

$[complete]
function extend_value (is_unsigned, value) = if is_unsigned then
  zero_extend(sizeof(xlen), value)
else
  sign_extend(sizeof(xlen), value)

val maybe_u : bool <-> string

mapping maybe_u = {
  true <-> "u",
  false <-> ""
}

val rtypew_mnemonic : ropw <-> string

mapping rtypew_mnemonic = {
  ADDW <-> "addw",
  SUBW <-> "subw",
  SLLW <-> "sllw",
  SRLW <-> "srlw",
  SRAW <-> "sraw"
}

val shiftiwop_mnemonic : sopw <-> string

mapping shiftiwop_mnemonic = {
  SLLIW <-> "slliw",
  SRLIW <-> "srliw",
  SRAIW <-> "sraiw"
}

val effective_fence_set : (bitvector(4), bool) -> bitvector(4)

$[complete]
function effective_fence_set (set : bits(4), fiom : bool) = {
    if fiom then {
        $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(set, 3, 2), $[overloaded { "name" = "|", "is_infix" = true }] or_vec($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(set, 1, 0), $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(set, 3, 2)))
    } else set
}

val bit_maybe_r : bitvector(1) <-> string

mapping bit_maybe_r = {
  0b1 <-> "r",
  0b0 <-> ""
}

val bit_maybe_w : bitvector(1) <-> string

mapping bit_maybe_w = {
  0b1 <-> "w",
  0b0 <-> ""
}

val bit_maybe_i : bitvector(1) <-> string

mapping bit_maybe_i = {
  0b1 <-> "i",
  0b0 <-> ""
}

val bit_maybe_o : bitvector(1) <-> string

mapping bit_maybe_o = {
  0b1 <-> "o",
  0b0 <-> ""
}

val fence_bits : bitvector(4) <-> string

mapping fence_bits = {
  0b0000 <-> "0",
  (i : bits(1)) @ (o : bits(1)) @ (r : bits(1)) @ (w : bits(1)) <-> bit_maybe_i(i) ^ bit_maybe_o(o) ^ bit_maybe_r(r) ^ bit_maybe_w(w)
}

val amo_encoding_valid : ({1, 2, 4, 8, 16}, amoop, regidx, regidx) -> bool

$[complete]
function amo_encoding_valid (width : word_width_wide, op : amoop, Regidx(rs2) : regidx, Regidx(rd) : regidx) = $[overloaded { "name" = "&", "is_infix" = true }] and_bool(if $[overloaded { "name" = "==", "is_infix" = true }] eq_anything(op, AMOCAS) then
  currentlyEnabled(Ext_Zacas)
else
  currentlyEnabled(Ext_Zaamo), if $[overloaded { "name" = "<", "is_infix" = true }] lt_int(width, 4) then
  currentlyEnabled(Ext_Zabha)
else
  $[overloaded { "name" = "|", "is_infix" = true }] or_bool($[overloaded { "name" = "<=", "is_infix" = true }] lteq_int(width, xlen_bytes), $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_anything(op, AMOCAS), $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "<=", "is_infix" = true }] lteq_int(width, $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(xlen_bytes, 2)), $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(rs2, 0), bitzero), $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(rd, 0), bitzero))))))

val encdec_amoop : amoop <-> bitvector(5)

mapping encdec_amoop = {
  AMOSWAP <-> 0b00001,
  AMOADD <-> 0b00000,
  AMOXOR <-> 0b00100,
  AMOAND <-> 0b01100,
  AMOOR <-> 0b01000,
  AMOMIN <-> 0b10000,
  AMOMAX <-> 0b10100,
  AMOMINU <-> 0b11000,
  AMOMAXU <-> 0b11100,
  AMOCAS <-> 0b00101
}

val amo_mnemonic : amoop <-> string

mapping amo_mnemonic = {
  AMOSWAP <-> "amoswap",
  AMOADD <-> "amoadd",
  AMOXOR <-> "amoxor",
  AMOAND <-> "amoand",
  AMOOR <-> "amoor",
  AMOMIN <-> "amomin",
  AMOMAX <-> "amomax",
  AMOMINU <-> "amominu",
  AMOMAXU <-> "amomaxu",
  AMOCAS <-> "amocas"
}

val lrsc_width_valid : {1, 2, 4, 8} -> bool

$[complete]
function lrsc_width_valid width : word_width = {
    $[complete] match width {
      4 => true,
      8 => $[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(xlen, 64),
      _ => false
    }
}

val encdec_mul_op : mul_op <-> bitvector(3)

mapping encdec_mul_op = {
  struct mul_op { high = false, signed_rs1 = true, signed_rs2 = true } <-> 0b000,
  struct mul_op { high = true, signed_rs1 = true, signed_rs2 = true } <-> 0b001,
  struct mul_op { high = true, signed_rs1 = true, signed_rs2 = false } <-> 0b010,
  struct mul_op { high = true, signed_rs1 = false, signed_rs2 = false } <-> 0b011
}

val mul_mnemonic : mul_op <-> string

mapping mul_mnemonic = {
  struct mul_op { high = false, signed_rs1 = true, signed_rs2 = true } <-> "mul",
  struct mul_op { high = true, signed_rs1 = true, signed_rs2 = true } <-> "mulh",
  struct mul_op { high = true, signed_rs1 = true, signed_rs2 = false } <-> "mulhsu",
  struct mul_op { high = true, signed_rs1 = false, signed_rs2 = false } <-> "mulhu"
}

val zba_rtypeuw_mnemonic : bitvector(2) <-> string

mapping zba_rtypeuw_mnemonic = {
  0b00 <-> "add.uw",
  0b01 <-> "sh1add.uw",
  0b10 <-> "sh2add.uw",
  0b11 <-> "sh3add.uw"
}

val zba_rtype_mnemonic : bitvector(2) <-> string

mapping zba_rtype_mnemonic = {
  0b01 <-> "sh1add",
  0b10 <-> "sh2add",
  0b11 <-> "sh3add"
}

val zbb_rtypew_mnemonic : bropw_zbb <-> string

mapping zbb_rtypew_mnemonic = {
  ROLW <-> "rolw",
  RORW <-> "rorw"
}

val zbb_rtype_mnemonic : brop_zbb <-> string

mapping zbb_rtype_mnemonic = {
  ANDN <-> "andn",
  ORN <-> "orn",
  XNOR <-> "xnor",
  MAX <-> "max",
  MAXU <-> "maxu",
  MIN <-> "min",
  MINU <-> "minu",
  ROL <-> "rol",
  ROR <-> "ror"
}

val zbb_extop_mnemonic : extop_zbb <-> string

mapping zbb_extop_mnemonic = {
  SEXTB <-> "sext.b",
  SEXTH <-> "sext.h",
  ZEXTH <-> "zext.h"
}

val zbs_iop_mnemonic : biop_zbs <-> string

mapping zbs_iop_mnemonic = {
  BCLRI <-> "bclri",
  BEXTI <-> "bexti",
  BINVI <-> "binvi",
  BSETI <-> "bseti"
}

val zbs_rtype_mnemonic : brop_zbs <-> string

mapping zbs_rtype_mnemonic = {
  BCLR <-> "bclr",
  BEXT <-> "bext",
  BINV <-> "binv",
  BSET <-> "bset"
}

val encdec_rounding_mode : rounding_mode <-> bitvector(3)

mapping encdec_rounding_mode = {
  RM_RNE <-> 0b000,
  RM_RTZ <-> 0b001,
  RM_RDN <-> 0b010,
  RM_RUP <-> 0b011,
  RM_RMM <-> 0b100,
  RM_DYN <-> 0b111
}

val frm_mnemonic : rounding_mode <-> string

mapping frm_mnemonic = {
  RM_RNE <-> "rne",
  RM_RTZ <-> "rtz",
  RM_RDN <-> "rdn",
  RM_RUP <-> "rup",
  RM_RMM <-> "rmm",
  RM_DYN <-> "dyn"
}

val valid_rounding_mode : bitvector(3) -> bool

$[complete]
function valid_rounding_mode rm = $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "!=", "is_infix" = true }] neq_bits(rm, 0b101), $[overloaded { "name" = "!=", "is_infix" = true }] neq_bits(rm, 0b110))

val select_instr_or_fcsr_rm : rounding_mode -> option(rounding_mode)

$[complete]
function select_instr_or_fcsr_rm instr_rm = if $[overloaded { "name" = "==", "is_infix" = true }] eq_anything(instr_rm, RM_DYN) then {
    let fcsr_rm = _get_Fcsr_FRM(fcsr);
    if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(valid_rounding_mode(fcsr_rm), $[overloaded { "name" = "!=", "is_infix" = true }] neq_bits(fcsr_rm, encdec_rounding_mode_forwards(RM_DYN))) then
      Some(encdec_rounding_mode_backwards(fcsr_rm))
    else
      None()
} else Some(instr_rm)

val nxFlag : unit -> bitvector(5)

$[complete]
function nxFlag () = 0b00001

val ufFlag : unit -> bitvector(5)

$[complete]
function ufFlag () = 0b00010

val ofFlag : unit -> bitvector(5)

$[complete]
function ofFlag () = 0b00100

val dzFlag : unit -> bitvector(5)

$[complete]
function dzFlag () = 0b01000

val nvFlag : unit -> bitvector(5)

$[complete]
function nvFlag () = 0b10000

val fsplit_S : bitvector(32) -> (bitvector(1), bitvector(8), bitvector(23))

$[complete]
function fsplit_S x32 = ($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(x32, 31, 31), $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(x32, 30, 23), $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(x32, 22, 0))

val fmake_S : (bitvector(1), bitvector(8), bitvector(23)) -> bitvector(32)

$[complete]
function fmake_S (sign, exp, mant) = $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(sign, $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(exp, mant))

val f_is_neg_inf_S : bitvector(32) -> bool

$[complete]
function f_is_neg_inf_S x32 = {
    let (sign, exp, mant) = fsplit_S(x32);
    $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_bits(sign, 0b1), $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_bits(exp, ones(8)), $[overloaded { "name" = "==", "is_infix" = true }] eq_bits(mant, zeros(23))))
}

val f_is_neg_norm_S : bitvector(32) -> bool

$[complete]
function f_is_neg_norm_S x32 = {
    let (sign, exp, mant) = fsplit_S(x32);
    $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_bits(sign, 0b1), $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "!=", "is_infix" = true }] neq_bits(exp, zeros(8)), $[overloaded { "name" = "!=", "is_infix" = true }] neq_bits(exp, ones(8))))
}

val f_is_neg_subnorm_S : bitvector(32) -> bool

$[complete]
function f_is_neg_subnorm_S x32 = {
    let (sign, exp, mant) = fsplit_S(x32);
    $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_bits(sign, 0b1), $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_bits(exp, zeros(8)), $[overloaded { "name" = "!=", "is_infix" = true }] neq_bits(mant, zeros(23))))
}

val f_is_neg_zero_S : bitvector(32) -> bool

$[complete]
function f_is_neg_zero_S x32 = {
    let (sign, exp, mant) = fsplit_S(x32);
    $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_bits(sign, ones(1)), $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_bits(exp, zeros(8)), $[overloaded { "name" = "==", "is_infix" = true }] eq_bits(mant, zeros(23))))
}

val f_is_pos_zero_S : bitvector(32) -> bool

$[complete]
function f_is_pos_zero_S x32 = {
    let (sign, exp, mant) = fsplit_S(x32);
    $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_bits(sign, zeros(1)), $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_bits(exp, zeros(8)), $[overloaded { "name" = "==", "is_infix" = true }] eq_bits(mant, zeros(23))))
}

val f_is_pos_subnorm_S : bitvector(32) -> bool

$[complete]
function f_is_pos_subnorm_S x32 = {
    let (sign, exp, mant) = fsplit_S(x32);
    $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_bits(sign, zeros(1)), $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_bits(exp, zeros(8)), $[overloaded { "name" = "!=", "is_infix" = true }] neq_bits(mant, zeros(23))))
}

val f_is_pos_norm_S : bitvector(32) -> bool

$[complete]
function f_is_pos_norm_S x32 = {
    let (sign, exp, mant) = fsplit_S(x32);
    $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_bits(sign, zeros(1)), $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "!=", "is_infix" = true }] neq_bits(exp, zeros(8)), $[overloaded { "name" = "!=", "is_infix" = true }] neq_bits(exp, ones(8))))
}

val f_is_pos_inf_S : bitvector(32) -> bool

$[complete]
function f_is_pos_inf_S x32 = {
    let (sign, exp, mant) = fsplit_S(x32);
    $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_bits(sign, zeros(1)), $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_bits(exp, ones(8)), $[overloaded { "name" = "==", "is_infix" = true }] eq_bits(mant, zeros(23))))
}

val f_is_SNaN_S : bitvector(32) -> bool

$[complete]
function f_is_SNaN_S x32 = {
    let (sign, exp, mant) = fsplit_S(x32);
    $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_bits(exp, ones(8)), $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(mant, 22), bitzero), $[overloaded { "name" = "!=", "is_infix" = true }] neq_bits(mant, zeros(23))))
}

val f_is_QNaN_S : bitvector(32) -> bool

$[complete]
function f_is_QNaN_S x32 = {
    let (sign, exp, mant) = fsplit_S(x32);
    $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_bits(exp, ones(8)), $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(mant, 22), bitone))
}

val f_is_NaN_S : bitvector(32) -> bool

$[complete]
function f_is_NaN_S x32 = {
    let (sign, exp, mant) = fsplit_S(x32);
    $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_bits(exp, ones(8)), $[overloaded { "name" = "!=", "is_infix" = true }] neq_bits(mant, zeros(23)))
}

val negate_S : bitvector(32) -> bitvector(32)

$[complete]
function negate_S x32 = {
    let (sign, exp, mant) = fsplit_S(x32);
    let new_sign = if $[overloaded { "name" = "==", "is_infix" = true }] eq_bits(sign, 0b0) then
      0b1
    else
      0b0;
    fmake_S(new_sign, exp, mant)
}

val feq_quiet_S : (bitvector(32), bitvector(32)) -> (bool, bitvector(5))

$[complete]
function feq_quiet_S (v1, v2) = {
    let (s1, e1, m1) = fsplit_S(v1);
    let (s2, e2, m2) = fsplit_S(v2);
    let v1Is0 = $[overloaded { "name" = "|", "is_infix" = true }] or_bool(f_is_neg_zero_S(v1), f_is_pos_zero_S(v1));
    let v2Is0 = $[overloaded { "name" = "|", "is_infix" = true }] or_bool(f_is_neg_zero_S(v2), f_is_pos_zero_S(v2));
    let result = $[overloaded { "name" = "|", "is_infix" = true }] or_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_bits(v1, v2), $[overloaded { "name" = "&", "is_infix" = true }] and_bool(v1Is0, v2Is0));
    let fflags = if $[overloaded { "name" = "|", "is_infix" = true }] or_bool(f_is_SNaN_S(v1), f_is_SNaN_S(v2)) then
      nvFlag()
    else
      zeros(5);
    (result, fflags)
}

val flt_S : (bitvector(32), bitvector(32), bool) -> (bool, bitvector(5))

$[complete]
function flt_S (v1, v2, is_quiet) = {
    let (s1, e1, m1) = fsplit_S(v1);
    let (s2, e2, m2) = fsplit_S(v2);
    let result : bool = if $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_bits(s1, 0b0), $[overloaded { "name" = "==", "is_infix" = true }] eq_bits(s2, 0b0)) then
      if $[overloaded { "name" = "==", "is_infix" = true }] eq_bits(e1, e2) then
        $[overloaded { "name" = "<", "is_infix" = true }] lt_int(unsigned(m1), unsigned(m2))
      else
        $[overloaded { "name" = "<", "is_infix" = true }] lt_int(unsigned(e1), unsigned(e2))
    else if $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_bits(s1, 0b0), $[overloaded { "name" = "==", "is_infix" = true }] eq_bits(s2, 0b1)) then
      false
    else
      if $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_bits(s1, 0b1), $[overloaded { "name" = "==", "is_infix" = true }] eq_bits(s2, 0b0)) then
        true
      else
        if $[overloaded { "name" = "==", "is_infix" = true }] eq_bits(e1, e2) then
          $[overloaded { "name" = ">", "is_infix" = true }] gt_int(unsigned(m1), unsigned(m2))
        else
          $[overloaded { "name" = ">", "is_infix" = true }] gt_int(unsigned(e1), unsigned(e2));
    let fflags = if is_quiet then
      if $[overloaded { "name" = "|", "is_infix" = true }] or_bool(f_is_SNaN_S(v1), f_is_SNaN_S(v2)) then
        nvFlag()
      else
        zeros(5)
    else if $[overloaded { "name" = "|", "is_infix" = true }] or_bool(f_is_NaN_S(v1), f_is_NaN_S(v2)) then
      nvFlag()
    else
      zeros(5);
    (result, fflags)
}

val fle_S : (bitvector(32), bitvector(32), bool) -> (bool, bitvector(5))

$[complete]
function fle_S (v1, v2, is_quiet) = {
    let (s1, e1, m1) = fsplit_S(v1);
    let (s2, e2, m2) = fsplit_S(v2);
    let v1Is0 = $[overloaded { "name" = "|", "is_infix" = true }] or_bool(f_is_neg_zero_S(v1), f_is_pos_zero_S(v1));
    let v2Is0 = $[overloaded { "name" = "|", "is_infix" = true }] or_bool(f_is_neg_zero_S(v2), f_is_pos_zero_S(v2));
    let result : bool = if $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_bits(s1, 0b0), $[overloaded { "name" = "==", "is_infix" = true }] eq_bits(s2, 0b0)) then
      if $[overloaded { "name" = "==", "is_infix" = true }] eq_bits(e1, e2) then
        $[overloaded { "name" = "<=", "is_infix" = true }] lteq_int(unsigned(m1), unsigned(m2))
      else
        $[overloaded { "name" = "<", "is_infix" = true }] lt_int(unsigned(e1), unsigned(e2))
    else if $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_bits(s1, 0b0), $[overloaded { "name" = "==", "is_infix" = true }] eq_bits(s2, 0b1)) then
      $[overloaded { "name" = "&", "is_infix" = true }] and_bool(v1Is0, v2Is0)
    else
      if $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_bits(s1, 0b1), $[overloaded { "name" = "==", "is_infix" = true }] eq_bits(s2, 0b0)) then
        true
      else
        if $[overloaded { "name" = "==", "is_infix" = true }] eq_bits(e1, e2) then
          $[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(unsigned(m1), unsigned(m2))
        else
          $[overloaded { "name" = ">", "is_infix" = true }] gt_int(unsigned(e1), unsigned(e2));
    let fflags = if is_quiet then
      if $[overloaded { "name" = "|", "is_infix" = true }] or_bool(f_is_SNaN_S(v1), f_is_SNaN_S(v2)) then
        nvFlag()
      else
        zeros(5)
    else if $[overloaded { "name" = "|", "is_infix" = true }] or_bool(f_is_NaN_S(v1), f_is_NaN_S(v2)) then
      nvFlag()
    else
      zeros(5);
    (result, fflags)
}

val haveSingleFPU : unit -> bool

$[complete]
function haveSingleFPU () = $[overloaded { "name" = "|", "is_infix" = true }] or_bool(currentlyEnabled(Ext_F), currentlyEnabled(Ext_Zfinx))

val float_load_store_width_supported : {1, 2, 4, 8} -> bool

$[complete]
function float_load_store_width_supported width : word_width = $[complete] match width {
  1 => false,
  2 => $[overloaded { "name" = "|", "is_infix" = true }] or_bool(currentlyEnabled(Ext_Zfhmin), currentlyEnabled(Ext_Zfbfmin)),
  4 => currentlyEnabled(Ext_F),
  ($[int_wildcard 8] _) => currentlyEnabled(Ext_D)
}

val f_madd_type_mnemonic_S : f_madd_op_S <-> string

mapping f_madd_type_mnemonic_S = {
  FMADD_S <-> "fmadd.s",
  FMSUB_S <-> "fmsub.s",
  FNMSUB_S <-> "fnmsub.s",
  FNMADD_S <-> "fnmadd.s"
}

val f_bin_rm_type_mnemonic_S : f_bin_rm_op_S <-> string

mapping f_bin_rm_type_mnemonic_S = {
  FADD_S <-> "fadd.s",
  FSUB_S <-> "fsub.s",
  FMUL_S <-> "fmul.s",
  FDIV_S <-> "fdiv.s"
}

val f_un_rm_fx_type_mnemonic_S : f_un_rm_fx_op_S <-> string

mapping f_un_rm_fx_type_mnemonic_S = {
  FCVT_W_S <-> "fcvt.w.s",
  FCVT_WU_S <-> "fcvt.wu.s",
  FCVT_L_S <-> "fcvt.l.s",
  FCVT_LU_S <-> "fcvt.lu.s"
}

val f_un_rm_xf_type_mnemonic_S : f_un_rm_xf_op_S <-> string

mapping f_un_rm_xf_type_mnemonic_S = {
  FCVT_S_W <-> "fcvt.s.w",
  FCVT_S_WU <-> "fcvt.s.wu",
  FCVT_S_L <-> "fcvt.s.l",
  FCVT_S_LU <-> "fcvt.s.lu"
}

val f_bin_type_mnemonic_f_S : f_bin_op_f_S <-> string

mapping f_bin_type_mnemonic_f_S = {
  FSGNJ_S <-> "fsgnj.s",
  FSGNJN_S <-> "fsgnjn.s",
  FSGNJX_S <-> "fsgnjx.s",
  FMIN_S <-> "fmin.s",
  FMAX_S <-> "fmax.s"
}

val f_bin_type_mnemonic_x_S : f_bin_op_x_S <-> string

mapping f_bin_type_mnemonic_x_S = {
  FEQ_S <-> "feq.s",
  FLT_S <-> "flt.s",
  FLE_S <-> "fle.s"
}

val f_un_type_mnemonic_x_S : f_un_op_x_S <-> string

mapping f_un_type_mnemonic_x_S = {
  FCLASS_S <-> "fclass.s",
  FMV_X_W <-> "fmv.x.w"
}

val f_un_type_mnemonic_f_S : f_un_op_f_S <-> string

mapping f_un_type_mnemonic_f_S = {FMV_W_X <-> "fmv.w.x"}

val fsplit_D : bitvector(64) -> (bitvector(1), bitvector(11), bitvector(52))

$[complete]
function fsplit_D x64 = ($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(x64, 63, 63), $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(x64, 62, 52), $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(x64, 51, 0))

val fmake_D : (bitvector(1), bitvector(11), bitvector(52)) -> bitvector(64)

$[complete]
function fmake_D (sign, exp, mant) = $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(sign, $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(exp, mant))

val f_is_neg_inf_D : bitvector(64) -> bool

$[complete]
function f_is_neg_inf_D x64 = {
    let (sign, exp, mant) = fsplit_D(x64);
    $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_bits(sign, 0b1), $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_bits(exp, ones(11)), $[overloaded { "name" = "==", "is_infix" = true }] eq_bits(mant, zeros(52))))
}

val f_is_neg_norm_D : bitvector(64) -> bool

$[complete]
function f_is_neg_norm_D x64 = {
    let (sign, exp, mant) = fsplit_D(x64);
    $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_bits(sign, 0b1), $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "!=", "is_infix" = true }] neq_bits(exp, zeros(11)), $[overloaded { "name" = "!=", "is_infix" = true }] neq_bits(exp, ones(11))))
}

val f_is_neg_subnorm_D : bitvector(64) -> bool

$[complete]
function f_is_neg_subnorm_D x64 = {
    let (sign, exp, mant) = fsplit_D(x64);
    $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_bits(sign, 0b1), $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_bits(exp, zeros(11)), $[overloaded { "name" = "!=", "is_infix" = true }] neq_bits(mant, zeros(52))))
}

val f_is_neg_zero_D : bitvector(64) -> bool

$[complete]
function f_is_neg_zero_D x64 = {
    let (sign, exp, mant) = fsplit_D(x64);
    $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_bits(sign, ones(1)), $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_bits(exp, zeros(11)), $[overloaded { "name" = "==", "is_infix" = true }] eq_bits(mant, zeros(52))))
}

val f_is_pos_zero_D : bitvector(64) -> bool

$[complete]
function f_is_pos_zero_D x64 = {
    let (sign, exp, mant) = fsplit_D(x64);
    $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_bits(sign, zeros(1)), $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_bits(exp, zeros(11)), $[overloaded { "name" = "==", "is_infix" = true }] eq_bits(mant, zeros(52))))
}

val f_is_pos_subnorm_D : bitvector(64) -> bool

$[complete]
function f_is_pos_subnorm_D x64 = {
    let (sign, exp, mant) = fsplit_D(x64);
    $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_bits(sign, zeros(1)), $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_bits(exp, zeros(11)), $[overloaded { "name" = "!=", "is_infix" = true }] neq_bits(mant, zeros(52))))
}

val f_is_pos_norm_D : bitvector(64) -> bool

$[complete]
function f_is_pos_norm_D x64 = {
    let (sign, exp, mant) = fsplit_D(x64);
    $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_bits(sign, zeros(1)), $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "!=", "is_infix" = true }] neq_bits(exp, zeros(11)), $[overloaded { "name" = "!=", "is_infix" = true }] neq_bits(exp, ones(11))))
}

val f_is_pos_inf_D : bitvector(64) -> bool

$[complete]
function f_is_pos_inf_D x64 = {
    let (sign, exp, mant) = fsplit_D(x64);
    $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_bits(sign, zeros(1)), $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_bits(exp, ones(11)), $[overloaded { "name" = "==", "is_infix" = true }] eq_bits(mant, zeros(52))))
}

val f_is_SNaN_D : bitvector(64) -> bool

$[complete]
function f_is_SNaN_D x64 = {
    let (sign, exp, mant) = fsplit_D(x64);
    $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_bits(exp, ones(11)), $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(mant, 51), bitzero), $[overloaded { "name" = "!=", "is_infix" = true }] neq_bits(mant, zeros(52))))
}

val f_is_QNaN_D : bitvector(64) -> bool

$[complete]
function f_is_QNaN_D x64 = {
    let (sign, exp, mant) = fsplit_D(x64);
    $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_bits(exp, ones(11)), $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(mant, 51), bitone))
}

val f_is_NaN_D : bitvector(64) -> bool

$[complete]
function f_is_NaN_D x64 = {
    let (sign, exp, mant) = fsplit_D(x64);
    $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_bits(exp, ones(11)), $[overloaded { "name" = "!=", "is_infix" = true }] neq_bits(mant, zeros(52)))
}

val negate_D : bitvector(64) -> bitvector(64)

$[complete]
function negate_D x64 = {
    let (sign, exp, mant) = fsplit_D(x64);
    let new_sign = if $[overloaded { "name" = "==", "is_infix" = true }] eq_bits(sign, 0b0) then
      0b1
    else
      0b0;
    fmake_D(new_sign, exp, mant)
}

val feq_quiet_D : (bitvector(64), bitvector(64)) -> (bool, bitvector(5))

$[complete]
function feq_quiet_D (v1, v2) = {
    let (s1, e1, m1) = fsplit_D(v1);
    let (s2, e2, m2) = fsplit_D(v2);
    let v1Is0 = $[overloaded { "name" = "|", "is_infix" = true }] or_bool(f_is_neg_zero_D(v1), f_is_pos_zero_D(v1));
    let v2Is0 = $[overloaded { "name" = "|", "is_infix" = true }] or_bool(f_is_neg_zero_D(v2), f_is_pos_zero_D(v2));
    let result = $[overloaded { "name" = "|", "is_infix" = true }] or_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_bits(v1, v2), $[overloaded { "name" = "&", "is_infix" = true }] and_bool(v1Is0, v2Is0));
    let fflags = if $[overloaded { "name" = "|", "is_infix" = true }] or_bool(f_is_SNaN_D(v1), f_is_SNaN_D(v2)) then
      nvFlag()
    else
      zeros(5);
    (result, fflags)
}

val flt_D : (bitvector(64), bitvector(64), bool) -> (bool, bitvector(5))

$[complete]
function flt_D (v1, v2, is_quiet) = {
    let (s1, e1, m1) = fsplit_D(v1);
    let (s2, e2, m2) = fsplit_D(v2);
    let result : bool = if $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_bits(s1, 0b0), $[overloaded { "name" = "==", "is_infix" = true }] eq_bits(s2, 0b0)) then
      if $[overloaded { "name" = "==", "is_infix" = true }] eq_bits(e1, e2) then
        $[overloaded { "name" = "<", "is_infix" = true }] lt_int(unsigned(m1), unsigned(m2))
      else
        $[overloaded { "name" = "<", "is_infix" = true }] lt_int(unsigned(e1), unsigned(e2))
    else if $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_bits(s1, 0b0), $[overloaded { "name" = "==", "is_infix" = true }] eq_bits(s2, 0b1)) then
      false
    else
      if $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_bits(s1, 0b1), $[overloaded { "name" = "==", "is_infix" = true }] eq_bits(s2, 0b0)) then
        true
      else
        if $[overloaded { "name" = "==", "is_infix" = true }] eq_bits(e1, e2) then
          $[overloaded { "name" = ">", "is_infix" = true }] gt_int(unsigned(m1), unsigned(m2))
        else
          $[overloaded { "name" = ">", "is_infix" = true }] gt_int(unsigned(e1), unsigned(e2));
    let fflags = if is_quiet then
      if $[overloaded { "name" = "|", "is_infix" = true }] or_bool(f_is_SNaN_D(v1), f_is_SNaN_D(v2)) then
        nvFlag()
      else
        zeros(5)
    else if $[overloaded { "name" = "|", "is_infix" = true }] or_bool(f_is_NaN_D(v1), f_is_NaN_D(v2)) then
      nvFlag()
    else
      zeros(5);
    (result, fflags)
}

val fle_D : (bitvector(64), bitvector(64), bool) -> (bool, bitvector(5))

$[complete]
function fle_D (v1, v2, is_quiet) = {
    let (s1, e1, m1) = fsplit_D(v1);
    let (s2, e2, m2) = fsplit_D(v2);
    let v1Is0 = $[overloaded { "name" = "|", "is_infix" = true }] or_bool(f_is_neg_zero_D(v1), f_is_pos_zero_D(v1));
    let v2Is0 = $[overloaded { "name" = "|", "is_infix" = true }] or_bool(f_is_neg_zero_D(v2), f_is_pos_zero_D(v2));
    let result : bool = if $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_bits(s1, 0b0), $[overloaded { "name" = "==", "is_infix" = true }] eq_bits(s2, 0b0)) then
      if $[overloaded { "name" = "==", "is_infix" = true }] eq_bits(e1, e2) then
        $[overloaded { "name" = "<=", "is_infix" = true }] lteq_int(unsigned(m1), unsigned(m2))
      else
        $[overloaded { "name" = "<", "is_infix" = true }] lt_int(unsigned(e1), unsigned(e2))
    else if $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_bits(s1, 0b0), $[overloaded { "name" = "==", "is_infix" = true }] eq_bits(s2, 0b1)) then
      $[overloaded { "name" = "&", "is_infix" = true }] and_bool(v1Is0, v2Is0)
    else
      if $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_bits(s1, 0b1), $[overloaded { "name" = "==", "is_infix" = true }] eq_bits(s2, 0b0)) then
        true
      else
        if $[overloaded { "name" = "==", "is_infix" = true }] eq_bits(e1, e2) then
          $[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(unsigned(m1), unsigned(m2))
        else
          $[overloaded { "name" = ">", "is_infix" = true }] gt_int(unsigned(e1), unsigned(e2));
    let fflags = if is_quiet then
      if $[overloaded { "name" = "|", "is_infix" = true }] or_bool(f_is_SNaN_D(v1), f_is_SNaN_D(v2)) then
        nvFlag()
      else
        zeros(5)
    else if $[overloaded { "name" = "|", "is_infix" = true }] or_bool(f_is_NaN_D(v1), f_is_NaN_D(v2)) then
      nvFlag()
    else
      zeros(5);
    (result, fflags)
}

val haveDoubleFPU : unit -> bool

$[complete]
function haveDoubleFPU () = $[overloaded { "name" = "|", "is_infix" = true }] or_bool(currentlyEnabled(Ext_D), currentlyEnabled(Ext_Zdinx))

val validDoubleRegs : forall ('n : Int), 'n > 0.
  (implicit('n), vector('n, fregidx)) -> bool

$[complete]
function validDoubleRegs (n, regs) = {
    if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zdinx), $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 32)) then {
        foreach (i from 0 to sub_atom(n, 1) by 1 in inc) {
            if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(fregidx_bits($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(regs, i)), 0), bitone) then return(false);
            ()
        }
    };
    true
}

val f_madd_type_mnemonic_D : f_madd_op_D <-> string

mapping f_madd_type_mnemonic_D = {
  FMADD_D <-> "fmadd.d",
  FMSUB_D <-> "fmsub.d",
  FNMSUB_D <-> "fnmsub.d",
  FNMADD_D <-> "fnmadd.d"
}

val f_bin_rm_type_mnemonic_D : f_bin_rm_op_D <-> string

mapping f_bin_rm_type_mnemonic_D = {
  FADD_D <-> "fadd.d",
  FSUB_D <-> "fsub.d",
  FMUL_D <-> "fmul.d",
  FDIV_D <-> "fdiv.d"
}

val f_un_rm_ff_type_mnemonic_D : f_un_rm_ff_op_D <-> string

mapping f_un_rm_ff_type_mnemonic_D = {
  FSQRT_D <-> "fsqrt.d",
  FCVT_S_D <-> "fcvt.s.d",
  FCVT_D_S <-> "fcvt.d.s"
}

val f_un_rm_fx_type_mnemonic_D : f_un_rm_fx_op_D <-> string

mapping f_un_rm_fx_type_mnemonic_D = {
  FCVT_W_D <-> "fcvt.w.d",
  FCVT_WU_D <-> "fcvt.wu.d",
  FCVT_L_D <-> "fcvt.l.d",
  FCVT_LU_D <-> "fcvt.lu.d"
}

val f_un_rm_xf_type_mnemonic_D : f_un_rm_xf_op_D <-> string

mapping f_un_rm_xf_type_mnemonic_D = {
  FCVT_D_W <-> "fcvt.d.w",
  FCVT_D_WU <-> "fcvt.d.wu",
  FCVT_D_L <-> "fcvt.d.l",
  FCVT_D_LU <-> "fcvt.d.lu"
}

val f_bin_f_type_mnemonic_D : f_bin_f_op_D <-> string

mapping f_bin_f_type_mnemonic_D = {
  FSGNJ_D <-> "fsgnj.d",
  FSGNJN_D <-> "fsgnjn.d",
  FSGNJX_D <-> "fsgnjx.d",
  FMIN_D <-> "fmin.d",
  FMAX_D <-> "fmax.d"
}

val f_bin_x_type_mnemonic_D : f_bin_x_op_D <-> string

mapping f_bin_x_type_mnemonic_D = {
  FEQ_D <-> "feq.d",
  FLT_D <-> "flt.d",
  FLE_D <-> "fle.d"
}

val f_un_x_type_mnemonic_D : f_un_x_op_D <-> string

mapping f_un_x_type_mnemonic_D = {
  FMV_X_D <-> "fmv.x.d",
  FCLASS_D <-> "fclass.d"
}

val f_un_f_type_mnemonic_D : f_un_f_op_D <-> string

mapping f_un_f_type_mnemonic_D = {FMV_D_X <-> "fmv.d.x"}

val fsplit_H : bitvector(16) -> (bitvector(1), bitvector(5), bitvector(10))

$[complete]
function fsplit_H xf16 = ($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(xf16, 15, 15), $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(xf16, 14, 10), $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(xf16, 9, 0))

val fmake_H : (bitvector(1), bitvector(5), bitvector(10)) -> bitvector(16)

$[complete]
function fmake_H (sign, exp, mant) = $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(sign, $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(exp, mant))

val negate_H : bitvector(16) -> bitvector(16)

$[complete]
function negate_H xf16 = {
    let (sign, exp, mant) = fsplit_H(xf16);
    let new_sign = if $[overloaded { "name" = "==", "is_infix" = true }] eq_bits(sign, 0b0) then
      0b1
    else
      0b0;
    fmake_H(new_sign, exp, mant)
}

val f_is_neg_inf_H : bitvector(16) -> bool

$[complete]
function f_is_neg_inf_H xf16 = {
    let (sign, exp, mant) = fsplit_H(xf16);
    $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_bits(sign, 0b1), $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_bits(exp, ones(5)), $[overloaded { "name" = "==", "is_infix" = true }] eq_bits(mant, zeros(10))))
}

val f_is_neg_norm_H : bitvector(16) -> bool

$[complete]
function f_is_neg_norm_H xf16 = {
    let (sign, exp, mant) = fsplit_H(xf16);
    $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_bits(sign, 0b1), $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "!=", "is_infix" = true }] neq_bits(exp, zeros(5)), $[overloaded { "name" = "!=", "is_infix" = true }] neq_bits(exp, ones(5))))
}

val f_is_neg_subnorm_H : bitvector(16) -> bool

$[complete]
function f_is_neg_subnorm_H xf16 = {
    let (sign, exp, mant) = fsplit_H(xf16);
    $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_bits(sign, 0b1), $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_bits(exp, zeros(5)), $[overloaded { "name" = "!=", "is_infix" = true }] neq_bits(mant, zeros(10))))
}

val f_is_pos_subnorm_H : bitvector(16) -> bool

$[complete]
function f_is_pos_subnorm_H xf16 = {
    let (sign, exp, mant) = fsplit_H(xf16);
    $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_bits(sign, zeros(1)), $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_bits(exp, zeros(5)), $[overloaded { "name" = "!=", "is_infix" = true }] neq_bits(mant, zeros(10))))
}

val f_is_pos_norm_H : bitvector(16) -> bool

$[complete]
function f_is_pos_norm_H xf16 = {
    let (sign, exp, mant) = fsplit_H(xf16);
    $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_bits(sign, zeros(1)), $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "!=", "is_infix" = true }] neq_bits(exp, zeros(5)), $[overloaded { "name" = "!=", "is_infix" = true }] neq_bits(exp, ones(5))))
}

val f_is_pos_inf_H : bitvector(16) -> bool

$[complete]
function f_is_pos_inf_H xf16 = {
    let (sign, exp, mant) = fsplit_H(xf16);
    $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_bits(sign, zeros(1)), $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_bits(exp, ones(5)), $[overloaded { "name" = "==", "is_infix" = true }] eq_bits(mant, zeros(10))))
}

val f_is_neg_zero_H : bitvector(16) -> bool

$[complete]
function f_is_neg_zero_H xf16 = {
    let (sign, exp, mant) = fsplit_H(xf16);
    $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_bits(sign, ones(1)), $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_bits(exp, zeros(5)), $[overloaded { "name" = "==", "is_infix" = true }] eq_bits(mant, zeros(10))))
}

val f_is_pos_zero_H : bitvector(16) -> bool

$[complete]
function f_is_pos_zero_H xf16 = {
    let (sign, exp, mant) = fsplit_H(xf16);
    $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_bits(sign, zeros(1)), $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_bits(exp, zeros(5)), $[overloaded { "name" = "==", "is_infix" = true }] eq_bits(mant, zeros(10))))
}

val f_is_SNaN_H : bitvector(16) -> bool

$[complete]
function f_is_SNaN_H xf16 = {
    let (sign, exp, mant) = fsplit_H(xf16);
    $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_bits(exp, ones(5)), $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(mant, 9), bitzero), $[overloaded { "name" = "!=", "is_infix" = true }] neq_bits(mant, zeros(10))))
}

val f_is_QNaN_H : bitvector(16) -> bool

$[complete]
function f_is_QNaN_H xf16 = {
    let (sign, exp, mant) = fsplit_H(xf16);
    $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_bits(exp, ones(5)), $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(mant, 9), bitone))
}

val f_is_NaN_H : bitvector(16) -> bool

$[complete]
function f_is_NaN_H xf16 = {
    let (sign, exp, mant) = fsplit_H(xf16);
    $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_bits(exp, ones(5)), $[overloaded { "name" = "!=", "is_infix" = true }] neq_bits(mant, zeros(10)))
}

val fle_H : (bitvector(16), bitvector(16), bool) -> (bool, bitvector(5))

$[complete]
function fle_H (v1, v2, is_quiet) = {
    let (s1, e1, m1) = fsplit_H(v1);
    let (s2, e2, m2) = fsplit_H(v2);
    let v1Is0 = $[overloaded { "name" = "|", "is_infix" = true }] or_bool(f_is_neg_zero_H(v1), f_is_pos_zero_H(v1));
    let v2Is0 = $[overloaded { "name" = "|", "is_infix" = true }] or_bool(f_is_neg_zero_H(v2), f_is_pos_zero_H(v2));
    let result : bool = if $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_bits(s1, 0b0), $[overloaded { "name" = "==", "is_infix" = true }] eq_bits(s2, 0b0)) then
      if $[overloaded { "name" = "==", "is_infix" = true }] eq_bits(e1, e2) then
        $[overloaded { "name" = "<=", "is_infix" = true }] lteq_int(unsigned(m1), unsigned(m2))
      else
        $[overloaded { "name" = "<", "is_infix" = true }] lt_int(unsigned(e1), unsigned(e2))
    else if $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_bits(s1, 0b0), $[overloaded { "name" = "==", "is_infix" = true }] eq_bits(s2, 0b1)) then
      $[overloaded { "name" = "&", "is_infix" = true }] and_bool(v1Is0, v2Is0)
    else
      if $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_bits(s1, 0b1), $[overloaded { "name" = "==", "is_infix" = true }] eq_bits(s2, 0b0)) then
        true
      else
        if $[overloaded { "name" = "==", "is_infix" = true }] eq_bits(e1, e2) then
          $[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(unsigned(m1), unsigned(m2))
        else
          $[overloaded { "name" = ">", "is_infix" = true }] gt_int(unsigned(e1), unsigned(e2));
    let fflags = if is_quiet then
      if $[overloaded { "name" = "|", "is_infix" = true }] or_bool(f_is_SNaN_H(v1), f_is_SNaN_H(v2)) then
        nvFlag()
      else
        zeros(5)
    else if $[overloaded { "name" = "|", "is_infix" = true }] or_bool(f_is_NaN_H(v1), f_is_NaN_H(v2)) then
      nvFlag()
    else
      zeros(5);
    (result, fflags)
}

val haveHalfFPU : unit -> bool

$[complete]
function haveHalfFPU () = $[overloaded { "name" = "|", "is_infix" = true }] or_bool(currentlyEnabled(Ext_Zfh), currentlyEnabled(Ext_Zhinx))

val haveHalfMin : unit -> bool

$[complete]
function haveHalfMin () = $[overloaded { "name" = "|", "is_infix" = true }] or_bool(haveHalfFPU(), $[overloaded { "name" = "|", "is_infix" = true }] or_bool(currentlyEnabled(Ext_Zfhmin), currentlyEnabled(Ext_Zhinxmin)))

val f_bin_rm_type_mnemonic_H : f_bin_rm_op_H <-> string

mapping f_bin_rm_type_mnemonic_H = {
  FADD_H <-> "fadd.h",
  FSUB_H <-> "fsub.h",
  FMUL_H <-> "fmul.h",
  FDIV_H <-> "fdiv.h"
}

val f_madd_type_mnemonic_H : f_madd_op_H <-> string

mapping f_madd_type_mnemonic_H = {
  FMADD_H <-> "fmadd.h",
  FMSUB_H <-> "fmsub.h",
  FNMSUB_H <-> "fnmsub.h",
  FNMADD_H <-> "fnmadd.h"
}

val f_bin_f_type_mnemonic_H : f_bin_f_op_H <-> string

mapping f_bin_f_type_mnemonic_H = {
  FSGNJ_H <-> "fsgnj.h",
  FSGNJN_H <-> "fsgnjn.h",
  FSGNJX_H <-> "fsgnjx.h",
  FMIN_H <-> "fmin.h",
  FMAX_H <-> "fmax.h"
}

val f_bin_x_type_mnemonic_H : f_bin_x_op_H <-> string

mapping f_bin_x_type_mnemonic_H = {
  FEQ_H <-> "feq.h",
  FLT_H <-> "flt.h",
  FLE_H <-> "fle.h"
}

val f_un_rm_ff_type_mnemonic_H : f_un_rm_ff_op_H <-> string

mapping f_un_rm_ff_type_mnemonic_H = {
  FSQRT_H <-> "fsqrt.h",
  FCVT_H_S <-> "fcvt.h.s",
  FCVT_H_D <-> "fcvt.h.d",
  FCVT_S_H <-> "fcvt.s.h",
  FCVT_D_H <-> "fcvt.d.h"
}

val f_un_rm_fx_type_mnemonic_H : f_un_rm_fx_op_H <-> string

mapping f_un_rm_fx_type_mnemonic_H = {
  FCVT_W_H <-> "fcvt.w.h",
  FCVT_WU_H <-> "fcvt.wu.h",
  FCVT_L_H <-> "fcvt.l.h",
  FCVT_LU_H <-> "fcvt.lu.h"
}

val f_un_rm_xf_type_mnemonic_H : f_un_rm_xf_op_H <-> string

mapping f_un_rm_xf_type_mnemonic_H = {
  FCVT_H_W <-> "fcvt.h.w",
  FCVT_H_WU <-> "fcvt.h.wu",
  FCVT_H_L <-> "fcvt.h.l",
  FCVT_H_LU <-> "fcvt.h.lu"
}

val f_un_f_type_mnemonic_H : f_un_f_op_H <-> string

mapping f_un_f_type_mnemonic_H = {FMV_H_X <-> "fmv.h.x"}

val f_un_x_type_mnemonic_H : f_un_x_op_H <-> string

mapping f_un_x_type_mnemonic_H = {
  FMV_X_H <-> "fmv.x.h",
  FCLASS_H <-> "fclass.h"
}

val fcvtmod_helper : bitvector(64) -> (bitvector(5), bitvector(32))

$[complete]
function fcvtmod_helper x64 = {
    let (sign, exp, mant) = fsplit_D(x64);
    let is_subnorm = $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_bits(exp, zeros(11)), $[overloaded { "name" = "!=", "is_infix" = true }] neq_bits(mant, zeros(52)));
    let is_zero = $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_bits(exp, zeros(11)), $[overloaded { "name" = "==", "is_infix" = true }] eq_bits(mant, zeros(52)));
    let is_nan_or_inf = $[overloaded { "name" = "==", "is_infix" = true }] eq_bits(exp, ones(11));
    let true_mant = $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(0b1, mant);
    let true_exp = $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(unsigned(exp), 1023);
    let is_too_large = $[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(true_exp, 84);
    let is_too_small = $[overloaded { "name" = "<", "is_infix" = true }] lt_int(true_exp, 0);
    if is_zero then (zeros(5), zeros(32)) else
      if is_subnorm then (nxFlag(), zeros(32)) else
        if is_nan_or_inf then (nvFlag(), zeros(32)) else
          if is_too_large then (nvFlag(), zeros(32)) else
            if is_too_small then (nxFlag(), zeros(32)) else {
                let fixedpoint : bits(84) = $[overloaded { "name" = "<<", "is_infix" = true }] shiftl(zero_extend(84, true_mant), true_exp);
                let integer = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(fixedpoint, 83, 52);
                let fractional = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(fixedpoint, 51, 0);
                let result = if $[overloaded { "name" = "==", "is_infix" = true }] eq_bits(sign, 0b1) then
                  $[overloaded { "name" = "+", "is_infix" = true }] add_bits_int($[overloaded { "name" = "~", "is_infix" = false }] not_vec(integer), 1)
                else
                  integer;
                let max_integer = if $[overloaded { "name" = "==", "is_infix" = true }] eq_bits(sign, 0b1) then
                  unsigned(0x80000000)
                else
                  unsigned(0x7fffffff);
                let flags : bits(5) = if $[overloaded { "name" = ">", "is_infix" = true }] gt_int(true_exp, 31) then
                  nvFlag()
                else
                  if $[overloaded { "name" = ">", "is_infix" = true }] gt_int(unsigned(integer), max_integer) then
                    nvFlag()
                  else
                    if $[overloaded { "name" = "!=", "is_infix" = true }] neq_bits(fractional, zeros(add_atom(sub_atom(51, 0), 1))) then
                      nxFlag()
                    else
                      zeros(5);
                (flags, result)
            }
}

val maybe_vmask : string <-> bitvector(1)

mapping maybe_vmask = {
  "" <-> 0b1,
  sep(()) ^ "v0.t" <-> 0b0
}

val valid_eew_emul : (int, int) -> bool

$[complete]
function valid_eew_emul (EEW, EMUL_pow) = {
    $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(EEW, 8), $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "<=", "is_infix" = true }] lteq_int(EEW, elen), $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(EMUL_pow, -3), $[overloaded { "name" = "<=", "is_infix" = true }] lteq_int(EMUL_pow, 3))))
}

val valid_vtype : unit -> bool

$[complete]
function valid_vtype () = {
    $[overloaded { "name" = "==", "is_infix" = true }] eq_bits(_get_Vtype_vill(vtype), 0b0)
}

val assert_vstart : int -> bool

$[complete]
function assert_vstart i = {
    $[overloaded { "name" = "==", "is_infix" = true }] eq_int(unsigned(vstart), i)
}

val valid_rd_mask : (vregidx, bitvector(1)) -> bool

$[complete]
function valid_rd_mask (rd, vm) = {
    $[overloaded { "name" = "|", "is_infix" = true }] or_bool($[overloaded { "name" = "!=", "is_infix" = true }] neq_bits(vm, 0b0), $[overloaded { "name" = "!=", "is_infix" = true }] neq_anything(rd, zvreg))
}

val valid_reg_overlap : (vregidx, vregidx, int, int) -> bool

$[complete]
function valid_reg_overlap (rs, rd, EMUL_pow_rs, EMUL_pow_rd) = {
    let rs_group = if $[overloaded { "name" = ">", "is_infix" = true }] gt_int(EMUL_pow_rs, 0) then
      2 ^ EMUL_pow_rs
    else
      1;
    let rd_group = if $[overloaded { "name" = ">", "is_infix" = true }] gt_int(EMUL_pow_rd, 0) then
      2 ^ EMUL_pow_rd
    else
      1;
    let rs_int = unsigned(vregidx_bits(rs));
    let rd_int = unsigned(vregidx_bits(rd));
    if $[overloaded { "name" = "<", "is_infix" = true }] lt_int(EMUL_pow_rs, EMUL_pow_rd) then {
        $[overloaded { "name" = "|", "is_infix" = true }] or_bool($[overloaded { "name" = "<=", "is_infix" = true }] lteq_int($[overloaded { "name" = "+", "is_infix" = true }] add_atom(rs_int, rs_group), rd_int), $[overloaded { "name" = "|", "is_infix" = true }] or_bool($[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(rs_int, $[overloaded { "name" = "+", "is_infix" = true }] add_atom(rd_int, rd_group)), $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_int($[overloaded { "name" = "+", "is_infix" = true }] add_atom(rs_int, rs_group), $[overloaded { "name" = "+", "is_infix" = true }] add_atom(rd_int, rd_group)), $[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(EMUL_pow_rs, 0))))
    } else if $[overloaded { "name" = ">", "is_infix" = true }] gt_int(EMUL_pow_rs, EMUL_pow_rd) then {
        $[overloaded { "name" = "|", "is_infix" = true }] or_bool($[overloaded { "name" = "<=", "is_infix" = true }] lteq_int(rd_int, rs_int), $[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(rd_int, $[overloaded { "name" = "+", "is_infix" = true }] add_atom(rs_int, rs_group)))
    } else true
}

val valid_segment : ({('q : Int), ('q > 0 & 'q <= 8). int('q)}, int) -> bool

$[complete]
function valid_segment (nf, EMUL_pow) = {
    if $[overloaded { "name" = "<", "is_infix" = true }] lt_int(EMUL_pow, 0) then
      $[overloaded { "name" = "<=", "is_infix" = true }] lteq_int($[overloaded { "name" = "/", "is_infix" = true }] quot_positive_round_zero(nf, 2 ^ sub_atom(0, EMUL_pow)), 8)
    else
      $[overloaded { "name" = "<=", "is_infix" = true }] lteq_int($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(nf, 2 ^ EMUL_pow), 8)
}

val illegal_normal : (vregidx, bitvector(1)) -> bool

$[complete]
function illegal_normal (vd, vm) = {
    $[overloaded { "name" = "|", "is_infix" = true }] or_bool(not(valid_vtype()), not(valid_rd_mask(vd, vm)))
}

val illegal_vd_masked : vregidx -> bool

$[complete]
function illegal_vd_masked vd = {
    $[overloaded { "name" = "|", "is_infix" = true }] or_bool(not(valid_vtype()), $[overloaded { "name" = "==", "is_infix" = true }] eq_anything(vd, zvreg))
}

val illegal_vd_unmasked : unit -> bool

$[complete]
function illegal_vd_unmasked () = {
    not(valid_vtype())
}

val illegal_variable_width : (vregidx, bitvector(1), int, int) -> bool

$[complete]
function illegal_variable_width (vd, vm, SEW_new, LMUL_pow_new) = {
    $[overloaded { "name" = "|", "is_infix" = true }] or_bool(not(valid_vtype()), $[overloaded { "name" = "|", "is_infix" = true }] or_bool(not(valid_rd_mask(vd, vm)), not(valid_eew_emul(SEW_new, LMUL_pow_new))))
}

val illegal_reduction : unit -> bool

$[complete]
function illegal_reduction () = {
    $[overloaded { "name" = "|", "is_infix" = true }] or_bool(not(valid_vtype()), not(assert_vstart(0)))
}

val illegal_widening_reduction : int -> bool

$[complete]
function illegal_widening_reduction EEW = {
    $[overloaded { "name" = "|", "is_infix" = true }] or_bool(not(valid_vtype()), $[overloaded { "name" = "|", "is_infix" = true }] or_bool(not(assert_vstart(0)), not($[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(EEW, 8), $[overloaded { "name" = "<=", "is_infix" = true }] lteq_int(EEW, elen)))))
}

val illegal_load : (vregidx, bitvector(1), {('q : Int), ('q > 0 & 'q <= 8). int('q)}, int, int) -> bool

$[complete]
function illegal_load (vd, vm, nf, EEW, EMUL_pow) = {
    $[overloaded { "name" = "|", "is_infix" = true }] or_bool(not(valid_vtype()), $[overloaded { "name" = "|", "is_infix" = true }] or_bool(not(valid_rd_mask(vd, vm)), $[overloaded { "name" = "|", "is_infix" = true }] or_bool(not(valid_eew_emul(EEW, EMUL_pow)), not(valid_segment(nf, EMUL_pow)))))
}

val illegal_store : ({('q : Int), ('q > 0 & 'q <= 8). int('q)}, int, int) -> bool

$[complete]
function illegal_store (nf, EEW, EMUL_pow) = {
    $[overloaded { "name" = "|", "is_infix" = true }] or_bool(not(valid_vtype()), $[overloaded { "name" = "|", "is_infix" = true }] or_bool(not(valid_eew_emul(EEW, EMUL_pow)), not(valid_segment(nf, EMUL_pow))))
}

val illegal_indexed_load : (vregidx, bitvector(1), {('q : Int), ('q > 0 & 'q <= 8). int('q)}, int, int, int) -> bool

$[complete]
function illegal_indexed_load (vd, vm, nf, EEW_index, EMUL_pow_index, EMUL_pow_data) = {
    $[overloaded { "name" = "|", "is_infix" = true }] or_bool(not(valid_vtype()), $[overloaded { "name" = "|", "is_infix" = true }] or_bool(not(valid_rd_mask(vd, vm)), $[overloaded { "name" = "|", "is_infix" = true }] or_bool(not(valid_eew_emul(EEW_index, EMUL_pow_index)), not(valid_segment(nf, EMUL_pow_data)))))
}

val illegal_indexed_store : ({('q : Int), ('q > 0 & 'q <= 8). int('q)}, int, int, int) -> bool

$[complete]
function illegal_indexed_store (nf, EEW_index, EMUL_pow_index, EMUL_pow_data) = {
    $[overloaded { "name" = "|", "is_infix" = true }] or_bool(not(valid_vtype()), $[overloaded { "name" = "|", "is_infix" = true }] or_bool(not(valid_eew_emul(EEW_index, EMUL_pow_index)), not(valid_segment(nf, EMUL_pow_data))))
}

val get_scalar : forall ('m : Int), 'm >= 8. (regidx, int('m)) -> bitvector('m)

$[complete]
function get_scalar (rs1, SEW) = {
    if $[overloaded { "name" = "<=", "is_infix" = true }] lteq_int(SEW, xlen) then {
        $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1), $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(SEW, 1), 0)
    } else {
        sign_extend(SEW, $[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1))
    }
}

val get_velem_quad : forall ('n : Int) ('m : Int) ('p : Int), ('n > 0 & 'm > 0 & 'p >= 0 & 4 * 'p + 3 < 'n).
  (vector('n, bitvector('m)), int('p)) -> bitvector(4 * 'm)

$[complete]
function get_velem_quad (v, i) = $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(v, $[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(4, i), 3)), $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(v, $[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(4, i), 2)), $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(v, $[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(4, i), 1)), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(v, $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(4, i)))))

val write_velem_quad : forall ('n : Int), 'n > 0.
  (vregidx, {8, 16, 32, 64}, bitvector('n), nat) -> unit

$[complete]
function write_velem_quad (vd, SEW, input, i) = {
    foreach (j from 0 to 3 by 1 in inc) {
        assert($[overloaded { "name" = "<=", "is_infix" = true }] lteq_int($[overloaded { "name" = "*", "is_infix" = true }] mult_atom($[overloaded { "name" = "+", "is_infix" = true }] add_atom(j, 1), SEW), $[overloaded { "name" = "__size", "is_infix" = false }] bitvector_length(input)), "./extensions/V/vext_utils_insts.sail:178.30-178.31");
        write_single_element(SEW, $[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(4, i), j), vd, $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(input, $[overloaded { "name" = "-", "is_infix" = true }] sub_atom($[overloaded { "name" = "*", "is_infix" = true }] mult_atom($[overloaded { "name" = "+", "is_infix" = true }] add_atom(j, 1), SEW), 1), $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(j, SEW)))
    }
}

val get_velem_oct_vec : forall ('n : Int) ('m : Int) ('p : Int), ('n > 0 & 8 <= 'm & 'm <= 64 & 'p >= 0 & 8 * 'p + 7 < 'n).
  (implicit('n), vector('n, bitvector('m)), int('p)) -> vector(8, bitvector('m))

$[complete]
function get_velem_oct_vec (n, v, i) = [$[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(v, $[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(8, i), 7)), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(v, $[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(8, i), 6)), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(v, $[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(8, i), 5)), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(v, $[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(8, i), 4)), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(v, $[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(8, i), 3)), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(v, $[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(8, i), 2)), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(v, $[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(8, i), 1)), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(v, $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(8, i))]

val write_velem_oct_vec : forall ('n : Int), is_sew_bitsize('n).
  (vregidx, int('n), vector(8, bitvector('n)), nat) -> unit

$[complete]
function write_velem_oct_vec (vd, SEW, input, i) = {
    foreach (j from 0 to 7 by 1 in inc) write_single_element(SEW, $[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(8, i), j), vd, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(input, j))
}

val get_velem_quad_vec : forall ('n : Int) ('m : Int) ('p : Int), ('n > 0 & 8 <= 'm & 'm <= 64 & 'p >= 0 & 4 * 'p + 3 < 'n).
  (vector('n, bitvector('m)), int('p)) -> vector(4, bitvector('m))

$[complete]
function get_velem_quad_vec (v, i) = [$[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(v, $[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(4, i), 3)), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(v, $[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(4, i), 2)), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(v, $[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(4, i), 1)), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(v, $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(4, i))]

val write_velem_quad_vec : forall ('p : Int) ('n : Int), (is_sew_bitsize('n) & 'p >= 0).
  (vregidx, int('n), vector(4, bitvector('n)), int('p)) -> unit

$[complete]
function write_velem_quad_vec (vd, SEW, input, i) = {
    foreach (j from 0 to 3 by 1 in inc) write_single_element(SEW, $[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(4, i), j), vd, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(input, j))
}

val get_start_element : unit -> result(nat, unit)

$[complete]
function get_start_element () = {
    let start_element = unsigned(vstart);
    let SEW_pow = get_sew_pow();
    if $[overloaded { "name" = ">", "is_infix" = true }] gt_int(start_element, $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(2 ^ sub_atom($[overloaded { "name" = "+", "is_infix" = true }] add_atom(3, vlen_exp), SEW_pow), 1)) then
      Err()
    else
      Ok(start_element)
}

val get_end_element : unit -> int

$[complete]
function get_end_element () = $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(unsigned(vl), 1)

val init_masked_result : forall ('n : Int) ('m : Int) ('p : Int), 'n >= 0.
  (int('n), int('m), int('p), vector('n, bitvector('m)), bitvector('n)) -> result((vector('n, bitvector('m)), bitvector('n)), unit)

$[complete]
function init_masked_result (num_elem, EEW, LMUL_pow, vd_val, vm_val) = {
    let start_element : nat = $[complete] match get_start_element() {
      Ok(v) => v,
      Err(()) => return(Err())
    };
    let end_element = get_end_element();
    let tail_ag : agtype = get_vtype_vta();
    let mask_ag : agtype = get_vtype_vma();
    var mask : bits('n) = undefined;
    var result : vector('n, bits('m)) = undefined;
    let real_num_elem = if $[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(LMUL_pow, 0) then
      num_elem
    else
      $[overloaded { "name" = "/", "is_infix" = true }] quot_positive_round_zero(num_elem, 2 ^ sub_atom(0, LMUL_pow));
    assert($[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(num_elem, real_num_elem), "./extensions/V/vext_utils_insts.sail:247.34-247.35");
    foreach (i from 0 to sub_atom(num_elem, 1) by 1 in inc) {
        if $[overloaded { "name" = "<", "is_infix" = true }] lt_int(i, start_element) then {
            result[i] = $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vd_val, i);
            mask[i] = bitzero
        } else if $[overloaded { "name" = ">", "is_infix" = true }] gt_int(i, end_element) then {
            result[i] = $[complete] match tail_ag {
              UNDISTURBED => $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vd_val, i),
              AGNOSTIC => $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vd_val, i)
            };
            mask[i] = bitzero
        } else if $[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(i, real_num_elem) then {
            result[i] = $[complete] match tail_ag {
              UNDISTURBED => $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vd_val, i),
              AGNOSTIC => $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vd_val, i)
            };
            mask[i] = bitzero
        } else if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(vm_val, i), bitzero) then {
            result[i] = $[complete] match mask_ag {
              UNDISTURBED => $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vd_val, i),
              AGNOSTIC => $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vd_val, i)
            };
            mask[i] = bitzero
        } else {
            mask[i] = bitone
        }
    };
    Ok((result, mask))
}

val init_masked_source : forall ('n : Int) ('p : Int), 'n > 0.
  (int('n), int('p), bitvector('n)) -> result(bitvector('n), unit)

$[complete]
function init_masked_source (num_elem, LMUL_pow, vm_val) = {
    let start_element : nat = $[complete] match get_start_element() {
      Ok(v) => v,
      Err(()) => return(Err())
    };
    let end_element = get_end_element();
    var mask : bits('n) = undefined;
    let real_num_elem = if $[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(LMUL_pow, 0) then
      num_elem
    else
      $[overloaded { "name" = "/", "is_infix" = true }] quot_positive_round_zero(num_elem, 2 ^ sub_atom(0, LMUL_pow));
    assert($[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(num_elem, real_num_elem), "./extensions/V/vext_utils_insts.sail:299.34-299.35");
    foreach (i from 0 to sub_atom(num_elem, 1) by 1 in inc) {
        if $[overloaded { "name" = "<", "is_infix" = true }] lt_int(i, start_element) then {
            mask[i] = bitzero
        } else if $[overloaded { "name" = ">", "is_infix" = true }] gt_int(i, end_element) then {
            mask[i] = bitzero
        } else if $[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(i, real_num_elem) then {
            mask[i] = bitzero
        } else if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(vm_val, i), bitzero) then {
            mask[i] = bitzero
        } else {
            mask[i] = bitone
        }
    };
    Ok(mask)
}

val init_masked_result_carry : forall ('n : Int), 'n >= 0.
  (int('n), {8, 16, 32, 64}, int, bitvector('n)) -> result((bitvector('n), bitvector('n)), unit)

$[complete]
function init_masked_result_carry (num_elem, EEW, LMUL_pow, vd_val) = {
    let start_element : nat = $[complete] match get_start_element() {
      Ok(v) => v,
      Err(()) => return(Err())
    };
    let end_element = get_end_element();
    var mask : bits('n) = undefined;
    var result : bits('n) = undefined;
    let real_num_elem = if $[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(LMUL_pow, 0) then
      num_elem
    else
      $[overloaded { "name" = "/", "is_infix" = true }] quot_positive_round_zero(num_elem, 2 ^ sub_atom(0, LMUL_pow));
    assert($[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(num_elem, real_num_elem), "./extensions/V/vext_utils_insts.sail:337.34-337.35");
    foreach (i from 0 to sub_atom(num_elem, 1) by 1 in inc) {
        if $[overloaded { "name" = "<", "is_infix" = true }] lt_int(i, start_element) then {
            result[i] = $[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(vd_val, i);
            mask[i] = bitzero
        } else if $[overloaded { "name" = ">", "is_infix" = true }] gt_int(i, end_element) then {
            result[i] = $[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(vd_val, i);
            mask[i] = bitzero
        } else if $[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(i, real_num_elem) then {
            result[i] = $[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(vd_val, i);
            mask[i] = bitzero
        } else {
            mask[i] = bitone
        }
    };
    Ok((result, mask))
}

val init_masked_result_cmp : forall ('n : Int), 'n >= 0.
  (int('n), {8, 16, 32, 64}, int, bitvector('n), bitvector('n)) -> result((bitvector('n), bitvector('n)), unit)

$[complete]
function init_masked_result_cmp (num_elem, EEW, LMUL_pow, vd_val, vm_val) = {
    let start_element : nat = $[complete] match get_start_element() {
      Ok(v) => v,
      Err(()) => return(Err())
    };
    let end_element = get_end_element();
    let mask_ag : agtype = get_vtype_vma();
    var mask : bits('n) = undefined;
    var result : bits('n) = undefined;
    let real_num_elem = if $[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(LMUL_pow, 0) then
      num_elem
    else
      $[overloaded { "name" = "/", "is_infix" = true }] quot_positive_round_zero(num_elem, 2 ^ sub_atom(0, LMUL_pow));
    assert($[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(num_elem, real_num_elem), "./extensions/V/vext_utils_insts.sail:377.34-377.35");
    foreach (i from 0 to sub_atom(num_elem, 1) by 1 in inc) {
        if $[overloaded { "name" = "<", "is_infix" = true }] lt_int(i, start_element) then {
            result[i] = $[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(vd_val, i);
            mask[i] = bitzero
        } else if $[overloaded { "name" = ">", "is_infix" = true }] gt_int(i, end_element) then {
            result[i] = $[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(vd_val, i);
            mask[i] = bitzero
        } else if $[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(i, real_num_elem) then {
            result[i] = $[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(vd_val, i);
            mask[i] = bitzero
        } else if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(vm_val, i), bitzero) then {
            result[i] = $[complete] match mask_ag {
              UNDISTURBED => $[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(vd_val, i),
              AGNOSTIC => $[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(vd_val, i)
            };
            mask[i] = bitzero
        } else {
            mask[i] = bitone
        }
    };
    Ok((result, mask))
}

val read_vreg_seg : forall ('n : Int) ('m : Int) ('p : Int) ('q : Int), ('n >= 0 & is_sew_bitsize('m) & nfields_range('q)).
  (int('n), int('m), int('p), int('q), vregidx) -> vector('n, bitvector('q * 'm))

$[complete]
function read_vreg_seg (num_elem, SEW, LMUL_pow, nf, vrid) = {
    let LMUL_reg : int = if $[overloaded { "name" = "<=", "is_infix" = true }] lteq_int(LMUL_pow, 0) then
      1
    else
      2 ^ LMUL_pow;
    var vreg_list : vector('q, vector('n, bits('m))) = vector_init($[overloaded { "name" = "__size", "is_infix" = false }] __id(nf), vector_init($[overloaded { "name" = "__size", "is_infix" = false }] __id(num_elem), zeros($[overloaded { "name" = "__size", "is_infix" = false }] __id(SEW))));
    var result : vector('n, bits('q * 'm)) = vector_init($[overloaded { "name" = "__size", "is_infix" = false }] __id(num_elem), zeros(mult_atom($[overloaded { "name" = "__size", "is_infix" = false }] vector_length(vreg_list), $[overloaded { "name" = "__size", "is_infix" = false }] __id(SEW))));
    foreach (j from 0 to sub_atom(nf, 1) by 1 in inc) {
        vreg_list[j] = read_vreg(num_elem, SEW, LMUL_pow, vregidx_offset(vrid, to_bits_unsafe(5, $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(j, LMUL_reg))))
    };
    foreach (i from 0 to sub_atom(num_elem, 1) by 1 in inc) {
        result[i] = zeros($[overloaded { "name" = "*", "is_infix" = true }] mult_atom($[overloaded { "name" = "__size", "is_infix" = false }] vector_length(vreg_list), $[overloaded { "name" = "__size", "is_infix" = false }] __id(SEW)));
        foreach (j from 0 to sub_atom(nf, 1) by 1 in inc) {
            result[i] = $[overloaded { "name" = "|", "is_infix" = true }] or_vec($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(result, i), $[overloaded { "name" = "<<", "is_infix" = true }] shiftl(zero_extend(mult_atom($[overloaded { "name" = "__size", "is_infix" = false }] vector_length(vreg_list), $[overloaded { "name" = "__size", "is_infix" = false }] __id(SEW)), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vreg_list, j), i)), $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(j, $[overloaded { "name" = "__size", "is_infix" = false }] __id(SEW))))
        }
    };
    result
}

val get_shift_amount : forall ('n : Int), 0 <= 'n.
  (bitvector('n), {8, 16, 32, 64}) -> nat

$[complete]
function get_shift_amount (bit_val, SEW) = {
    let lowlog2bits = log2(SEW);
    assert($[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "<", "is_infix" = true }] lt_int(0, lowlog2bits), $[overloaded { "name" = "<", "is_infix" = true }] lt_int(lowlog2bits, $[overloaded { "name" = "__size", "is_infix" = false }] bitvector_length(bit_val))), "./extensions/V/vext_utils_insts.sail:434.43-434.44");
    unsigned($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(bit_val, $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(lowlog2bits, 1), 0))
}

val get_fixed_rounding_incr : forall ('m : Int) ('n : Int), ('m > 0 & 'n >= 0).
  (bitvector('m), int('n)) -> bitvector(1)

$[complete]
function get_fixed_rounding_incr (vec_elem, shift_amount) = {
    if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(shift_amount, 0) then
      0b0
    else {
        let rounding_mode = _get_Vcsr_vxrm(vcsr);
        assert($[overloaded { "name" = "<", "is_infix" = true }] lt_int(shift_amount, $[overloaded { "name" = "__size", "is_infix" = false }] bitvector_length(vec_elem)), "./extensions/V/vext_utils_insts.sail:445.28-445.29");
        $[complete] match rounding_mode {
          0b00 => bit_to_bits($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(vec_elem, $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(shift_amount, 1))),
          0b01 => {
              bool_to_bits($[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(vec_elem, $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(shift_amount, 1)), bitone), $[overloaded { "name" = "|", "is_infix" = true }] or_bool(if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(shift_amount, 1) then
                false
              else
                $[overloaded { "name" = "!=", "is_infix" = true }] neq_bits($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(vec_elem, $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(shift_amount, 2), 0), zeros(add_atom(sub_atom(sub_atom($[overloaded { "name" = "__size", "is_infix" = false }] __id(shift_amount), 2), 0), 1))), $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(vec_elem, shift_amount), bitone))))
          },
          0b10 => 0b0,
          _ : bitvector(2) => bool_to_bits($[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "!=", "is_infix" = true }] neq_anything($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(vec_elem, shift_amount), bitone), $[overloaded { "name" = "!=", "is_infix" = true }] neq_bits($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(vec_elem, $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(shift_amount, 1), 0), zeros(add_atom(sub_atom(sub_atom($[overloaded { "name" = "__size", "is_infix" = false }] __id(shift_amount), 1), 0), 1)))))
        }
    }
}

val unsigned_saturation : forall ('m : Int) ('n : Int), ('n >= 'm & 'm > 1).
  (int('m), bitvector('n)) -> bitvector('m)

$[complete]
function unsigned_saturation (len, elem) = {
    if $[overloaded { "name" = ">", "is_infix" = true }] gt_int(unsigned(elem), unsigned(ones($[overloaded { "name" = "__size", "is_infix" = false }] __id(len)))) then {
        vcsr.bits[0 .. 0] = 0b1;
        ones($[overloaded { "name" = "__size", "is_infix" = false }] __id(len))
    } else {
        $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(elem, $[overloaded { "name" = "-", "is_infix" = true }] sub_atom($[overloaded { "name" = "__size", "is_infix" = false }] __id(len), 1), 0)
    }
}

val signed_saturation : forall ('m : Int) ('n : Int), ('n >= 'm & 'm > 1).
  (int('m), bitvector('n)) -> bitvector('m)

$[complete]
function signed_saturation (len, elem) = {
    if $[overloaded { "name" = ">", "is_infix" = true }] gt_int(signed(elem), signed($[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(0b0, ones($[overloaded { "name" = "-", "is_infix" = true }] sub_atom($[overloaded { "name" = "__size", "is_infix" = false }] __id(len), 1))))) then {
        vcsr.bits[0 .. 0] = 0b1;
        $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(0b0, ones($[overloaded { "name" = "-", "is_infix" = true }] sub_atom($[overloaded { "name" = "__size", "is_infix" = false }] __id(len), 1)))
    } else if $[overloaded { "name" = "<", "is_infix" = true }] lt_int(signed(elem), signed($[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(0b1, zeros($[overloaded { "name" = "-", "is_infix" = true }] sub_atom($[overloaded { "name" = "__size", "is_infix" = false }] __id(len), 1))))) then {
        vcsr.bits[0 .. 0] = 0b1;
        $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(0b1, zeros($[overloaded { "name" = "-", "is_infix" = true }] sub_atom($[overloaded { "name" = "__size", "is_infix" = false }] __id(len), 1)))
    } else {
        $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(elem, $[overloaded { "name" = "-", "is_infix" = true }] sub_atom($[overloaded { "name" = "__size", "is_infix" = false }] __id(len), 1), 0)
    }
}

val vrev8 : forall ('n : Int) ('m : Int), ('n >= 0 & 'm >= 0).
  (implicit('m), vector('n, bitvector('m * 8))) -> vector('n, bitvector('m * 8))

$[complete]
function vrev8 (m, input) = {
    var output : vector('n, bits('m * 8)) = input;
    foreach (i
    from 0
    to sub_atom($[overloaded { "name" = "__size", "is_infix" = false }] vector_length(output), 1)
    by 1
    in inc) {
        output[i] = rev8($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(input, i))
    };
    output
}

val valid_fp_op : ({8, 16, 32, 64}, bitvector(3)) -> bool

$[complete]
function valid_fp_op (SEW, rm_3b) = {
    let valid_sew = $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(SEW, 16), $[overloaded { "name" = "<=", "is_infix" = true }] lteq_int(SEW, 128));
    let valid_rm = not($[overloaded { "name" = "|", "is_infix" = true }] or_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_bits(rm_3b, 0b101), $[overloaded { "name" = "|", "is_infix" = true }] or_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_bits(rm_3b, 0b110), $[overloaded { "name" = "==", "is_infix" = true }] eq_bits(rm_3b, 0b111))));
    $[overloaded { "name" = "&", "is_infix" = true }] and_bool(valid_sew, valid_rm)
}

val illegal_fp_normal : (vregidx, bitvector(1), {8, 16, 32, 64}, bitvector(3)) -> bool

$[complete]
function illegal_fp_normal (vd, vm, SEW, rm_3b) = {
    $[overloaded { "name" = "|", "is_infix" = true }] or_bool(not(valid_vtype()), $[overloaded { "name" = "|", "is_infix" = true }] or_bool(not(valid_rd_mask(vd, vm)), not(valid_fp_op(SEW, rm_3b))))
}

val illegal_fp_vd_masked : (vregidx, {8, 16, 32, 64}, bitvector(3)) -> bool

$[complete]
function illegal_fp_vd_masked (vd, SEW, rm_3b) = {
    $[overloaded { "name" = "|", "is_infix" = true }] or_bool(not(valid_vtype()), $[overloaded { "name" = "|", "is_infix" = true }] or_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_anything(vd, zvreg), not(valid_fp_op(SEW, rm_3b))))
}

val illegal_fp_vd_unmasked : ({8, 16, 32, 64}, bitvector(3)) -> bool

$[complete]
function illegal_fp_vd_unmasked (SEW, rm_3b) = {
    $[overloaded { "name" = "|", "is_infix" = true }] or_bool(not(valid_vtype()), not(valid_fp_op(SEW, rm_3b)))
}

val illegal_fp_variable_width : (vregidx, bitvector(1), {8, 16, 32, 64}, bitvector(3), int, int) -> bool

$[complete]
function illegal_fp_variable_width (vd, vm, SEW, rm_3b, SEW_new, LMUL_pow_new) = {
    $[overloaded { "name" = "|", "is_infix" = true }] or_bool(not(valid_vtype()), $[overloaded { "name" = "|", "is_infix" = true }] or_bool(not(valid_rd_mask(vd, vm)), $[overloaded { "name" = "|", "is_infix" = true }] or_bool(not(valid_fp_op(SEW, rm_3b)), not(valid_eew_emul(SEW_new, LMUL_pow_new)))))
}

val illegal_fp_reduction : ({8, 16, 32, 64}, bitvector(3)) -> bool

$[complete]
function illegal_fp_reduction (SEW, rm_3b) = {
    $[overloaded { "name" = "|", "is_infix" = true }] or_bool(not(valid_vtype()), $[overloaded { "name" = "|", "is_infix" = true }] or_bool(not(assert_vstart(0)), not(valid_fp_op(SEW, rm_3b))))
}

val illegal_fp_widening_reduction : ({8, 16, 32, 64}, bitvector(3), int) -> bool

$[complete]
function illegal_fp_widening_reduction (SEW, rm_3b, EEW) = {
    $[overloaded { "name" = "|", "is_infix" = true }] or_bool(not(valid_vtype()), $[overloaded { "name" = "|", "is_infix" = true }] or_bool(not(assert_vstart(0)), $[overloaded { "name" = "|", "is_infix" = true }] or_bool(not(valid_fp_op(SEW, rm_3b)), not($[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(EEW, 8), $[overloaded { "name" = "<=", "is_infix" = true }] lteq_int(EEW, elen))))))
}

val f_is_neg_inf : forall ('m : Int), 'm in {16, 32, 64}. bitvector('m) -> bool

$[complete]
function f_is_neg_inf xf = {
    $[complete] match $[overloaded { "name" = "__size", "is_infix" = false }] bitvector_length(xf) {
      16 => f_is_neg_inf_H(xf),
      32 => f_is_neg_inf_S(xf),
      ($[int_wildcard 64] _) => f_is_neg_inf_D(xf)
    }
}

val f_is_neg_norm : forall ('m : Int), 'm in {16, 32, 64}. bitvector('m) -> bool

$[complete]
function f_is_neg_norm xf = {
    $[complete] match $[overloaded { "name" = "__size", "is_infix" = false }] bitvector_length(xf) {
      16 => f_is_neg_norm_H(xf),
      32 => f_is_neg_norm_S(xf),
      ($[int_wildcard 64] _) => f_is_neg_norm_D(xf)
    }
}

val f_is_neg_subnorm : forall ('m : Int), 'm in {16, 32, 64}.
  bitvector('m) -> bool

$[complete]
function f_is_neg_subnorm xf = {
    $[complete] match $[overloaded { "name" = "__size", "is_infix" = false }] bitvector_length(xf) {
      16 => f_is_neg_subnorm_H(xf),
      32 => f_is_neg_subnorm_S(xf),
      ($[int_wildcard 64] _) => f_is_neg_subnorm_D(xf)
    }
}

val f_is_neg_zero : forall ('m : Int), 'm in {16, 32, 64}. bitvector('m) -> bool

$[complete]
function f_is_neg_zero xf = {
    $[complete] match $[overloaded { "name" = "__size", "is_infix" = false }] bitvector_length(xf) {
      16 => f_is_neg_zero_H(xf),
      32 => f_is_neg_zero_S(xf),
      ($[int_wildcard 64] _) => f_is_neg_zero_D(xf)
    }
}

val f_is_pos_zero : forall ('m : Int), 'm in {16, 32, 64}. bitvector('m) -> bool

$[complete]
function f_is_pos_zero xf = {
    $[complete] match $[overloaded { "name" = "__size", "is_infix" = false }] bitvector_length(xf) {
      16 => f_is_pos_zero_H(xf),
      32 => f_is_pos_zero_S(xf),
      ($[int_wildcard 64] _) => f_is_pos_zero_D(xf)
    }
}

val f_is_pos_subnorm : forall ('m : Int), 'm in {16, 32, 64}.
  bitvector('m) -> bool

$[complete]
function f_is_pos_subnorm xf = {
    $[complete] match $[overloaded { "name" = "__size", "is_infix" = false }] bitvector_length(xf) {
      16 => f_is_pos_subnorm_H(xf),
      32 => f_is_pos_subnorm_S(xf),
      ($[int_wildcard 64] _) => f_is_pos_subnorm_D(xf)
    }
}

val f_is_pos_norm : forall ('m : Int), 'm in {16, 32, 64}. bitvector('m) -> bool

$[complete]
function f_is_pos_norm xf = {
    $[complete] match $[overloaded { "name" = "__size", "is_infix" = false }] bitvector_length(xf) {
      16 => f_is_pos_norm_H(xf),
      32 => f_is_pos_norm_S(xf),
      ($[int_wildcard 64] _) => f_is_pos_norm_D(xf)
    }
}

val f_is_pos_inf : forall ('m : Int), 'm in {16, 32, 64}. bitvector('m) -> bool

$[complete]
function f_is_pos_inf xf = {
    $[complete] match $[overloaded { "name" = "__size", "is_infix" = false }] bitvector_length(xf) {
      16 => f_is_pos_inf_H(xf),
      32 => f_is_pos_inf_S(xf),
      ($[int_wildcard 64] _) => f_is_pos_inf_D(xf)
    }
}

val f_is_SNaN : forall ('m : Int), 'm in {16, 32, 64}. bitvector('m) -> bool

$[complete]
function f_is_SNaN xf = {
    $[complete] match $[overloaded { "name" = "__size", "is_infix" = false }] bitvector_length(xf) {
      16 => f_is_SNaN_H(xf),
      32 => f_is_SNaN_S(xf),
      ($[int_wildcard 64] _) => f_is_SNaN_D(xf)
    }
}

val f_is_QNaN : forall ('m : Int), 'm in {16, 32, 64}. bitvector('m) -> bool

$[complete]
function f_is_QNaN xf = {
    $[complete] match $[overloaded { "name" = "__size", "is_infix" = false }] bitvector_length(xf) {
      16 => f_is_QNaN_H(xf),
      32 => f_is_QNaN_S(xf),
      ($[int_wildcard 64] _) => f_is_QNaN_D(xf)
    }
}

val f_is_NaN : forall ('m : Int), 'm in {16, 32, 64}. bitvector('m) -> bool

$[complete]
function f_is_NaN xf = {
    $[complete] match $[overloaded { "name" = "__size", "is_infix" = false }] bitvector_length(xf) {
      16 => f_is_NaN_H(xf),
      32 => f_is_NaN_S(xf),
      ($[int_wildcard 64] _) => f_is_NaN_D(xf)
    }
}

val get_scalar_fp : forall ('n : Int), 'n in {16, 32, 64}.
  (fregidx, int('n)) -> bitvector('n)

$[complete]
function get_scalar_fp (rs1, SEW) = {
    assert($[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(flen, SEW), "invalid vector floating-point type width: FLEN < SEW");
    $[complete] match SEW {
      16 => $[overloaded { "name" = "F_H", "is_infix" = false }] rF_H(rs1),
      32 => $[overloaded { "name" = "F_S", "is_infix" = false }] rF_S(rs1),
      ($[int_wildcard 64] _) => $[overloaded { "name" = "F_D", "is_infix" = false }] rF_D(rs1)
    }
}

val get_fp_rounding_mode : unit -> rounding_mode

$[complete]
function get_fp_rounding_mode () = encdec_rounding_mode_backwards(_get_Fcsr_FRM(fcsr))

val negate_fp : forall ('m : Int), 'm in {16, 32, 64}.
  bitvector('m) -> bitvector('m)

$[complete]
function negate_fp xf = {
    $[complete] match $[overloaded { "name" = "__size", "is_infix" = false }] bitvector_length(xf) {
      16 => negate_H(xf),
      32 => negate_S(xf),
      ($[int_wildcard 64] _) => negate_D(xf)
    }
}

val fp_add : forall ('m : Int), 'm in {16, 32, 64}.
  (bitvector(3), bitvector('m), bitvector('m)) -> bitvector('m)

$[complete]
function fp_add (rm_3b, op1, op2) = {
    let (fflags, result_val) : (bits_fflags, bits('m)) = $[complete] match $[overloaded { "name" = "__size", "is_infix" = false }] bitvector_length(op2) {
      16 => riscv_f16Add(rm_3b, op1, op2),
      32 => riscv_f32Add(rm_3b, op1, op2),
      ($[int_wildcard 64] _) => riscv_f64Add(rm_3b, op1, op2)
    };
    accrue_fflags(fflags);
    result_val
}

val fp_sub : forall ('m : Int), 'm in {16, 32, 64}.
  (bitvector(3), bitvector('m), bitvector('m)) -> bitvector('m)

$[complete]
function fp_sub (rm_3b, op1, op2) = {
    let (fflags, result_val) : (bits_fflags, bits('m)) = $[complete] match $[overloaded { "name" = "__size", "is_infix" = false }] bitvector_length(op2) {
      16 => riscv_f16Sub(rm_3b, op1, op2),
      32 => riscv_f32Sub(rm_3b, op1, op2),
      ($[int_wildcard 64] _) => riscv_f64Sub(rm_3b, op1, op2)
    };
    accrue_fflags(fflags);
    result_val
}

val fp_min : forall ('m : Int), 'm in {16, 32, 64}.
  (bitvector('m), bitvector('m)) -> bitvector('m)

$[complete]
function fp_min (op1, op2) = {
    let (fflags, op1_lt_op2) : (bits_fflags, bool) = $[complete] match $[overloaded { "name" = "__size", "is_infix" = false }] bitvector_length(op2) {
      16 => riscv_f16Lt_quiet(op1, op2),
      32 => riscv_f32Lt_quiet(op1, op2),
      ($[int_wildcard 64] _) => riscv_f64Lt_quiet(op1, op2)
    };
    let result_val = if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(f_is_NaN(op1), f_is_NaN(op2)) then
      canonical_NaN($[overloaded { "name" = "__size", "is_infix" = false }] bitvector_length(op2))
    else
      if f_is_NaN(op1) then op2 else
        if f_is_NaN(op2) then op1 else
          if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(f_is_neg_zero(op1), f_is_pos_zero(op2)) then
            op1
          else
            if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(f_is_neg_zero(op2), f_is_pos_zero(op1)) then
              op2
            else
              if op1_lt_op2 then op1 else op2;
    accrue_fflags(fflags);
    result_val
}

val fp_max : forall ('m : Int), 'm in {16, 32, 64}.
  (bitvector('m), bitvector('m)) -> bitvector('m)

$[complete]
function fp_max (op1, op2) = {
    let (fflags, op1_lt_op2) : (bits_fflags, bool) = $[complete] match $[overloaded { "name" = "__size", "is_infix" = false }] bitvector_length(op2) {
      16 => riscv_f16Lt_quiet(op1, op2),
      32 => riscv_f32Lt_quiet(op1, op2),
      ($[int_wildcard 64] _) => riscv_f64Lt_quiet(op1, op2)
    };
    let result_val = if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(f_is_NaN(op1), f_is_NaN(op2)) then
      canonical_NaN($[overloaded { "name" = "__size", "is_infix" = false }] bitvector_length(op2))
    else
      if f_is_NaN(op1) then op2 else
        if f_is_NaN(op2) then op1 else
          if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(f_is_neg_zero(op1), f_is_pos_zero(op2)) then
            op2
          else
            if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(f_is_neg_zero(op2), f_is_pos_zero(op1)) then
              op1
            else
              if op1_lt_op2 then op2 else op1;
    accrue_fflags(fflags);
    result_val
}

val fp_eq : forall ('m : Int), 'm in {16, 32, 64}.
  (bitvector('m), bitvector('m)) -> bool

$[complete]
function fp_eq (op1, op2) = {
    let (fflags, result_val) : (bits_fflags, bool) = $[complete] match $[overloaded { "name" = "__size", "is_infix" = false }] bitvector_length(op2) {
      16 => riscv_f16Eq(op1, op2),
      32 => riscv_f32Eq(op1, op2),
      ($[int_wildcard 64] _) => riscv_f64Eq(op1, op2)
    };
    accrue_fflags(fflags);
    result_val
}

val fp_gt : forall ('m : Int), 'm in {16, 32, 64}.
  (bitvector('m), bitvector('m)) -> bool

$[complete]
function fp_gt (op1, op2) = {
    let (fflags, temp_val) : (bits_fflags, bool) = $[complete] match $[overloaded { "name" = "__size", "is_infix" = false }] bitvector_length(op2) {
      16 => riscv_f16Le(op1, op2),
      32 => riscv_f32Le(op1, op2),
      ($[int_wildcard 64] _) => riscv_f64Le(op1, op2)
    };
    let result_val = if $[overloaded { "name" = "==", "is_infix" = true }] eq_bits(fflags, 0b10000) then
      false
    else
      not(temp_val);
    accrue_fflags(fflags);
    result_val
}

val fp_ge : forall ('m : Int), 'm in {16, 32, 64}.
  (bitvector('m), bitvector('m)) -> bool

$[complete]
function fp_ge (op1, op2) = {
    let (fflags, temp_val) : (bits_fflags, bool) = $[complete] match $[overloaded { "name" = "__size", "is_infix" = false }] bitvector_length(op2) {
      16 => riscv_f16Lt(op1, op2),
      32 => riscv_f32Lt(op1, op2),
      ($[int_wildcard 64] _) => riscv_f64Lt(op1, op2)
    };
    let result_val = if $[overloaded { "name" = "==", "is_infix" = true }] eq_bits(fflags, 0b10000) then
      false
    else
      not(temp_val);
    accrue_fflags(fflags);
    result_val
}

val fp_lt : forall ('m : Int), 'm in {16, 32, 64}.
  (bitvector('m), bitvector('m)) -> bool

$[complete]
function fp_lt (op1, op2) = {
    let (fflags, result_val) : (bits_fflags, bool) = $[complete] match $[overloaded { "name" = "__size", "is_infix" = false }] bitvector_length(op2) {
      16 => riscv_f16Lt(op1, op2),
      32 => riscv_f32Lt(op1, op2),
      ($[int_wildcard 64] _) => riscv_f64Lt(op1, op2)
    };
    accrue_fflags(fflags);
    result_val
}

val fp_le : forall ('m : Int), 'm in {16, 32, 64}.
  (bitvector('m), bitvector('m)) -> bool

$[complete]
function fp_le (op1, op2) = {
    let (fflags, result_val) : (bits_fflags, bool) = $[complete] match $[overloaded { "name" = "__size", "is_infix" = false }] bitvector_length(op2) {
      16 => riscv_f16Le(op1, op2),
      32 => riscv_f32Le(op1, op2),
      ($[int_wildcard 64] _) => riscv_f64Le(op1, op2)
    };
    accrue_fflags(fflags);
    result_val
}

val fp_mul : forall ('m : Int), 'm in {16, 32, 64}.
  (bitvector(3), bitvector('m), bitvector('m)) -> bitvector('m)

$[complete]
function fp_mul (rm_3b, op1, op2) = {
    let (fflags, result_val) : (bits_fflags, bits('m)) = $[complete] match $[overloaded { "name" = "__size", "is_infix" = false }] bitvector_length(op2) {
      16 => riscv_f16Mul(rm_3b, op1, op2),
      32 => riscv_f32Mul(rm_3b, op1, op2),
      ($[int_wildcard 64] _) => riscv_f64Mul(rm_3b, op1, op2)
    };
    accrue_fflags(fflags);
    result_val
}

val fp_div : forall ('m : Int), 'm in {16, 32, 64}.
  (bitvector(3), bitvector('m), bitvector('m)) -> bitvector('m)

$[complete]
function fp_div (rm_3b, op1, op2) = {
    let (fflags, result_val) : (bits_fflags, bits('m)) = $[complete] match $[overloaded { "name" = "__size", "is_infix" = false }] bitvector_length(op2) {
      16 => riscv_f16Div(rm_3b, op1, op2),
      32 => riscv_f32Div(rm_3b, op1, op2),
      ($[int_wildcard 64] _) => riscv_f64Div(rm_3b, op1, op2)
    };
    accrue_fflags(fflags);
    result_val
}

val fp_muladd : forall ('m : Int), 'm in {16, 32, 64}.
  (bitvector(3), bitvector('m), bitvector('m), bitvector('m)) -> bitvector('m)

$[complete]
function fp_muladd (rm_3b, op1, op2, opadd) = {
    let (fflags, result_val) : (bits_fflags, bits('m)) = $[complete] match $[overloaded { "name" = "__size", "is_infix" = false }] bitvector_length(opadd) {
      16 => riscv_f16MulAdd(rm_3b, op1, op2, opadd),
      32 => riscv_f32MulAdd(rm_3b, op1, op2, opadd),
      ($[int_wildcard 64] _) => riscv_f64MulAdd(rm_3b, op1, op2, opadd)
    };
    accrue_fflags(fflags);
    result_val
}

val fp_nmuladd : forall ('m : Int), 'm in {16, 32, 64}.
  (bitvector(3), bitvector('m), bitvector('m), bitvector('m)) -> bitvector('m)

$[complete]
function fp_nmuladd (rm_3b, op1, op2, opadd) = {
    let op1 = negate_fp(op1);
    let (fflags, result_val) : (bits_fflags, bits('m)) = $[complete] match $[overloaded { "name" = "__size", "is_infix" = false }] bitvector_length(opadd) {
      16 => riscv_f16MulAdd(rm_3b, op1, op2, opadd),
      32 => riscv_f32MulAdd(rm_3b, op1, op2, opadd),
      ($[int_wildcard 64] _) => riscv_f64MulAdd(rm_3b, op1, op2, opadd)
    };
    accrue_fflags(fflags);
    result_val
}

val fp_mulsub : forall ('m : Int), 'm in {16, 32, 64}.
  (bitvector(3), bitvector('m), bitvector('m), bitvector('m)) -> bitvector('m)

$[complete]
function fp_mulsub (rm_3b, op1, op2, opsub) = {
    let opsub = negate_fp(opsub);
    let (fflags, result_val) : (bits_fflags, bits('m)) = $[complete] match $[overloaded { "name" = "__size", "is_infix" = false }] bitvector_length(opsub) {
      16 => riscv_f16MulAdd(rm_3b, op1, op2, opsub),
      32 => riscv_f32MulAdd(rm_3b, op1, op2, opsub),
      ($[int_wildcard 64] _) => riscv_f64MulAdd(rm_3b, op1, op2, opsub)
    };
    accrue_fflags(fflags);
    result_val
}

val fp_nmulsub : forall ('m : Int), 'm in {16, 32, 64}.
  (bitvector(3), bitvector('m), bitvector('m), bitvector('m)) -> bitvector('m)

$[complete]
function fp_nmulsub (rm_3b, op1, op2, opsub) = {
    let opsub = negate_fp(opsub);
    let op1 = negate_fp(op1);
    let (fflags, result_val) : (bits_fflags, bits('m)) = $[complete] match $[overloaded { "name" = "__size", "is_infix" = false }] bitvector_length(opsub) {
      16 => riscv_f16MulAdd(rm_3b, op1, op2, opsub),
      32 => riscv_f32MulAdd(rm_3b, op1, op2, opsub),
      ($[int_wildcard 64] _) => riscv_f64MulAdd(rm_3b, op1, op2, opsub)
    };
    accrue_fflags(fflags);
    result_val
}

val fp_class : forall ('m : Int), 'm in {16, 32, 64}.
  bitvector('m) -> bitvector('m)

$[complete]
function fp_class xf = {
    let result_val_10b : bits(10) = if f_is_neg_inf(xf) then 0b0000000001 else
      if f_is_neg_norm(xf) then 0b0000000010 else
        if f_is_neg_subnorm(xf) then 0b0000000100 else
          if f_is_neg_zero(xf) then 0b0000001000 else
            if f_is_pos_zero(xf) then 0b0000010000 else
              if f_is_pos_subnorm(xf) then 0b0000100000 else
                if f_is_pos_norm(xf) then 0b0001000000 else
                  if f_is_pos_inf(xf) then 0b0010000000 else
                    if f_is_SNaN(xf) then 0b0100000000 else
                      if f_is_QNaN(xf) then 0b1000000000 else zeros(10);
    zero_extend($[overloaded { "name" = "__size", "is_infix" = false }] bitvector_length(xf), result_val_10b)
}

val fp_widen : forall ('m : Int), 'm in {16, 32}.
  bitvector('m) -> bitvector('m * 2)

$[complete]
function fp_widen nval = {
    let rm_3b = _get_Fcsr_FRM(fcsr);
    let (fflags, wval) : (bits_fflags, bits('m * 2)) = $[complete] match $[overloaded { "name" = "__size", "is_infix" = false }] bitvector_length(nval) {
      16 => riscv_f16ToF32(rm_3b, nval),
      ($[int_wildcard 32] _) => riscv_f32ToF64(rm_3b, nval)
    };
    accrue_fflags(fflags);
    wval
}

val riscv_f16ToI16 : (bitvector(3), bitvector(16)) -> (bitvector(5), bitvector(16))

$[complete]
function riscv_f16ToI16 (rm, v) = {
    let (flag, sig32) = riscv_f16ToI32(rm, v);
    if $[overloaded { "name" = ">", "is_infix" = true }] gt_int(signed(sig32), signed($[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(0b0, ones(15)))) then
      (nvFlag(), $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(0b0, ones(15)))
    else
      if $[overloaded { "name" = "<", "is_infix" = true }] lt_int(signed(sig32), signed($[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(0b1, zeros(15)))) then
        (nvFlag(), $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(0b1, zeros(15)))
      else
        (flag, $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(sig32, 15, 0))
}

val riscv_f16ToI8 : (bitvector(3), bitvector(16)) -> (bitvector(5), bitvector(8))

$[complete]
function riscv_f16ToI8 (rm, v) = {
    let (flag, sig32) = riscv_f16ToI32(rm, v);
    if $[overloaded { "name" = ">", "is_infix" = true }] gt_int(signed(sig32), signed($[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(0b0, ones(7)))) then
      (nvFlag(), $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(0b0, ones(7)))
    else
      if $[overloaded { "name" = "<", "is_infix" = true }] lt_int(signed(sig32), signed($[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(0b1, zeros(7)))) then
        (nvFlag(), $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(0b1, zeros(7)))
      else
        (flag, $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(sig32, 7, 0))
}

val riscv_f32ToI16 : (bitvector(3), bitvector(32)) -> (bitvector(5), bitvector(16))

$[complete]
function riscv_f32ToI16 (rm, v) = {
    let (flag, sig32) = riscv_f32ToI32(rm, v);
    if $[overloaded { "name" = ">", "is_infix" = true }] gt_int(signed(sig32), signed($[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(0b0, ones(15)))) then
      (nvFlag(), $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(0b0, ones(15)))
    else
      if $[overloaded { "name" = "<", "is_infix" = true }] lt_int(signed(sig32), signed($[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(0b1, zeros(15)))) then
        (nvFlag(), $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(0b1, zeros(15)))
      else
        (flag, $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(sig32, 15, 0))
}

val riscv_f16ToUi16 : (bitvector(3), bitvector(16)) -> (bitvector(5), bitvector(16))

$[complete]
function riscv_f16ToUi16 (rm, v) = {
    let (flag, sig32) = riscv_f16ToUi32(rm, v);
    if $[overloaded { "name" = ">", "is_infix" = true }] gt_int(unsigned(sig32), unsigned(ones(16))) then
      (nvFlag(), ones(16))
    else
      (flag, $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(sig32, 15, 0))
}

val riscv_f16ToUi8 : (bitvector(3), bitvector(16)) -> (bitvector(5), bitvector(8))

$[complete]
function riscv_f16ToUi8 (rm, v) = {
    let (flag, sig32) = riscv_f16ToUi32(rm, v);
    if $[overloaded { "name" = ">", "is_infix" = true }] gt_int(unsigned(sig32), unsigned(ones(8))) then
      (nvFlag(), ones(8))
    else
      (flag, $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(sig32, 7, 0))
}

val riscv_f32ToUi16 : (bitvector(3), bitvector(32)) -> (bitvector(5), bitvector(16))

$[complete]
function riscv_f32ToUi16 (rm, v) = {
    let (flag, sig32) = riscv_f32ToUi32(rm, v);
    if $[overloaded { "name" = ">", "is_infix" = true }] gt_int(unsigned(sig32), unsigned(ones(16))) then
      (nvFlag(), ones(16))
    else
      (flag, $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(sig32, 15, 0))
}

val rsqrt7 : forall ('m : Int), 'm in {16, 32, 64}.
  (bitvector('m), bool) -> bitvector(64)

$[complete]
function rsqrt7 (v, sub) = {
    let (sig, exp, sign, e, s) : (bits(64), bits(64), bits(1), {5, 8, 11}, {10, 23, 52}) = $[complete] match $[overloaded { "name" = "__size", "is_infix" = false }] bitvector_length(v) {
      16 => (zero_extend(64, $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v, 9, 0)), zero_extend(64, $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v, 14, 10)), [$[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(v, 15)], 5, 10),
      32 => (zero_extend(64, $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v, 22, 0)), zero_extend(64, $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v, 30, 23)), [$[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(v, 31)], 8, 23),
      ($[int_wildcard 64] _) => (zero_extend(64, $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v, 51, 0)), zero_extend(64, $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v, 62, 52)), [$[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(v, 63)], 11, 52)
    };
    let table : vector(128, int) = [52, 51, 50, 48, 47, 46, 44, 43, 42, 41, 40, 39, 38, 36, 35, 34, 33, 32, 31, 30, 30, 29, 28, 27, 26, 25, 24, 23, 23, 22, 21, 20, 19, 19, 18, 17, 16, 16, 15, 14, 14, 13, 12, 12, 11, 10, 10, 9, 9, 8, 7, 7, 6, 6, 5, 4, 4, 3, 3, 2, 2, 1, 1, 0, 127, 125, 123, 121, 119, 118, 116, 114, 113, 111, 109, 108, 106, 105, 103, 102, 100, 99, 97, 96, 95, 93, 92, 91, 90, 88, 87, 86, 85, 84, 83, 82, 80, 79, 78, 77, 76, 75, 74, 73, 72, 71, 70, 70, 69, 68, 67, 66, 65, 64, 63, 63, 62, 61, 60, 59, 59, 58, 57, 56, 56, 55, 54, 53];
    let (normalized_exp, normalized_sig) = if sub then {
        let nr_leadingzeros = count_leading_zeros($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(sig, $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(s, 1), 0));
        assert($[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(nr_leadingzeros, 0), "./extensions/V/vext_fp_utils_insts.sail:478.35-478.36");
        (to_bits_unsafe(64, $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(0, nr_leadingzeros)), zero_extend(64, $[overloaded { "name" = "<<", "is_infix" = true }] shiftl($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(sig, $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(s, 1), 0), $[overloaded { "name" = "+", "is_infix" = true }] add_atom(1, nr_leadingzeros))))
    } else {
        (exp, sig)
    };
    let idx : nat = $[complete] match $[overloaded { "name" = "__size", "is_infix" = false }] bitvector_length(v) {
      16 => unsigned($[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat([$[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(normalized_exp, 0)], $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(normalized_sig, 9, 4))),
      32 => unsigned($[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat([$[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(normalized_exp, 0)], $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(normalized_sig, 22, 17))),
      ($[int_wildcard 64] _) => unsigned($[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat([$[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(normalized_exp, 0)], $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(normalized_sig, 51, 46)))
    };
    assert($[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(idx, 0), $[overloaded { "name" = "<", "is_infix" = true }] lt_int(idx, 128)), "./extensions/V/vext_fp_utils_insts.sail:489.29-489.30");
    let out_sig = $[overloaded { "name" = "<<", "is_infix" = true }] shiftl(to_bits_unsafe(s, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(table, $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(127, idx))), $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(s, 7));
    let out_exp = to_bits_unsafe(e, quot_round_zero($[overloaded { "name" = "-", "is_infix" = true }] sub_atom($[overloaded { "name" = "-", "is_infix" = true }] sub_atom($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(3, $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(2 ^ sub_atom(e, 1), 1)), 1), signed(normalized_exp)), 2));
    zero_extend(64, $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(sign, $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(out_exp, out_sig)))
}

val riscv_f16Rsqrte7 : (bitvector(3), bitvector(16)) -> (bitvector(5), bitvector(16))

$[complete]
function riscv_f16Rsqrte7 (rm, v) = {
    $[complete] match fp_class(v) {
      0x0001 => (nvFlag(), 0x7e00),
      0x0002 => (nvFlag(), 0x7e00),
      0x0004 => (nvFlag(), 0x7e00),
      0x0100 => (nvFlag(), 0x7e00),
      0x0200 => (zeros(5), 0x7e00),
      0x0008 => (dzFlag(), 0xfc00),
      0x0010 => (dzFlag(), 0x7c00),
      0x0080 => (zeros(5), 0x0000),
      0x0020 => (zeros(5), $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(rsqrt7(v, true), 15, 0)),
      _ => (zeros(5), $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(rsqrt7(v, false), 15, 0))
    }
}

val riscv_f32Rsqrte7 : (bitvector(3), bitvector(32)) -> (bitvector(5), bitvector(32))

$[complete]
function riscv_f32Rsqrte7 (rm, v) = {
    $[complete] match $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(fp_class(v), 15, 0) {
      0x0001 => (nvFlag(), 0x7fc00000),
      0x0002 => (nvFlag(), 0x7fc00000),
      0x0004 => (nvFlag(), 0x7fc00000),
      0x0100 => (nvFlag(), 0x7fc00000),
      0x0200 => (zeros(5), 0x7fc00000),
      0x0008 => (dzFlag(), 0xff800000),
      0x0010 => (dzFlag(), 0x7f800000),
      0x0080 => (zeros(5), 0x00000000),
      0x0020 => (zeros(5), $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(rsqrt7(v, true), 31, 0)),
      _ => (zeros(5), $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(rsqrt7(v, false), 31, 0))
    }
}

val riscv_f64Rsqrte7 : (bitvector(3), bitvector(64)) -> (bitvector(5), bitvector(64))

$[complete]
function riscv_f64Rsqrte7 (rm, v) = {
    $[complete] match $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(fp_class(v), 15, 0) {
      0x0001 => (nvFlag(), 0x7ff8000000000000),
      0x0002 => (nvFlag(), 0x7ff8000000000000),
      0x0004 => (nvFlag(), 0x7ff8000000000000),
      0x0100 => (nvFlag(), 0x7ff8000000000000),
      0x0200 => (zeros(5), 0x7ff8000000000000),
      0x0008 => (dzFlag(), 0xfff0000000000000),
      0x0010 => (dzFlag(), 0x7ff0000000000000),
      0x0080 => (zeros(5), zeros(64)),
      0x0020 => (zeros(5), $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(rsqrt7(v, true), 63, 0)),
      _ => (zeros(5), $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(rsqrt7(v, false), 63, 0))
    }
}

val recip7 : forall ('m : Int), 'm in {16, 32, 64}.
  (bitvector('m), bitvector(3), bool) -> (bool, bitvector(64))

$[complete]
function recip7 (v, rm_3b, sub) = {
    let (sig, exp, sign, e, s) : (bits(64), bits(64), bits(1), {5, 8, 11}, {10, 23, 52}) = $[complete] match $[overloaded { "name" = "__size", "is_infix" = false }] bitvector_length(v) {
      16 => (zero_extend(64, $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v, 9, 0)), zero_extend(64, $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v, 14, 10)), [$[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(v, 15)], 5, 10),
      32 => (zero_extend(64, $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v, 22, 0)), zero_extend(64, $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v, 30, 23)), [$[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(v, 31)], 8, 23),
      ($[int_wildcard 64] _) => (zero_extend(64, $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v, 51, 0)), zero_extend(64, $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v, 62, 52)), [$[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(v, 63)], 11, 52)
    };
    let table : vector(128, int) = [127, 125, 123, 121, 119, 117, 116, 114, 112, 110, 109, 107, 105, 104, 102, 100, 99, 97, 96, 94, 93, 91, 90, 88, 87, 85, 84, 83, 81, 80, 79, 77, 76, 75, 74, 72, 71, 70, 69, 68, 66, 65, 64, 63, 62, 61, 60, 59, 58, 57, 56, 55, 54, 53, 52, 51, 50, 49, 48, 47, 46, 45, 44, 43, 42, 41, 40, 40, 39, 38, 37, 36, 35, 35, 34, 33, 32, 31, 31, 30, 29, 28, 28, 27, 26, 25, 25, 24, 23, 23, 22, 21, 21, 20, 19, 19, 18, 17, 17, 16, 15, 15, 14, 14, 13, 12, 12, 11, 11, 10, 9, 9, 8, 8, 7, 7, 6, 5, 5, 4, 4, 3, 3, 2, 2, 1, 1, 0];
    let nr_leadingzeros = count_leading_zeros($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(sig, $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(s, 1), 0));
    assert($[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(nr_leadingzeros, 0), "./extensions/V/vext_fp_utils_insts.sail:569.29-569.30");
    let (normalized_exp, normalized_sig) = if sub then {
        (to_bits_unsafe(64, $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(0, nr_leadingzeros)), zero_extend(64, $[overloaded { "name" = "<<", "is_infix" = true }] shiftl($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(sig, $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(s, 1), 0), $[overloaded { "name" = "+", "is_infix" = true }] add_atom(1, nr_leadingzeros))))
    } else {
        (exp, sig)
    };
    let idx : nat = $[complete] match $[overloaded { "name" = "__size", "is_infix" = false }] bitvector_length(v) {
      16 => unsigned($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(normalized_sig, 9, 3)),
      32 => unsigned($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(normalized_sig, 22, 16)),
      ($[int_wildcard 64] _) => unsigned($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(normalized_sig, 51, 45))
    };
    assert($[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(idx, 0), $[overloaded { "name" = "<", "is_infix" = true }] lt_int(idx, 128)), "./extensions/V/vext_fp_utils_insts.sail:582.29-582.30");
    let mid_exp = to_bits_unsafe(e, $[overloaded { "name" = "-", "is_infix" = true }] sub_atom($[overloaded { "name" = "-", "is_infix" = true }] sub_atom($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(2, $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(2 ^ sub_atom(e, 1), 1)), 1), signed(normalized_exp)));
    let mid_sig = $[overloaded { "name" = "<<", "is_infix" = true }] shiftl(to_bits_unsafe(s, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(table, $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(127, idx))), $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(s, 7));
    let (out_exp, out_sig) = if $[overloaded { "name" = "==", "is_infix" = true }] eq_bits(mid_exp, zeros(e)) then {
        (mid_exp, $[overloaded { "name" = "|", "is_infix" = true }] or_vec($[overloaded { "name" = ">>", "is_infix" = true }] shiftr(mid_sig, 1), $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(0b1, zeros($[overloaded { "name" = "-", "is_infix" = true }] sub_atom(s, 1)))))
    } else if $[overloaded { "name" = "==", "is_infix" = true }] eq_bits(mid_exp, ones(e)) then {
        (zeros(e), $[overloaded { "name" = "|", "is_infix" = true }] or_vec($[overloaded { "name" = ">>", "is_infix" = true }] shiftr(mid_sig, 2), $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(0b01, zeros($[overloaded { "name" = "-", "is_infix" = true }] sub_atom(s, 2)))))
    } else (mid_exp, mid_sig);
    if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(sub, $[overloaded { "name" = ">", "is_infix" = true }] gt_int(nr_leadingzeros, 1)) then {
        if $[overloaded { "name" = "|", "is_infix" = true }] or_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_bits(rm_3b, 0b001), $[overloaded { "name" = "|", "is_infix" = true }] or_bool($[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_bits(rm_3b, 0b010), $[overloaded { "name" = "==", "is_infix" = true }] eq_bits(sign, 0b0)), $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_bits(rm_3b, 0b011), $[overloaded { "name" = "==", "is_infix" = true }] eq_bits(sign, 0b1)))) then {
            (true, zero_extend(64, $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(sign, $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(ones($[overloaded { "name" = "-", "is_infix" = true }] sub_atom(e, 1)), $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(0b0, ones(s))))))
        } else
          (true, zero_extend(64, $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(sign, $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(ones(e), zeros(s)))))
    } else
      (false, zero_extend(64, $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(sign, $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(out_exp, out_sig))))
}

val riscv_f16Recip7 : (bitvector(3), bitvector(16)) -> (bitvector(5), bitvector(16))

$[complete]
function riscv_f16Recip7 (rm, v) = {
    let (round_abnormal_true, res_true) = recip7(v, rm, true);
    let (round_abnormal_false, res_false) = recip7(v, rm, false);
    $[complete] match fp_class(v) {
      0x0001 => (zeros(5), 0x8000),
      0x0080 => (zeros(5), 0x0000),
      0x0008 => (dzFlag(), 0xfc00),
      0x0010 => (dzFlag(), 0x7c00),
      0x0100 => (nvFlag(), 0x7e00),
      0x0200 => (zeros(5), 0x7e00),
      0x0004 => if round_abnormal_true then
        ($[overloaded { "name" = "|", "is_infix" = true }] or_vec(nxFlag(), ofFlag()), $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(res_true, 15, 0))
      else
        (zeros(5), $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(res_true, 15, 0)),
      0x0020 => if round_abnormal_true then
        ($[overloaded { "name" = "|", "is_infix" = true }] or_vec(nxFlag(), ofFlag()), $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(res_true, 15, 0))
      else
        (zeros(5), $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(res_true, 15, 0)),
      _ => if round_abnormal_false then
        ($[overloaded { "name" = "|", "is_infix" = true }] or_vec(nxFlag(), ofFlag()), $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(res_false, 15, 0))
      else
        (zeros(5), $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(res_false, 15, 0))
    }
}

val riscv_f32Recip7 : (bitvector(3), bitvector(32)) -> (bitvector(5), bitvector(32))

$[complete]
function riscv_f32Recip7 (rm, v) = {
    let (round_abnormal_true, res_true) = recip7(v, rm, true);
    let (round_abnormal_false, res_false) = recip7(v, rm, false);
    $[complete] match $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(fp_class(v), 15, 0) {
      0x0001 => (zeros(5), 0x80000000),
      0x0080 => (zeros(5), 0x00000000),
      0x0008 => (dzFlag(), 0xff800000),
      0x0010 => (dzFlag(), 0x7f800000),
      0x0100 => (nvFlag(), 0x7fc00000),
      0x0200 => (zeros(5), 0x7fc00000),
      0x0004 => if round_abnormal_true then
        ($[overloaded { "name" = "|", "is_infix" = true }] or_vec(nxFlag(), ofFlag()), $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(res_true, 31, 0))
      else
        (zeros(5), $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(res_true, 31, 0)),
      0x0020 => if round_abnormal_true then
        ($[overloaded { "name" = "|", "is_infix" = true }] or_vec(nxFlag(), ofFlag()), $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(res_true, 31, 0))
      else
        (zeros(5), $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(res_true, 31, 0)),
      _ => if round_abnormal_false then
        ($[overloaded { "name" = "|", "is_infix" = true }] or_vec(nxFlag(), ofFlag()), $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(res_false, 31, 0))
      else
        (zeros(5), $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(res_false, 31, 0))
    }
}

val riscv_f64Recip7 : (bitvector(3), bitvector(64)) -> (bitvector(5), bitvector(64))

$[complete]
function riscv_f64Recip7 (rm, v) = {
    let (round_abnormal_true, res_true) = recip7(v, rm, true);
    let (round_abnormal_false, res_false) = recip7(v, rm, false);
    $[complete] match $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(fp_class(v), 15, 0) {
      0x0001 => (zeros(5), 0x8000000000000000),
      0x0080 => (zeros(5), 0x0000000000000000),
      0x0008 => (dzFlag(), 0xfff0000000000000),
      0x0010 => (dzFlag(), 0x7ff0000000000000),
      0x0100 => (nvFlag(), 0x7ff8000000000000),
      0x0200 => (zeros(5), 0x7ff8000000000000),
      0x0004 => if round_abnormal_true then
        ($[overloaded { "name" = "|", "is_infix" = true }] or_vec(nxFlag(), ofFlag()), $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(res_true, 63, 0))
      else
        (zeros(5), $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(res_true, 63, 0)),
      0x0020 => if round_abnormal_true then
        ($[overloaded { "name" = "|", "is_infix" = true }] or_vec(nxFlag(), ofFlag()), $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(res_true, 63, 0))
      else
        (zeros(5), $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(res_true, 63, 0)),
      _ => if round_abnormal_false then
        ($[overloaded { "name" = "|", "is_infix" = true }] or_vec(nxFlag(), ofFlag()), $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(res_false, 63, 0))
      else
        (zeros(5), $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(res_false, 63, 0))
    }
}

val sew_flag : string <-> bitvector(3)

mapping sew_flag = {
  "e8" <-> 0b000,
  "e16" <-> 0b001,
  "e32" <-> 0b010,
  "e64" <-> 0b011
}

val maybe_lmul_flag : string <-> bitvector(3)

mapping maybe_lmul_flag = {
  sep(()) ^ "mf8" <-> 0b101,
  sep(()) ^ "mf4" <-> 0b110,
  sep(()) ^ "mf2" <-> 0b111,
  sep(()) ^ "m1" <-> 0b000,
  sep(()) ^ "m2" <-> 0b001,
  sep(()) ^ "m4" <-> 0b010,
  sep(()) ^ "m8" <-> 0b011,
  forwards "" => 0b000
}

val ta_flag : string <-> bitvector(1)

mapping ta_flag = {
  sep(()) ^ "ta" <-> 0b1,
  sep(()) ^ "tu" <-> 0b0
}

val ma_flag : string <-> bitvector(1)

mapping ma_flag = {
  sep(()) ^ "ma" <-> 0b1,
  sep(()) ^ "mu" <-> 0b0
}

val vtype_assembly : string <-> (bitvector(1), bitvector(1), bitvector(3), bitvector(3))

mapping vtype_assembly = {
  sew_flag(sew) ^ maybe_lmul_flag(lmul) ^ ta_flag(ta) ^ ma_flag(ma) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "!=", "is_infix" = true }] neq_anything($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(sew, 2), bitone), $[overloaded { "name" = "!=", "is_infix" = true }] neq_bits(lmul, 0b100)) <-> (ma, ta, sew, lmul) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "!=", "is_infix" = true }] neq_anything($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(sew, 2), bitone), $[overloaded { "name" = "!=", "is_infix" = true }] neq_bits(lmul, 0b100)),
  hex_bits_8((ma : bitvector(1)) @ (ta : bitvector(1)) @ (sew : bitvector(3)) @ (lmul : bitvector(3))) <-> (ma, ta, sew, lmul)
}

val handle_illegal_vtype : unit -> unit

$[complete]
function handle_illegal_vtype () = {
    vtype.bits = $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(0b1, zeros($[overloaded { "name" = "-", "is_infix" = true }] sub_atom(xlen, 1)));
    vl = zeros(sizeof(xlen));
    $[overloaded { "name" = "csr_write_callback", "is_infix" = false }] csr_name_write_callback("vtype", vtype.bits);
    $[overloaded { "name" = "csr_write_callback", "is_infix" = false }] csr_name_write_callback("vl", vl);
    set_vstart(zeros(16))
}

let vl_use_ceil : bool = config extensions.V.vl_use_ceil

val calculate_new_vl : (int, int) -> bitvector(xlen)

$[complete]
function calculate_new_vl (AVL : int, VLMAX : int) = {
    let new_vl = if $[overloaded { "name" = "<=", "is_infix" = true }] lteq_int(AVL, VLMAX) then
      AVL
    else
      if $[overloaded { "name" = "<", "is_infix" = true }] lt_int(AVL, $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(2, VLMAX)) then {
          if vl_use_ceil then
            $[overloaded { "name" = "/", "is_infix" = true }] quot_positive_round_zero($[overloaded { "name" = "+", "is_infix" = true }] add_atom(AVL, 1), 2)
          else
            VLMAX
      } else VLMAX;
    to_bits_unsafe(xlen, new_vl)
}

val encdec_vvfunct6 : vvfunct6 <-> bitvector(6)

mapping encdec_vvfunct6 = {
  VV_VADD <-> 0b000000,
  VV_VSUB <-> 0b000010,
  VV_VMINU <-> 0b000100,
  VV_VMIN <-> 0b000101,
  VV_VMAXU <-> 0b000110,
  VV_VMAX <-> 0b000111,
  VV_VAND <-> 0b001001,
  VV_VOR <-> 0b001010,
  VV_VXOR <-> 0b001011,
  VV_VRGATHER <-> 0b001100,
  VV_VRGATHEREI16 <-> 0b001110,
  VV_VSADDU <-> 0b100000,
  VV_VSADD <-> 0b100001,
  VV_VSSUBU <-> 0b100010,
  VV_VSSUB <-> 0b100011,
  VV_VSLL <-> 0b100101,
  VV_VSMUL <-> 0b100111,
  VV_VSRL <-> 0b101000,
  VV_VSRA <-> 0b101001,
  VV_VSSRL <-> 0b101010,
  VV_VSSRA <-> 0b101011
}

val vvtype_mnemonic : vvfunct6 <-> string

mapping vvtype_mnemonic = {
  VV_VADD <-> "vadd.vv",
  VV_VSUB <-> "vsub.vv",
  VV_VAND <-> "vand.vv",
  VV_VOR <-> "vor.vv",
  VV_VXOR <-> "vxor.vv",
  VV_VRGATHER <-> "vrgather.vv",
  VV_VRGATHEREI16 <-> "vrgatherei16.vv",
  VV_VSADDU <-> "vsaddu.vv",
  VV_VSADD <-> "vsadd.vv",
  VV_VSSUBU <-> "vssubu.vv",
  VV_VSSUB <-> "vssub.vv",
  VV_VSLL <-> "vsll.vv",
  VV_VSMUL <-> "vsmul.vv",
  VV_VSRL <-> "vsrl.vv",
  VV_VSRA <-> "vsra.vv",
  VV_VSSRL <-> "vssrl.vv",
  VV_VSSRA <-> "vssra.vv",
  VV_VMINU <-> "vminu.vv",
  VV_VMIN <-> "vmin.vv",
  VV_VMAXU <-> "vmaxu.vv",
  VV_VMAX <-> "vmax.vv"
}

val encdec_nvsfunct6 : nvsfunct6 <-> bitvector(6)

mapping encdec_nvsfunct6 = {
  NVS_VNSRL <-> 0b101100,
  NVS_VNSRA <-> 0b101101
}

val nvstype_mnemonic : nvsfunct6 <-> string

mapping nvstype_mnemonic = {
  NVS_VNSRL <-> "vnsrl.wv",
  NVS_VNSRA <-> "vnsra.wv"
}

val encdec_nvfunct6 : nvfunct6 <-> bitvector(6)

mapping encdec_nvfunct6 = {
  NV_VNCLIPU <-> 0b101110,
  NV_VNCLIP <-> 0b101111
}

val nvtype_mnemonic : nvfunct6 <-> string

mapping nvtype_mnemonic = {
  NV_VNCLIPU <-> "vnclipu.wv",
  NV_VNCLIP <-> "vnclip.wv"
}

val encdec_vxfunct6 : vxfunct6 <-> bitvector(6)

mapping encdec_vxfunct6 = {
  VX_VADD <-> 0b000000,
  VX_VSUB <-> 0b000010,
  VX_VRSUB <-> 0b000011,
  VX_VMINU <-> 0b000100,
  VX_VMIN <-> 0b000101,
  VX_VMAXU <-> 0b000110,
  VX_VMAX <-> 0b000111,
  VX_VAND <-> 0b001001,
  VX_VOR <-> 0b001010,
  VX_VXOR <-> 0b001011,
  VX_VSADDU <-> 0b100000,
  VX_VSADD <-> 0b100001,
  VX_VSSUBU <-> 0b100010,
  VX_VSSUB <-> 0b100011,
  VX_VSLL <-> 0b100101,
  VX_VSMUL <-> 0b100111,
  VX_VSRL <-> 0b101000,
  VX_VSRA <-> 0b101001,
  VX_VSSRL <-> 0b101010,
  VX_VSSRA <-> 0b101011
}

val vxtype_mnemonic : vxfunct6 <-> string

mapping vxtype_mnemonic = {
  VX_VADD <-> "vadd.vx",
  VX_VSUB <-> "vsub.vx",
  VX_VRSUB <-> "vrsub.vx",
  VX_VAND <-> "vand.vx",
  VX_VOR <-> "vor.vx",
  VX_VXOR <-> "vxor.vx",
  VX_VSADDU <-> "vsaddu.vx",
  VX_VSADD <-> "vsadd.vx",
  VX_VSSUBU <-> "vssubu.vx",
  VX_VSSUB <-> "vssub.vx",
  VX_VSLL <-> "vsll.vx",
  VX_VSMUL <-> "vsmul.vx",
  VX_VSRL <-> "vsrl.vx",
  VX_VSRA <-> "vsra.vx",
  VX_VSSRL <-> "vssrl.vx",
  VX_VSSRA <-> "vssra.vx",
  VX_VMINU <-> "vminu.vx",
  VX_VMIN <-> "vmin.vx",
  VX_VMAXU <-> "vmaxu.vx",
  VX_VMAX <-> "vmax.vx"
}

val encdec_nxsfunct6 : nxsfunct6 <-> bitvector(6)

mapping encdec_nxsfunct6 = {
  NXS_VNSRL <-> 0b101100,
  NXS_VNSRA <-> 0b101101
}

val nxstype_mnemonic : nxsfunct6 <-> string

mapping nxstype_mnemonic = {
  NXS_VNSRL <-> "vnsrl.wx",
  NXS_VNSRA <-> "vnsra.wx"
}

val encdec_nxfunct6 : nxfunct6 <-> bitvector(6)

mapping encdec_nxfunct6 = {
  NX_VNCLIPU <-> 0b101110,
  NX_VNCLIP <-> 0b101111
}

val nxtype_mnemonic : nxfunct6 <-> string

mapping nxtype_mnemonic = {
  NX_VNCLIPU <-> "vnclipu.wx",
  NX_VNCLIP <-> "vnclip.wx"
}

val encdec_vxsgfunct6 : vxsgfunct6 <-> bitvector(6)

mapping encdec_vxsgfunct6 = {
  VX_VSLIDEUP <-> 0b001110,
  VX_VSLIDEDOWN <-> 0b001111,
  VX_VRGATHER <-> 0b001100
}

val vxsg_mnemonic : vxsgfunct6 <-> string

mapping vxsg_mnemonic = {
  VX_VSLIDEUP <-> "vslideup.vx",
  VX_VSLIDEDOWN <-> "vslidedown.vx",
  VX_VRGATHER <-> "vrgather.vx"
}

val encdec_vifunct6 : vifunct6 <-> bitvector(6)

mapping encdec_vifunct6 = {
  VI_VADD <-> 0b000000,
  VI_VRSUB <-> 0b000011,
  VI_VAND <-> 0b001001,
  VI_VOR <-> 0b001010,
  VI_VXOR <-> 0b001011,
  VI_VSADDU <-> 0b100000,
  VI_VSADD <-> 0b100001,
  VI_VSLL <-> 0b100101,
  VI_VSRL <-> 0b101000,
  VI_VSRA <-> 0b101001,
  VI_VSSRL <-> 0b101010,
  VI_VSSRA <-> 0b101011
}

val vitype_mnemonic : vifunct6 <-> string

mapping vitype_mnemonic = {
  VI_VADD <-> "vadd.vi",
  VI_VRSUB <-> "vrsub.vi",
  VI_VAND <-> "vand.vi",
  VI_VOR <-> "vor.vi",
  VI_VXOR <-> "vxor.vi",
  VI_VSADDU <-> "vsaddu.vi",
  VI_VSADD <-> "vsadd.vi",
  VI_VSLL <-> "vsll.vi",
  VI_VSRL <-> "vsrl.vi",
  VI_VSRA <-> "vsra.vi",
  VI_VSSRL <-> "vssrl.vi",
  VI_VSSRA <-> "vssra.vi"
}

val encdec_nisfunct6 : nisfunct6 <-> bitvector(6)

mapping encdec_nisfunct6 = {
  NIS_VNSRL <-> 0b101100,
  NIS_VNSRA <-> 0b101101
}

val nistype_mnemonic : nisfunct6 <-> string

mapping nistype_mnemonic = {
  NIS_VNSRL <-> "vnsrl.wi",
  NIS_VNSRA <-> "vnsra.wi"
}

val encdec_nifunct6 : nifunct6 <-> bitvector(6)

mapping encdec_nifunct6 = {
  NI_VNCLIPU <-> 0b101110,
  NI_VNCLIP <-> 0b101111
}

val nitype_mnemonic : nifunct6 <-> string

mapping nitype_mnemonic = {
  NI_VNCLIPU <-> "vnclipu.wi",
  NI_VNCLIP <-> "vnclip.wi"
}

val encdec_visgfunct6 : visgfunct6 <-> bitvector(6)

mapping encdec_visgfunct6 = {
  VI_VSLIDEUP <-> 0b001110,
  VI_VSLIDEDOWN <-> 0b001111,
  VI_VRGATHER <-> 0b001100
}

val visg_mnemonic : visgfunct6 <-> string

mapping visg_mnemonic = {
  VI_VSLIDEUP <-> "vslideup.vi",
  VI_VSLIDEDOWN <-> "vslidedown.vi",
  VI_VRGATHER <-> "vrgather.vi"
}

val encdec_nreg : bitvector(5) <-> {1, 2, 4, 8}

mapping encdec_nreg = {
  0b00000 <-> 1,
  0b00001 <-> 2,
  0b00011 <-> 4,
  0b00111 <-> 8
}

val nreg_string : {1, 2, 4, 8} <-> string

mapping nreg_string = {
  1 <-> "1",
  2 <-> "2",
  4 <-> "4",
  8 <-> "8"
}

val encdec_mvvfunct6 : mvvfunct6 <-> bitvector(6)

mapping encdec_mvvfunct6 = {
  MVV_VAADDU <-> 0b001000,
  MVV_VAADD <-> 0b001001,
  MVV_VASUBU <-> 0b001010,
  MVV_VASUB <-> 0b001011,
  MVV_VMUL <-> 0b100101,
  MVV_VMULH <-> 0b100111,
  MVV_VMULHU <-> 0b100100,
  MVV_VMULHSU <-> 0b100110,
  MVV_VDIVU <-> 0b100000,
  MVV_VDIV <-> 0b100001,
  MVV_VREMU <-> 0b100010,
  MVV_VREM <-> 0b100011
}

val mvvtype_mnemonic : mvvfunct6 <-> string

mapping mvvtype_mnemonic = {
  MVV_VAADDU <-> "vaaddu.vv",
  MVV_VAADD <-> "vaadd.vv",
  MVV_VASUBU <-> "vasubu.vv",
  MVV_VASUB <-> "vasub.vv",
  MVV_VMUL <-> "vmul.vv",
  MVV_VMULH <-> "vmulh.vv",
  MVV_VMULHU <-> "vmulhu.vv",
  MVV_VMULHSU <-> "vmulhsu.vv",
  MVV_VDIVU <-> "vdivu.vv",
  MVV_VDIV <-> "vdiv.vv",
  MVV_VREMU <-> "vremu.vv",
  MVV_VREM <-> "vrem.vv"
}

val encdec_mvvmafunct6 : mvvmafunct6 <-> bitvector(6)

mapping encdec_mvvmafunct6 = {
  MVV_VMACC <-> 0b101101,
  MVV_VNMSAC <-> 0b101111,
  MVV_VMADD <-> 0b101001,
  MVV_VNMSUB <-> 0b101011
}

val mvvmatype_mnemonic : mvvmafunct6 <-> string

mapping mvvmatype_mnemonic = {
  MVV_VMACC <-> "vmacc.vv",
  MVV_VNMSAC <-> "vnmsac.vv",
  MVV_VMADD <-> "vmadd.vv",
  MVV_VNMSUB <-> "vnmsub.vv"
}

val encdec_wvvfunct6 : wvvfunct6 <-> bitvector(6)

mapping encdec_wvvfunct6 = {
  WVV_VADD <-> 0b110001,
  WVV_VSUB <-> 0b110011,
  WVV_VADDU <-> 0b110000,
  WVV_VSUBU <-> 0b110010,
  WVV_VWMUL <-> 0b111011,
  WVV_VWMULU <-> 0b111000,
  WVV_VWMULSU <-> 0b111010
}

val wvvtype_mnemonic : wvvfunct6 <-> string

mapping wvvtype_mnemonic = {
  WVV_VADD <-> "vwadd.vv",
  WVV_VSUB <-> "vwsub.vv",
  WVV_VADDU <-> "vwaddu.vv",
  WVV_VSUBU <-> "vwsubu.vv",
  WVV_VWMUL <-> "vwmul.vv",
  WVV_VWMULU <-> "vwmulu.vv",
  WVV_VWMULSU <-> "vwmulsu.vv"
}

val encdec_wvfunct6 : wvfunct6 <-> bitvector(6)

mapping encdec_wvfunct6 = {
  WV_VADD <-> 0b110101,
  WV_VSUB <-> 0b110111,
  WV_VADDU <-> 0b110100,
  WV_VSUBU <-> 0b110110
}

val wvtype_mnemonic : wvfunct6 <-> string

mapping wvtype_mnemonic = {
  WV_VADD <-> "vwadd.wv",
  WV_VSUB <-> "vwsub.wv",
  WV_VADDU <-> "vwaddu.wv",
  WV_VSUBU <-> "vwsubu.wv"
}

val encdec_wmvvfunct6 : wmvvfunct6 <-> bitvector(6)

mapping encdec_wmvvfunct6 = {
  WMVV_VWMACCU <-> 0b111100,
  WMVV_VWMACC <-> 0b111101,
  WMVV_VWMACCSU <-> 0b111111
}

val wmvvtype_mnemonic : wmvvfunct6 <-> string

mapping wmvvtype_mnemonic = {
  WMVV_VWMACCU <-> "vwmaccu.vv",
  WMVV_VWMACC <-> "vwmacc.vv",
  WMVV_VWMACCSU <-> "vwmaccsu.vv"
}

val vext_vs1 : vextfunct6 <-> bitvector(5)

mapping vext_vs1 = {
  VEXT2_ZVF2 <-> 0b00110,
  VEXT2_SVF2 <-> 0b00111,
  VEXT4_ZVF4 <-> 0b00100,
  VEXT4_SVF4 <-> 0b00101,
  VEXT8_ZVF8 <-> 0b00010,
  VEXT8_SVF8 <-> 0b00011
}

val vexttype_mnemonic : vextfunct6 <-> string

mapping vexttype_mnemonic = {
  VEXT2_ZVF2 <-> "vzext.vf2",
  VEXT2_SVF2 <-> "vsext.vf2",
  VEXT4_ZVF4 <-> "vzext.vf4",
  VEXT4_SVF4 <-> "vsext.vf4",
  VEXT8_ZVF8 <-> "vzext.vf8",
  VEXT8_SVF8 <-> "vsext.vf8"
}

val encdec_mvxfunct6 : mvxfunct6 <-> bitvector(6)

mapping encdec_mvxfunct6 = {
  MVX_VAADDU <-> 0b001000,
  MVX_VAADD <-> 0b001001,
  MVX_VASUBU <-> 0b001010,
  MVX_VASUB <-> 0b001011,
  MVX_VSLIDE1UP <-> 0b001110,
  MVX_VSLIDE1DOWN <-> 0b001111,
  MVX_VMUL <-> 0b100101,
  MVX_VMULH <-> 0b100111,
  MVX_VMULHU <-> 0b100100,
  MVX_VMULHSU <-> 0b100110,
  MVX_VDIVU <-> 0b100000,
  MVX_VDIV <-> 0b100001,
  MVX_VREMU <-> 0b100010,
  MVX_VREM <-> 0b100011
}

val mvxtype_mnemonic : mvxfunct6 <-> string

mapping mvxtype_mnemonic = {
  MVX_VAADDU <-> "vaaddu.vx",
  MVX_VAADD <-> "vaadd.vx",
  MVX_VASUBU <-> "vasubu.vx",
  MVX_VASUB <-> "vasub.vx",
  MVX_VSLIDE1UP <-> "vslide1up.vx",
  MVX_VSLIDE1DOWN <-> "vslide1down.vx",
  MVX_VMUL <-> "vmul.vx",
  MVX_VMULH <-> "vmulh.vx",
  MVX_VMULHU <-> "vmulhu.vx",
  MVX_VMULHSU <-> "vmulhsu.vx",
  MVX_VDIVU <-> "vdivu.vx",
  MVX_VDIV <-> "vdiv.vx",
  MVX_VREMU <-> "vremu.vx",
  MVX_VREM <-> "vrem.vx"
}

val encdec_mvxmafunct6 : mvxmafunct6 <-> bitvector(6)

mapping encdec_mvxmafunct6 = {
  MVX_VMACC <-> 0b101101,
  MVX_VNMSAC <-> 0b101111,
  MVX_VMADD <-> 0b101001,
  MVX_VNMSUB <-> 0b101011
}

val mvxmatype_mnemonic : mvxmafunct6 <-> string

mapping mvxmatype_mnemonic = {
  MVX_VMACC <-> "vmacc.vx",
  MVX_VNMSAC <-> "vnmsac.vx",
  MVX_VMADD <-> "vmadd.vx",
  MVX_VNMSUB <-> "vnmsub.vx"
}

val encdec_wvxfunct6 : wvxfunct6 <-> bitvector(6)

mapping encdec_wvxfunct6 = {
  WVX_VADD <-> 0b110001,
  WVX_VSUB <-> 0b110011,
  WVX_VADDU <-> 0b110000,
  WVX_VSUBU <-> 0b110010,
  WVX_VWMUL <-> 0b111011,
  WVX_VWMULU <-> 0b111000,
  WVX_VWMULSU <-> 0b111010
}

val wvxtype_mnemonic : wvxfunct6 <-> string

mapping wvxtype_mnemonic = {
  WVX_VADD <-> "vwadd.vx",
  WVX_VSUB <-> "vwsub.vx",
  WVX_VADDU <-> "vwaddu.vx",
  WVX_VSUBU <-> "vwsubu.vx",
  WVX_VWMUL <-> "vwmul.vx",
  WVX_VWMULU <-> "vwmulu.vx",
  WVX_VWMULSU <-> "vwmulsu.vx"
}

val encdec_wxfunct6 : wxfunct6 <-> bitvector(6)

mapping encdec_wxfunct6 = {
  WX_VADD <-> 0b110101,
  WX_VSUB <-> 0b110111,
  WX_VADDU <-> 0b110100,
  WX_VSUBU <-> 0b110110
}

val wxtype_mnemonic : wxfunct6 <-> string

mapping wxtype_mnemonic = {
  WX_VADD <-> "vwadd.wx",
  WX_VSUB <-> "vwsub.wx",
  WX_VADDU <-> "vwaddu.wx",
  WX_VSUBU <-> "vwsubu.wx"
}

val encdec_wmvxfunct6 : wmvxfunct6 <-> bitvector(6)

mapping encdec_wmvxfunct6 = {
  WMVX_VWMACCU <-> 0b111100,
  WMVX_VWMACC <-> 0b111101,
  WMVX_VWMACCUS <-> 0b111110,
  WMVX_VWMACCSU <-> 0b111111
}

val wmvxtype_mnemonic : wmvxfunct6 <-> string

mapping wmvxtype_mnemonic = {
  WMVX_VWMACCU <-> "vwmaccu.vx",
  WMVX_VWMACC <-> "vwmacc.vx",
  WMVX_VWMACCUS <-> "vwmaccus.vx",
  WMVX_VWMACCSU <-> "vwmaccsu.vx"
}

val encdec_fvvfunct6 : fvvfunct6 <-> bitvector(6)

mapping encdec_fvvfunct6 = {
  FVV_VADD <-> 0b000000,
  FVV_VSUB <-> 0b000010,
  FVV_VMIN <-> 0b000100,
  FVV_VMAX <-> 0b000110,
  FVV_VSGNJ <-> 0b001000,
  FVV_VSGNJN <-> 0b001001,
  FVV_VSGNJX <-> 0b001010,
  FVV_VDIV <-> 0b100000,
  FVV_VMUL <-> 0b100100
}

val fvvtype_mnemonic : fvvfunct6 <-> string

mapping fvvtype_mnemonic = {
  FVV_VADD <-> "vfadd.vv",
  FVV_VSUB <-> "vfsub.vv",
  FVV_VMIN <-> "vfmin.vv",
  FVV_VMAX <-> "vfmax.vv",
  FVV_VSGNJ <-> "vfsgnj.vv",
  FVV_VSGNJN <-> "vfsgnjn.vv",
  FVV_VSGNJX <-> "vfsgnjx.vv",
  FVV_VDIV <-> "vfdiv.vv",
  FVV_VMUL <-> "vfmul.vv"
}

val encdec_fvvmafunct6 : fvvmafunct6 <-> bitvector(6)

mapping encdec_fvvmafunct6 = {
  FVV_VMADD <-> 0b101000,
  FVV_VNMADD <-> 0b101001,
  FVV_VMSUB <-> 0b101010,
  FVV_VNMSUB <-> 0b101011,
  FVV_VMACC <-> 0b101100,
  FVV_VNMACC <-> 0b101101,
  FVV_VMSAC <-> 0b101110,
  FVV_VNMSAC <-> 0b101111
}

val fvvmatype_mnemonic : fvvmafunct6 <-> string

mapping fvvmatype_mnemonic = {
  FVV_VMADD <-> "vfmadd.vv",
  FVV_VNMADD <-> "vfnmadd.vv",
  FVV_VMSUB <-> "vfmsub.vv",
  FVV_VNMSUB <-> "vfnmsub.vv",
  FVV_VMACC <-> "vfmacc.vv",
  FVV_VNMACC <-> "vfnmacc.vv",
  FVV_VMSAC <-> "vfmsac.vv",
  FVV_VNMSAC <-> "vfnmsac.vv"
}

val encdec_fwvvfunct6 : fwvvfunct6 <-> bitvector(6)

mapping encdec_fwvvfunct6 = {
  FWVV_VADD <-> 0b110000,
  FWVV_VSUB <-> 0b110010,
  FWVV_VMUL <-> 0b111000
}

val fwvvtype_mnemonic : fwvvfunct6 <-> string

mapping fwvvtype_mnemonic = {
  FWVV_VADD <-> "vfwadd.vv",
  FWVV_VSUB <-> "vfwsub.vv",
  FWVV_VMUL <-> "vfwmul.vv"
}

val encdec_fwvvmafunct6 : fwvvmafunct6 <-> bitvector(6)

mapping encdec_fwvvmafunct6 = {
  FWVV_VMACC <-> 0b111100,
  FWVV_VNMACC <-> 0b111101,
  FWVV_VMSAC <-> 0b111110,
  FWVV_VNMSAC <-> 0b111111
}

val fwvvmatype_mnemonic : fwvvmafunct6 <-> string

mapping fwvvmatype_mnemonic = {
  FWVV_VMACC <-> "vfwmacc.vv",
  FWVV_VNMACC <-> "vfwnmacc.vv",
  FWVV_VMSAC <-> "vfwmsac.vv",
  FWVV_VNMSAC <-> "vfwnmsac.vv"
}

val encdec_fwvfunct6 : fwvfunct6 <-> bitvector(6)

mapping encdec_fwvfunct6 = {
  FWV_VADD <-> 0b110100,
  FWV_VSUB <-> 0b110110
}

val fwvtype_mnemonic : fwvfunct6 <-> string

mapping fwvtype_mnemonic = {
  FWV_VADD <-> "vfwadd.wv",
  FWV_VSUB <-> "vfwsub.wv"
}

val encdec_vfunary0_vs1 : vfunary0 <-> bitvector(5)

mapping encdec_vfunary0_vs1 = {
  FV_CVT_XU_F <-> 0b00000,
  FV_CVT_X_F <-> 0b00001,
  FV_CVT_F_XU <-> 0b00010,
  FV_CVT_F_X <-> 0b00011,
  FV_CVT_RTZ_XU_F <-> 0b00110,
  FV_CVT_RTZ_X_F <-> 0b00111
}

val vfunary0_mnemonic : vfunary0 <-> string

mapping vfunary0_mnemonic = {
  FV_CVT_XU_F <-> "vfcvt.xu.f.v",
  FV_CVT_X_F <-> "vfcvt.x.f.v",
  FV_CVT_F_XU <-> "vfcvt.f.xu.v",
  FV_CVT_F_X <-> "vfcvt.f.x.v",
  FV_CVT_RTZ_XU_F <-> "vfcvt.rtz.xu.f.v",
  FV_CVT_RTZ_X_F <-> "vfcvt.rtz.x.f.v"
}

val encdec_vfwunary0_vs1 : vfwunary0 <-> bitvector(5)

mapping encdec_vfwunary0_vs1 = {
  FWV_CVT_XU_F <-> 0b01000,
  FWV_CVT_X_F <-> 0b01001,
  FWV_CVT_F_XU <-> 0b01010,
  FWV_CVT_F_X <-> 0b01011,
  FWV_CVT_F_F <-> 0b01100,
  FWV_CVT_RTZ_XU_F <-> 0b01110,
  FWV_CVT_RTZ_X_F <-> 0b01111
}

val vfwunary0_mnemonic : vfwunary0 <-> string

mapping vfwunary0_mnemonic = {
  FWV_CVT_XU_F <-> "vfwcvt.xu.f.v",
  FWV_CVT_X_F <-> "vfwcvt.x.f.v",
  FWV_CVT_F_XU <-> "vfwcvt.f.xu.v",
  FWV_CVT_F_X <-> "vfwcvt.f.x.v",
  FWV_CVT_F_F <-> "vfwcvt.f.f.v",
  FWV_CVT_RTZ_XU_F <-> "vfwcvt.rtz.xu.f.v",
  FWV_CVT_RTZ_X_F <-> "vfwcvt.rtz.x.f.v"
}

val encdec_vfnunary0_vs1 : vfnunary0 <-> bitvector(5)

mapping encdec_vfnunary0_vs1 = {
  FNV_CVT_XU_F <-> 0b10000,
  FNV_CVT_X_F <-> 0b10001,
  FNV_CVT_F_XU <-> 0b10010,
  FNV_CVT_F_X <-> 0b10011,
  FNV_CVT_F_F <-> 0b10100,
  FNV_CVT_ROD_F_F <-> 0b10101,
  FNV_CVT_RTZ_XU_F <-> 0b10110,
  FNV_CVT_RTZ_X_F <-> 0b10111
}

val vfnunary0_mnemonic : vfnunary0 <-> string

mapping vfnunary0_mnemonic = {
  FNV_CVT_XU_F <-> "vfncvt.xu.f.w",
  FNV_CVT_X_F <-> "vfncvt.x.f.w",
  FNV_CVT_F_XU <-> "vfncvt.f.xu.w",
  FNV_CVT_F_X <-> "vfncvt.f.x.w",
  FNV_CVT_F_F <-> "vfncvt.f.f.w",
  FNV_CVT_ROD_F_F <-> "vfncvt.rod.f.f.w",
  FNV_CVT_RTZ_XU_F <-> "vfncvt.rtz.xu.f.w",
  FNV_CVT_RTZ_X_F <-> "vfncvt.rtz.x.f.w"
}

val encdec_vfunary1_vs1 : vfunary1 <-> bitvector(5)

mapping encdec_vfunary1_vs1 = {
  FVV_VSQRT <-> 0b00000,
  FVV_VRSQRT7 <-> 0b00100,
  FVV_VREC7 <-> 0b00101,
  FVV_VCLASS <-> 0b10000
}

val vfunary1_mnemonic : vfunary1 <-> string

mapping vfunary1_mnemonic = {
  FVV_VSQRT <-> "vfsqrt.v",
  FVV_VRSQRT7 <-> "vfrsqrt7.v",
  FVV_VREC7 <-> "vfrec7.v",
  FVV_VCLASS <-> "vfclass.v"
}

val encdec_fvffunct6 : fvffunct6 <-> bitvector(6)

mapping encdec_fvffunct6 = {
  VF_VADD <-> 0b000000,
  VF_VSUB <-> 0b000010,
  VF_VMIN <-> 0b000100,
  VF_VMAX <-> 0b000110,
  VF_VSGNJ <-> 0b001000,
  VF_VSGNJN <-> 0b001001,
  VF_VSGNJX <-> 0b001010,
  VF_VSLIDE1UP <-> 0b001110,
  VF_VSLIDE1DOWN <-> 0b001111,
  VF_VDIV <-> 0b100000,
  VF_VRDIV <-> 0b100001,
  VF_VMUL <-> 0b100100,
  VF_VRSUB <-> 0b100111
}

val fvftype_mnemonic : fvffunct6 <-> string

mapping fvftype_mnemonic = {
  VF_VADD <-> "vfadd.vf",
  VF_VSUB <-> "vfsub.vf",
  VF_VMIN <-> "vfmin.vf",
  VF_VMAX <-> "vfmax.vf",
  VF_VSGNJ <-> "vfsgnj.vf",
  VF_VSGNJN <-> "vfsgnjn.vf",
  VF_VSGNJX <-> "vfsgnjx.vf",
  VF_VSLIDE1UP <-> "vfslide1up.vf",
  VF_VSLIDE1DOWN <-> "vfslide1down.vf",
  VF_VDIV <-> "vfdiv.vf",
  VF_VRDIV <-> "vfrdiv.vf",
  VF_VMUL <-> "vfmul.vf",
  VF_VRSUB <-> "vfrsub.vf"
}

val encdec_fvfmafunct6 : fvfmafunct6 <-> bitvector(6)

mapping encdec_fvfmafunct6 = {
  VF_VMADD <-> 0b101000,
  VF_VNMADD <-> 0b101001,
  VF_VMSUB <-> 0b101010,
  VF_VNMSUB <-> 0b101011,
  VF_VMACC <-> 0b101100,
  VF_VNMACC <-> 0b101101,
  VF_VMSAC <-> 0b101110,
  VF_VNMSAC <-> 0b101111
}

val fvfmatype_mnemonic : fvfmafunct6 <-> string

mapping fvfmatype_mnemonic = {
  VF_VMADD <-> "vfmadd.vf",
  VF_VNMADD <-> "vfnmadd.vf",
  VF_VMSUB <-> "vfmsub.vf",
  VF_VNMSUB <-> "vfnmsub.vf",
  VF_VMACC <-> "vfmacc.vf",
  VF_VNMACC <-> "vfnmacc.vf",
  VF_VMSAC <-> "vfmsac.vf",
  VF_VNMSAC <-> "vfnmsac.vf"
}

val encdec_fwvffunct6 : fwvffunct6 <-> bitvector(6)

mapping encdec_fwvffunct6 = {
  FWVF_VADD <-> 0b110000,
  FWVF_VSUB <-> 0b110010,
  FWVF_VMUL <-> 0b111000
}

val fwvftype_mnemonic : fwvffunct6 <-> string

mapping fwvftype_mnemonic = {
  FWVF_VADD <-> "vfwadd.vf",
  FWVF_VSUB <-> "vfwsub.vf",
  FWVF_VMUL <-> "vfwmul.vf"
}

val encdec_fwvfmafunct6 : fwvfmafunct6 <-> bitvector(6)

mapping encdec_fwvfmafunct6 = {
  FWVF_VMACC <-> 0b111100,
  FWVF_VNMACC <-> 0b111101,
  FWVF_VMSAC <-> 0b111110,
  FWVF_VNMSAC <-> 0b111111
}

val fwvfmatype_mnemonic : fwvfmafunct6 <-> string

mapping fwvfmatype_mnemonic = {
  FWVF_VMACC <-> "vfwmacc.vf",
  FWVF_VNMACC <-> "vfwnmacc.vf",
  FWVF_VMSAC <-> "vfwmsac.vf",
  FWVF_VNMSAC <-> "vfwnmsac.vf"
}

val encdec_fwffunct6 : fwffunct6 <-> bitvector(6)

mapping encdec_fwffunct6 = {
  FWF_VADD <-> 0b110100,
  FWF_VSUB <-> 0b110110
}

val fwftype_mnemonic : fwffunct6 <-> string

mapping fwftype_mnemonic = {
  FWF_VADD <-> "vfwadd.wf",
  FWF_VSUB <-> "vfwsub.wf"
}

val vlewidth_bitsnumberstr : vlewidth <-> string

mapping vlewidth_bitsnumberstr = {
  VLE8 <-> "8",
  VLE16 <-> "16",
  VLE32 <-> "32",
  VLE64 <-> "64"
}

val encdec_vlewidth : vlewidth <-> bitvector(3)

mapping encdec_vlewidth = {
  VLE8 <-> 0b000,
  VLE16 <-> 0b101,
  VLE32 <-> 0b110,
  VLE64 <-> 0b111
}

val vlewidth_pow : vlewidth <-> {3, 4, 5, 6}

mapping vlewidth_pow = {
  VLE8 <-> 3,
  VLE16 <-> 4,
  VLE32 <-> 5,
  VLE64 <-> 6
}

val process_vlseg : ({('q : Int), ('q > 0 & 'q <= 8). int('q)}, bitvector(1), vregidx, {1, 2, 4, 8}, regidx, int, {('n : Int), 'n > 0. int('n)}) -> ExecutionResult

$[complete]
function process_vlseg (nf, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) = {
    let EMUL_reg = if $[overloaded { "name" = "<=", "is_infix" = true }] lteq_int(EMUL_pow, 0) then
      1
    else
      2 ^ EMUL_pow;
    let vm_val = read_vmask(num_elem, vm, zvreg);
    let vd_seg = read_vreg_seg(num_elem, $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(load_width_bytes, 8), EMUL_pow, nf, vd);
    let 'm = $[overloaded { "name" = "*", "is_infix" = true }] mult_atom($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(nf, load_width_bytes), 8);
    let 'n = num_elem;
    let (result, mask) : (vector('n, bits('m)), bits('n)) = $[complete] match init_masked_result(num_elem, $[overloaded { "name" = "__size", "is_infix" = false }] __id(m), EMUL_pow, vd_seg, vm_val) {
      Ok(v) => v,
      Err(()) => return(Illegal_Instruction())
    };
    foreach (i from 0 to sub_atom(num_elem, 1) by 1 in inc) {
        if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(mask, i), bitone) then {
            set_vstart(to_bits_unsafe(16, i));
            foreach (j from 0 to sub_atom(nf, 1) by 1 in inc) {
                let elem_offset = $[overloaded { "name" = "*", "is_infix" = true }] mult_atom($[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(i, nf), j), load_width_bytes);
                $[complete] match vmem_read(rs1, to_bits_unsafe(xlen, elem_offset), load_width_bytes, Read(Data), false, false, false) {
                  Ok(elem) => write_single_element($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(load_width_bytes, 8), i, vregidx_offset(vd, to_bits_unsafe(5, $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(j, EMUL_reg))), elem),
                  Err(e) => return(e)
                }
            }
        } else {
            foreach (j from 0 to sub_atom(nf, 1) by 1 in inc) {
                let skipped_elem = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits($[overloaded { "name" = ">>", "is_infix" = true }] shiftr($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(result, i), $[overloaded { "name" = "*", "is_infix" = true }] mult_atom($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(j, load_width_bytes), 8)), $[overloaded { "name" = "-", "is_infix" = true }] sub_atom($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(load_width_bytes, 8), 1), 0);
                write_single_element($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(load_width_bytes, 8), i, vregidx_offset(vd, to_bits_unsafe(5, $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(j, EMUL_reg))), skipped_elem)
            }
        }
    };
    set_vstart(zeros(16));
    RETIRE_SUCCESS
}

val process_vlsegff : ({('q : Int), ('q > 0 & 'q <= 8). int('q)}, bitvector(1), vregidx, {1, 2, 4, 8}, regidx, int, {('n : Int), 'n > 0. int('n)}) -> ExecutionResult

$[complete]
function process_vlsegff (nf, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) = {
    let EMUL_reg = if $[overloaded { "name" = "<=", "is_infix" = true }] lteq_int(EMUL_pow, 0) then
      1
    else
      2 ^ EMUL_pow;
    let vm_val = read_vmask(num_elem, vm, zvreg);
    let vd_seg = read_vreg_seg(num_elem, $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(load_width_bytes, 8), EMUL_pow, nf, vd);
    let tail_ag = get_vtype_vta();
    let 'm = $[overloaded { "name" = "*", "is_infix" = true }] mult_atom($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(nf, load_width_bytes), 8);
    let 'n = num_elem;
    let (result, mask) : (vector('n, bits('m)), bits('n)) = $[complete] match init_masked_result(num_elem, $[overloaded { "name" = "*", "is_infix" = true }] mult_atom($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(nf, load_width_bytes), 8), EMUL_pow, vd_seg, vm_val) {
      Ok(v) => v,
      Err(()) => return(Illegal_Instruction())
    };
    var trimmed : bool = false;
    foreach (i from 0 to sub_atom(num_elem, 1) by 1 in inc) {
        if not(trimmed) then {
            if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(mask, i), bitone) then {
                foreach (j from 0 to sub_atom(nf, 1) by 1 in inc) {
                    let elem_offset = $[overloaded { "name" = "*", "is_infix" = true }] mult_atom($[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(i, nf), j), load_width_bytes);
                    $[complete] match vmem_read(rs1, to_bits_unsafe(xlen, elem_offset), load_width_bytes, Read(Data), false, false, false) {
                      Ok(elem) => write_single_element($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(load_width_bytes, 8), i, vregidx_offset(vd, to_bits_unsafe(5, $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(j, EMUL_reg))), elem),
                      Err(e) => if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(i, 0) then
                        return(e)
                      else {
                          vl = to_bits_unsafe(xlen, i);
                          $[overloaded { "name" = "csr_write_callback", "is_infix" = false }] csr_name_write_callback("vl", vl);
                          trimmed = true
                      }
                    }
                }
            } else {
                foreach (j from 0 to sub_atom(nf, 1) by 1 in inc) {
                    let skipped_elem = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits($[overloaded { "name" = ">>", "is_infix" = true }] shiftr($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(result, i), $[overloaded { "name" = "*", "is_infix" = true }] mult_atom($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(j, load_width_bytes), 8)), $[overloaded { "name" = "-", "is_infix" = true }] sub_atom($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(load_width_bytes, 8), 1), 0);
                    write_single_element($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(load_width_bytes, 8), i, vregidx_offset(vd, to_bits_unsafe(5, $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(j, EMUL_reg))), skipped_elem)
                }
            }
        } else {
            if $[overloaded { "name" = "==", "is_infix" = true }] eq_anything(tail_ag, AGNOSTIC) then {
                foreach (j from 0 to sub_atom(nf, 1) by 1 in inc) {
                    let skipped_elem = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits($[overloaded { "name" = ">>", "is_infix" = true }] shiftr($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vd_seg, i), $[overloaded { "name" = "*", "is_infix" = true }] mult_atom($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(j, load_width_bytes), 8)), $[overloaded { "name" = "-", "is_infix" = true }] sub_atom($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(load_width_bytes, 8), 1), 0);
                    write_single_element($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(load_width_bytes, 8), i, vregidx_offset(vd, to_bits_unsafe(5, $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(j, EMUL_reg))), skipped_elem)
                }
            };
            ()
        }
    };
    set_vstart(zeros(16));
    RETIRE_SUCCESS
}

val process_vsseg : ({('q : Int), ('q > 0 & 'q <= 8). int('q)}, bitvector(1), vregidx, {1, 2, 4, 8}, regidx, int, {('n : Int), 'n > 0. int('n)}) -> ExecutionResult

$[complete]
function process_vsseg (nf, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem) = {
    let EMUL_reg = if $[overloaded { "name" = "<=", "is_infix" = true }] lteq_int(EMUL_pow, 0) then
      1
    else
      2 ^ EMUL_pow;
    let vm_val = read_vmask(num_elem, vm, zvreg);
    let vs3_seg = read_vreg_seg(num_elem, $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(load_width_bytes, 8), EMUL_pow, nf, vs3);
    let 'n = num_elem;
    let mask : bits('n) = $[complete] match init_masked_source(num_elem, EMUL_pow, vm_val) {
      Ok(v) => v,
      Err(()) => return(Illegal_Instruction())
    };
    foreach (i from 0 to sub_atom(num_elem, 1) by 1 in inc) {
        if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(mask, i), bitone) then {
            set_vstart(to_bits_unsafe(16, i));
            foreach (j from 0 to sub_atom(nf, 1) by 1 in inc) {
                let elem_offset = $[overloaded { "name" = "*", "is_infix" = true }] mult_atom($[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(i, nf), j), load_width_bytes);
                let vs = vregidx_offset(vs3, to_bits_unsafe(5, $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(j, EMUL_reg)));
                let data = read_single_element($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(load_width_bytes, 8), i, vs);
                $[complete] match vmem_write(rs1, to_bits_unsafe(xlen, elem_offset), load_width_bytes, data, Write(Data), false, false, false) {
                  Ok(true) => (),
                  Ok(false) => internal_error("./extensions/V/vext_mem_insts.sail", 202, "store got false from vmem_write"),
                  Err(e) => return(e)
                }
            }
        };
        ()
    };
    set_vstart(zeros(16));
    RETIRE_SUCCESS
}

val process_vlsseg : ({('q : Int), ('q > 0 & 'q <= 8). int('q)}, bitvector(1), vregidx, {1, 2, 4, 8}, regidx, regidx, int, {('n : Int), 'n > 0. int('n)}) -> ExecutionResult

$[complete]
function process_vlsseg (nf, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) = {
    let EMUL_reg = if $[overloaded { "name" = "<=", "is_infix" = true }] lteq_int(EMUL_pow, 0) then
      1
    else
      2 ^ EMUL_pow;
    let vm_val = read_vmask(num_elem, vm, zvreg);
    let vd_seg = read_vreg_seg(num_elem, $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(load_width_bytes, 8), EMUL_pow, nf, vd);
    let rs2_val = unsigned(get_scalar(rs2, xlen));
    let 'm = $[overloaded { "name" = "*", "is_infix" = true }] mult_atom($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(nf, load_width_bytes), 8);
    let 'n = num_elem;
    let (result, mask) : (vector('n, bits('m)), bits('n)) = $[complete] match init_masked_result(num_elem, $[overloaded { "name" = "*", "is_infix" = true }] mult_atom($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(nf, load_width_bytes), 8), EMUL_pow, vd_seg, vm_val) {
      Ok(v) => v,
      Err(()) => return(Illegal_Instruction())
    };
    foreach (i from 0 to sub_atom(num_elem, 1) by 1 in inc) {
        if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(mask, i), bitone) then {
            set_vstart(to_bits_unsafe(16, i));
            foreach (j from 0 to sub_atom(nf, 1) by 1 in inc) {
                let elem_offset = $[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(i, rs2_val), $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(j, load_width_bytes));
                $[complete] match vmem_read(rs1, to_bits_unsafe(xlen, elem_offset), load_width_bytes, Read(Data), false, false, false) {
                  Ok(elem) => write_single_element($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(load_width_bytes, 8), i, vregidx_offset(vd, to_bits_unsafe(5, $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(j, EMUL_reg))), elem),
                  Err(e) => return(e)
                }
            }
        } else {
            foreach (j from 0 to sub_atom(nf, 1) by 1 in inc) {
                let skipped_elem = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits($[overloaded { "name" = ">>", "is_infix" = true }] shiftr($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(result, i), $[overloaded { "name" = "*", "is_infix" = true }] mult_atom($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(j, load_width_bytes), 8)), $[overloaded { "name" = "-", "is_infix" = true }] sub_atom($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(load_width_bytes, 8), 1), 0);
                write_single_element($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(load_width_bytes, 8), i, vregidx_offset(vd, to_bits_unsafe(5, $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(j, EMUL_reg))), skipped_elem)
            }
        }
    };
    set_vstart(zeros(16));
    RETIRE_SUCCESS
}

val process_vssseg : ({('q : Int), ('q > 0 & 'q <= 8). int('q)}, bitvector(1), vregidx, {1, 2, 4, 8}, regidx, regidx, int, {('n : Int), 'n > 0. int('n)}) -> ExecutionResult

$[complete]
function process_vssseg (nf, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) = {
    let EMUL_reg = if $[overloaded { "name" = "<=", "is_infix" = true }] lteq_int(EMUL_pow, 0) then
      1
    else
      2 ^ EMUL_pow;
    let vm_val = read_vmask(num_elem, vm, zvreg);
    let vs3_seg = read_vreg_seg(num_elem, $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(load_width_bytes, 8), EMUL_pow, nf, vs3);
    let rs2_val = unsigned(get_scalar(rs2, xlen));
    let 'n = num_elem;
    let mask : bits('n) = $[complete] match init_masked_source(num_elem, EMUL_pow, vm_val) {
      Ok(v) => v,
      Err(()) => return(Illegal_Instruction())
    };
    foreach (i from 0 to sub_atom(num_elem, 1) by 1 in inc) {
        if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(mask, i), bitone) then {
            set_vstart(to_bits_unsafe(16, i));
            foreach (j from 0 to sub_atom(nf, 1) by 1 in inc) {
                let elem_offset = $[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(i, rs2_val), $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(j, load_width_bytes));
                let vs = vregidx_offset(vs3, to_bits_unsafe(5, $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(j, EMUL_reg)));
                let data = read_single_element($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(load_width_bytes, 8), i, vs);
                $[complete] match vmem_write(rs1, to_bits_unsafe(xlen, elem_offset), load_width_bytes, data, Write(Data), false, false, false) {
                  Ok(true) => (),
                  Ok(false) => internal_error("./extensions/V/vext_mem_insts.sail", 323, "store got false from vmem_write"),
                  Err(e) => return(e)
                }
            }
        };
        ()
    };
    set_vstart(zeros(16));
    RETIRE_SUCCESS
}

val process_vlxseg : ({('q : Int), ('q > 0 & 'q <= 8). int('q)}, bitvector(1), vregidx, {1, 2, 4, 8}, {1, 2, 4, 8}, int, int, regidx, vregidx, {('n : Int), 'n > 0. int('n)}, int) -> ExecutionResult

$[complete]
function process_vlxseg (nf, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, mop) = {
    let EMUL_data_reg = if $[overloaded { "name" = "<=", "is_infix" = true }] lteq_int(EMUL_data_pow, 0) then
      1
    else
      2 ^ EMUL_data_pow;
    let vm_val = read_vmask(num_elem, vm, zvreg);
    let vd_seg = read_vreg_seg(num_elem, $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(EEW_data_bytes, 8), EMUL_data_pow, nf, vd);
    let vs2_val = read_vreg(num_elem, $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(EEW_index_bytes, 8), EMUL_index_pow, vs2);
    let 'm = $[overloaded { "name" = "*", "is_infix" = true }] mult_atom($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(nf, EEW_data_bytes), 8);
    let 'n = num_elem;
    let (result, mask) : (vector('n, bits('m)), bits('n)) = $[complete] match init_masked_result(num_elem, $[overloaded { "name" = "*", "is_infix" = true }] mult_atom($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(nf, EEW_data_bytes), 8), EMUL_data_pow, vd_seg, vm_val) {
      Ok(v) => v,
      Err(()) => return(Illegal_Instruction())
    };
    foreach (i from 0 to sub_atom(num_elem, 1) by 1 in inc) {
        if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(mask, i), bitone) then {
            set_vstart(to_bits_unsafe(16, i));
            foreach (j from 0 to sub_atom(nf, 1) by 1 in inc) {
                let elem_offset : int = $[overloaded { "name" = "+", "is_infix" = true }] add_atom(unsigned($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)), $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(j, EEW_data_bytes));
                $[complete] match vmem_read(rs1, to_bits_unsafe(xlen, elem_offset), EEW_data_bytes, Read(Data), false, false, false) {
                  Ok(elem) => write_single_element($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(EEW_data_bytes, 8), i, vregidx_offset(vd, to_bits_unsafe(5, $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(j, EMUL_data_reg))), elem),
                  Err(e) => return(e)
                }
            }
        } else {
            foreach (j from 0 to sub_atom(nf, 1) by 1 in inc) {
                let skipped_elem = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits($[overloaded { "name" = ">>", "is_infix" = true }] shiftr($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(result, i), $[overloaded { "name" = "*", "is_infix" = true }] mult_atom($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(j, EEW_data_bytes), 8)), $[overloaded { "name" = "-", "is_infix" = true }] sub_atom($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(EEW_data_bytes, 8), 1), 0);
                write_single_element($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(EEW_data_bytes, 8), i, vregidx_offset(vd, to_bits_unsafe(5, $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(j, EMUL_data_reg))), skipped_elem)
            }
        }
    };
    set_vstart(zeros(16));
    RETIRE_SUCCESS
}

val process_vsxseg : ({('q : Int), ('q > 0 & 'q <= 8). int('q)}, bitvector(1), vregidx, {1, 2, 4, 8}, {1, 2, 4, 8}, int, int, regidx, vregidx, {('n : Int), 'n > 0. int('n)}, int) -> ExecutionResult

$[complete]
function process_vsxseg (nf, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, mop) = {
    let EMUL_data_reg = if $[overloaded { "name" = "<=", "is_infix" = true }] lteq_int(EMUL_data_pow, 0) then
      1
    else
      2 ^ EMUL_data_pow;
    let vm_val = read_vmask(num_elem, vm, zvreg);
    let vs3_seg = read_vreg_seg(num_elem, $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(EEW_data_bytes, 8), EMUL_data_pow, nf, vs3);
    let vs2_val = read_vreg(num_elem, $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(EEW_index_bytes, 8), EMUL_index_pow, vs2);
    let 'n = num_elem;
    let mask : bits('n) = $[complete] match init_masked_source(num_elem, EMUL_data_pow, vm_val) {
      Ok(v) => v,
      Err(()) => return(Illegal_Instruction())
    };
    foreach (i from 0 to sub_atom(num_elem, 1) by 1 in inc) {
        if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(mask, i), bitone) then {
            set_vstart(to_bits_unsafe(16, i));
            foreach (j from 0 to sub_atom(nf, 1) by 1 in inc) {
                let elem_offset : int = $[overloaded { "name" = "+", "is_infix" = true }] add_atom(unsigned($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)), $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(j, EEW_data_bytes));
                let vs = vregidx_offset(vs3, to_bits_unsafe(5, $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(j, EMUL_data_reg)));
                let data = read_single_element($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(EEW_data_bytes, 8), i, vs);
                $[complete] match vmem_write(rs1, to_bits_unsafe(xlen, elem_offset), EEW_data_bytes, data, Write(Data), false, false, false) {
                  Ok(true) => (),
                  Ok(false) => internal_error("./extensions/V/vext_mem_insts.sail", 474, "store got false from vmem_write"),
                  Err(e) => return(e)
                }
            }
        };
        ()
    };
    set_vstart(zeros(16));
    RETIRE_SUCCESS
}

val process_vlre : ({1, 2, 4, 8}, vregidx, {1, 2, 4, 8}, regidx, nat) -> ExecutionResult

$[complete]
function process_vlre (nf, vd, load_width_bytes, rs1, elem_per_reg) = {
    let start_element : nat = $[complete] match get_start_element() {
      Ok(v) => v,
      Err(()) => return(Illegal_Instruction())
    };
    if $[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(start_element, $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(nf, elem_per_reg)) then return(RETIRE_SUCCESS);
    let elem_to_align : int = $[overloaded { "name" = "%", "is_infix" = true }] rem_positive_round_zero(start_element, elem_per_reg);
    var cur_field : int = $[overloaded { "name" = "/", "is_infix" = true }] quot_positive_round_zero(start_element, elem_per_reg);
    var cur_elem : int = start_element;
    if $[overloaded { "name" = ">", "is_infix" = true }] gt_int(elem_to_align, 0) then {
        foreach (i from elem_to_align to sub_atom(elem_per_reg, 1) by 1 in inc) {
            set_vstart(to_bits_unsafe(16, cur_elem));
            let elem_offset = $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(cur_elem, load_width_bytes);
            $[complete] match vmem_read(rs1, to_bits_unsafe(xlen, elem_offset), load_width_bytes, Read(Data), false, false, false) {
              Ok(elem) => write_single_element($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(load_width_bytes, 8), i, vregidx_offset(vd, to_bits_unsafe(5, cur_field)), elem),
              Err(e) => return(e)
            };
            cur_elem = $[overloaded { "name" = "+", "is_infix" = true }] add_atom(cur_elem, 1)
        };
        cur_field = $[overloaded { "name" = "+", "is_infix" = true }] add_atom(cur_field, 1)
    };
    foreach (j from cur_field to sub_atom(nf, 1) by 1 in inc) {
        foreach (i from 0 to sub_atom(elem_per_reg, 1) by 1 in inc) {
            set_vstart(to_bits_unsafe(16, cur_elem));
            let elem_offset = $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(cur_elem, load_width_bytes);
            $[complete] match vmem_read(rs1, to_bits_unsafe(xlen, elem_offset), load_width_bytes, Read(Data), false, false, false) {
              Ok(elem) => write_single_element($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(load_width_bytes, 8), i, vregidx_offset(vd, to_bits_unsafe(5, j)), elem),
              Err(e) => return(e)
            };
            cur_elem = $[overloaded { "name" = "+", "is_infix" = true }] add_atom(cur_elem, 1)
        }
    };
    set_vstart(zeros(16));
    RETIRE_SUCCESS
}

val process_vsre : ({1, 2, 4, 8}, {1, 2, 4, 8}, regidx, vregidx, nat) -> ExecutionResult

$[complete]
function process_vsre (nf, load_width_bytes, rs1, vs3, elem_per_reg) = {
    let start_element : nat = $[complete] match get_start_element() {
      Ok(v) => v,
      Err(()) => return(Illegal_Instruction())
    };
    if $[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(start_element, $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(nf, elem_per_reg)) then return(RETIRE_SUCCESS);
    let elem_to_align : int = $[overloaded { "name" = "%", "is_infix" = true }] rem_positive_round_zero(start_element, elem_per_reg);
    var cur_field : int = $[overloaded { "name" = "/", "is_infix" = true }] quot_positive_round_zero(start_element, elem_per_reg);
    var cur_elem : int = start_element;
    if $[overloaded { "name" = ">", "is_infix" = true }] gt_int(elem_to_align, 0) then {
        foreach (i from elem_to_align to sub_atom(elem_per_reg, 1) by 1 in inc) {
            set_vstart(to_bits_unsafe(16, cur_elem));
            let elem_offset : int = $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(cur_elem, load_width_bytes);
            let vs = vregidx_offset(vs3, to_bits_unsafe(5, cur_field));
            let data = read_single_element($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(load_width_bytes, 8), i, vs);
            $[complete] match vmem_write(rs1, to_bits_unsafe(xlen, elem_offset), load_width_bytes, data, Write(Data), false, false, false) {
              Ok(true) => (),
              Ok(false) => internal_error("./extensions/V/vext_mem_insts.sail", 619, "store got false from vmem_write"),
              Err(e) => return(e)
            };
            cur_elem = $[overloaded { "name" = "+", "is_infix" = true }] add_atom(cur_elem, 1)
        };
        cur_field = $[overloaded { "name" = "+", "is_infix" = true }] add_atom(cur_field, 1)
    };
    foreach (j from cur_field to sub_atom(nf, 1) by 1 in inc) {
        let vs3_val = read_vreg(elem_per_reg, $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(load_width_bytes, 8), 0, vregidx_offset(vs3, to_bits_unsafe(5, j)));
        foreach (i from 0 to sub_atom(elem_per_reg, 1) by 1 in inc) {
            set_vstart(to_bits_unsafe(16, cur_elem));
            let elem_offset = $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(cur_elem, load_width_bytes);
            $[complete] match vmem_write(rs1, to_bits_unsafe(xlen, elem_offset), load_width_bytes, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs3_val, i), Write(Data), false, false, false) {
              Ok(true) => (),
              Ok(false) => internal_error("./extensions/V/vext_mem_insts.sail", 634, "store got false from vmem_write"),
              Err(e) => return(e)
            };
            cur_elem = $[overloaded { "name" = "+", "is_infix" = true }] add_atom(cur_elem, 1)
        }
    };
    set_vstart(zeros(16));
    RETIRE_SUCCESS
}

val encdec_lsop : vmlsop <-> bitvector(7)

mapping encdec_lsop = {
  VLM <-> 0b0000111,
  VSM <-> 0b0100111
}

val process_vm : (vregidx, regidx, nat, nat, vmlsop) -> ExecutionResult

$[complete]
function process_vm (vd_or_vs3, rs1, num_elem, evl, op) = {
    let start_element : nat = $[complete] match get_start_element() {
      Ok(v) => v,
      Err(()) => return(Illegal_Instruction())
    };
    let 'n = num_elem;
    let vd_or_vs3_val : vector('n, bits(8)) = read_vreg(num_elem, 8, 0, vd_or_vs3);
    foreach (i from start_element to sub_atom(num_elem, 1) by 1 in inc) {
        if $[overloaded { "name" = "<", "is_infix" = true }] lt_int(i, evl) then {
            set_vstart(to_bits_unsafe(16, i));
            if $[overloaded { "name" = "==", "is_infix" = true }] eq_anything(op, VLM) then {
                $[complete] match vmem_read(rs1, to_bits_unsafe(xlen, i), 1, Read(Data), false, false, false) {
                  Ok(elem) => write_single_element(8, i, vd_or_vs3, elem),
                  Err(e) => return(e)
                }
            } else if $[overloaded { "name" = "==", "is_infix" = true }] eq_anything(op, VSM) then {
                $[complete] match vmem_write(rs1, to_bits_unsafe(xlen, i), 1, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vd_or_vs3_val, i), Write(Data), false, false, false) {
                  Ok(true) => (),
                  Ok(false) => internal_error("./extensions/V/vext_mem_insts.sail", 690, "store got false from vmem_write"),
                  Err(e) => return(e)
                }
            } else ()
        } else {
            if $[overloaded { "name" = "==", "is_infix" = true }] eq_anything(op, VLM) then {
                write_single_element(8, i, vd_or_vs3, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vd_or_vs3_val, i))
            };
            ()
        }
    };
    set_vstart(zeros(16));
    RETIRE_SUCCESS
}

val vmtype_mnemonic : vmlsop <-> string

mapping vmtype_mnemonic = {
  VLM <-> "vlm.v",
  VSM <-> "vsm.v"
}

val encdec_mmfunct6 : mmfunct6 <-> bitvector(6)

mapping encdec_mmfunct6 = {
  MM_VMAND <-> 0b011001,
  MM_VMNAND <-> 0b011101,
  MM_VMANDN <-> 0b011000,
  MM_VMXOR <-> 0b011011,
  MM_VMOR <-> 0b011010,
  MM_VMNOR <-> 0b011110,
  MM_VMORN <-> 0b011100,
  MM_VMXNOR <-> 0b011111
}

val mmtype_mnemonic : mmfunct6 <-> string

mapping mmtype_mnemonic = {
  MM_VMAND <-> "vmand.mm",
  MM_VMNAND <-> "vmnand.mm",
  MM_VMANDN <-> "vmandn.mm",
  MM_VMXOR <-> "vmxor.mm",
  MM_VMOR <-> "vmor.mm",
  MM_VMNOR <-> "vmnor.mm",
  MM_VMORN <-> "vmorn.mm",
  MM_VMXNOR <-> "vmxnor.mm"
}

val encdec_vvmfunct6 : vvmfunct6 <-> bitvector(6)

mapping encdec_vvmfunct6 = {
  VVM_VMADC <-> 0b010001,
  VVM_VMSBC <-> 0b010011
}

val vvmtype_mnemonic : vvmfunct6 <-> string

mapping vvmtype_mnemonic = {
  VVM_VMADC <-> "vmadc.vvm",
  VVM_VMSBC <-> "vmsbc.vvm"
}

val encdec_vvmcfunct6 : vvmcfunct6 <-> bitvector(6)

mapping encdec_vvmcfunct6 = {
  VVMC_VMADC <-> 0b010001,
  VVMC_VMSBC <-> 0b010011
}

val vvmctype_mnemonic : vvmcfunct6 <-> string

mapping vvmctype_mnemonic = {
  VVMC_VMADC <-> "vmadc.vv",
  VVMC_VMSBC <-> "vmsbc.vv"
}

val encdec_vvmsfunct6 : vvmsfunct6 <-> bitvector(6)

mapping encdec_vvmsfunct6 = {
  VVMS_VADC <-> 0b010000,
  VVMS_VSBC <-> 0b010010
}

val vvmstype_mnemonic : vvmsfunct6 <-> string

mapping vvmstype_mnemonic = {
  VVMS_VADC <-> "vadc.vvm",
  VVMS_VSBC <-> "vsbc.vvm"
}

val encdec_vvcmpfunct6 : vvcmpfunct6 <-> bitvector(6)

mapping encdec_vvcmpfunct6 = {
  VVCMP_VMSEQ <-> 0b011000,
  VVCMP_VMSNE <-> 0b011001,
  VVCMP_VMSLTU <-> 0b011010,
  VVCMP_VMSLT <-> 0b011011,
  VVCMP_VMSLEU <-> 0b011100,
  VVCMP_VMSLE <-> 0b011101
}

val vvcmptype_mnemonic : vvcmpfunct6 <-> string

mapping vvcmptype_mnemonic = {
  VVCMP_VMSEQ <-> "vmseq.vv",
  VVCMP_VMSNE <-> "vmsne.vv",
  VVCMP_VMSLTU <-> "vmsltu.vv",
  VVCMP_VMSLT <-> "vmslt.vv",
  VVCMP_VMSLEU <-> "vmsleu.vv",
  VVCMP_VMSLE <-> "vmsle.vv"
}

val encdec_vxmfunct6 : vxmfunct6 <-> bitvector(6)

mapping encdec_vxmfunct6 = {
  VXM_VMADC <-> 0b010001,
  VXM_VMSBC <-> 0b010011
}

val vxmtype_mnemonic : vxmfunct6 <-> string

mapping vxmtype_mnemonic = {
  VXM_VMADC <-> "vmadc.vxm",
  VXM_VMSBC <-> "vmsbc.vxm"
}

val encdec_vxmcfunct6 : vxmcfunct6 <-> bitvector(6)

mapping encdec_vxmcfunct6 = {
  VXMC_VMADC <-> 0b010001,
  VXMC_VMSBC <-> 0b010011
}

val vxmctype_mnemonic : vxmcfunct6 <-> string

mapping vxmctype_mnemonic = {
  VXMC_VMADC <-> "vmadc.vx",
  VXMC_VMSBC <-> "vmsbc.vx"
}

val encdec_vxmsfunct6 : vxmsfunct6 <-> bitvector(6)

mapping encdec_vxmsfunct6 = {
  VXMS_VADC <-> 0b010000,
  VXMS_VSBC <-> 0b010010
}

val vxmstype_mnemonic : vxmsfunct6 <-> string

mapping vxmstype_mnemonic = {
  VXMS_VADC <-> "vadc.vxm",
  VXMS_VSBC <-> "vsbc.vxm"
}

val encdec_vxcmpfunct6 : vxcmpfunct6 <-> bitvector(6)

mapping encdec_vxcmpfunct6 = {
  VXCMP_VMSEQ <-> 0b011000,
  VXCMP_VMSNE <-> 0b011001,
  VXCMP_VMSLTU <-> 0b011010,
  VXCMP_VMSLT <-> 0b011011,
  VXCMP_VMSLEU <-> 0b011100,
  VXCMP_VMSLE <-> 0b011101,
  VXCMP_VMSGTU <-> 0b011110,
  VXCMP_VMSGT <-> 0b011111
}

val vxcmptype_mnemonic : vxcmpfunct6 <-> string

mapping vxcmptype_mnemonic = {
  VXCMP_VMSEQ <-> "vmseq.vx",
  VXCMP_VMSNE <-> "vmsne.vx",
  VXCMP_VMSLTU <-> "vmsltu.vx",
  VXCMP_VMSLT <-> "vmslt.vx",
  VXCMP_VMSLEU <-> "vmsleu.vx",
  VXCMP_VMSLE <-> "vmsle.vx",
  VXCMP_VMSGTU <-> "vmsgtu.vx",
  VXCMP_VMSGT <-> "vmsgt.vx"
}

val encdec_vimfunct6 : vimfunct6 <-> bitvector(6)

mapping encdec_vimfunct6 = {VIM_VMADC <-> 0b010001}

val vimtype_mnemonic : vimfunct6 <-> string

mapping vimtype_mnemonic = {VIM_VMADC <-> "vmadc.vim"}

val encdec_vimcfunct6 : vimcfunct6 <-> bitvector(6)

mapping encdec_vimcfunct6 = {VIMC_VMADC <-> 0b010001}

val vimctype_mnemonic : vimcfunct6 <-> string

mapping vimctype_mnemonic = {VIMC_VMADC <-> "vmadc.vi"}

val encdec_vimsfunct6 : vimsfunct6 <-> bitvector(6)

mapping encdec_vimsfunct6 = {VIMS_VADC <-> 0b010000}

val vimstype_mnemonic : vimsfunct6 <-> string

mapping vimstype_mnemonic = {VIMS_VADC <-> "vadc.vim"}

val encdec_vicmpfunct6 : vicmpfunct6 <-> bitvector(6)

mapping encdec_vicmpfunct6 = {
  VICMP_VMSEQ <-> 0b011000,
  VICMP_VMSNE <-> 0b011001,
  VICMP_VMSLEU <-> 0b011100,
  VICMP_VMSLE <-> 0b011101,
  VICMP_VMSGTU <-> 0b011110,
  VICMP_VMSGT <-> 0b011111
}

val vicmptype_mnemonic : vicmpfunct6 <-> string

mapping vicmptype_mnemonic = {
  VICMP_VMSEQ <-> "vmseq.vi",
  VICMP_VMSNE <-> "vmsne.vi",
  VICMP_VMSLEU <-> "vmsleu.vi",
  VICMP_VMSLE <-> "vmsle.vi",
  VICMP_VMSGTU <-> "vmsgtu.vi",
  VICMP_VMSGT <-> "vmsgt.vi"
}

val encdec_fvvmfunct6 : fvvmfunct6 <-> bitvector(6)

mapping encdec_fvvmfunct6 = {
  FVVM_VMFEQ <-> 0b011000,
  FVVM_VMFLE <-> 0b011001,
  FVVM_VMFLT <-> 0b011011,
  FVVM_VMFNE <-> 0b011100
}

val fvvmtype_mnemonic : fvvmfunct6 <-> string

mapping fvvmtype_mnemonic = {
  FVVM_VMFEQ <-> "vmfeq.vv",
  FVVM_VMFLE <-> "vmfle.vv",
  FVVM_VMFLT <-> "vmflt.vv",
  FVVM_VMFNE <-> "vmfne.vv"
}

val encdec_fvfmfunct6 : fvfmfunct6 <-> bitvector(6)

mapping encdec_fvfmfunct6 = {
  VFM_VMFEQ <-> 0b011000,
  VFM_VMFLE <-> 0b011001,
  VFM_VMFLT <-> 0b011011,
  VFM_VMFNE <-> 0b011100,
  VFM_VMFGT <-> 0b011101,
  VFM_VMFGE <-> 0b011111
}

val fvfmtype_mnemonic : fvfmfunct6 <-> string

mapping fvfmtype_mnemonic = {
  VFM_VMFEQ <-> "vmfeq.vf",
  VFM_VMFLE <-> "vmfle.vf",
  VFM_VMFLT <-> "vmflt.vf",
  VFM_VMFNE <-> "vmfne.vf",
  VFM_VMFGT <-> "vmfgt.vf",
  VFM_VMFGE <-> "vmfge.vf"
}

val encdec_rivvfunct6 : rivvfunct6 <-> bitvector(6)

mapping encdec_rivvfunct6 = {
  IVV_VWREDSUMU <-> 0b110000,
  IVV_VWREDSUM <-> 0b110001
}

val rivvtype_mnemonic : rivvfunct6 <-> string

mapping rivvtype_mnemonic = {
  IVV_VWREDSUMU <-> "vwredsumu.vs",
  IVV_VWREDSUM <-> "vwredsum.vs"
}

val encdec_rmvvfunct6 : rmvvfunct6 <-> bitvector(6)

mapping encdec_rmvvfunct6 = {
  MVV_VREDSUM <-> 0b000000,
  MVV_VREDAND <-> 0b000001,
  MVV_VREDOR <-> 0b000010,
  MVV_VREDXOR <-> 0b000011,
  MVV_VREDMINU <-> 0b000100,
  MVV_VREDMIN <-> 0b000101,
  MVV_VREDMAXU <-> 0b000110,
  MVV_VREDMAX <-> 0b000111
}

val rmvvtype_mnemonic : rmvvfunct6 <-> string

mapping rmvvtype_mnemonic = {
  MVV_VREDSUM <-> "vredsum.vs",
  MVV_VREDAND <-> "vredand.vs",
  MVV_VREDOR <-> "vredor.vs",
  MVV_VREDXOR <-> "vredxor.vs",
  MVV_VREDMINU <-> "vredminu.vs",
  MVV_VREDMIN <-> "vredmin.vs",
  MVV_VREDMAXU <-> "vredmaxu.vs",
  MVV_VREDMAX <-> "vredmax.vs"
}

val encdec_rfvvfunct6 : rfvvfunct6 <-> bitvector(6)

mapping encdec_rfvvfunct6 = {
  FVV_VFREDOSUM <-> 0b000011,
  FVV_VFREDUSUM <-> 0b000001,
  FVV_VFREDMAX <-> 0b000111,
  FVV_VFREDMIN <-> 0b000101,
  FVV_VFWREDOSUM <-> 0b110011,
  FVV_VFWREDUSUM <-> 0b110001
}

val process_rfvv_single : (rfvvfunct6, bitvector(1), vregidx, vregidx, vregidx, {('n : Int), 'n > 0. int('n)}, {8, 16, 32, 64}, range(-3, 3)) -> ExecutionResult

$[complete]
function process_rfvv_single (funct6, vm, vs2, vs1, vd, num_elem_vs, SEW, LMUL_pow) = {
    let rm_3b = _get_Fcsr_FRM(fcsr);
    let num_elem_vd = get_num_elem(0, SEW);
    if illegal_fp_reduction(SEW, rm_3b) then return(Illegal_Instruction());
    assert($[overloaded { "name" = "!=", "is_infix" = true }] neq_int(SEW, 8), "./extensions/V/vext_fp_red_insts.sail:36.17-36.18");
    if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(unsigned(vl), 0) then return(RETIRE_SUCCESS);
    let 'n = num_elem_vs;
    let 'd = num_elem_vd;
    let 'm = SEW;
    let vm_val : bits('n) = read_vmask(num_elem_vs, vm, zvreg);
    let vd_val : vector('d, bits('m)) = read_vreg(num_elem_vd, SEW, 0, vd);
    let vs2_val : vector('n, bits('m)) = read_vreg(num_elem_vs, SEW, LMUL_pow, vs2);
    let mask : bits('n) = $[complete] match init_masked_source(num_elem_vs, LMUL_pow, vm_val) {
      Ok(v) => v,
      Err(()) => return(Illegal_Instruction())
    };
    var sum : bits('m) = read_single_element(SEW, 0, vs1);
    foreach (i from 0 to sub_atom(num_elem_vs, 1) by 1 in inc) {
        if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(mask, i), bitone) then {
            sum = $[complete] match funct6 {
              FVV_VFREDOSUM => fp_add(rm_3b, sum, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)),
              FVV_VFREDUSUM => fp_add(rm_3b, sum, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)),
              FVV_VFREDMAX => fp_max(sum, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)),
              FVV_VFREDMIN => fp_min(sum, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)),
              _ => internal_error("./extensions/V/vext_fp_red_insts.sail", 61, "Widening op unexpected")
            }
        };
        ()
    };
    write_single_element(SEW, 0, vd, sum);
    set_vstart(zeros(16));
    RETIRE_SUCCESS
}

val process_rfvv_widening_reduction : (rfvvfunct6, bitvector(1), vregidx, vregidx, vregidx, {('n : Int), 'n > 0. int('n)}, {8, 16, 32, 64}, range(-3, 3)) -> ExecutionResult

$[complete]
function process_rfvv_widening_reduction (funct6, vm, vs2, vs1, vd, num_elem_vs, SEW, LMUL_pow) = {
    let rm_3b = _get_Fcsr_FRM(fcsr);
    let SEW_widen = $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(SEW, 2);
    if illegal_fp_widening_reduction(SEW, rm_3b, SEW_widen) then return(Illegal_Instruction());
    assert($[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(SEW, 16), $[overloaded { "name" = "<=", "is_infix" = true }] lteq_int(SEW_widen, 64)), "./extensions/V/vext_fp_red_insts.sail:79.36-79.37");
    let num_elem_vd = get_num_elem(0, SEW_widen);
    if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(unsigned(vl), 0) then return(RETIRE_SUCCESS);
    let 'n = num_elem_vs;
    let 'd = num_elem_vd;
    let 'm = SEW;
    let 'o = SEW_widen;
    let vm_val : bits('n) = read_vmask(num_elem_vs, vm, zvreg);
    let vd_val : vector('d, bits('o)) = read_vreg(num_elem_vd, SEW_widen, 0, vd);
    let vs2_val : vector('n, bits('m)) = read_vreg(num_elem_vs, SEW, LMUL_pow, vs2);
    let mask : bits('n) = $[complete] match init_masked_source(num_elem_vs, LMUL_pow, vm_val) {
      Ok(v) => v,
      Err(()) => return(Illegal_Instruction())
    };
    var sum : bits('o) = read_single_element(SEW_widen, 0, vs1);
    foreach (i from 0 to sub_atom(num_elem_vs, 1) by 1 in inc) {
        if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(mask, i), bitone) then {
            sum = fp_add(rm_3b, sum, fp_widen($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)))
        };
        ()
    };
    write_single_element(SEW_widen, 0, vd, sum);
    set_vstart(zeros(16));
    RETIRE_SUCCESS
}

val rfvvtype_mnemonic : rfvvfunct6 <-> string

mapping rfvvtype_mnemonic = {
  FVV_VFREDOSUM <-> "vfredosum.vs",
  FVV_VFREDUSUM <-> "vfredusum.vs",
  FVV_VFREDMAX <-> "vfredmax.vs",
  FVV_VFREDMIN <-> "vfredmin.vs",
  FVV_VFWREDOSUM <-> "vfwredosum.vs",
  FVV_VFWREDUSUM <-> "vfwredusum.vs"
}

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum seed_opst = {BIST, ES16, WAIT, DEAD}

val undefined_seed_opst : unit -> seed_opst

$[complete]
function undefined_seed_opst () = internal_pick([|BIST, ES16, WAIT, DEAD|])

val seed_opst_of_num : forall ('e : Int), (0 <= 'e & 'e <= 3).
  int('e) -> seed_opst

$[complete]
function seed_opst_of_num arg# = $[complete] match arg# {
  0 => BIST,
  1 => ES16,
  2 => WAIT,
  _ => DEAD
}

val num_of_seed_opst : seed_opst -> {('e : Int), (0 <= 'e & 'e <= 3). int('e)}

$[complete]
function num_of_seed_opst arg# = $[complete] match arg# {
  BIST => 0,
  ES16 => 1,
  WAIT => 2,
  DEAD => 3
}

val opst_code : seed_opst <-> bitvector(2)

mapping opst_code = {
  BIST <-> 0b00,
  WAIT <-> 0b01,
  ES16 <-> 0b10,
  DEAD <-> 0b11
}

val read_seed_csr : unit -> bitvector(xlen)

$[complete]
function read_seed_csr () = {
    let reserved_bits : bits(6) = 0b000000;
    let custom_bits : bits(8) = 0x00;
    let seed : bits(16) = get_16_random_bits();
    zero_extend(sizeof(xlen), $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(opst_code_forwards(ES16), $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(reserved_bits, $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(custom_bits, seed))))
}

val write_seed_csr : unit -> bitvector(xlen)

$[complete]
function write_seed_csr () = zeros(sizeof(xlen))

val zbkb_rtype_mnemonic : brop_zbkb <-> string

mapping zbkb_rtype_mnemonic = {
  PACK <-> "pack",
  PACKH <-> "packh"
}

val encdec_vaesdf : zvk_vaesdf_funct6 <-> bitvector(6)

mapping encdec_vaesdf = {
  ZVK_VAESDF_VV <-> 0b101000,
  ZVK_VAESDF_VS <-> 0b101001
}

val vaesdf_mnemonic : zvk_vaesdf_funct6 <-> string

mapping vaesdf_mnemonic = {
  ZVK_VAESDF_VV <-> "vaesdf.vv",
  ZVK_VAESDF_VS <-> "vaesdf.vs"
}

val encdec_vaesdm : zvk_vaesdm_funct6 <-> bitvector(6)

mapping encdec_vaesdm = {
  ZVK_VAESDM_VV <-> 0b101000,
  ZVK_VAESDM_VS <-> 0b101001
}

val vaesdm_mnemonic : zvk_vaesdm_funct6 <-> string

mapping vaesdm_mnemonic = {
  ZVK_VAESDM_VV <-> "vaesdm.vv",
  ZVK_VAESDM_VS <-> "vaesdm.vs"
}

val encdec_vaesef : zvk_vaesef_funct6 <-> bitvector(6)

mapping encdec_vaesef = {
  ZVK_VAESEF_VV <-> 0b101000,
  ZVK_VAESEF_VS <-> 0b101001
}

val vaesef_mnemonic : zvk_vaesef_funct6 <-> string

mapping vaesef_mnemonic = {
  ZVK_VAESEF_VV <-> "vaesef.vv",
  ZVK_VAESEF_VS <-> "vaesef.vs"
}

val encdec_vaesem : zvk_vaesem_funct6 <-> bitvector(6)

mapping encdec_vaesem = {
  ZVK_VAESEM_VV <-> 0b101000,
  ZVK_VAESEM_VS <-> 0b101001
}

val vaesem_mnemonic : zvk_vaesem_funct6 <-> string

mapping vaesem_mnemonic = {
  ZVK_VAESEM_VV <-> "vaesem.vv",
  ZVK_VAESEM_VS <-> "vaesem.vs"
}

val vsm4r_mnemonic : zvk_vsm4r_funct6 <-> string

mapping vsm4r_mnemonic = {
  ZVK_VSM4R_VV <-> "vsm4r.vv",
  ZVK_VSM4R_VS <-> "vsm4r.vs"
}

val encdec_vsha2 : zvk_vsha2_funct6 <-> bitvector(6)

mapping encdec_vsha2 = {
  ZVK_VSHA2CH_VV <-> 0b101110,
  ZVK_VSHA2CL_VV <-> 0b101111
}

val vsha2_mnemonic : zvk_vsha2_funct6 <-> string

mapping vsha2_mnemonic = {
  ZVK_VSHA2CH_VV <-> "vsha2ch.vv",
  ZVK_VSHA2CL_VV <-> "vsha2cl.vv"
}

val encdec_csrop : csrop <-> bitvector(2)

mapping encdec_csrop = {
  CSRRW <-> 0b01,
  CSRRS <-> 0b10,
  CSRRC <-> 0b11
}

val doCSR : (bitvector(12), bitvector(xlen), regidx, csrop, bool) -> ExecutionResult

$[complete]
function doCSR (csr : csreg, rs1_val : xlenbits, rd : regidx, op : csrop, is_CSR_Write : bool) = {
    if not(check_CSR(csr, cur_privilege, is_CSR_Write)) then
      Illegal_Instruction()
    else
      if not(ext_check_CSR(csr, cur_privilege, is_CSR_Write)) then
        Ext_CSR_Check_Failure()
      else {
          let is_CSR_Read = not($[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_anything(op, CSRRW), $[overloaded { "name" = "==", "is_infix" = true }] eq_anything(rd, zreg)));
          let csr_val : xlenbits = if is_CSR_Read then read_CSR(csr) else
            zeros(sizeof(xlen));
          if is_CSR_Write then {
              let new_val : xlenbits = $[complete] match op {
                CSRRW => rs1_val,
                CSRRS => $[overloaded { "name" = "|", "is_infix" = true }] or_vec(csr_val, rs1_val),
                CSRRC => $[overloaded { "name" = "&", "is_infix" = true }] and_vec(csr_val, $[overloaded { "name" = "~", "is_infix" = false }] not_vec(rs1_val))
              };
              $[complete] match write_CSR(csr, new_val) {
                Ok(final_val) => {
                    $[overloaded { "name" = "csr_write_callback", "is_infix" = false }] csr_id_write_callback(csr, final_val);
                    $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(rd, csr_val);
                    RETIRE_SUCCESS
                },
                Err(()) => Illegal_Instruction()
              }
          } else {
              $[overloaded { "name" = "csr_read_callback", "is_infix" = false }] csr_id_read_callback(csr, csr_val);
              $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(rd, csr_val);
              RETIRE_SUCCESS
          }
      }
}

val csr_mnemonic : csrop <-> string

mapping csr_mnemonic = {
  CSRRW <-> "csrrw",
  CSRRS <-> "csrrs",
  CSRRC <-> "csrrc"
}

$[undefined_gen "skip"]
$[bitfield]
struct HpmEvent = {bits : bitvector(64)}

val undefined_HpmEvent : unit -> HpmEvent

$[complete]
function undefined_HpmEvent () = struct HpmEvent { bits = undefined }

val Mk_HpmEvent : bitvector(64) -> HpmEvent

$[complete]
function Mk_HpmEvent v = struct HpmEvent { bits = v }

$[fix_location]
val _get_HpmEvent_bits : HpmEvent -> bitvector(64)

$[complete]
$[fix_location]
function _get_HpmEvent_bits v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, sub_atom(64, 1), 0)

$[fix_location]
val _update_HpmEvent_bits : (HpmEvent, bitvector(64)) -> HpmEvent

$[complete]
$[fix_location]
function _update_HpmEvent_bits (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, sub_atom(64, 1), 0, x) }

$[fix_location]
overload update_bits = {_update_HpmEvent_bits}

$[fix_location]
val _set_HpmEvent_bits : (register(HpmEvent), bitvector(64)) -> unit

$[complete]
$[fix_location]
function _set_HpmEvent_bits (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_HpmEvent_bits(r, v)
}

overload _mod_bits = {_get_HpmEvent_bits, _set_HpmEvent_bits}

$[fix_location]
val _get_HpmEvent_MINH : HpmEvent -> bitvector(1)

$[complete]
$[fix_location]
function _get_HpmEvent_MINH v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 62, 62)

$[fix_location]
val _update_HpmEvent_MINH : (HpmEvent, bitvector(1)) -> HpmEvent

$[complete]
$[fix_location]
function _update_HpmEvent_MINH (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 62, 62, x) }

$[fix_location]
overload update_MINH = {_update_HpmEvent_MINH}

$[fix_location]
val _set_HpmEvent_MINH : (register(HpmEvent), bitvector(1)) -> unit

$[complete]
$[fix_location]
function _set_HpmEvent_MINH (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_HpmEvent_MINH(r, v)
}

overload _mod_MINH = {_get_HpmEvent_MINH, _set_HpmEvent_MINH}

$[fix_location]
val _get_HpmEvent_OF : HpmEvent -> bitvector(1)

$[complete]
$[fix_location]
function _get_HpmEvent_OF v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 63, 63)

$[fix_location]
val _update_HpmEvent_OF : (HpmEvent, bitvector(1)) -> HpmEvent

$[complete]
$[fix_location]
function _update_HpmEvent_OF (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 63, 63, x) }

$[fix_location]
overload update_OF = {_update_HpmEvent_OF}

$[fix_location]
val _set_HpmEvent_OF : (register(HpmEvent), bitvector(1)) -> unit

$[complete]
$[fix_location]
function _set_HpmEvent_OF (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_HpmEvent_OF(r, v)
}

overload _mod_OF = {_get_HpmEvent_OF, _set_HpmEvent_OF}

$[fix_location]
val _get_HpmEvent_SINH : HpmEvent -> bitvector(1)

$[complete]
$[fix_location]
function _get_HpmEvent_SINH v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 61, 61)

$[fix_location]
val _update_HpmEvent_SINH : (HpmEvent, bitvector(1)) -> HpmEvent

$[complete]
$[fix_location]
function _update_HpmEvent_SINH (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 61, 61, x) }

$[fix_location]
overload update_SINH = {_update_HpmEvent_SINH}

$[fix_location]
val _set_HpmEvent_SINH : (register(HpmEvent), bitvector(1)) -> unit

$[complete]
$[fix_location]
function _set_HpmEvent_SINH (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_HpmEvent_SINH(r, v)
}

overload _mod_SINH = {_get_HpmEvent_SINH, _set_HpmEvent_SINH}

$[fix_location]
val _get_HpmEvent_UINH : HpmEvent -> bitvector(1)

$[complete]
$[fix_location]
function _get_HpmEvent_UINH v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 60, 60)

$[fix_location]
val _update_HpmEvent_UINH : (HpmEvent, bitvector(1)) -> HpmEvent

$[complete]
$[fix_location]
function _update_HpmEvent_UINH (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 60, 60, x) }

$[fix_location]
overload update_UINH = {_update_HpmEvent_UINH}

$[fix_location]
val _set_HpmEvent_UINH : (register(HpmEvent), bitvector(1)) -> unit

$[complete]
$[fix_location]
function _set_HpmEvent_UINH (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_HpmEvent_UINH(r, v)
}

overload _mod_UINH = {_get_HpmEvent_UINH, _set_HpmEvent_UINH}

$[fix_location]
val _get_HpmEvent_VSINH : HpmEvent -> bitvector(1)

$[complete]
$[fix_location]
function _get_HpmEvent_VSINH v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 59, 59)

$[fix_location]
val _update_HpmEvent_VSINH : (HpmEvent, bitvector(1)) -> HpmEvent

$[complete]
$[fix_location]
function _update_HpmEvent_VSINH (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 59, 59, x) }

$[fix_location]
overload update_VSINH = {_update_HpmEvent_VSINH}

$[fix_location]
val _set_HpmEvent_VSINH : (register(HpmEvent), bitvector(1)) -> unit

$[complete]
$[fix_location]
function _set_HpmEvent_VSINH (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_HpmEvent_VSINH(r, v)
}

overload _mod_VSINH = {_get_HpmEvent_VSINH, _set_HpmEvent_VSINH}

$[fix_location]
val _get_HpmEvent_VUINH : HpmEvent -> bitvector(1)

$[complete]
$[fix_location]
function _get_HpmEvent_VUINH v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 58, 58)

$[fix_location]
val _update_HpmEvent_VUINH : (HpmEvent, bitvector(1)) -> HpmEvent

$[complete]
$[fix_location]
function _update_HpmEvent_VUINH (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 58, 58, x) }

$[fix_location]
overload update_VUINH = {_update_HpmEvent_VUINH}

$[fix_location]
val _set_HpmEvent_VUINH : (register(HpmEvent), bitvector(1)) -> unit

$[complete]
$[fix_location]
function _set_HpmEvent_VUINH (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_HpmEvent_VUINH(r, v)
}

overload _mod_VUINH = {_get_HpmEvent_VUINH, _set_HpmEvent_VUINH}

$[fix_location]
val _get_HpmEvent_event : HpmEvent -> bitvector(32)

$[complete]
$[fix_location]
function _get_HpmEvent_event v = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v.bits, 31, 0)

$[fix_location]
val _update_HpmEvent_event : (HpmEvent, bitvector(32)) -> HpmEvent

$[complete]
$[fix_location]
function _update_HpmEvent_event (v, x) = { v with bits = $[overloaded { "name" = "vector_update_subrange", "is_infix" = false }] update_subrange_bits(v.bits, 31, 0, x) }

$[fix_location]
overload update_event = {_update_HpmEvent_event}

$[fix_location]
val _set_HpmEvent_event : (register(HpmEvent), bitvector(32)) -> unit

$[complete]
$[fix_location]
function _set_HpmEvent_event (r_ref, v) = {
    let r = __deref(r_ref);
    (*r_ref) = _update_HpmEvent_event(r, v)
}

overload _mod_event = {_get_HpmEvent_event, _set_HpmEvent_event}

register mhpmevent : vector(32, HpmEvent)

register mhpmcounter : vector(32, bits(64))

type hpmidx = range(3, 31)

val hpmidx_from_bits : bitvector(5) -> range(3, 31)

$[complete]
function hpmidx_from_bits b : bits(5) = {
    let index = unsigned(b);
    assert($[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(index, 3), "unreachable HPM index");
    index
}

val legalize_hpmevent : HpmEvent -> HpmEvent

$[complete]
function legalize_hpmevent v : HpmEvent = {
    _update_HpmEvent_event(_update_HpmEvent_VUINH(_update_HpmEvent_VSINH(_update_HpmEvent_UINH(_update_HpmEvent_SINH(_update_HpmEvent_MINH(_update_HpmEvent_OF(Mk_HpmEvent(zeros(64)), if currentlyEnabled(Ext_Sscofpmf) then
      _get_HpmEvent_OF(v)
    else
      0b0), if currentlyEnabled(Ext_Sscofpmf) then _get_HpmEvent_MINH(v) else
      0b0), if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Sscofpmf), currentlyEnabled(Ext_S)) then
      _get_HpmEvent_SINH(v)
    else
      0b0), if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Sscofpmf), currentlyEnabled(Ext_U)) then
      _get_HpmEvent_UINH(v)
    else
      0b0), 0b0), 0b0), _get_HpmEvent_event(v))
}

val read_mhpmcounter : range(3, 31) -> bitvector(xlen)

$[complete]
function read_mhpmcounter index : hpmidx = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(mhpmcounter, index), $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(xlen, 1), 0)

val read_mhpmcounterh : range(3, 31) -> bitvector(32)

$[complete]
function read_mhpmcounterh index : hpmidx = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(mhpmcounter, index), 63, 32)

val read_mhpmevent : range(3, 31) -> bitvector(xlen)

$[complete]
function read_mhpmevent index : hpmidx = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(plain_vector_access(mhpmevent, index).bits, $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(xlen, 1), 0)

val write_mhpmcounter : (range(3, 31), bitvector(xlen)) -> unit

$[complete]
function write_mhpmcounter (index : hpmidx, value : xlenbits) = if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(sys_writable_hpm_counters, index), bitone) then
  mhpmcounter[index][$[overloaded { "name" = "-", "is_infix" = true }] sub_atom(xlen, 1) .. 0] = value
else ()

val write_mhpmcounterh : (range(3, 31), bitvector(32)) -> unit

$[complete]
function write_mhpmcounterh (index : hpmidx, value : bits(32)) = if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(sys_writable_hpm_counters, index), bitone) then
  mhpmcounter[index][63 .. 32] = value
else ()

val write_mhpmevent : (range(3, 31), bitvector(xlen)) -> unit

$[complete]
function write_mhpmevent (index : hpmidx, value : xlenbits) = if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(sys_writable_hpm_counters, index), bitone) then
  mhpmevent[index] = legalize_hpmevent(Mk_HpmEvent($[complete] match xlen {
    32 => $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(plain_vector_access(mhpmevent, index).bits, 63, 32), value),
    64 => value,
    _ => internal_error("./extensions/Zihpm/zihpm.sail", 223, "Unsupported xlen")
  }))
else ()

val read_mhpmeventh : range(3, 31) -> bitvector(32)

$[complete]
function read_mhpmeventh index : hpmidx = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(plain_vector_access(mhpmevent, index).bits, 63, 32)

val write_mhpmeventh : (range(3, 31), bitvector(32)) -> unit

$[complete]
function write_mhpmeventh (index : hpmidx, value : bits(32)) = if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(sys_writable_hpm_counters, index), bitone) then
  mhpmevent[index] = legalize_hpmevent(Mk_HpmEvent($[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(value, $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(plain_vector_access(mhpmevent, index).bits, 31, 0))))
else ()

val get_scountovf : Privilege -> bitvector(32)

$[complete]
function get_scountovf priv : Privilege = {
    let overflow = $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(_get_HpmEvent_OF($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(mhpmevent, 31)), $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(_get_HpmEvent_OF($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(mhpmevent, 30)), $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(_get_HpmEvent_OF($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(mhpmevent, 29)), $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(_get_HpmEvent_OF($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(mhpmevent, 28)), $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(_get_HpmEvent_OF($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(mhpmevent, 27)), $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(_get_HpmEvent_OF($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(mhpmevent, 26)), $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(_get_HpmEvent_OF($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(mhpmevent, 25)), $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(_get_HpmEvent_OF($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(mhpmevent, 24)), $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(_get_HpmEvent_OF($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(mhpmevent, 23)), $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(_get_HpmEvent_OF($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(mhpmevent, 22)), $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(_get_HpmEvent_OF($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(mhpmevent, 21)), $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(_get_HpmEvent_OF($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(mhpmevent, 20)), $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(_get_HpmEvent_OF($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(mhpmevent, 19)), $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(_get_HpmEvent_OF($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(mhpmevent, 18)), $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(_get_HpmEvent_OF($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(mhpmevent, 17)), $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(_get_HpmEvent_OF($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(mhpmevent, 16)), $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(_get_HpmEvent_OF($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(mhpmevent, 15)), $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(_get_HpmEvent_OF($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(mhpmevent, 14)), $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(_get_HpmEvent_OF($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(mhpmevent, 13)), $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(_get_HpmEvent_OF($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(mhpmevent, 12)), $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(_get_HpmEvent_OF($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(mhpmevent, 11)), $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(_get_HpmEvent_OF($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(mhpmevent, 10)), $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(_get_HpmEvent_OF($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(mhpmevent, 9)), $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(_get_HpmEvent_OF($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(mhpmevent, 8)), $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(_get_HpmEvent_OF($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(mhpmevent, 7)), $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(_get_HpmEvent_OF($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(mhpmevent, 6)), $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(_get_HpmEvent_OF($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(mhpmevent, 5)), $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(_get_HpmEvent_OF($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(mhpmevent, 4)), $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(_get_HpmEvent_OF($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(mhpmevent, 3)), 0b000)))))))))))))))))))))))))))));
    $[complete] match priv {
      Machine => overflow,
      Supervisor => $[overloaded { "name" = "&", "is_infix" = true }] and_vec(overflow, mcounteren.bits),
      User => internal_error("./extensions/Sscofpmf/sscofpmf.sail", 74, "scountovf not readable from User mode"),
      VirtualUser => internal_error("./extensions/Sscofpmf/sscofpmf.sail", 75, "Hypervisor extension not supported"),
      VirtualSupervisor => internal_error("./extensions/Sscofpmf/sscofpmf.sail", 76, "Hypervisor extension not supported")
    }
}

val sstc_CSRs_accessible : Privilege -> bool

$[complete]
function sstc_CSRs_accessible priv : Privilege = $[overloaded { "name" = "|", "is_infix" = true }] or_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_anything(priv, Machine), $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_anything(priv, Supervisor), $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_bits(_get_Counteren_TM(mcounteren), 0b1), $[overloaded { "name" = "==", "is_infix" = true }] eq_bits(_get_MEnvcfg_STCE(menvcfg), 0b1))))

val encdec_wrsop : wrsop <-> bitvector(12)

mapping encdec_wrsop = {
  WRS_STO <-> 0b000000011101,
  WRS_NTO <-> 0b000000001101
}

val encdec_zicondop : zicondop <-> bitvector(3)

mapping encdec_zicondop = {
  CZERO_EQZ <-> 0b101,
  CZERO_NEZ <-> 0b111
}

val zicond_mnemonic : zicondop <-> string

mapping zicond_mnemonic = {
  CZERO_EQZ <-> "czero.eqz",
  CZERO_NEZ <-> "czero.nez"
}

val cbo_clean_flush_enabled : Privilege -> bool

$[complete]
function cbo_clean_flush_enabled p : Privilege = feature_enabled_for_priv(p, $[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(_get_MEnvcfg_CBCFE(menvcfg), 0), $[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(_get_SEnvcfg_CBCFE(senvcfg), 0))

val encdec_cbop : cbop_zicbom <-> bitvector(12)

mapping encdec_cbop = {
  CBO_CLEAN <-> 0b000000000001,
  CBO_FLUSH <-> 0b000000000010,
  CBO_INVAL <-> 0b000000000000
}

val cbop_mnemonic : cbop_zicbom <-> string

mapping cbop_mnemonic = {
  CBO_CLEAN <-> "cbo.clean",
  CBO_FLUSH <-> "cbo.flush",
  CBO_INVAL <-> "cbo.inval"
}

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum cbie = {CBIE_ILLEGAL, CBIE_EXEC_FLUSH, CBIE_EXEC_INVAL}

val undefined_cbie : unit -> cbie

$[complete]
function undefined_cbie () = internal_pick([|CBIE_ILLEGAL, CBIE_EXEC_FLUSH, CBIE_EXEC_INVAL|])

val cbie_of_num : forall ('e : Int), (0 <= 'e & 'e <= 2). int('e) -> cbie

$[complete]
function cbie_of_num arg# = $[complete] match arg# {
  0 => CBIE_ILLEGAL,
  1 => CBIE_EXEC_FLUSH,
  _ => CBIE_EXEC_INVAL
}

val num_of_cbie : cbie -> {('e : Int), (0 <= 'e & 'e <= 2). int('e)}

$[complete]
function num_of_cbie arg# = $[complete] match arg# {
  CBIE_ILLEGAL => 0,
  CBIE_EXEC_FLUSH => 1,
  CBIE_EXEC_INVAL => 2
}

val encdec_cbie : cbie <-> bitvector(2)

mapping encdec_cbie = {
  CBIE_ILLEGAL <-> 0b00,
  CBIE_EXEC_FLUSH <-> 0b01,
  CBIE_EXEC_INVAL <-> 0b11,
  backwards 0b10 => internal_error("./extensions/Zicbom/zicbom_insts.sail", 44, "reserved CBIE")
}

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum checked_cbop = {
  CBOP_ILLEGAL,
  CBOP_ILLEGAL_VIRTUAL,
  CBOP_INVAL_FLUSH,
  CBOP_INVAL_INVAL
}

val undefined_checked_cbop : unit -> checked_cbop

$[complete]
function undefined_checked_cbop () = internal_pick([|CBOP_ILLEGAL, CBOP_ILLEGAL_VIRTUAL, CBOP_INVAL_FLUSH, CBOP_INVAL_INVAL|])

val checked_cbop_of_num : forall ('e : Int), (0 <= 'e & 'e <= 3).
  int('e) -> checked_cbop

$[complete]
function checked_cbop_of_num arg# = $[complete] match arg# {
  0 => CBOP_ILLEGAL,
  1 => CBOP_ILLEGAL_VIRTUAL,
  2 => CBOP_INVAL_FLUSH,
  _ => CBOP_INVAL_INVAL
}

val num_of_checked_cbop : checked_cbop -> {('e : Int), (0 <= 'e & 'e <= 3). int('e)}

$[complete]
function num_of_checked_cbop arg# = $[complete] match arg# {
  CBOP_ILLEGAL => 0,
  CBOP_ILLEGAL_VIRTUAL => 1,
  CBOP_INVAL_FLUSH => 2,
  CBOP_INVAL_INVAL => 3
}

val cbop_priv_check : Privilege -> checked_cbop

$[complete]
function cbop_priv_check p : Privilege = {
    let mCBIE : cbie = encdec_cbie_backwards(_get_MEnvcfg_CBIE(menvcfg));
    let sCBIE : cbie = if currentlyEnabled(Ext_S) then
      encdec_cbie_backwards(_get_SEnvcfg_CBIE(senvcfg))
    else
      encdec_cbie_backwards(_get_MEnvcfg_CBIE(menvcfg));
    $[complete] match (p, mCBIE, sCBIE) {
      (VirtualUser, _, _) => internal_error("./extensions/Zicbom/zicbom_insts.sail", 58, "Hypervisor extension not supported"),
      (VirtualSupervisor, _, _) => internal_error("./extensions/Zicbom/zicbom_insts.sail", 59, "Hypervisor extension not supported"),
      (Machine, _, _) => CBOP_INVAL_INVAL,
      (_, CBIE_ILLEGAL, _) => CBOP_ILLEGAL,
      (User, _, CBIE_ILLEGAL) => CBOP_ILLEGAL,
      (_, CBIE_EXEC_FLUSH, _) => CBOP_INVAL_FLUSH,
      (User, _, CBIE_EXEC_FLUSH) => CBOP_INVAL_FLUSH,
      _ => CBOP_INVAL_INVAL
    }
}

val process_clean_inval : (regidx, cbop_zicbom) -> ExecutionResult

$[complete]
function process_clean_inval (rs1, cbop) = {
    let rs1_val = $[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1);
    let cache_block_size = 2 ^ plat_cache_block_size_exp;
    let negative_offset = $[overloaded { "name" = "-", "is_infix" = true }] sub_vec($[overloaded { "name" = "&", "is_infix" = true }] and_vec(rs1_val, $[overloaded { "name" = "~", "is_infix" = false }] not_vec(zero_extend(sizeof(xlen), ones(plat_cache_block_size_exp)))), rs1_val);
    $[complete] match ext_data_get_addr(rs1, negative_offset, Read(Data), cache_block_size) {
      Ext_DataAddr_Error(e) => Ext_DataAddr_Check_Failure(e),
      Ext_DataAddr_OK(vaddr) => {
          let res : option(ExceptionType) = $[complete] match translateAddr(vaddr, Read(Data)) {
            Ok((paddr, _)) => {
                let ep = effectivePrivilege(Read(Data), mstatus, cur_privilege);
                let exc_read = phys_access_check(Read(Data), ep, paddr, cache_block_size);
                let exc_write = phys_access_check(Write(Data), ep, paddr, cache_block_size);
                $[complete] match (exc_read, exc_write) {
                  (Some(exc_read), Some(exc_write)) => Some(exc_write),
                  _ => None()
                }
            },
            Err((e, _)) => Some(e)
          };
          $[complete] match res {
            None(()) => RETIRE_SUCCESS,
            Some(e) => {
                let e : ExceptionType = $[complete] match e {
                  E_Load_Access_Fault(()) => E_SAMO_Access_Fault(),
                  E_SAMO_Access_Fault(()) => E_SAMO_Access_Fault(),
                  E_Load_Page_Fault(()) => E_SAMO_Page_Fault(),
                  E_SAMO_Page_Fault(()) => E_SAMO_Page_Fault(),
                  _ => internal_error("./extensions/Zicbom/zicbom_insts.sail", 127, "unexpected exception for cmo.clean/inval")
                };
                Memory_Exception(($[overloaded { "name" = "-", "is_infix" = true }] sub_virtaddr_xlenbits(vaddr, negative_offset), e))
            }
          }
      }
    }
}

val cbo_zero_enabled : Privilege -> bool

$[complete]
function cbo_zero_enabled p : Privilege = feature_enabled_for_priv(p, $[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(_get_MEnvcfg_CBZE(menvcfg), 0), $[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(_get_SEnvcfg_CBZE(senvcfg), 0))

val fsplit_BF16 : bitvector(16) -> (bitvector(1), bitvector(8), bitvector(7))

$[complete]
function fsplit_BF16 v : bits(16) = ($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v, 15, 15), $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v, 14, 7), $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(v, 6, 0))

val fmake_BF16 : (bitvector(1), bitvector(8), bitvector(7)) -> bitvector(16)

$[complete]
function fmake_BF16 (sign : bits(1), exp : bits(8), mant : bits(7)) = $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(sign, $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(exp, mant))

val bf16_to_f32 : bitvector(16) -> (bitvector(5), bitvector(32))

$[complete]
function bf16_to_f32 v : bits(16) = {
    let (sign, exp, mant) = fsplit_BF16(v);
    let is_nan = $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_bits(exp, ones(8)), $[overloaded { "name" = "!=", "is_infix" = true }] neq_bits(mant, zeros(7)));
    let is_inf = $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_bits(exp, ones(8)), $[overloaded { "name" = "==", "is_infix" = true }] eq_bits(mant, zeros(7)));
    let fflags = if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(is_nan, gteq_int(signed(mant), 0) : bool) then
      nvFlag()
    else
      zeros(5);
    let value = if is_nan then canonical_NaN_S() else
      if is_inf then fmake_S(sign, ones(8), zeros(23)) else
        fmake_S(sign, exp, $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(mant, zeros(16)));
    (fflags, value)
}

$[complete]
function currentlyEnabled Ext_Zkt = hartSupports(Ext_Zkt)
and currentlyEnabled Ext_Zvkt = hartSupports(Ext_Zvkt)
and currentlyEnabled Ext_Zvkn = hartSupports(Ext_Zvkn)
and currentlyEnabled Ext_Zvknc = hartSupports(Ext_Zvknc)
and currentlyEnabled Ext_Zvkng = hartSupports(Ext_Zvkng)
and currentlyEnabled Ext_Zvks = hartSupports(Ext_Zvks)
and currentlyEnabled Ext_Zvksc = hartSupports(Ext_Zvksc)
and currentlyEnabled Ext_Zvksg = hartSupports(Ext_Zvksg)
and currentlyEnabled Ext_Sstc = hartSupports(Ext_Sstc)
and currentlyEnabled Ext_U = $[overloaded { "name" = "&", "is_infix" = true }] and_bool(hartSupports(Ext_U), $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_bits(_get_Misa_U(misa), 0b1), currentlyEnabled(Ext_Zicsr)))
and currentlyEnabled Ext_S = $[overloaded { "name" = "&", "is_infix" = true }] and_bool(hartSupports(Ext_S), $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_bits(_get_Misa_S(misa), 0b1), currentlyEnabled(Ext_Zicsr)))
and currentlyEnabled Ext_Svbare = currentlyEnabled(Ext_S)
and currentlyEnabled Ext_Sv32 = $[overloaded { "name" = "&", "is_infix" = true }] and_bool(hartSupports(Ext_Sv32), currentlyEnabled(Ext_S))
and currentlyEnabled Ext_Sv39 = $[overloaded { "name" = "&", "is_infix" = true }] and_bool(hartSupports(Ext_Sv39), currentlyEnabled(Ext_S))
and currentlyEnabled Ext_Sv48 = $[overloaded { "name" = "&", "is_infix" = true }] and_bool(hartSupports(Ext_Sv48), currentlyEnabled(Ext_S))
and currentlyEnabled Ext_Sv57 = $[overloaded { "name" = "&", "is_infix" = true }] and_bool(hartSupports(Ext_Sv57), currentlyEnabled(Ext_S))
and currentlyEnabled Ext_F = $[overloaded { "name" = "&", "is_infix" = true }] and_bool(hartSupports(Ext_F), $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_bits(_get_Misa_F(misa), 0b1), $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "!=", "is_infix" = true }] neq_bits(_get_Mstatus_FS(mstatus), 0b00), currentlyEnabled(Ext_Zicsr))))
and currentlyEnabled Ext_D = $[overloaded { "name" = "&", "is_infix" = true }] and_bool(hartSupports(Ext_D), $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_bits(_get_Misa_D(misa), 0b1), $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "!=", "is_infix" = true }] neq_bits(_get_Mstatus_FS(mstatus), 0b00), $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(flen, 64), currentlyEnabled(Ext_Zicsr)))))
and currentlyEnabled Ext_Zfinx = $[overloaded { "name" = "&", "is_infix" = true }] and_bool(hartSupports(Ext_Zfinx), currentlyEnabled(Ext_Zicsr))
and currentlyEnabled Ext_V = $[overloaded { "name" = "&", "is_infix" = true }] and_bool(hartSupports(Ext_V), $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_bits(_get_Misa_V(misa), 0b1), $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "!=", "is_infix" = true }] neq_bits(_get_Mstatus_VS(mstatus), 0b00), currentlyEnabled(Ext_Zicsr))))
and currentlyEnabled Ext_Smcntrpmf = $[overloaded { "name" = "&", "is_infix" = true }] and_bool(hartSupports(Ext_Smcntrpmf), currentlyEnabled(Ext_Zicntr))
and currentlyEnabled Ext_Svnapot = false
and currentlyEnabled Ext_Svpbmt = false
and currentlyEnabled Ext_Svrsw60t59b = $[overloaded { "name" = "&", "is_infix" = true }] and_bool(hartSupports(Ext_Svrsw60t59b), currentlyEnabled(Ext_Sv39))
and currentlyEnabled Ext_Zicbop = hartSupports(Ext_Zicbop)
and currentlyEnabled Ext_Zihintntl = hartSupports(Ext_Zihintntl)
and currentlyEnabled Ext_Zihintpause = hartSupports(Ext_Zihintpause)
and currentlyEnabled Ext_C = $[overloaded { "name" = "&", "is_infix" = true }] and_bool(hartSupports(Ext_C), $[overloaded { "name" = "==", "is_infix" = true }] eq_bits(_get_Misa_C(misa), 0b1))
and currentlyEnabled Ext_Zca = $[overloaded { "name" = "&", "is_infix" = true }] and_bool(hartSupports(Ext_Zca), $[overloaded { "name" = "|", "is_infix" = true }] or_bool(currentlyEnabled(Ext_C), not(hartSupports(Ext_C))))
and currentlyEnabled Ext_A = $[overloaded { "name" = "&", "is_infix" = true }] and_bool(hartSupports(Ext_A), $[overloaded { "name" = "==", "is_infix" = true }] eq_bits(_get_Misa_A(misa), 0b1))
and currentlyEnabled Ext_Zaamo = $[overloaded { "name" = "|", "is_infix" = true }] or_bool(hartSupports(Ext_Zaamo), currentlyEnabled(Ext_A))
and currentlyEnabled Ext_Zabha = $[overloaded { "name" = "&", "is_infix" = true }] and_bool(hartSupports(Ext_Zabha), currentlyEnabled(Ext_Zaamo))
and currentlyEnabled Ext_Zacas = $[overloaded { "name" = "&", "is_infix" = true }] and_bool(hartSupports(Ext_Zacas), currentlyEnabled(Ext_Zaamo))
and currentlyEnabled Ext_Zalrsc = $[overloaded { "name" = "|", "is_infix" = true }] or_bool(hartSupports(Ext_Zalrsc), currentlyEnabled(Ext_A))
and currentlyEnabled Ext_M = $[overloaded { "name" = "&", "is_infix" = true }] and_bool(hartSupports(Ext_M), $[overloaded { "name" = "==", "is_infix" = true }] eq_bits(_get_Misa_M(misa), 0b1))
and currentlyEnabled Ext_Zmmul = $[overloaded { "name" = "|", "is_infix" = true }] or_bool(hartSupports(Ext_Zmmul), currentlyEnabled(Ext_M))
and currentlyEnabled Ext_B = $[overloaded { "name" = "&", "is_infix" = true }] and_bool(hartSupports(Ext_B), $[overloaded { "name" = "==", "is_infix" = true }] eq_bits(_get_Misa_B(misa), 0b1))
and currentlyEnabled Ext_Zba = $[overloaded { "name" = "|", "is_infix" = true }] or_bool(hartSupports(Ext_Zba), currentlyEnabled(Ext_B))
and currentlyEnabled Ext_Zbb = $[overloaded { "name" = "|", "is_infix" = true }] or_bool(hartSupports(Ext_Zbb), currentlyEnabled(Ext_B))
and currentlyEnabled Ext_Zbkb = hartSupports(Ext_Zbkb)
and currentlyEnabled Ext_Zbc = hartSupports(Ext_Zbc)
and currentlyEnabled Ext_Zbkc = hartSupports(Ext_Zbkc)
and currentlyEnabled Ext_Zbs = $[overloaded { "name" = "|", "is_infix" = true }] or_bool(hartSupports(Ext_Zbs), currentlyEnabled(Ext_B))
and currentlyEnabled Ext_Zcb = $[overloaded { "name" = "&", "is_infix" = true }] and_bool(hartSupports(Ext_Zcb), currentlyEnabled(Ext_Zca))
and currentlyEnabled Ext_H = $[overloaded { "name" = "&", "is_infix" = true }] and_bool(hartSupports(Ext_H), $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_bits(_get_Misa_H(misa), 0b1), virtual_memory_supported()))
and currentlyEnabled Ext_Zfh = $[overloaded { "name" = "&", "is_infix" = true }] and_bool(hartSupports(Ext_Zfh), currentlyEnabled(Ext_F))
and currentlyEnabled Ext_Zfhmin = $[overloaded { "name" = "|", "is_infix" = true }] or_bool($[overloaded { "name" = "&", "is_infix" = true }] and_bool(hartSupports(Ext_Zfhmin), currentlyEnabled(Ext_F)), currentlyEnabled(Ext_Zfh))
and currentlyEnabled Ext_Zcf = $[overloaded { "name" = "&", "is_infix" = true }] and_bool(hartSupports(Ext_Zcf), $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_F), $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zca), $[overloaded { "name" = "|", "is_infix" = true }] or_bool(currentlyEnabled(Ext_C), not(hartSupports(Ext_C))))))
and currentlyEnabled Ext_Zdinx = $[overloaded { "name" = "&", "is_infix" = true }] and_bool(hartSupports(Ext_Zdinx), $[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(flen, 64))
and currentlyEnabled Ext_Zcd = $[overloaded { "name" = "&", "is_infix" = true }] and_bool(hartSupports(Ext_Zcd), $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_D), $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zca), $[overloaded { "name" = "|", "is_infix" = true }] or_bool(currentlyEnabled(Ext_C), not(hartSupports(Ext_C))))))
and currentlyEnabled Ext_Zhinx = $[overloaded { "name" = "&", "is_infix" = true }] and_bool(hartSupports(Ext_Zhinx), currentlyEnabled(Ext_Zfinx))
and currentlyEnabled Ext_Zhinxmin = $[overloaded { "name" = "|", "is_infix" = true }] or_bool($[overloaded { "name" = "&", "is_infix" = true }] and_bool(hartSupports(Ext_Zhinxmin), currentlyEnabled(Ext_Zfinx)), currentlyEnabled(Ext_Zhinx))
and currentlyEnabled Ext_Zfa = $[overloaded { "name" = "&", "is_infix" = true }] and_bool(hartSupports(Ext_Zfa), currentlyEnabled(Ext_F))
and currentlyEnabled Ext_Zknh = hartSupports(Ext_Zknh)
and currentlyEnabled Ext_Zkne = hartSupports(Ext_Zkne)
and currentlyEnabled Ext_Zknd = hartSupports(Ext_Zknd)
and currentlyEnabled Ext_Zksh = hartSupports(Ext_Zksh)
and currentlyEnabled Ext_Zksed = hartSupports(Ext_Zksed)
and currentlyEnabled Ext_Zkr = hartSupports(Ext_Zkr)
and currentlyEnabled Ext_Zbkx = hartSupports(Ext_Zbkx)
and currentlyEnabled Ext_Zvbb = $[overloaded { "name" = "&", "is_infix" = true }] and_bool(hartSupports(Ext_Zvbb), currentlyEnabled(Ext_V))
and currentlyEnabled Ext_Zvkb = $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "|", "is_infix" = true }] or_bool(hartSupports(Ext_Zvkb), currentlyEnabled(Ext_Zvbb)), currentlyEnabled(Ext_V))
and currentlyEnabled Ext_Zvbc = $[overloaded { "name" = "&", "is_infix" = true }] and_bool(hartSupports(Ext_Zvbc), currentlyEnabled(Ext_V))
and currentlyEnabled Ext_Zvkg = $[overloaded { "name" = "&", "is_infix" = true }] and_bool(hartSupports(Ext_Zvkg), currentlyEnabled(Ext_V))
and currentlyEnabled Ext_Zvkned = $[overloaded { "name" = "&", "is_infix" = true }] and_bool(hartSupports(Ext_Zvkned), currentlyEnabled(Ext_V))
and currentlyEnabled Ext_Zvksed = $[overloaded { "name" = "&", "is_infix" = true }] and_bool(hartSupports(Ext_Zvksed), currentlyEnabled(Ext_V))
and currentlyEnabled Ext_Zvknha = $[overloaded { "name" = "&", "is_infix" = true }] and_bool(hartSupports(Ext_Zvknha), currentlyEnabled(Ext_V))
and currentlyEnabled Ext_Zvknhb = $[overloaded { "name" = "&", "is_infix" = true }] and_bool(hartSupports(Ext_Zvknhb), currentlyEnabled(Ext_V))
and currentlyEnabled Ext_Zvksh = $[overloaded { "name" = "&", "is_infix" = true }] and_bool(hartSupports(Ext_Zvksh), currentlyEnabled(Ext_V))
and currentlyEnabled Ext_Zicsr = hartSupports(Ext_Zicsr)
and currentlyEnabled Ext_Svinval = hartSupports(Ext_Svinval)
and currentlyEnabled Ext_Zihpm = $[overloaded { "name" = "&", "is_infix" = true }] and_bool(hartSupports(Ext_Zihpm), currentlyEnabled(Ext_Zicsr))
and currentlyEnabled Ext_Sscofpmf = $[overloaded { "name" = "&", "is_infix" = true }] and_bool(hartSupports(Ext_Sscofpmf), currentlyEnabled(Ext_Zihpm))
and currentlyEnabled Ext_Zawrs = hartSupports(Ext_Zawrs)
and currentlyEnabled Ext_Zicond = hartSupports(Ext_Zicond)
and currentlyEnabled Ext_Zicntr = $[overloaded { "name" = "&", "is_infix" = true }] and_bool(hartSupports(Ext_Zicntr), currentlyEnabled(Ext_Zicsr))
and currentlyEnabled Ext_Zicbom = hartSupports(Ext_Zicbom)
and currentlyEnabled Ext_Zicboz = hartSupports(Ext_Zicboz)
and currentlyEnabled Ext_Zifencei = hartSupports(Ext_Zifencei)
and currentlyEnabled Ext_Zfbfmin = $[overloaded { "name" = "&", "is_infix" = true }] and_bool(hartSupports(Ext_Zfbfmin), currentlyEnabled(Ext_F))
and currentlyEnabled Ext_Zimop = hartSupports(Ext_Zimop)
and currentlyEnabled Ext_Zcmop = $[overloaded { "name" = "&", "is_infix" = true }] and_bool(hartSupports(Ext_Zcmop), currentlyEnabled(Ext_Zca))

mapping encdec = {
  ZICBOP(cbop, rs1, (offset11_5 : bitvector(7)) @ 0b00000) if currentlyEnabled(Ext_Zicbop) <-> (offset11_5 : bitvector(7)) @ encdec_cbop_zicbop(cbop) @ encdec_reg(rs1) @ 0b110 @ 0b00000 @ 0b0010011 if currentlyEnabled(Ext_Zicbop),
  NTL(op) if currentlyEnabled(Ext_Zihintntl) <-> 0b0000000 @ encdec_ntl(op) @ 0b00000 @ 0b000 @ 0b00000 @ 0b0110011 if currentlyEnabled(Ext_Zihintntl),
  PAUSE(()) if currentlyEnabled(Ext_Zihintpause) <-> 0b0000 @ 0b0001 @ 0b0000 @ 0b00000 @ 0b000 @ 0b00000 @ 0b0001111 if currentlyEnabled(Ext_Zihintpause),
  UTYPE(imm, rd, op) <-> (imm : bitvector(20)) @ encdec_reg(rd) @ encdec_uop(op),
  JAL((imm_19 : bits(1)) @ (imm_7_0 : bits(8)) @ (imm_8 : bits(1)) @ (imm_18_13 : bits(6)) @ (imm_12_9 : bits(4)) @ 0b0, rd) <-> (imm_19 : bits(1)) @ (imm_18_13 : bits(6)) @ (imm_12_9 : bits(4)) @ (imm_8 : bits(1)) @ (imm_7_0 : bits(8)) @ encdec_reg(rd) @ 0b1101111,
  JALR(imm, rs1, rd) <-> (imm : bitvector(12)) @ encdec_reg(rs1) @ 0b000 @ encdec_reg(rd) @ 0b1100111,
  BTYPE((imm7_6 : bits(1)) @ (imm5_0 : bits(1)) @ (imm7_5_0 : bits(6)) @ (imm5_4_1 : bits(4)) @ 0b0, rs2, rs1, op) <-> (imm7_6 : bits(1)) @ (imm7_5_0 : bits(6)) @ encdec_reg(rs2) @ encdec_reg(rs1) @ encdec_bop(op) @ (imm5_4_1 : bits(4)) @ (imm5_0 : bits(1)) @ 0b1100011,
  ITYPE(imm, rs1, rd, op) <-> (imm : bitvector(12)) @ encdec_reg(rs1) @ encdec_iop(op) @ encdec_reg(rd) @ 0b0010011,
  SHIFTIOP(shamt, rs1, rd, SLLI) if $[overloaded { "name" = "|", "is_infix" = true }] or_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64), $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(shamt, 5), bitzero)) <-> 0b000000 @ (shamt : bitvector(6)) @ encdec_reg(rs1) @ 0b001 @ encdec_reg(rd) @ 0b0010011 if $[overloaded { "name" = "|", "is_infix" = true }] or_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64), $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(shamt, 5), bitzero)),
  SHIFTIOP(shamt, rs1, rd, SRLI) if $[overloaded { "name" = "|", "is_infix" = true }] or_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64), $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(shamt, 5), bitzero)) <-> 0b000000 @ (shamt : bitvector(6)) @ encdec_reg(rs1) @ 0b101 @ encdec_reg(rd) @ 0b0010011 if $[overloaded { "name" = "|", "is_infix" = true }] or_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64), $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(shamt, 5), bitzero)),
  SHIFTIOP(shamt, rs1, rd, SRAI) if $[overloaded { "name" = "|", "is_infix" = true }] or_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64), $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(shamt, 5), bitzero)) <-> 0b010000 @ (shamt : bitvector(6)) @ encdec_reg(rs1) @ 0b101 @ encdec_reg(rd) @ 0b0010011 if $[overloaded { "name" = "|", "is_infix" = true }] or_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64), $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(shamt, 5), bitzero)),
  RTYPE(rs2, rs1, rd, ADD) <-> 0b0000000 @ encdec_reg(rs2) @ encdec_reg(rs1) @ 0b000 @ encdec_reg(rd) @ 0b0110011,
  RTYPE(rs2, rs1, rd, SLT) <-> 0b0000000 @ encdec_reg(rs2) @ encdec_reg(rs1) @ 0b010 @ encdec_reg(rd) @ 0b0110011,
  RTYPE(rs2, rs1, rd, SLTU) <-> 0b0000000 @ encdec_reg(rs2) @ encdec_reg(rs1) @ 0b011 @ encdec_reg(rd) @ 0b0110011,
  RTYPE(rs2, rs1, rd, AND) <-> 0b0000000 @ encdec_reg(rs2) @ encdec_reg(rs1) @ 0b111 @ encdec_reg(rd) @ 0b0110011,
  RTYPE(rs2, rs1, rd, OR) <-> 0b0000000 @ encdec_reg(rs2) @ encdec_reg(rs1) @ 0b110 @ encdec_reg(rd) @ 0b0110011,
  RTYPE(rs2, rs1, rd, XOR) <-> 0b0000000 @ encdec_reg(rs2) @ encdec_reg(rs1) @ 0b100 @ encdec_reg(rd) @ 0b0110011,
  RTYPE(rs2, rs1, rd, SLL) <-> 0b0000000 @ encdec_reg(rs2) @ encdec_reg(rs1) @ 0b001 @ encdec_reg(rd) @ 0b0110011,
  RTYPE(rs2, rs1, rd, SRL) <-> 0b0000000 @ encdec_reg(rs2) @ encdec_reg(rs1) @ 0b101 @ encdec_reg(rd) @ 0b0110011,
  RTYPE(rs2, rs1, rd, SUB) <-> 0b0100000 @ encdec_reg(rs2) @ encdec_reg(rs1) @ 0b000 @ encdec_reg(rd) @ 0b0110011,
  RTYPE(rs2, rs1, rd, SRA) <-> 0b0100000 @ encdec_reg(rs2) @ encdec_reg(rs1) @ 0b101 @ encdec_reg(rd) @ 0b0110011,
  LOAD(imm, rs1, rd, is_unsigned, width) if valid_load_encdec(width, is_unsigned) <-> (imm : bitvector(12)) @ encdec_reg(rs1) @ bool_bits(is_unsigned) @ width_enc(width) @ encdec_reg(rd) @ 0b0000011 if valid_load_encdec(width, is_unsigned),
  STORE((imm7 : bits(7)) @ (imm5 : bits(5)), rs2, rs1, width) if $[overloaded { "name" = "<=", "is_infix" = true }] lteq_int(width, xlen_bytes) <-> (imm7 : bits(7)) @ encdec_reg(rs2) @ encdec_reg(rs1) @ 0b0 @ width_enc(width) @ (imm5 : bits(5)) @ 0b0100011 if $[overloaded { "name" = "<=", "is_infix" = true }] lteq_int(width, xlen_bytes),
  ADDIW(imm, rs1, rd) if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64) <-> (imm : bitvector(12)) @ encdec_reg(rs1) @ 0b000 @ encdec_reg(rd) @ 0b0011011 if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64),
  RTYPEW(rs2, rs1, rd, ADDW) if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64) <-> 0b0000000 @ encdec_reg(rs2) @ encdec_reg(rs1) @ 0b000 @ encdec_reg(rd) @ 0b0111011 if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64),
  RTYPEW(rs2, rs1, rd, SUBW) if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64) <-> 0b0100000 @ encdec_reg(rs2) @ encdec_reg(rs1) @ 0b000 @ encdec_reg(rd) @ 0b0111011 if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64),
  RTYPEW(rs2, rs1, rd, SLLW) if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64) <-> 0b0000000 @ encdec_reg(rs2) @ encdec_reg(rs1) @ 0b001 @ encdec_reg(rd) @ 0b0111011 if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64),
  RTYPEW(rs2, rs1, rd, SRLW) if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64) <-> 0b0000000 @ encdec_reg(rs2) @ encdec_reg(rs1) @ 0b101 @ encdec_reg(rd) @ 0b0111011 if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64),
  RTYPEW(rs2, rs1, rd, SRAW) if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64) <-> 0b0100000 @ encdec_reg(rs2) @ encdec_reg(rs1) @ 0b101 @ encdec_reg(rd) @ 0b0111011 if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64),
  SHIFTIWOP(shamt, rs1, rd, SLLIW) if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64) <-> 0b0000000 @ (shamt : bitvector(5)) @ encdec_reg(rs1) @ 0b001 @ encdec_reg(rd) @ 0b0011011 if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64),
  SHIFTIWOP(shamt, rs1, rd, SRLIW) if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64) <-> 0b0000000 @ (shamt : bitvector(5)) @ encdec_reg(rs1) @ 0b101 @ encdec_reg(rd) @ 0b0011011 if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64),
  SHIFTIWOP(shamt, rs1, rd, SRAIW) if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64) <-> 0b0100000 @ (shamt : bitvector(5)) @ encdec_reg(rs1) @ 0b101 @ encdec_reg(rd) @ 0b0011011 if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64),
  FENCE(pred, succ) <-> 0b0000 @ (pred : bitvector(4)) @ (succ : bitvector(4)) @ 0b00000 @ 0b000 @ 0b00000 @ 0b0001111,
  FENCE_TSO(()) <-> 0b1000 @ 0b0011 @ 0b0011 @ 0b00000 @ 0b000 @ 0b00000 @ 0b0001111,
  ECALL(()) <-> 0b000000000000 @ 0b00000 @ 0b000 @ 0b00000 @ 0b1110011,
  MRET(()) <-> 0b0011000 @ 0b00010 @ 0b00000 @ 0b000 @ 0b00000 @ 0b1110011,
  SRET(()) <-> 0b0001000 @ 0b00010 @ 0b00000 @ 0b000 @ 0b00000 @ 0b1110011,
  EBREAK(()) <-> 0b000000000001 @ 0b00000 @ 0b000 @ 0b00000 @ 0b1110011,
  WFI(()) <-> 0b000100000101 @ 0b00000 @ 0b000 @ 0b00000 @ 0b1110011,
  SFENCE_VMA(rs1, rs2) if $[overloaded { "name" = "|", "is_infix" = true }] or_bool(virtual_memory_supported(), not(config extensions.Svbare.sfence_vma_illegal_if_svbare_only : bool)) <-> 0b0001001 @ encdec_reg(rs2) @ encdec_reg(rs1) @ 0b000 @ 0b00000 @ 0b1110011 if $[overloaded { "name" = "|", "is_infix" = true }] or_bool(virtual_memory_supported(), not(config extensions.Svbare.sfence_vma_illegal_if_svbare_only : bool)),
  FENCE_RESERVED(fm, pred, succ, rs, rd) if $[overloaded { "name" = "|", "is_infix" = true }] or_bool($[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "!=", "is_infix" = true }] neq_bits(fm, 0b0000), $[overloaded { "name" = "!=", "is_infix" = true }] neq_bits(fm, 0b1000)), $[overloaded { "name" = "|", "is_infix" = true }] or_bool($[overloaded { "name" = "!=", "is_infix" = true }] neq_anything(rs, zreg), $[overloaded { "name" = "!=", "is_infix" = true }] neq_anything(rd, zreg))) <-> (fm : bits(4)) @ (pred : bits(4)) @ (succ : bits(4)) @ encdec_reg(rs) @ 0b000 @ encdec_reg(rd) @ 0b0001111 if $[overloaded { "name" = "|", "is_infix" = true }] or_bool($[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "!=", "is_infix" = true }] neq_bits(fm, 0b0000), $[overloaded { "name" = "!=", "is_infix" = true }] neq_bits(fm, 0b1000)), $[overloaded { "name" = "|", "is_infix" = true }] or_bool($[overloaded { "name" = "!=", "is_infix" = true }] neq_anything(rs, zreg), $[overloaded { "name" = "!=", "is_infix" = true }] neq_anything(rd, zreg))),
  FENCEI_RESERVED(imm, rs, rd) if $[overloaded { "name" = "|", "is_infix" = true }] or_bool($[overloaded { "name" = "!=", "is_infix" = true }] neq_bits(imm, 0b000000000000), $[overloaded { "name" = "|", "is_infix" = true }] or_bool($[overloaded { "name" = "!=", "is_infix" = true }] neq_anything(rs, zreg), $[overloaded { "name" = "!=", "is_infix" = true }] neq_anything(rd, zreg))) <-> (imm : bits(12)) @ encdec_reg(rs) @ 0b001 @ encdec_reg(rd) @ 0b0001111 if $[overloaded { "name" = "|", "is_infix" = true }] or_bool($[overloaded { "name" = "!=", "is_infix" = true }] neq_bits(imm, 0b000000000000), $[overloaded { "name" = "|", "is_infix" = true }] or_bool($[overloaded { "name" = "!=", "is_infix" = true }] neq_anything(rs, zreg), $[overloaded { "name" = "!=", "is_infix" = true }] neq_anything(rd, zreg))),
  AMO(op, aq, rl, rs2, rs1, size, rd) if amo_encoding_valid(size, op, rs2, rd) <-> encdec_amoop(op) @ bool_bits(aq) @ bool_bits(rl) @ encdec_reg(rs2) @ encdec_reg(rs1) @ width_enc_wide(size) @ encdec_reg(rd) @ 0b0101111 if amo_encoding_valid(size, op, rs2, rd),
  LOADRES(aq, rl, rs1, width, rd) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zalrsc), lrsc_width_valid(width)) <-> 0b00010 @ bool_bits(aq) @ bool_bits(rl) @ 0b00000 @ encdec_reg(rs1) @ 0b0 @ width_enc(width) @ encdec_reg(rd) @ 0b0101111 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zalrsc), lrsc_width_valid(width)),
  STORECON(aq, rl, rs2, rs1, width, rd) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zalrsc), lrsc_width_valid(width)) <-> 0b00011 @ bool_bits(aq) @ bool_bits(rl) @ encdec_reg(rs2) @ encdec_reg(rs1) @ 0b0 @ width_enc(width) @ encdec_reg(rd) @ 0b0101111 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zalrsc), lrsc_width_valid(width)),
  MUL(rs2, rs1, rd, mul_op) if $[overloaded { "name" = "|", "is_infix" = true }] or_bool(currentlyEnabled(Ext_M), currentlyEnabled(Ext_Zmmul)) <-> 0b0000001 @ encdec_reg(rs2) @ encdec_reg(rs1) @ encdec_mul_op(mul_op) @ encdec_reg(rd) @ 0b0110011 if $[overloaded { "name" = "|", "is_infix" = true }] or_bool(currentlyEnabled(Ext_M), currentlyEnabled(Ext_Zmmul)),
  DIV(rs2, rs1, rd, is_unsigned) if currentlyEnabled(Ext_M) <-> 0b0000001 @ encdec_reg(rs2) @ encdec_reg(rs1) @ 0b10 @ bool_bits(is_unsigned) @ encdec_reg(rd) @ 0b0110011 if currentlyEnabled(Ext_M),
  REM(rs2, rs1, rd, is_unsigned) if currentlyEnabled(Ext_M) <-> 0b0000001 @ encdec_reg(rs2) @ encdec_reg(rs1) @ 0b11 @ bool_bits(is_unsigned) @ encdec_reg(rd) @ 0b0110011 if currentlyEnabled(Ext_M),
  MULW(rs2, rs1, rd) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64), $[overloaded { "name" = "|", "is_infix" = true }] or_bool(currentlyEnabled(Ext_M), currentlyEnabled(Ext_Zmmul))) <-> 0b0000001 @ encdec_reg(rs2) @ encdec_reg(rs1) @ 0b000 @ encdec_reg(rd) @ 0b0111011 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64), $[overloaded { "name" = "|", "is_infix" = true }] or_bool(currentlyEnabled(Ext_M), currentlyEnabled(Ext_Zmmul))),
  DIVW(rs2, rs1, rd, is_unsigned) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64), currentlyEnabled(Ext_M)) <-> 0b0000001 @ encdec_reg(rs2) @ encdec_reg(rs1) @ 0b10 @ bool_bits(is_unsigned) @ encdec_reg(rd) @ 0b0111011 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64), currentlyEnabled(Ext_M)),
  REMW(rs2, rs1, rd, is_unsigned) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64), currentlyEnabled(Ext_M)) <-> 0b0000001 @ encdec_reg(rs2) @ encdec_reg(rs1) @ 0b11 @ bool_bits(is_unsigned) @ encdec_reg(rd) @ 0b0111011 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64), currentlyEnabled(Ext_M)),
  SLLIUW(shamt, rs1, rd) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zba), $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64)) <-> 0b000010 @ (shamt : bitvector(6)) @ encdec_reg(rs1) @ 0b001 @ encdec_reg(rd) @ 0b0011011 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zba), $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64)),
  ZBA_RTYPEUW(rs2, rs1, rd, 0b00) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zba), $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64)) <-> 0b0000100 @ encdec_reg(rs2) @ encdec_reg(rs1) @ 0b00 @ 0b0 @ encdec_reg(rd) @ 0b0111011 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zba), $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64)),
  ZBA_RTYPEUW(rs2, rs1, rd, shamt) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zba), $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64)) <-> 0b0010000 @ encdec_reg(rs2) @ encdec_reg(rs1) @ (shamt : bitvector(2)) @ 0b0 @ encdec_reg(rd) @ 0b0111011 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zba), $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64)),
  ZBA_RTYPE(rs2, rs1, rd, shamt) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "!=", "is_infix" = true }] neq_bits(shamt, 0b00), currentlyEnabled(Ext_Zba)) <-> 0b0010000 @ encdec_reg(rs2) @ encdec_reg(rs1) @ (shamt : bitvector(2)) @ 0b0 @ encdec_reg(rd) @ 0b0110011 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "!=", "is_infix" = true }] neq_bits(shamt, 0b00), currentlyEnabled(Ext_Zba)),
  RORIW(shamt, rs1, rd) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "|", "is_infix" = true }] or_bool(currentlyEnabled(Ext_Zbb), currentlyEnabled(Ext_Zbkb)), $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64)) <-> 0b0110000 @ (shamt : bitvector(5)) @ encdec_reg(rs1) @ 0b101 @ encdec_reg(rd) @ 0b0011011 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "|", "is_infix" = true }] or_bool(currentlyEnabled(Ext_Zbb), currentlyEnabled(Ext_Zbkb)), $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64)),
  RORI(shamt, rs1, rd) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "|", "is_infix" = true }] or_bool(currentlyEnabled(Ext_Zbb), currentlyEnabled(Ext_Zbkb)), $[overloaded { "name" = "|", "is_infix" = true }] or_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64), $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(shamt, 5), bitzero))) <-> 0b011000 @ (shamt : bitvector(6)) @ encdec_reg(rs1) @ 0b101 @ encdec_reg(rd) @ 0b0010011 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "|", "is_infix" = true }] or_bool(currentlyEnabled(Ext_Zbb), currentlyEnabled(Ext_Zbkb)), $[overloaded { "name" = "|", "is_infix" = true }] or_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64), $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(shamt, 5), bitzero))),
  ZBB_RTYPEW(rs2, rs1, rd, ROLW) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "|", "is_infix" = true }] or_bool(currentlyEnabled(Ext_Zbb), currentlyEnabled(Ext_Zbkb)), $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64)) <-> 0b0110000 @ encdec_reg(rs2) @ encdec_reg(rs1) @ 0b001 @ encdec_reg(rd) @ 0b0111011 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "|", "is_infix" = true }] or_bool(currentlyEnabled(Ext_Zbb), currentlyEnabled(Ext_Zbkb)), $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64)),
  ZBB_RTYPEW(rs2, rs1, rd, RORW) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "|", "is_infix" = true }] or_bool(currentlyEnabled(Ext_Zbb), currentlyEnabled(Ext_Zbkb)), $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64)) <-> 0b0110000 @ encdec_reg(rs2) @ encdec_reg(rs1) @ 0b101 @ encdec_reg(rd) @ 0b0111011 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "|", "is_infix" = true }] or_bool(currentlyEnabled(Ext_Zbb), currentlyEnabled(Ext_Zbkb)), $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64)),
  ZBB_RTYPE(rs2, rs1, rd, ANDN) if $[overloaded { "name" = "|", "is_infix" = true }] or_bool(currentlyEnabled(Ext_Zbb), currentlyEnabled(Ext_Zbkb)) <-> 0b0100000 @ encdec_reg(rs2) @ encdec_reg(rs1) @ 0b111 @ encdec_reg(rd) @ 0b0110011 if $[overloaded { "name" = "|", "is_infix" = true }] or_bool(currentlyEnabled(Ext_Zbb), currentlyEnabled(Ext_Zbkb)),
  ZBB_RTYPE(rs2, rs1, rd, ORN) if $[overloaded { "name" = "|", "is_infix" = true }] or_bool(currentlyEnabled(Ext_Zbb), currentlyEnabled(Ext_Zbkb)) <-> 0b0100000 @ encdec_reg(rs2) @ encdec_reg(rs1) @ 0b110 @ encdec_reg(rd) @ 0b0110011 if $[overloaded { "name" = "|", "is_infix" = true }] or_bool(currentlyEnabled(Ext_Zbb), currentlyEnabled(Ext_Zbkb)),
  ZBB_RTYPE(rs2, rs1, rd, XNOR) if $[overloaded { "name" = "|", "is_infix" = true }] or_bool(currentlyEnabled(Ext_Zbb), currentlyEnabled(Ext_Zbkb)) <-> 0b0100000 @ encdec_reg(rs2) @ encdec_reg(rs1) @ 0b100 @ encdec_reg(rd) @ 0b0110011 if $[overloaded { "name" = "|", "is_infix" = true }] or_bool(currentlyEnabled(Ext_Zbb), currentlyEnabled(Ext_Zbkb)),
  ZBB_RTYPE(rs2, rs1, rd, MAX) if currentlyEnabled(Ext_Zbb) <-> 0b0000101 @ encdec_reg(rs2) @ encdec_reg(rs1) @ 0b110 @ encdec_reg(rd) @ 0b0110011 if currentlyEnabled(Ext_Zbb),
  ZBB_RTYPE(rs2, rs1, rd, MAXU) if currentlyEnabled(Ext_Zbb) <-> 0b0000101 @ encdec_reg(rs2) @ encdec_reg(rs1) @ 0b111 @ encdec_reg(rd) @ 0b0110011 if currentlyEnabled(Ext_Zbb),
  ZBB_RTYPE(rs2, rs1, rd, MIN) if currentlyEnabled(Ext_Zbb) <-> 0b0000101 @ encdec_reg(rs2) @ encdec_reg(rs1) @ 0b100 @ encdec_reg(rd) @ 0b0110011 if currentlyEnabled(Ext_Zbb),
  ZBB_RTYPE(rs2, rs1, rd, MINU) if currentlyEnabled(Ext_Zbb) <-> 0b0000101 @ encdec_reg(rs2) @ encdec_reg(rs1) @ 0b101 @ encdec_reg(rd) @ 0b0110011 if currentlyEnabled(Ext_Zbb),
  ZBB_RTYPE(rs2, rs1, rd, ROL) if $[overloaded { "name" = "|", "is_infix" = true }] or_bool(currentlyEnabled(Ext_Zbb), currentlyEnabled(Ext_Zbkb)) <-> 0b0110000 @ encdec_reg(rs2) @ encdec_reg(rs1) @ 0b001 @ encdec_reg(rd) @ 0b0110011 if $[overloaded { "name" = "|", "is_infix" = true }] or_bool(currentlyEnabled(Ext_Zbb), currentlyEnabled(Ext_Zbkb)),
  ZBB_RTYPE(rs2, rs1, rd, ROR) if $[overloaded { "name" = "|", "is_infix" = true }] or_bool(currentlyEnabled(Ext_Zbb), currentlyEnabled(Ext_Zbkb)) <-> 0b0110000 @ encdec_reg(rs2) @ encdec_reg(rs1) @ 0b101 @ encdec_reg(rd) @ 0b0110011 if $[overloaded { "name" = "|", "is_infix" = true }] or_bool(currentlyEnabled(Ext_Zbb), currentlyEnabled(Ext_Zbkb)),
  ZBB_EXTOP(rs1, rd, SEXTB) if currentlyEnabled(Ext_Zbb) <-> 0b0110000 @ 0b00100 @ encdec_reg(rs1) @ 0b001 @ encdec_reg(rd) @ 0b0010011 if currentlyEnabled(Ext_Zbb),
  ZBB_EXTOP(rs1, rd, SEXTH) if currentlyEnabled(Ext_Zbb) <-> 0b0110000 @ 0b00101 @ encdec_reg(rs1) @ 0b001 @ encdec_reg(rd) @ 0b0010011 if currentlyEnabled(Ext_Zbb),
  ZBB_EXTOP(rs1, rd, ZEXTH) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zbb), $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 32)) <-> 0b0000100 @ 0b00000 @ encdec_reg(rs1) @ 0b100 @ encdec_reg(rd) @ 0b0110011 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zbb), $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 32)),
  ZBB_EXTOP(rs1, rd, ZEXTH) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zbb), $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64)) <-> 0b0000100 @ 0b00000 @ encdec_reg(rs1) @ 0b100 @ encdec_reg(rd) @ 0b0111011 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zbb), $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64)),
  REV8(rs1, rd) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "|", "is_infix" = true }] or_bool(currentlyEnabled(Ext_Zbb), currentlyEnabled(Ext_Zbkb)), $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 32)) <-> 0b011010011000 @ encdec_reg(rs1) @ 0b101 @ encdec_reg(rd) @ 0b0010011 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "|", "is_infix" = true }] or_bool(currentlyEnabled(Ext_Zbb), currentlyEnabled(Ext_Zbkb)), $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 32)),
  REV8(rs1, rd) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "|", "is_infix" = true }] or_bool(currentlyEnabled(Ext_Zbb), currentlyEnabled(Ext_Zbkb)), $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64)) <-> 0b011010111000 @ encdec_reg(rs1) @ 0b101 @ encdec_reg(rd) @ 0b0010011 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "|", "is_infix" = true }] or_bool(currentlyEnabled(Ext_Zbb), currentlyEnabled(Ext_Zbkb)), $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64)),
  ORCB(rs1, rd) if currentlyEnabled(Ext_Zbb) <-> 0b001010000111 @ encdec_reg(rs1) @ 0b101 @ encdec_reg(rd) @ 0b0010011 if currentlyEnabled(Ext_Zbb),
  CPOP(rs1, rd) if currentlyEnabled(Ext_Zbb) <-> 0b011000000010 @ encdec_reg(rs1) @ 0b001 @ encdec_reg(rd) @ 0b0010011 if currentlyEnabled(Ext_Zbb),
  CPOPW(rs1, rd) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zbb), $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64)) <-> 0b011000000010 @ encdec_reg(rs1) @ 0b001 @ encdec_reg(rd) @ 0b0011011 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zbb), $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64)),
  CLZ(rs1, rd) if currentlyEnabled(Ext_Zbb) <-> 0b011000000000 @ encdec_reg(rs1) @ 0b001 @ encdec_reg(rd) @ 0b0010011 if currentlyEnabled(Ext_Zbb),
  CLZW(rs1, rd) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zbb), $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64)) <-> 0b011000000000 @ encdec_reg(rs1) @ 0b001 @ encdec_reg(rd) @ 0b0011011 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zbb), $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64)),
  CTZ(rs1, rd) if currentlyEnabled(Ext_Zbb) <-> 0b011000000001 @ encdec_reg(rs1) @ 0b001 @ encdec_reg(rd) @ 0b0010011 if currentlyEnabled(Ext_Zbb),
  CTZW(rs1, rd) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zbb), $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64)) <-> 0b011000000001 @ encdec_reg(rs1) @ 0b001 @ encdec_reg(rd) @ 0b0011011 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zbb), $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64)),
  CLMUL(rs2, rs1, rd) if $[overloaded { "name" = "|", "is_infix" = true }] or_bool(currentlyEnabled(Ext_Zbc), currentlyEnabled(Ext_Zbkc)) <-> 0b0000101 @ encdec_reg(rs2) @ encdec_reg(rs1) @ 0b001 @ encdec_reg(rd) @ 0b0110011 if $[overloaded { "name" = "|", "is_infix" = true }] or_bool(currentlyEnabled(Ext_Zbc), currentlyEnabled(Ext_Zbkc)),
  CLMULH(rs2, rs1, rd) if $[overloaded { "name" = "|", "is_infix" = true }] or_bool(currentlyEnabled(Ext_Zbc), currentlyEnabled(Ext_Zbkc)) <-> 0b0000101 @ encdec_reg(rs2) @ encdec_reg(rs1) @ 0b011 @ encdec_reg(rd) @ 0b0110011 if $[overloaded { "name" = "|", "is_infix" = true }] or_bool(currentlyEnabled(Ext_Zbc), currentlyEnabled(Ext_Zbkc)),
  CLMULR(rs2, rs1, rd) if currentlyEnabled(Ext_Zbc) <-> 0b0000101 @ encdec_reg(rs2) @ encdec_reg(rs1) @ 0b010 @ encdec_reg(rd) @ 0b0110011 if currentlyEnabled(Ext_Zbc),
  ZBS_IOP(shamt, rs1, rd, BCLRI) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zbs), $[overloaded { "name" = "|", "is_infix" = true }] or_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64), $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(shamt, 5), bitzero))) <-> 0b010010 @ (shamt : bitvector(6)) @ encdec_reg(rs1) @ 0b001 @ encdec_reg(rd) @ 0b0010011 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zbs), $[overloaded { "name" = "|", "is_infix" = true }] or_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64), $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(shamt, 5), bitzero))),
  ZBS_IOP(shamt, rs1, rd, BEXTI) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zbs), $[overloaded { "name" = "|", "is_infix" = true }] or_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64), $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(shamt, 5), bitzero))) <-> 0b010010 @ (shamt : bitvector(6)) @ encdec_reg(rs1) @ 0b101 @ encdec_reg(rd) @ 0b0010011 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zbs), $[overloaded { "name" = "|", "is_infix" = true }] or_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64), $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(shamt, 5), bitzero))),
  ZBS_IOP(shamt, rs1, rd, BINVI) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zbs), $[overloaded { "name" = "|", "is_infix" = true }] or_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64), $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(shamt, 5), bitzero))) <-> 0b011010 @ (shamt : bitvector(6)) @ encdec_reg(rs1) @ 0b001 @ encdec_reg(rd) @ 0b0010011 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zbs), $[overloaded { "name" = "|", "is_infix" = true }] or_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64), $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(shamt, 5), bitzero))),
  ZBS_IOP(shamt, rs1, rd, BSETI) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zbs), $[overloaded { "name" = "|", "is_infix" = true }] or_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64), $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(shamt, 5), bitzero))) <-> 0b001010 @ (shamt : bitvector(6)) @ encdec_reg(rs1) @ 0b001 @ encdec_reg(rd) @ 0b0010011 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zbs), $[overloaded { "name" = "|", "is_infix" = true }] or_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64), $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(shamt, 5), bitzero))),
  ZBS_RTYPE(rs2, rs1, rd, BCLR) if currentlyEnabled(Ext_Zbs) <-> 0b0100100 @ encdec_reg(rs2) @ encdec_reg(rs1) @ 0b001 @ encdec_reg(rd) @ 0b0110011 if currentlyEnabled(Ext_Zbs),
  ZBS_RTYPE(rs2, rs1, rd, BEXT) if currentlyEnabled(Ext_Zbs) <-> 0b0100100 @ encdec_reg(rs2) @ encdec_reg(rs1) @ 0b101 @ encdec_reg(rd) @ 0b0110011 if currentlyEnabled(Ext_Zbs),
  ZBS_RTYPE(rs2, rs1, rd, BINV) if currentlyEnabled(Ext_Zbs) <-> 0b0110100 @ encdec_reg(rs2) @ encdec_reg(rs1) @ 0b001 @ encdec_reg(rd) @ 0b0110011 if currentlyEnabled(Ext_Zbs),
  ZBS_RTYPE(rs2, rs1, rd, BSET) if currentlyEnabled(Ext_Zbs) <-> 0b0010100 @ encdec_reg(rs2) @ encdec_reg(rs1) @ 0b001 @ encdec_reg(rd) @ 0b0110011 if currentlyEnabled(Ext_Zbs),
  LOAD_FP(imm, rs1, rd, width) if float_load_store_width_supported(width) <-> (imm : bitvector(12)) @ encdec_reg(rs1) @ 0b0 @ width_enc(width) @ encdec_freg(rd) @ 0b0000111 if float_load_store_width_supported(width),
  STORE_FP((imm7 : bits(7)) @ (imm5 : bits(5)), rs2, rs1, width) if float_load_store_width_supported(width) <-> (imm7 : bits(7)) @ encdec_freg(rs2) @ encdec_reg(rs1) @ 0b0 @ width_enc(width) @ (imm5 : bits(5)) @ 0b0100111 if float_load_store_width_supported(width),
  F_MADD_TYPE_S(rs3, rs2, rs1, rm, rd, FMADD_S) if haveSingleFPU() <-> encdec_freg(rs3) @ 0b00 @ encdec_freg(rs2) @ encdec_freg(rs1) @ encdec_rounding_mode(rm) @ encdec_freg(rd) @ 0b1000011 if haveSingleFPU(),
  F_MADD_TYPE_S(rs3, rs2, rs1, rm, rd, FMSUB_S) if haveSingleFPU() <-> encdec_freg(rs3) @ 0b00 @ encdec_freg(rs2) @ encdec_freg(rs1) @ encdec_rounding_mode(rm) @ encdec_freg(rd) @ 0b1000111 if haveSingleFPU(),
  F_MADD_TYPE_S(rs3, rs2, rs1, rm, rd, FNMSUB_S) if haveSingleFPU() <-> encdec_freg(rs3) @ 0b00 @ encdec_freg(rs2) @ encdec_freg(rs1) @ encdec_rounding_mode(rm) @ encdec_freg(rd) @ 0b1001011 if haveSingleFPU(),
  F_MADD_TYPE_S(rs3, rs2, rs1, rm, rd, FNMADD_S) if haveSingleFPU() <-> encdec_freg(rs3) @ 0b00 @ encdec_freg(rs2) @ encdec_freg(rs1) @ encdec_rounding_mode(rm) @ encdec_freg(rd) @ 0b1001111 if haveSingleFPU(),
  F_BIN_RM_TYPE_S(rs2, rs1, rm, rd, FADD_S) if haveSingleFPU() <-> 0b0000000 @ encdec_freg(rs2) @ encdec_freg(rs1) @ encdec_rounding_mode(rm) @ encdec_freg(rd) @ 0b1010011 if haveSingleFPU(),
  F_BIN_RM_TYPE_S(rs2, rs1, rm, rd, FSUB_S) if haveSingleFPU() <-> 0b0000100 @ encdec_freg(rs2) @ encdec_freg(rs1) @ encdec_rounding_mode(rm) @ encdec_freg(rd) @ 0b1010011 if haveSingleFPU(),
  F_BIN_RM_TYPE_S(rs2, rs1, rm, rd, FMUL_S) if haveSingleFPU() <-> 0b0001000 @ encdec_freg(rs2) @ encdec_freg(rs1) @ encdec_rounding_mode(rm) @ encdec_freg(rd) @ 0b1010011 if haveSingleFPU(),
  F_BIN_RM_TYPE_S(rs2, rs1, rm, rd, FDIV_S) if haveSingleFPU() <-> 0b0001100 @ encdec_freg(rs2) @ encdec_freg(rs1) @ encdec_rounding_mode(rm) @ encdec_freg(rd) @ 0b1010011 if haveSingleFPU(),
  F_UN_RM_FF_TYPE_S(rs1, rm, rd, FSQRT_S) if haveSingleFPU() <-> 0b0101100 @ 0b00000 @ encdec_freg(rs1) @ encdec_rounding_mode(rm) @ encdec_freg(rd) @ 0b1010011 if haveSingleFPU(),
  F_UN_RM_FX_TYPE_S(rs1, rm, rd, FCVT_W_S) if haveSingleFPU() <-> 0b1100000 @ 0b00000 @ encdec_freg(rs1) @ encdec_rounding_mode(rm) @ encdec_reg(rd) @ 0b1010011 if haveSingleFPU(),
  F_UN_RM_FX_TYPE_S(rs1, rm, rd, FCVT_WU_S) if haveSingleFPU() <-> 0b1100000 @ 0b00001 @ encdec_freg(rs1) @ encdec_rounding_mode(rm) @ encdec_reg(rd) @ 0b1010011 if haveSingleFPU(),
  F_UN_RM_XF_TYPE_S(rs1, rm, rd, FCVT_S_W) if haveSingleFPU() <-> 0b1101000 @ 0b00000 @ encdec_reg(rs1) @ encdec_rounding_mode(rm) @ encdec_freg(rd) @ 0b1010011 if haveSingleFPU(),
  F_UN_RM_XF_TYPE_S(rs1, rm, rd, FCVT_S_WU) if haveSingleFPU() <-> 0b1101000 @ 0b00001 @ encdec_reg(rs1) @ encdec_rounding_mode(rm) @ encdec_freg(rd) @ 0b1010011 if haveSingleFPU(),
  F_UN_RM_FX_TYPE_S(rs1, rm, rd, FCVT_L_S) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(haveSingleFPU(), $[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(xlen, 64)) <-> 0b1100000 @ 0b00010 @ encdec_freg(rs1) @ encdec_rounding_mode(rm) @ encdec_reg(rd) @ 0b1010011 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(haveSingleFPU(), $[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(xlen, 64)),
  F_UN_RM_FX_TYPE_S(rs1, rm, rd, FCVT_LU_S) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(haveSingleFPU(), $[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(xlen, 64)) <-> 0b1100000 @ 0b00011 @ encdec_freg(rs1) @ encdec_rounding_mode(rm) @ encdec_reg(rd) @ 0b1010011 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(haveSingleFPU(), $[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(xlen, 64)),
  F_UN_RM_XF_TYPE_S(rs1, rm, rd, FCVT_S_L) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(haveSingleFPU(), $[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(xlen, 64)) <-> 0b1101000 @ 0b00010 @ encdec_reg(rs1) @ encdec_rounding_mode(rm) @ encdec_freg(rd) @ 0b1010011 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(haveSingleFPU(), $[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(xlen, 64)),
  F_UN_RM_XF_TYPE_S(rs1, rm, rd, FCVT_S_LU) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(haveSingleFPU(), $[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(xlen, 64)) <-> 0b1101000 @ 0b00011 @ encdec_reg(rs1) @ encdec_rounding_mode(rm) @ encdec_freg(rd) @ 0b1010011 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(haveSingleFPU(), $[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(xlen, 64)),
  F_BIN_TYPE_F_S(rs2, rs1, rd, FSGNJ_S) if haveSingleFPU() <-> 0b0010000 @ encdec_freg(rs2) @ encdec_freg(rs1) @ 0b000 @ encdec_freg(rd) @ 0b1010011 if haveSingleFPU(),
  F_BIN_TYPE_F_S(rs2, rs1, rd, FSGNJN_S) if haveSingleFPU() <-> 0b0010000 @ encdec_freg(rs2) @ encdec_freg(rs1) @ 0b001 @ encdec_freg(rd) @ 0b1010011 if haveSingleFPU(),
  F_BIN_TYPE_F_S(rs2, rs1, rd, FSGNJX_S) if haveSingleFPU() <-> 0b0010000 @ encdec_freg(rs2) @ encdec_freg(rs1) @ 0b010 @ encdec_freg(rd) @ 0b1010011 if haveSingleFPU(),
  F_BIN_TYPE_F_S(rs2, rs1, rd, FMIN_S) if haveSingleFPU() <-> 0b0010100 @ encdec_freg(rs2) @ encdec_freg(rs1) @ 0b000 @ encdec_freg(rd) @ 0b1010011 if haveSingleFPU(),
  F_BIN_TYPE_F_S(rs2, rs1, rd, FMAX_S) if haveSingleFPU() <-> 0b0010100 @ encdec_freg(rs2) @ encdec_freg(rs1) @ 0b001 @ encdec_freg(rd) @ 0b1010011 if haveSingleFPU(),
  F_BIN_TYPE_X_S(rs2, rs1, rd, FEQ_S) if haveSingleFPU() <-> 0b1010000 @ encdec_freg(rs2) @ encdec_freg(rs1) @ 0b010 @ encdec_reg(rd) @ 0b1010011 if haveSingleFPU(),
  F_BIN_TYPE_X_S(rs2, rs1, rd, FLT_S) if haveSingleFPU() <-> 0b1010000 @ encdec_freg(rs2) @ encdec_freg(rs1) @ 0b001 @ encdec_reg(rd) @ 0b1010011 if haveSingleFPU(),
  F_BIN_TYPE_X_S(rs2, rs1, rd, FLE_S) if haveSingleFPU() <-> 0b1010000 @ encdec_freg(rs2) @ encdec_freg(rs1) @ 0b000 @ encdec_reg(rd) @ 0b1010011 if haveSingleFPU(),
  F_UN_TYPE_X_S(rs1, rd, FCLASS_S) if haveSingleFPU() <-> 0b1110000 @ 0b00000 @ encdec_freg(rs1) @ 0b001 @ encdec_reg(rd) @ 0b1010011 if haveSingleFPU(),
  F_UN_TYPE_X_S(rs1, rd, FMV_X_W) if currentlyEnabled(Ext_F) <-> 0b1110000 @ 0b00000 @ encdec_freg(rs1) @ 0b000 @ encdec_reg(rd) @ 0b1010011 if currentlyEnabled(Ext_F),
  F_UN_TYPE_F_S(rs1, rd, FMV_W_X) if currentlyEnabled(Ext_F) <-> 0b1111000 @ 0b00000 @ encdec_reg(rs1) @ 0b000 @ encdec_freg(rd) @ 0b1010011 if currentlyEnabled(Ext_F),
  F_MADD_TYPE_D(rs3, rs2, rs1, rm, rd, FMADD_D) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(haveDoubleFPU(), validDoubleRegs(4, [rs3, rs2, rs1, rd])) <-> encdec_freg(rs3) @ 0b01 @ encdec_freg(rs2) @ encdec_freg(rs1) @ encdec_rounding_mode(rm) @ encdec_freg(rd) @ 0b1000011 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(haveDoubleFPU(), validDoubleRegs(4, [rs3, rs2, rs1, rd])),
  F_MADD_TYPE_D(rs3, rs2, rs1, rm, rd, FMSUB_D) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(haveDoubleFPU(), validDoubleRegs(4, [rs3, rs2, rs1, rd])) <-> encdec_freg(rs3) @ 0b01 @ encdec_freg(rs2) @ encdec_freg(rs1) @ encdec_rounding_mode(rm) @ encdec_freg(rd) @ 0b1000111 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(haveDoubleFPU(), validDoubleRegs(4, [rs3, rs2, rs1, rd])),
  F_MADD_TYPE_D(rs3, rs2, rs1, rm, rd, FNMSUB_D) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(haveDoubleFPU(), validDoubleRegs(4, [rs3, rs2, rs1, rd])) <-> encdec_freg(rs3) @ 0b01 @ encdec_freg(rs2) @ encdec_freg(rs1) @ encdec_rounding_mode(rm) @ encdec_freg(rd) @ 0b1001011 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(haveDoubleFPU(), validDoubleRegs(4, [rs3, rs2, rs1, rd])),
  F_MADD_TYPE_D(rs3, rs2, rs1, rm, rd, FNMADD_D) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(haveDoubleFPU(), validDoubleRegs(4, [rs3, rs2, rs1, rd])) <-> encdec_freg(rs3) @ 0b01 @ encdec_freg(rs2) @ encdec_freg(rs1) @ encdec_rounding_mode(rm) @ encdec_freg(rd) @ 0b1001111 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(haveDoubleFPU(), validDoubleRegs(4, [rs3, rs2, rs1, rd])),
  F_BIN_RM_TYPE_D(rs2, rs1, rm, rd, FADD_D) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(haveDoubleFPU(), validDoubleRegs(3, [rs2, rs1, rd])) <-> 0b0000001 @ encdec_freg(rs2) @ encdec_freg(rs1) @ encdec_rounding_mode(rm) @ encdec_freg(rd) @ 0b1010011 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(haveDoubleFPU(), validDoubleRegs(3, [rs2, rs1, rd])),
  F_BIN_RM_TYPE_D(rs2, rs1, rm, rd, FSUB_D) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(haveDoubleFPU(), validDoubleRegs(3, [rs2, rs1, rd])) <-> 0b0000101 @ encdec_freg(rs2) @ encdec_freg(rs1) @ encdec_rounding_mode(rm) @ encdec_freg(rd) @ 0b1010011 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(haveDoubleFPU(), validDoubleRegs(3, [rs2, rs1, rd])),
  F_BIN_RM_TYPE_D(rs2, rs1, rm, rd, FMUL_D) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(haveDoubleFPU(), validDoubleRegs(3, [rs2, rs1, rd])) <-> 0b0001001 @ encdec_freg(rs2) @ encdec_freg(rs1) @ encdec_rounding_mode(rm) @ encdec_freg(rd) @ 0b1010011 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(haveDoubleFPU(), validDoubleRegs(3, [rs2, rs1, rd])),
  F_BIN_RM_TYPE_D(rs2, rs1, rm, rd, FDIV_D) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(haveDoubleFPU(), validDoubleRegs(3, [rs2, rs1, rd])) <-> 0b0001101 @ encdec_freg(rs2) @ encdec_freg(rs1) @ encdec_rounding_mode(rm) @ encdec_freg(rd) @ 0b1010011 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(haveDoubleFPU(), validDoubleRegs(3, [rs2, rs1, rd])),
  F_UN_RM_FF_TYPE_D(rs1, rm, rd, FSQRT_D) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(haveDoubleFPU(), validDoubleRegs(2, [rs1, rd])) <-> 0b0101101 @ 0b00000 @ encdec_freg(rs1) @ encdec_rounding_mode(rm) @ encdec_freg(rd) @ 0b1010011 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(haveDoubleFPU(), validDoubleRegs(2, [rs1, rd])),
  F_UN_RM_FX_TYPE_D(rs1, rm, rd, FCVT_W_D) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(haveDoubleFPU(), validDoubleRegs(1, [rs1])) <-> 0b1100001 @ 0b00000 @ encdec_freg(rs1) @ encdec_rounding_mode(rm) @ encdec_reg(rd) @ 0b1010011 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(haveDoubleFPU(), validDoubleRegs(1, [rs1])),
  F_UN_RM_FX_TYPE_D(rs1, rm, rd, FCVT_WU_D) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(haveDoubleFPU(), validDoubleRegs(1, [rs1])) <-> 0b1100001 @ 0b00001 @ encdec_freg(rs1) @ encdec_rounding_mode(rm) @ encdec_reg(rd) @ 0b1010011 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(haveDoubleFPU(), validDoubleRegs(1, [rs1])),
  F_UN_RM_XF_TYPE_D(rs1, rm, rd, FCVT_D_W) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(haveDoubleFPU(), validDoubleRegs(1, [rd])) <-> 0b1101001 @ 0b00000 @ encdec_reg(rs1) @ encdec_rounding_mode(rm) @ encdec_freg(rd) @ 0b1010011 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(haveDoubleFPU(), validDoubleRegs(1, [rd])),
  F_UN_RM_XF_TYPE_D(rs1, rm, rd, FCVT_D_WU) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(haveDoubleFPU(), validDoubleRegs(1, [rd])) <-> 0b1101001 @ 0b00001 @ encdec_reg(rs1) @ encdec_rounding_mode(rm) @ encdec_freg(rd) @ 0b1010011 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(haveDoubleFPU(), validDoubleRegs(1, [rd])),
  F_UN_RM_FF_TYPE_D(rs1, rm, rd, FCVT_S_D) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(haveDoubleFPU(), validDoubleRegs(1, [rs1])) <-> 0b0100000 @ 0b00001 @ encdec_freg(rs1) @ encdec_rounding_mode(rm) @ encdec_freg(rd) @ 0b1010011 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(haveDoubleFPU(), validDoubleRegs(1, [rs1])),
  F_UN_RM_FF_TYPE_D(rs1, rm, rd, FCVT_D_S) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(haveDoubleFPU(), validDoubleRegs(1, [rd])) <-> 0b0100001 @ 0b00000 @ encdec_freg(rs1) @ encdec_rounding_mode(rm) @ encdec_freg(rd) @ 0b1010011 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(haveDoubleFPU(), validDoubleRegs(1, [rd])),
  F_UN_RM_FX_TYPE_D(rs1, rm, rd, FCVT_L_D) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(haveDoubleFPU(), $[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(xlen, 64)) <-> 0b1100001 @ 0b00010 @ encdec_freg(rs1) @ encdec_rounding_mode(rm) @ encdec_reg(rd) @ 0b1010011 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(haveDoubleFPU(), $[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(xlen, 64)),
  F_UN_RM_FX_TYPE_D(rs1, rm, rd, FCVT_LU_D) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(haveDoubleFPU(), $[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(xlen, 64)) <-> 0b1100001 @ 0b00011 @ encdec_freg(rs1) @ encdec_rounding_mode(rm) @ encdec_reg(rd) @ 0b1010011 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(haveDoubleFPU(), $[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(xlen, 64)),
  F_UN_RM_XF_TYPE_D(rs1, rm, rd, FCVT_D_L) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(haveDoubleFPU(), $[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(xlen, 64)) <-> 0b1101001 @ 0b00010 @ encdec_reg(rs1) @ encdec_rounding_mode(rm) @ encdec_freg(rd) @ 0b1010011 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(haveDoubleFPU(), $[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(xlen, 64)),
  F_UN_RM_XF_TYPE_D(rs1, rm, rd, FCVT_D_LU) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(haveDoubleFPU(), $[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(xlen, 64)) <-> 0b1101001 @ 0b00011 @ encdec_reg(rs1) @ encdec_rounding_mode(rm) @ encdec_freg(rd) @ 0b1010011 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(haveDoubleFPU(), $[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(xlen, 64)),
  F_BIN_F_TYPE_D(rs2, rs1, rd, FSGNJ_D) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(haveDoubleFPU(), validDoubleRegs(3, [rs2, rs1, rd])) <-> 0b0010001 @ encdec_freg(rs2) @ encdec_freg(rs1) @ 0b000 @ encdec_freg(rd) @ 0b1010011 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(haveDoubleFPU(), validDoubleRegs(3, [rs2, rs1, rd])),
  F_BIN_F_TYPE_D(rs2, rs1, rd, FSGNJN_D) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(haveDoubleFPU(), validDoubleRegs(3, [rs2, rs1, rd])) <-> 0b0010001 @ encdec_freg(rs2) @ encdec_freg(rs1) @ 0b001 @ encdec_freg(rd) @ 0b1010011 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(haveDoubleFPU(), validDoubleRegs(3, [rs2, rs1, rd])),
  F_BIN_F_TYPE_D(rs2, rs1, rd, FSGNJX_D) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(haveDoubleFPU(), validDoubleRegs(3, [rs2, rs1, rd])) <-> 0b0010001 @ encdec_freg(rs2) @ encdec_freg(rs1) @ 0b010 @ encdec_freg(rd) @ 0b1010011 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(haveDoubleFPU(), validDoubleRegs(3, [rs2, rs1, rd])),
  F_BIN_F_TYPE_D(rs2, rs1, rd, FMIN_D) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(haveDoubleFPU(), validDoubleRegs(3, [rs2, rs1, rd])) <-> 0b0010101 @ encdec_freg(rs2) @ encdec_freg(rs1) @ 0b000 @ encdec_freg(rd) @ 0b1010011 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(haveDoubleFPU(), validDoubleRegs(3, [rs2, rs1, rd])),
  F_BIN_F_TYPE_D(rs2, rs1, rd, FMAX_D) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(haveDoubleFPU(), validDoubleRegs(3, [rs2, rs1, rd])) <-> 0b0010101 @ encdec_freg(rs2) @ encdec_freg(rs1) @ 0b001 @ encdec_freg(rd) @ 0b1010011 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(haveDoubleFPU(), validDoubleRegs(3, [rs2, rs1, rd])),
  F_BIN_X_TYPE_D(rs2, rs1, rd, FEQ_D) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(haveDoubleFPU(), validDoubleRegs(2, [rs2, rs1])) <-> 0b1010001 @ encdec_freg(rs2) @ encdec_freg(rs1) @ 0b010 @ encdec_reg(rd) @ 0b1010011 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(haveDoubleFPU(), validDoubleRegs(2, [rs2, rs1])),
  F_BIN_X_TYPE_D(rs2, rs1, rd, FLT_D) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(haveDoubleFPU(), validDoubleRegs(2, [rs2, rs1])) <-> 0b1010001 @ encdec_freg(rs2) @ encdec_freg(rs1) @ 0b001 @ encdec_reg(rd) @ 0b1010011 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(haveDoubleFPU(), validDoubleRegs(2, [rs2, rs1])),
  F_BIN_X_TYPE_D(rs2, rs1, rd, FLE_D) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(haveDoubleFPU(), validDoubleRegs(2, [rs2, rs1])) <-> 0b1010001 @ encdec_freg(rs2) @ encdec_freg(rs1) @ 0b000 @ encdec_reg(rd) @ 0b1010011 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(haveDoubleFPU(), validDoubleRegs(2, [rs2, rs1])),
  F_UN_X_TYPE_D(rs1, rd, FCLASS_D) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(haveDoubleFPU(), validDoubleRegs(1, [rs1])) <-> 0b1110001 @ 0b00000 @ encdec_freg(rs1) @ 0b001 @ encdec_reg(rd) @ 0b1010011 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(haveDoubleFPU(), validDoubleRegs(1, [rs1])),
  F_UN_X_TYPE_D(rs1, rd, FMV_X_D) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_D), $[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(xlen, 64)) <-> 0b1110001 @ 0b00000 @ encdec_freg(rs1) @ 0b000 @ encdec_reg(rd) @ 0b1010011 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_D), $[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(xlen, 64)),
  F_UN_F_TYPE_D(rs1, rd, FMV_D_X) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_D), $[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(xlen, 64)) <-> 0b1111001 @ 0b00000 @ encdec_reg(rs1) @ 0b000 @ encdec_freg(rd) @ 0b1010011 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_D), $[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(xlen, 64)),
  F_BIN_RM_TYPE_H(rs2, rs1, rm, rd, FADD_H) if haveHalfFPU() <-> 0b0000010 @ encdec_freg(rs2) @ encdec_freg(rs1) @ encdec_rounding_mode(rm) @ encdec_freg(rd) @ 0b1010011 if haveHalfFPU(),
  F_BIN_RM_TYPE_H(rs2, rs1, rm, rd, FSUB_H) if haveHalfFPU() <-> 0b0000110 @ encdec_freg(rs2) @ encdec_freg(rs1) @ encdec_rounding_mode(rm) @ encdec_freg(rd) @ 0b1010011 if haveHalfFPU(),
  F_BIN_RM_TYPE_H(rs2, rs1, rm, rd, FMUL_H) if haveHalfFPU() <-> 0b0001010 @ encdec_freg(rs2) @ encdec_freg(rs1) @ encdec_rounding_mode(rm) @ encdec_freg(rd) @ 0b1010011 if haveHalfFPU(),
  F_BIN_RM_TYPE_H(rs2, rs1, rm, rd, FDIV_H) if haveHalfFPU() <-> 0b0001110 @ encdec_freg(rs2) @ encdec_freg(rs1) @ encdec_rounding_mode(rm) @ encdec_freg(rd) @ 0b1010011 if haveHalfFPU(),
  F_MADD_TYPE_H(rs3, rs2, rs1, rm, rd, FMADD_H) if haveHalfFPU() <-> encdec_freg(rs3) @ 0b10 @ encdec_freg(rs2) @ encdec_freg(rs1) @ encdec_rounding_mode(rm) @ encdec_freg(rd) @ 0b1000011 if haveHalfFPU(),
  F_MADD_TYPE_H(rs3, rs2, rs1, rm, rd, FMSUB_H) if haveHalfFPU() <-> encdec_freg(rs3) @ 0b10 @ encdec_freg(rs2) @ encdec_freg(rs1) @ encdec_rounding_mode(rm) @ encdec_freg(rd) @ 0b1000111 if haveHalfFPU(),
  F_MADD_TYPE_H(rs3, rs2, rs1, rm, rd, FNMSUB_H) if haveHalfFPU() <-> encdec_freg(rs3) @ 0b10 @ encdec_freg(rs2) @ encdec_freg(rs1) @ encdec_rounding_mode(rm) @ encdec_freg(rd) @ 0b1001011 if haveHalfFPU(),
  F_MADD_TYPE_H(rs3, rs2, rs1, rm, rd, FNMADD_H) if haveHalfFPU() <-> encdec_freg(rs3) @ 0b10 @ encdec_freg(rs2) @ encdec_freg(rs1) @ encdec_rounding_mode(rm) @ encdec_freg(rd) @ 0b1001111 if haveHalfFPU(),
  F_BIN_F_TYPE_H(rs2, rs1, rd, FSGNJ_H) if haveHalfFPU() <-> 0b0010010 @ encdec_freg(rs2) @ encdec_freg(rs1) @ 0b000 @ encdec_freg(rd) @ 0b1010011 if haveHalfFPU(),
  F_BIN_F_TYPE_H(rs2, rs1, rd, FSGNJN_H) if haveHalfFPU() <-> 0b0010010 @ encdec_freg(rs2) @ encdec_freg(rs1) @ 0b001 @ encdec_freg(rd) @ 0b1010011 if haveHalfFPU(),
  F_BIN_F_TYPE_H(rs2, rs1, rd, FSGNJX_H) if haveHalfFPU() <-> 0b0010010 @ encdec_freg(rs2) @ encdec_freg(rs1) @ 0b010 @ encdec_freg(rd) @ 0b1010011 if haveHalfFPU(),
  F_BIN_F_TYPE_H(rs2, rs1, rd, FMIN_H) if haveHalfFPU() <-> 0b0010110 @ encdec_freg(rs2) @ encdec_freg(rs1) @ 0b000 @ encdec_freg(rd) @ 0b1010011 if haveHalfFPU(),
  F_BIN_F_TYPE_H(rs2, rs1, rd, FMAX_H) if haveHalfFPU() <-> 0b0010110 @ encdec_freg(rs2) @ encdec_freg(rs1) @ 0b001 @ encdec_freg(rd) @ 0b1010011 if haveHalfFPU(),
  F_BIN_X_TYPE_H(rs2, rs1, rd, FEQ_H) if haveHalfFPU() <-> 0b1010010 @ encdec_freg(rs2) @ encdec_freg(rs1) @ 0b010 @ encdec_reg(rd) @ 0b1010011 if haveHalfFPU(),
  F_BIN_X_TYPE_H(rs2, rs1, rd, FLT_H) if haveHalfFPU() <-> 0b1010010 @ encdec_freg(rs2) @ encdec_freg(rs1) @ 0b001 @ encdec_reg(rd) @ 0b1010011 if haveHalfFPU(),
  F_BIN_X_TYPE_H(rs2, rs1, rd, FLE_H) if haveHalfFPU() <-> 0b1010010 @ encdec_freg(rs2) @ encdec_freg(rs1) @ 0b000 @ encdec_reg(rd) @ 0b1010011 if haveHalfFPU(),
  F_UN_RM_FF_TYPE_H(rs1, rm, rd, FSQRT_H) if haveHalfFPU() <-> 0b0101110 @ 0b00000 @ encdec_freg(rs1) @ encdec_rounding_mode(rm) @ encdec_freg(rd) @ 0b1010011 if haveHalfFPU(),
  F_UN_RM_FX_TYPE_H(rs1, rm, rd, FCVT_W_H) if haveHalfFPU() <-> 0b1100010 @ 0b00000 @ encdec_freg(rs1) @ encdec_rounding_mode(rm) @ encdec_reg(rd) @ 0b1010011 if haveHalfFPU(),
  F_UN_RM_FX_TYPE_H(rs1, rm, rd, FCVT_WU_H) if haveHalfFPU() <-> 0b1100010 @ 0b00001 @ encdec_freg(rs1) @ encdec_rounding_mode(rm) @ encdec_reg(rd) @ 0b1010011 if haveHalfFPU(),
  F_UN_RM_XF_TYPE_H(rs1, rm, rd, FCVT_H_W) if haveHalfFPU() <-> 0b1101010 @ 0b00000 @ encdec_reg(rs1) @ encdec_rounding_mode(rm) @ encdec_freg(rd) @ 0b1010011 if haveHalfFPU(),
  F_UN_RM_XF_TYPE_H(rs1, rm, rd, FCVT_H_WU) if haveHalfFPU() <-> 0b1101010 @ 0b00001 @ encdec_reg(rs1) @ encdec_rounding_mode(rm) @ encdec_freg(rd) @ 0b1010011 if haveHalfFPU(),
  F_UN_RM_FF_TYPE_H(rs1, rm, rd, FCVT_H_S) if haveHalfMin() <-> 0b0100010 @ 0b00000 @ encdec_freg(rs1) @ encdec_rounding_mode(rm) @ encdec_freg(rd) @ 0b1010011 if haveHalfMin(),
  F_UN_RM_FF_TYPE_H(rs1, rm, rd, FCVT_H_D) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(haveHalfMin(), $[overloaded { "name" = "&", "is_infix" = true }] and_bool(haveDoubleFPU(), validDoubleRegs(1, [rs1]))) <-> 0b0100010 @ 0b00001 @ encdec_freg(rs1) @ encdec_rounding_mode(rm) @ encdec_freg(rd) @ 0b1010011 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(haveHalfMin(), $[overloaded { "name" = "&", "is_infix" = true }] and_bool(haveDoubleFPU(), validDoubleRegs(1, [rs1]))),
  F_UN_RM_FF_TYPE_H(rs1, rm, rd, FCVT_S_H) if haveHalfMin() <-> 0b0100000 @ 0b00010 @ encdec_freg(rs1) @ encdec_rounding_mode(rm) @ encdec_freg(rd) @ 0b1010011 if haveHalfMin(),
  F_UN_RM_FF_TYPE_H(rs1, rm, rd, FCVT_D_H) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(haveHalfMin(), $[overloaded { "name" = "&", "is_infix" = true }] and_bool(haveDoubleFPU(), validDoubleRegs(1, [rd]))) <-> 0b0100001 @ 0b00010 @ encdec_freg(rs1) @ encdec_rounding_mode(rm) @ encdec_freg(rd) @ 0b1010011 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(haveHalfMin(), $[overloaded { "name" = "&", "is_infix" = true }] and_bool(haveDoubleFPU(), validDoubleRegs(1, [rd]))),
  F_UN_RM_FX_TYPE_H(rs1, rm, rd, FCVT_L_H) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(haveHalfFPU(), $[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(xlen, 64)) <-> 0b1100010 @ 0b00010 @ encdec_freg(rs1) @ encdec_rounding_mode(rm) @ encdec_reg(rd) @ 0b1010011 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(haveHalfFPU(), $[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(xlen, 64)),
  F_UN_RM_FX_TYPE_H(rs1, rm, rd, FCVT_LU_H) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(haveHalfFPU(), $[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(xlen, 64)) <-> 0b1100010 @ 0b00011 @ encdec_freg(rs1) @ encdec_rounding_mode(rm) @ encdec_reg(rd) @ 0b1010011 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(haveHalfFPU(), $[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(xlen, 64)),
  F_UN_RM_XF_TYPE_H(rs1, rm, rd, FCVT_H_L) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(haveHalfFPU(), $[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(xlen, 64)) <-> 0b1101010 @ 0b00010 @ encdec_reg(rs1) @ encdec_rounding_mode(rm) @ encdec_freg(rd) @ 0b1010011 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(haveHalfFPU(), $[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(xlen, 64)),
  F_UN_RM_XF_TYPE_H(rs1, rm, rd, FCVT_H_LU) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(haveHalfFPU(), $[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(xlen, 64)) <-> 0b1101010 @ 0b00011 @ encdec_reg(rs1) @ encdec_rounding_mode(rm) @ encdec_freg(rd) @ 0b1010011 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(haveHalfFPU(), $[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(xlen, 64)),
  F_UN_X_TYPE_H(rs1, rd, FCLASS_H) if haveHalfFPU() <-> 0b1110010 @ 0b00000 @ encdec_freg(rs1) @ 0b001 @ encdec_reg(rd) @ 0b1010011 if haveHalfFPU(),
  F_UN_X_TYPE_H(rs1, rd, FMV_X_H) if $[overloaded { "name" = "|", "is_infix" = true }] or_bool(currentlyEnabled(Ext_Zfhmin), currentlyEnabled(Ext_Zfbfmin)) <-> 0b1110010 @ 0b00000 @ encdec_freg(rs1) @ 0b000 @ encdec_reg(rd) @ 0b1010011 if $[overloaded { "name" = "|", "is_infix" = true }] or_bool(currentlyEnabled(Ext_Zfhmin), currentlyEnabled(Ext_Zfbfmin)),
  F_UN_F_TYPE_H(rs1, rd, FMV_H_X) if $[overloaded { "name" = "|", "is_infix" = true }] or_bool(currentlyEnabled(Ext_Zfhmin), currentlyEnabled(Ext_Zfbfmin)) <-> 0b1111010 @ 0b00000 @ encdec_reg(rs1) @ 0b000 @ encdec_freg(rd) @ 0b1010011 if $[overloaded { "name" = "|", "is_infix" = true }] or_bool(currentlyEnabled(Ext_Zfhmin), currentlyEnabled(Ext_Zfbfmin)),
  FLI_H(constantidx, rd) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zfh), currentlyEnabled(Ext_Zfa)) <-> 0b1111010 @ 0b00001 @ (constantidx : bitvector(5)) @ 0b000 @ encdec_freg(rd) @ 0b1010011 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zfh), currentlyEnabled(Ext_Zfa)),
  FLI_S(constantidx, rd) if currentlyEnabled(Ext_Zfa) <-> 0b1111000 @ 0b00001 @ (constantidx : bitvector(5)) @ 0b000 @ encdec_freg(rd) @ 0b1010011 if currentlyEnabled(Ext_Zfa),
  FLI_D(constantidx, rd) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_D), currentlyEnabled(Ext_Zfa)) <-> 0b1111001 @ 0b00001 @ (constantidx : bitvector(5)) @ 0b000 @ encdec_freg(rd) @ 0b1010011 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_D), currentlyEnabled(Ext_Zfa)),
  FMINM_H(rs2, rs1, rd) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zfh), currentlyEnabled(Ext_Zfa)) <-> 0b0010110 @ encdec_freg(rs2) @ encdec_freg(rs1) @ 0b010 @ encdec_freg(rd) @ 0b1010011 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zfh), currentlyEnabled(Ext_Zfa)),
  FMAXM_H(rs2, rs1, rd) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zfh), currentlyEnabled(Ext_Zfa)) <-> 0b0010110 @ encdec_freg(rs2) @ encdec_freg(rs1) @ 0b011 @ encdec_freg(rd) @ 0b1010011 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zfh), currentlyEnabled(Ext_Zfa)),
  FMINM_S(rs2, rs1, rd) if currentlyEnabled(Ext_Zfa) <-> 0b0010100 @ encdec_freg(rs2) @ encdec_freg(rs1) @ 0b010 @ encdec_freg(rd) @ 0b1010011 if currentlyEnabled(Ext_Zfa),
  FMAXM_S(rs2, rs1, rd) if currentlyEnabled(Ext_Zfa) <-> 0b0010100 @ encdec_freg(rs2) @ encdec_freg(rs1) @ 0b011 @ encdec_freg(rd) @ 0b1010011 if currentlyEnabled(Ext_Zfa),
  FMINM_D(rs2, rs1, rd) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_D), currentlyEnabled(Ext_Zfa)) <-> 0b0010101 @ encdec_freg(rs2) @ encdec_freg(rs1) @ 0b010 @ encdec_freg(rd) @ 0b1010011 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_D), currentlyEnabled(Ext_Zfa)),
  FMAXM_D(rs2, rs1, rd) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_D), currentlyEnabled(Ext_Zfa)) <-> 0b0010101 @ encdec_freg(rs2) @ encdec_freg(rs1) @ 0b011 @ encdec_freg(rd) @ 0b1010011 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_D), currentlyEnabled(Ext_Zfa)),
  FROUND_H(rs1, rm, rd) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zfh), currentlyEnabled(Ext_Zfa)) <-> 0b0100010 @ 0b00100 @ encdec_freg(rs1) @ encdec_rounding_mode(rm) @ encdec_freg(rd) @ 0b1010011 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zfh), currentlyEnabled(Ext_Zfa)),
  FROUNDNX_H(rs1, rm, rd) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zfh), currentlyEnabled(Ext_Zfa)) <-> 0b0100010 @ 0b00101 @ encdec_freg(rs1) @ encdec_rounding_mode(rm) @ encdec_freg(rd) @ 0b1010011 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zfh), currentlyEnabled(Ext_Zfa)),
  FROUND_S(rs1, rm, rd) if currentlyEnabled(Ext_Zfa) <-> 0b0100000 @ 0b00100 @ encdec_freg(rs1) @ encdec_rounding_mode(rm) @ encdec_freg(rd) @ 0b1010011 if currentlyEnabled(Ext_Zfa),
  FROUNDNX_S(rs1, rm, rd) if currentlyEnabled(Ext_Zfa) <-> 0b0100000 @ 0b00101 @ encdec_freg(rs1) @ encdec_rounding_mode(rm) @ encdec_freg(rd) @ 0b1010011 if currentlyEnabled(Ext_Zfa),
  FROUND_D(rs1, rm, rd) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_D), currentlyEnabled(Ext_Zfa)) <-> 0b0100001 @ 0b00100 @ encdec_freg(rs1) @ encdec_rounding_mode(rm) @ encdec_freg(rd) @ 0b1010011 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_D), currentlyEnabled(Ext_Zfa)),
  FROUNDNX_D(rs1, rm, rd) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_D), currentlyEnabled(Ext_Zfa)) <-> 0b0100001 @ 0b00101 @ encdec_freg(rs1) @ encdec_rounding_mode(rm) @ encdec_freg(rd) @ 0b1010011 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_D), currentlyEnabled(Ext_Zfa)),
  FMVH_X_D(rs1, rd) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_D), $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zfa), in32BitMode())) <-> 0b1110001 @ 0b00001 @ encdec_freg(rs1) @ 0b000 @ encdec_reg(rd) @ 0b1010011 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_D), $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zfa), in32BitMode())),
  FMVP_D_X(rs2, rs1, rd) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_D), $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zfa), in32BitMode())) <-> 0b1011001 @ encdec_reg(rs2) @ encdec_reg(rs1) @ 0b000 @ encdec_freg(rd) @ 0b1010011 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_D), $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zfa), in32BitMode())),
  FLEQ_H(rs2, rs1, rd) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zfh), currentlyEnabled(Ext_Zfa)) <-> 0b1010010 @ encdec_freg(rs2) @ encdec_freg(rs1) @ 0b100 @ encdec_reg(rd) @ 0b1010011 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zfh), currentlyEnabled(Ext_Zfa)),
  FLTQ_H(rs2, rs1, rd) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zfh), currentlyEnabled(Ext_Zfa)) <-> 0b1010010 @ encdec_freg(rs2) @ encdec_freg(rs1) @ 0b101 @ encdec_reg(rd) @ 0b1010011 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zfh), currentlyEnabled(Ext_Zfa)),
  FLEQ_S(rs2, rs1, rd) if currentlyEnabled(Ext_Zfa) <-> 0b1010000 @ encdec_freg(rs2) @ encdec_freg(rs1) @ 0b100 @ encdec_reg(rd) @ 0b1010011 if currentlyEnabled(Ext_Zfa),
  FLTQ_S(rs2, rs1, rd) if currentlyEnabled(Ext_Zfa) <-> 0b1010000 @ encdec_freg(rs2) @ encdec_freg(rs1) @ 0b101 @ encdec_reg(rd) @ 0b1010011 if currentlyEnabled(Ext_Zfa),
  FLEQ_D(rs2, rs1, rd) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_D), currentlyEnabled(Ext_Zfa)) <-> 0b1010001 @ encdec_freg(rs2) @ encdec_freg(rs1) @ 0b100 @ encdec_reg(rd) @ 0b1010011 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_D), currentlyEnabled(Ext_Zfa)),
  FLTQ_D(rs2, rs1, rd) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_D), currentlyEnabled(Ext_Zfa)) <-> 0b1010001 @ encdec_freg(rs2) @ encdec_freg(rs1) @ 0b101 @ encdec_reg(rd) @ 0b1010011 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_D), currentlyEnabled(Ext_Zfa)),
  FCVTMOD_W_D(rs1, rd) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_D), currentlyEnabled(Ext_Zfa)) <-> 0b1100001 @ 0b01000 @ encdec_freg(rs1) @ 0b001 @ encdec_reg(rd) @ 0b1010011 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_D), currentlyEnabled(Ext_Zfa)),
  VSETVLI(ma, ta, sew, lmul, rs1, rd) if currentlyEnabled(Ext_V) <-> 0b0000 @ (ma : bitvector(1)) @ (ta : bitvector(1)) @ (sew : bitvector(3)) @ (lmul : bitvector(3)) @ encdec_reg(rs1) @ 0b111 @ encdec_reg(rd) @ 0b1010111 if currentlyEnabled(Ext_V),
  VSETVL(rs2, rs1, rd) if currentlyEnabled(Ext_V) <-> 0b1000000 @ encdec_reg(rs2) @ encdec_reg(rs1) @ 0b111 @ encdec_reg(rd) @ 0b1010111 if currentlyEnabled(Ext_V),
  VSETIVLI(ma, ta, sew, lmul, uimm, rd) if currentlyEnabled(Ext_V) <-> 0b1100 @ (ma : bitvector(1)) @ (ta : bitvector(1)) @ (sew : bitvector(3)) @ (lmul : bitvector(3)) @ (uimm : bitvector(5)) @ 0b111 @ encdec_reg(rd) @ 0b1010111 if currentlyEnabled(Ext_V),
  VVTYPE(funct6, vm, vs2, vs1, vd) if currentlyEnabled(Ext_V) <-> encdec_vvfunct6(funct6) @ (vm : bitvector(1)) @ encdec_vreg(vs2) @ encdec_vreg(vs1) @ 0b000 @ encdec_vreg(vd) @ 0b1010111 if currentlyEnabled(Ext_V),
  NVSTYPE(funct6, vm, vs2, vs1, vd) if currentlyEnabled(Ext_V) <-> encdec_nvsfunct6(funct6) @ (vm : bitvector(1)) @ encdec_vreg(vs2) @ encdec_vreg(vs1) @ 0b000 @ encdec_vreg(vd) @ 0b1010111 if currentlyEnabled(Ext_V),
  NVTYPE(funct6, vm, vs2, vs1, vd) if currentlyEnabled(Ext_V) <-> encdec_nvfunct6(funct6) @ (vm : bitvector(1)) @ encdec_vreg(vs2) @ encdec_vreg(vs1) @ 0b000 @ encdec_vreg(vd) @ 0b1010111 if currentlyEnabled(Ext_V),
  MASKTYPEV(vs2, vs1, vd) if currentlyEnabled(Ext_V) <-> 0b010111 @ 0b0 @ encdec_vreg(vs2) @ encdec_vreg(vs1) @ 0b000 @ encdec_vreg(vd) @ 0b1010111 if currentlyEnabled(Ext_V),
  MOVETYPEV(vs1, vd) if currentlyEnabled(Ext_V) <-> 0b010111 @ 0b1 @ 0b00000 @ encdec_vreg(vs1) @ 0b000 @ encdec_vreg(vd) @ 0b1010111 if currentlyEnabled(Ext_V),
  VXTYPE(funct6, vm, vs2, rs1, vd) if currentlyEnabled(Ext_V) <-> encdec_vxfunct6(funct6) @ (vm : bitvector(1)) @ encdec_vreg(vs2) @ encdec_reg(rs1) @ 0b100 @ encdec_vreg(vd) @ 0b1010111 if currentlyEnabled(Ext_V),
  NXSTYPE(funct6, vm, vs2, rs1, vd) if currentlyEnabled(Ext_V) <-> encdec_nxsfunct6(funct6) @ (vm : bitvector(1)) @ encdec_vreg(vs2) @ encdec_reg(rs1) @ 0b100 @ encdec_vreg(vd) @ 0b1010111 if currentlyEnabled(Ext_V),
  NXTYPE(funct6, vm, vs2, rs1, vd) if currentlyEnabled(Ext_V) <-> encdec_nxfunct6(funct6) @ (vm : bitvector(1)) @ encdec_vreg(vs2) @ encdec_reg(rs1) @ 0b100 @ encdec_vreg(vd) @ 0b1010111 if currentlyEnabled(Ext_V),
  VXSG(funct6, vm, vs2, rs1, vd) if currentlyEnabled(Ext_V) <-> encdec_vxsgfunct6(funct6) @ (vm : bitvector(1)) @ encdec_vreg(vs2) @ encdec_reg(rs1) @ 0b100 @ encdec_vreg(vd) @ 0b1010111 if currentlyEnabled(Ext_V),
  MASKTYPEX(vs2, rs1, vd) if currentlyEnabled(Ext_V) <-> 0b010111 @ 0b0 @ encdec_vreg(vs2) @ encdec_reg(rs1) @ 0b100 @ encdec_vreg(vd) @ 0b1010111 if currentlyEnabled(Ext_V),
  MOVETYPEX(rs1, vd) if currentlyEnabled(Ext_V) <-> 0b010111 @ 0b1 @ 0b00000 @ encdec_reg(rs1) @ 0b100 @ encdec_vreg(vd) @ 0b1010111 if currentlyEnabled(Ext_V),
  VITYPE(funct6, vm, vs2, simm, vd) if currentlyEnabled(Ext_V) <-> encdec_vifunct6(funct6) @ (vm : bitvector(1)) @ encdec_vreg(vs2) @ (simm : bitvector(5)) @ 0b011 @ encdec_vreg(vd) @ 0b1010111 if currentlyEnabled(Ext_V),
  NISTYPE(funct6, vm, vs2, uimm, vd) if currentlyEnabled(Ext_V) <-> encdec_nisfunct6(funct6) @ (vm : bitvector(1)) @ encdec_vreg(vs2) @ (uimm : bitvector(5)) @ 0b011 @ encdec_vreg(vd) @ 0b1010111 if currentlyEnabled(Ext_V),
  NITYPE(funct6, vm, vs2, uimm, vd) if currentlyEnabled(Ext_V) <-> encdec_nifunct6(funct6) @ (vm : bitvector(1)) @ encdec_vreg(vs2) @ (uimm : bitvector(5)) @ 0b011 @ encdec_vreg(vd) @ 0b1010111 if currentlyEnabled(Ext_V),
  VISG(funct6, vm, vs2, simm, vd) if currentlyEnabled(Ext_V) <-> encdec_visgfunct6(funct6) @ (vm : bitvector(1)) @ encdec_vreg(vs2) @ (simm : bitvector(5)) @ 0b011 @ encdec_vreg(vd) @ 0b1010111 if currentlyEnabled(Ext_V),
  MASKTYPEI(vs2, simm, vd) if currentlyEnabled(Ext_V) <-> 0b010111 @ 0b0 @ encdec_vreg(vs2) @ (simm : bitvector(5)) @ 0b011 @ encdec_vreg(vd) @ 0b1010111 if currentlyEnabled(Ext_V),
  MOVETYPEI(vd, simm) if currentlyEnabled(Ext_V) <-> 0b010111 @ 0b1 @ 0b00000 @ (simm : bitvector(5)) @ 0b011 @ encdec_vreg(vd) @ 0b1010111 if currentlyEnabled(Ext_V),
  VMVRTYPE(vs2, nreg, vd) if currentlyEnabled(Ext_V) <-> 0b100111 @ 0b1 @ encdec_vreg(vs2) @ encdec_nreg(nreg) @ 0b011 @ encdec_vreg(vd) @ 0b1010111 if currentlyEnabled(Ext_V),
  MVVTYPE(funct6, vm, vs2, vs1, vd) if currentlyEnabled(Ext_V) <-> encdec_mvvfunct6(funct6) @ (vm : bitvector(1)) @ encdec_vreg(vs2) @ encdec_vreg(vs1) @ 0b010 @ encdec_vreg(vd) @ 0b1010111 if currentlyEnabled(Ext_V),
  MVVMATYPE(funct6, vm, vs2, vs1, vd) if currentlyEnabled(Ext_V) <-> encdec_mvvmafunct6(funct6) @ (vm : bitvector(1)) @ encdec_vreg(vs2) @ encdec_vreg(vs1) @ 0b010 @ encdec_vreg(vd) @ 0b1010111 if currentlyEnabled(Ext_V),
  WVVTYPE(funct6, vm, vs2, vs1, vd) if currentlyEnabled(Ext_V) <-> encdec_wvvfunct6(funct6) @ (vm : bitvector(1)) @ encdec_vreg(vs2) @ encdec_vreg(vs1) @ 0b010 @ encdec_vreg(vd) @ 0b1010111 if currentlyEnabled(Ext_V),
  WVTYPE(funct6, vm, vs2, vs1, vd) if currentlyEnabled(Ext_V) <-> encdec_wvfunct6(funct6) @ (vm : bitvector(1)) @ encdec_vreg(vs2) @ encdec_vreg(vs1) @ 0b010 @ encdec_vreg(vd) @ 0b1010111 if currentlyEnabled(Ext_V),
  WMVVTYPE(funct6, vm, vs2, vs1, vd) if currentlyEnabled(Ext_V) <-> encdec_wmvvfunct6(funct6) @ (vm : bitvector(1)) @ encdec_vreg(vs2) @ encdec_vreg(vs1) @ 0b010 @ encdec_vreg(vd) @ 0b1010111 if currentlyEnabled(Ext_V),
  VEXTTYPE(funct6, vm, vs2, vd) if currentlyEnabled(Ext_V) <-> 0b010010 @ (vm : bitvector(1)) @ encdec_vreg(vs2) @ vext_vs1(funct6) @ 0b010 @ encdec_vreg(vd) @ 0b1010111 if currentlyEnabled(Ext_V),
  VMVXS(vs2, rd) if currentlyEnabled(Ext_V) <-> 0b010000 @ 0b1 @ encdec_vreg(vs2) @ 0b00000 @ 0b010 @ encdec_reg(rd) @ 0b1010111 if currentlyEnabled(Ext_V),
  MVVCOMPRESS(vs2, vs1, vd) if currentlyEnabled(Ext_V) <-> 0b010111 @ 0b1 @ encdec_vreg(vs2) @ encdec_vreg(vs1) @ 0b010 @ encdec_vreg(vd) @ 0b1010111 if currentlyEnabled(Ext_V),
  MVXTYPE(funct6, vm, vs2, rs1, vd) if currentlyEnabled(Ext_V) <-> encdec_mvxfunct6(funct6) @ (vm : bitvector(1)) @ encdec_vreg(vs2) @ encdec_reg(rs1) @ 0b110 @ encdec_vreg(vd) @ 0b1010111 if currentlyEnabled(Ext_V),
  MVXMATYPE(funct6, vm, vs2, rs1, vd) if currentlyEnabled(Ext_V) <-> encdec_mvxmafunct6(funct6) @ (vm : bitvector(1)) @ encdec_vreg(vs2) @ encdec_reg(rs1) @ 0b110 @ encdec_vreg(vd) @ 0b1010111 if currentlyEnabled(Ext_V),
  WVXTYPE(funct6, vm, vs2, rs1, vd) if currentlyEnabled(Ext_V) <-> encdec_wvxfunct6(funct6) @ (vm : bitvector(1)) @ encdec_vreg(vs2) @ encdec_reg(rs1) @ 0b110 @ encdec_vreg(vd) @ 0b1010111 if currentlyEnabled(Ext_V),
  WXTYPE(funct6, vm, vs2, rs1, vd) if currentlyEnabled(Ext_V) <-> encdec_wxfunct6(funct6) @ (vm : bitvector(1)) @ encdec_vreg(vs2) @ encdec_reg(rs1) @ 0b110 @ encdec_vreg(vd) @ 0b1010111 if currentlyEnabled(Ext_V),
  WMVXTYPE(funct6, vm, vs2, rs1, vd) if currentlyEnabled(Ext_V) <-> encdec_wmvxfunct6(funct6) @ (vm : bitvector(1)) @ encdec_vreg(vs2) @ encdec_reg(rs1) @ 0b110 @ encdec_vreg(vd) @ 0b1010111 if currentlyEnabled(Ext_V),
  VMVSX(rs1, vd) if currentlyEnabled(Ext_V) <-> 0b010000 @ 0b1 @ 0b00000 @ encdec_reg(rs1) @ 0b110 @ encdec_vreg(vd) @ 0b1010111 if currentlyEnabled(Ext_V),
  FVVTYPE(funct6, vm, vs2, vs1, vd) if currentlyEnabled(Ext_V) <-> encdec_fvvfunct6(funct6) @ (vm : bitvector(1)) @ encdec_vreg(vs2) @ encdec_vreg(vs1) @ 0b001 @ encdec_vreg(vd) @ 0b1010111 if currentlyEnabled(Ext_V),
  FVVMATYPE(funct6, vm, vs2, vs1, vd) if currentlyEnabled(Ext_V) <-> encdec_fvvmafunct6(funct6) @ (vm : bitvector(1)) @ encdec_vreg(vs2) @ encdec_vreg(vs1) @ 0b001 @ encdec_vreg(vd) @ 0b1010111 if currentlyEnabled(Ext_V),
  FWVVTYPE(funct6, vm, vs2, vs1, vd) if currentlyEnabled(Ext_V) <-> encdec_fwvvfunct6(funct6) @ (vm : bitvector(1)) @ encdec_vreg(vs2) @ encdec_vreg(vs1) @ 0b001 @ encdec_vreg(vd) @ 0b1010111 if currentlyEnabled(Ext_V),
  FWVVMATYPE(funct6, vm, vs1, vs2, vd) if currentlyEnabled(Ext_V) <-> encdec_fwvvmafunct6(funct6) @ (vm : bitvector(1)) @ encdec_vreg(vs1) @ encdec_vreg(vs2) @ 0b001 @ encdec_vreg(vd) @ 0b1010111 if currentlyEnabled(Ext_V),
  FWVTYPE(funct6, vm, vs2, vs1, vd) if currentlyEnabled(Ext_V) <-> encdec_fwvfunct6(funct6) @ (vm : bitvector(1)) @ encdec_vreg(vs2) @ encdec_vreg(vs1) @ 0b001 @ encdec_vreg(vd) @ 0b1010111 if currentlyEnabled(Ext_V),
  VFUNARY0(vm, vs2, vfunary0, vd) if currentlyEnabled(Ext_V) <-> 0b010010 @ (vm : bitvector(1)) @ encdec_vreg(vs2) @ encdec_vfunary0_vs1(vfunary0) @ 0b001 @ encdec_vreg(vd) @ 0b1010111 if currentlyEnabled(Ext_V),
  VFWUNARY0(vm, vs2, vfwunary0, vd) if currentlyEnabled(Ext_V) <-> 0b010010 @ (vm : bitvector(1)) @ encdec_vreg(vs2) @ encdec_vfwunary0_vs1(vfwunary0) @ 0b001 @ encdec_vreg(vd) @ 0b1010111 if currentlyEnabled(Ext_V),
  VFNUNARY0(vm, vs2, vfnunary0, vd) if currentlyEnabled(Ext_V) <-> 0b010010 @ (vm : bitvector(1)) @ encdec_vreg(vs2) @ encdec_vfnunary0_vs1(vfnunary0) @ 0b001 @ encdec_vreg(vd) @ 0b1010111 if currentlyEnabled(Ext_V),
  VFUNARY1(vm, vs2, vfunary1, vd) if currentlyEnabled(Ext_V) <-> 0b010011 @ (vm : bitvector(1)) @ encdec_vreg(vs2) @ encdec_vfunary1_vs1(vfunary1) @ 0b001 @ encdec_vreg(vd) @ 0b1010111 if currentlyEnabled(Ext_V),
  VFMVFS(vs2, rd) if currentlyEnabled(Ext_V) <-> 0b010000 @ 0b1 @ encdec_vreg(vs2) @ 0b00000 @ 0b001 @ encdec_freg(rd) @ 0b1010111 if currentlyEnabled(Ext_V),
  FVFTYPE(funct6, vm, vs2, rs1, vd) if currentlyEnabled(Ext_V) <-> encdec_fvffunct6(funct6) @ (vm : bitvector(1)) @ encdec_vreg(vs2) @ encdec_freg(rs1) @ 0b101 @ encdec_vreg(vd) @ 0b1010111 if currentlyEnabled(Ext_V),
  FVFMATYPE(funct6, vm, vs2, rs1, vd) if currentlyEnabled(Ext_V) <-> encdec_fvfmafunct6(funct6) @ (vm : bitvector(1)) @ encdec_vreg(vs2) @ encdec_freg(rs1) @ 0b101 @ encdec_vreg(vd) @ 0b1010111 if currentlyEnabled(Ext_V),
  FWVFTYPE(funct6, vm, vs2, rs1, vd) if currentlyEnabled(Ext_V) <-> encdec_fwvffunct6(funct6) @ (vm : bitvector(1)) @ encdec_vreg(vs2) @ encdec_freg(rs1) @ 0b101 @ encdec_vreg(vd) @ 0b1010111 if currentlyEnabled(Ext_V),
  FWVFMATYPE(funct6, vm, rs1, vs2, vd) if currentlyEnabled(Ext_V) <-> encdec_fwvfmafunct6(funct6) @ (vm : bitvector(1)) @ encdec_vreg(vs2) @ encdec_freg(rs1) @ 0b101 @ encdec_vreg(vd) @ 0b1010111 if currentlyEnabled(Ext_V),
  FWFTYPE(funct6, vm, vs2, rs1, vd) if currentlyEnabled(Ext_V) <-> encdec_fwffunct6(funct6) @ (vm : bitvector(1)) @ encdec_vreg(vs2) @ encdec_freg(rs1) @ 0b101 @ encdec_vreg(vd) @ 0b1010111 if currentlyEnabled(Ext_V),
  VFMERGE(vs2, rs1, vd) if currentlyEnabled(Ext_V) <-> 0b010111 @ 0b0 @ encdec_vreg(vs2) @ encdec_freg(rs1) @ 0b101 @ encdec_vreg(vd) @ 0b1010111 if currentlyEnabled(Ext_V),
  VFMV(rs1, vd) if currentlyEnabled(Ext_V) <-> 0b010111 @ 0b1 @ 0b00000 @ encdec_freg(rs1) @ 0b101 @ encdec_vreg(vd) @ 0b1010111 if currentlyEnabled(Ext_V),
  VFMVSF(rs1, vd) if currentlyEnabled(Ext_V) <-> 0b010000 @ 0b1 @ 0b00000 @ encdec_freg(rs1) @ 0b101 @ encdec_vreg(vd) @ 0b1010111 if currentlyEnabled(Ext_V),
  VLSEGTYPE(nf, vm, rs1, width, vd) if currentlyEnabled(Ext_V) <-> encdec_nfields(nf) @ 0b0 @ 0b00 @ (vm : bitvector(1)) @ 0b00000 @ encdec_reg(rs1) @ encdec_vlewidth(width) @ encdec_vreg(vd) @ 0b0000111 if currentlyEnabled(Ext_V),
  VLSEGFFTYPE(nf, vm, rs1, width, vd) if currentlyEnabled(Ext_V) <-> encdec_nfields(nf) @ 0b0 @ 0b00 @ (vm : bitvector(1)) @ 0b10000 @ encdec_reg(rs1) @ encdec_vlewidth(width) @ encdec_vreg(vd) @ 0b0000111 if currentlyEnabled(Ext_V),
  VSSEGTYPE(nf, vm, rs1, width, vs3) if currentlyEnabled(Ext_V) <-> encdec_nfields(nf) @ 0b0 @ 0b00 @ (vm : bitvector(1)) @ 0b00000 @ encdec_reg(rs1) @ encdec_vlewidth(width) @ encdec_vreg(vs3) @ 0b0100111 if currentlyEnabled(Ext_V),
  VLSSEGTYPE(nf, vm, rs2, rs1, width, vd) if currentlyEnabled(Ext_V) <-> encdec_nfields(nf) @ 0b0 @ 0b10 @ (vm : bitvector(1)) @ encdec_reg(rs2) @ encdec_reg(rs1) @ encdec_vlewidth(width) @ encdec_vreg(vd) @ 0b0000111 if currentlyEnabled(Ext_V),
  VSSSEGTYPE(nf, vm, rs2, rs1, width, vs3) if currentlyEnabled(Ext_V) <-> encdec_nfields(nf) @ 0b0 @ 0b10 @ (vm : bitvector(1)) @ encdec_reg(rs2) @ encdec_reg(rs1) @ encdec_vlewidth(width) @ encdec_vreg(vs3) @ 0b0100111 if currentlyEnabled(Ext_V),
  VLUXSEGTYPE(nf, vm, vs2, rs1, width, vd) if currentlyEnabled(Ext_V) <-> encdec_nfields(nf) @ 0b0 @ 0b01 @ (vm : bitvector(1)) @ encdec_vreg(vs2) @ encdec_reg(rs1) @ encdec_vlewidth(width) @ encdec_vreg(vd) @ 0b0000111 if currentlyEnabled(Ext_V),
  VLOXSEGTYPE(nf, vm, vs2, rs1, width, vd) if currentlyEnabled(Ext_V) <-> encdec_nfields(nf) @ 0b0 @ 0b11 @ (vm : bitvector(1)) @ encdec_vreg(vs2) @ encdec_reg(rs1) @ encdec_vlewidth(width) @ encdec_vreg(vd) @ 0b0000111 if currentlyEnabled(Ext_V),
  VSUXSEGTYPE(nf, vm, vs2, rs1, width, vs3) if currentlyEnabled(Ext_V) <-> encdec_nfields(nf) @ 0b0 @ 0b01 @ (vm : bitvector(1)) @ encdec_vreg(vs2) @ encdec_reg(rs1) @ encdec_vlewidth(width) @ encdec_vreg(vs3) @ 0b0100111 if currentlyEnabled(Ext_V),
  VSOXSEGTYPE(nf, vm, vs2, rs1, width, vs3) if currentlyEnabled(Ext_V) <-> encdec_nfields(nf) @ 0b0 @ 0b11 @ (vm : bitvector(1)) @ encdec_vreg(vs2) @ encdec_reg(rs1) @ encdec_vlewidth(width) @ encdec_vreg(vs3) @ 0b0100111 if currentlyEnabled(Ext_V),
  VLRETYPE(nf, rs1, width, vd) if currentlyEnabled(Ext_V) <-> encdec_nfields_pow2(nf) @ 0b0 @ 0b00 @ 0b1 @ 0b01000 @ encdec_reg(rs1) @ encdec_vlewidth(width) @ encdec_vreg(vd) @ 0b0000111 if currentlyEnabled(Ext_V),
  VSRETYPE(nf, rs1, vs3) if currentlyEnabled(Ext_V) <-> encdec_nfields_pow2(nf) @ 0b0 @ 0b00 @ 0b1 @ 0b01000 @ encdec_reg(rs1) @ 0b000 @ encdec_vreg(vs3) @ 0b0100111 if currentlyEnabled(Ext_V),
  VMTYPE(rs1, vd_or_vs3, op) if currentlyEnabled(Ext_V) <-> 0b000 @ 0b0 @ 0b00 @ 0b1 @ 0b01011 @ encdec_reg(rs1) @ 0b000 @ encdec_vreg(vd_or_vs3) @ encdec_lsop(op) if currentlyEnabled(Ext_V),
  MMTYPE(funct6, vs2, vs1, vd) if currentlyEnabled(Ext_V) <-> encdec_mmfunct6(funct6) @ 0b1 @ encdec_vreg(vs2) @ encdec_vreg(vs1) @ 0b010 @ encdec_vreg(vd) @ 0b1010111 if currentlyEnabled(Ext_V),
  VCPOP_M(vm, vs2, rd) if currentlyEnabled(Ext_V) <-> 0b010000 @ (vm : bitvector(1)) @ encdec_vreg(vs2) @ 0b10000 @ 0b010 @ encdec_reg(rd) @ 0b1010111 if currentlyEnabled(Ext_V),
  VFIRST_M(vm, vs2, rd) if currentlyEnabled(Ext_V) <-> 0b010000 @ (vm : bitvector(1)) @ encdec_vreg(vs2) @ 0b10001 @ 0b010 @ encdec_reg(rd) @ 0b1010111 if currentlyEnabled(Ext_V),
  VMSBF_M(vm, vs2, vd) if currentlyEnabled(Ext_V) <-> 0b010100 @ (vm : bitvector(1)) @ encdec_vreg(vs2) @ 0b00001 @ 0b010 @ encdec_vreg(vd) @ 0b1010111 if currentlyEnabled(Ext_V),
  VMSIF_M(vm, vs2, vd) if currentlyEnabled(Ext_V) <-> 0b010100 @ (vm : bitvector(1)) @ encdec_vreg(vs2) @ 0b00011 @ 0b010 @ encdec_vreg(vd) @ 0b1010111 if currentlyEnabled(Ext_V),
  VMSOF_M(vm, vs2, vd) if currentlyEnabled(Ext_V) <-> 0b010100 @ (vm : bitvector(1)) @ encdec_vreg(vs2) @ 0b00010 @ 0b010 @ encdec_vreg(vd) @ 0b1010111 if currentlyEnabled(Ext_V),
  VIOTA_M(vm, vs2, vd) if currentlyEnabled(Ext_V) <-> 0b010100 @ (vm : bitvector(1)) @ encdec_vreg(vs2) @ 0b10000 @ 0b010 @ encdec_vreg(vd) @ 0b1010111 if currentlyEnabled(Ext_V),
  VID_V(vm, vd) if currentlyEnabled(Ext_V) <-> 0b010100 @ (vm : bitvector(1)) @ 0b00000 @ 0b10001 @ 0b010 @ encdec_vreg(vd) @ 0b1010111 if currentlyEnabled(Ext_V),
  VVMTYPE(funct6, vs2, vs1, vd) if currentlyEnabled(Ext_V) <-> encdec_vvmfunct6(funct6) @ 0b0 @ encdec_vreg(vs2) @ encdec_vreg(vs1) @ 0b000 @ encdec_vreg(vd) @ 0b1010111 if currentlyEnabled(Ext_V),
  VVMCTYPE(funct6, vs2, vs1, vd) if currentlyEnabled(Ext_V) <-> encdec_vvmcfunct6(funct6) @ 0b1 @ encdec_vreg(vs2) @ encdec_vreg(vs1) @ 0b000 @ encdec_vreg(vd) @ 0b1010111 if currentlyEnabled(Ext_V),
  VVMSTYPE(funct6, vs2, vs1, vd) if currentlyEnabled(Ext_V) <-> encdec_vvmsfunct6(funct6) @ 0b0 @ encdec_vreg(vs2) @ encdec_vreg(vs1) @ 0b000 @ encdec_vreg(vd) @ 0b1010111 if currentlyEnabled(Ext_V),
  VVCMPTYPE(funct6, vm, vs2, vs1, vd) if currentlyEnabled(Ext_V) <-> encdec_vvcmpfunct6(funct6) @ (vm : bitvector(1)) @ encdec_vreg(vs2) @ encdec_vreg(vs1) @ 0b000 @ encdec_vreg(vd) @ 0b1010111 if currentlyEnabled(Ext_V),
  VXMTYPE(funct6, vs2, rs1, vd) if currentlyEnabled(Ext_V) <-> encdec_vxmfunct6(funct6) @ 0b0 @ encdec_vreg(vs2) @ encdec_reg(rs1) @ 0b100 @ encdec_vreg(vd) @ 0b1010111 if currentlyEnabled(Ext_V),
  VXMCTYPE(funct6, vs2, rs1, vd) if currentlyEnabled(Ext_V) <-> encdec_vxmcfunct6(funct6) @ 0b1 @ encdec_vreg(vs2) @ encdec_reg(rs1) @ 0b100 @ encdec_vreg(vd) @ 0b1010111 if currentlyEnabled(Ext_V),
  VXMSTYPE(funct6, vs2, rs1, vd) if currentlyEnabled(Ext_V) <-> encdec_vxmsfunct6(funct6) @ 0b0 @ encdec_vreg(vs2) @ encdec_reg(rs1) @ 0b100 @ encdec_vreg(vd) @ 0b1010111 if currentlyEnabled(Ext_V),
  VXCMPTYPE(funct6, vm, vs2, rs1, vd) if currentlyEnabled(Ext_V) <-> encdec_vxcmpfunct6(funct6) @ (vm : bitvector(1)) @ encdec_vreg(vs2) @ encdec_reg(rs1) @ 0b100 @ encdec_vreg(vd) @ 0b1010111 if currentlyEnabled(Ext_V),
  VIMTYPE(funct6, vs2, simm, vd) if currentlyEnabled(Ext_V) <-> encdec_vimfunct6(funct6) @ 0b0 @ encdec_vreg(vs2) @ (simm : bitvector(5)) @ 0b011 @ encdec_vreg(vd) @ 0b1010111 if currentlyEnabled(Ext_V),
  VIMCTYPE(funct6, vs2, simm, vd) if currentlyEnabled(Ext_V) <-> encdec_vimcfunct6(funct6) @ 0b1 @ encdec_vreg(vs2) @ (simm : bitvector(5)) @ 0b011 @ encdec_vreg(vd) @ 0b1010111 if currentlyEnabled(Ext_V),
  VIMSTYPE(funct6, vs2, simm, vd) if currentlyEnabled(Ext_V) <-> encdec_vimsfunct6(funct6) @ 0b0 @ encdec_vreg(vs2) @ (simm : bitvector(5)) @ 0b011 @ encdec_vreg(vd) @ 0b1010111 if currentlyEnabled(Ext_V),
  VICMPTYPE(funct6, vm, vs2, simm, vd) if currentlyEnabled(Ext_V) <-> encdec_vicmpfunct6(funct6) @ (vm : bitvector(1)) @ encdec_vreg(vs2) @ (simm : bitvector(5)) @ 0b011 @ encdec_vreg(vd) @ 0b1010111 if currentlyEnabled(Ext_V),
  FVVMTYPE(funct6, vm, vs2, vs1, vd) if currentlyEnabled(Ext_V) <-> encdec_fvvmfunct6(funct6) @ (vm : bitvector(1)) @ encdec_vreg(vs2) @ encdec_vreg(vs1) @ 0b001 @ encdec_vreg(vd) @ 0b1010111 if currentlyEnabled(Ext_V),
  FVFMTYPE(funct6, vm, vs2, rs1, vd) if currentlyEnabled(Ext_V) <-> encdec_fvfmfunct6(funct6) @ (vm : bitvector(1)) @ encdec_vreg(vs2) @ encdec_freg(rs1) @ 0b101 @ encdec_vreg(vd) @ 0b1010111 if currentlyEnabled(Ext_V),
  RIVVTYPE(funct6, vm, vs2, vs1, vd) if currentlyEnabled(Ext_V) <-> encdec_rivvfunct6(funct6) @ (vm : bitvector(1)) @ encdec_vreg(vs2) @ encdec_vreg(vs1) @ 0b000 @ encdec_vreg(vd) @ 0b1010111 if currentlyEnabled(Ext_V),
  RMVVTYPE(funct6, vm, vs2, vs1, vd) if currentlyEnabled(Ext_V) <-> encdec_rmvvfunct6(funct6) @ (vm : bitvector(1)) @ encdec_vreg(vs2) @ encdec_vreg(vs1) @ 0b010 @ encdec_vreg(vd) @ 0b1010111 if currentlyEnabled(Ext_V),
  RFVVTYPE(funct6, vm, vs2, vs1, vd) if currentlyEnabled(Ext_V) <-> encdec_rfvvfunct6(funct6) @ (vm : bitvector(1)) @ encdec_vreg(vs2) @ encdec_vreg(vs1) @ 0b001 @ encdec_vreg(vd) @ 0b1010111 if currentlyEnabled(Ext_V),
  SHA256SUM0(rs1, rd) if currentlyEnabled(Ext_Zknh) <-> 0b00 @ 0b01000 @ 0b00000 @ encdec_reg(rs1) @ 0b001 @ encdec_reg(rd) @ 0b0010011 if currentlyEnabled(Ext_Zknh),
  SHA256SUM1(rs1, rd) if currentlyEnabled(Ext_Zknh) <-> 0b00 @ 0b01000 @ 0b00001 @ encdec_reg(rs1) @ 0b001 @ encdec_reg(rd) @ 0b0010011 if currentlyEnabled(Ext_Zknh),
  SHA256SIG0(rs1, rd) if currentlyEnabled(Ext_Zknh) <-> 0b00 @ 0b01000 @ 0b00010 @ encdec_reg(rs1) @ 0b001 @ encdec_reg(rd) @ 0b0010011 if currentlyEnabled(Ext_Zknh),
  SHA256SIG1(rs1, rd) if currentlyEnabled(Ext_Zknh) <-> 0b00 @ 0b01000 @ 0b00011 @ encdec_reg(rs1) @ 0b001 @ encdec_reg(rd) @ 0b0010011 if currentlyEnabled(Ext_Zknh),
  AES32ESMI(bs, rs2, rs1, rd) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zkne), $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 32)) <-> (bs : bitvector(2)) @ 0b10011 @ encdec_reg(rs2) @ encdec_reg(rs1) @ 0b000 @ encdec_reg(rd) @ 0b0110011 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zkne), $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 32)),
  AES32ESI(bs, rs2, rs1, rd) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zkne), $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 32)) <-> (bs : bitvector(2)) @ 0b10001 @ encdec_reg(rs2) @ encdec_reg(rs1) @ 0b000 @ encdec_reg(rd) @ 0b0110011 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zkne), $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 32)),
  AES32DSMI(bs, rs2, rs1, rd) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zknd), $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 32)) <-> (bs : bitvector(2)) @ 0b10111 @ encdec_reg(rs2) @ encdec_reg(rs1) @ 0b000 @ encdec_reg(rd) @ 0b0110011 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zknd), $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 32)),
  AES32DSI(bs, rs2, rs1, rd) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zknd), $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 32)) <-> (bs : bitvector(2)) @ 0b10101 @ encdec_reg(rs2) @ encdec_reg(rs1) @ 0b000 @ encdec_reg(rd) @ 0b0110011 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zknd), $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 32)),
  SHA512SUM0R(rs2, rs1, rd) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zknh), $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 32)) <-> 0b01 @ 0b01000 @ encdec_reg(rs2) @ encdec_reg(rs1) @ 0b000 @ encdec_reg(rd) @ 0b0110011 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zknh), $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 32)),
  SHA512SUM1R(rs2, rs1, rd) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zknh), $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 32)) <-> 0b01 @ 0b01001 @ encdec_reg(rs2) @ encdec_reg(rs1) @ 0b000 @ encdec_reg(rd) @ 0b0110011 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zknh), $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 32)),
  SHA512SIG0L(rs2, rs1, rd) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zknh), $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 32)) <-> 0b01 @ 0b01010 @ encdec_reg(rs2) @ encdec_reg(rs1) @ 0b000 @ encdec_reg(rd) @ 0b0110011 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zknh), $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 32)),
  SHA512SIG0H(rs2, rs1, rd) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zknh), $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 32)) <-> 0b01 @ 0b01110 @ encdec_reg(rs2) @ encdec_reg(rs1) @ 0b000 @ encdec_reg(rd) @ 0b0110011 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zknh), $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 32)),
  SHA512SIG1L(rs2, rs1, rd) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zknh), $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 32)) <-> 0b01 @ 0b01011 @ encdec_reg(rs2) @ encdec_reg(rs1) @ 0b000 @ encdec_reg(rd) @ 0b0110011 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zknh), $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 32)),
  SHA512SIG1H(rs2, rs1, rd) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zknh), $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 32)) <-> 0b01 @ 0b01111 @ encdec_reg(rs2) @ encdec_reg(rs1) @ 0b000 @ encdec_reg(rd) @ 0b0110011 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zknh), $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 32)),
  AES64KS1I(rnum, rs1, rd) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "|", "is_infix" = true }] or_bool(currentlyEnabled(Ext_Zkne), currentlyEnabled(Ext_Zknd)), $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64), operator <_u(rnum, 0xB))) <-> 0b00 @ 0b11000 @ 0b1 @ (rnum : bitvector(4)) @ encdec_reg(rs1) @ 0b001 @ encdec_reg(rd) @ 0b0010011 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "|", "is_infix" = true }] or_bool(currentlyEnabled(Ext_Zkne), currentlyEnabled(Ext_Zknd)), $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64), operator <_u(rnum, 0xB))),
  AES64IM(rs1, rd) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zknd), $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64)) <-> 0b00 @ 0b11000 @ 0b00000 @ encdec_reg(rs1) @ 0b001 @ encdec_reg(rd) @ 0b0010011 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zknd), $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64)),
  AES64KS2(rs2, rs1, rd) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "|", "is_infix" = true }] or_bool(currentlyEnabled(Ext_Zkne), currentlyEnabled(Ext_Zknd)), $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64)) <-> 0b01 @ 0b11111 @ encdec_reg(rs2) @ encdec_reg(rs1) @ 0b000 @ encdec_reg(rd) @ 0b0110011 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "|", "is_infix" = true }] or_bool(currentlyEnabled(Ext_Zkne), currentlyEnabled(Ext_Zknd)), $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64)),
  AES64ESM(rs2, rs1, rd) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zkne), $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64)) <-> 0b00 @ 0b11011 @ encdec_reg(rs2) @ encdec_reg(rs1) @ 0b000 @ encdec_reg(rd) @ 0b0110011 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zkne), $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64)),
  AES64ES(rs2, rs1, rd) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zkne), $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64)) <-> 0b00 @ 0b11001 @ encdec_reg(rs2) @ encdec_reg(rs1) @ 0b000 @ encdec_reg(rd) @ 0b0110011 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zkne), $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64)),
  AES64DSM(rs2, rs1, rd) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zknd), $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64)) <-> 0b00 @ 0b11111 @ encdec_reg(rs2) @ encdec_reg(rs1) @ 0b000 @ encdec_reg(rd) @ 0b0110011 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zknd), $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64)),
  AES64DS(rs2, rs1, rd) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zknd), $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64)) <-> 0b00 @ 0b11101 @ encdec_reg(rs2) @ encdec_reg(rs1) @ 0b000 @ encdec_reg(rd) @ 0b0110011 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zknd), $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64)),
  SHA512SUM0(rs1, rd) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zknh), $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64)) <-> 0b00 @ 0b01000 @ 0b00100 @ encdec_reg(rs1) @ 0b001 @ encdec_reg(rd) @ 0b0010011 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zknh), $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64)),
  SHA512SUM1(rs1, rd) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zknh), $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64)) <-> 0b00 @ 0b01000 @ 0b00101 @ encdec_reg(rs1) @ 0b001 @ encdec_reg(rd) @ 0b0010011 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zknh), $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64)),
  SHA512SIG0(rs1, rd) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zknh), $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64)) <-> 0b00 @ 0b01000 @ 0b00110 @ encdec_reg(rs1) @ 0b001 @ encdec_reg(rd) @ 0b0010011 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zknh), $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64)),
  SHA512SIG1(rs1, rd) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zknh), $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64)) <-> 0b00 @ 0b01000 @ 0b00111 @ encdec_reg(rs1) @ 0b001 @ encdec_reg(rd) @ 0b0010011 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zknh), $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64)),
  SM3P0(rs1, rd) if currentlyEnabled(Ext_Zksh) <-> 0b00 @ 0b01000 @ 0b01000 @ encdec_reg(rs1) @ 0b001 @ encdec_reg(rd) @ 0b0010011 if currentlyEnabled(Ext_Zksh),
  SM3P1(rs1, rd) if currentlyEnabled(Ext_Zksh) <-> 0b00 @ 0b01000 @ 0b01001 @ encdec_reg(rs1) @ 0b001 @ encdec_reg(rd) @ 0b0010011 if currentlyEnabled(Ext_Zksh),
  SM4ED(bs, rs2, rs1, rd) if currentlyEnabled(Ext_Zksed) <-> (bs : bitvector(2)) @ 0b11000 @ encdec_reg(rs2) @ encdec_reg(rs1) @ 0b000 @ encdec_reg(rd) @ 0b0110011 if currentlyEnabled(Ext_Zksed),
  SM4KS(bs, rs2, rs1, rd) if currentlyEnabled(Ext_Zksed) <-> (bs : bitvector(2)) @ 0b11010 @ encdec_reg(rs2) @ encdec_reg(rs1) @ 0b000 @ encdec_reg(rd) @ 0b0110011 if currentlyEnabled(Ext_Zksed),
  ZBKB_RTYPE(rs2, rs1, rd, PACK) if currentlyEnabled(Ext_Zbkb) <-> 0b0000100 @ encdec_reg(rs2) @ encdec_reg(rs1) @ 0b100 @ encdec_reg(rd) @ 0b0110011 if currentlyEnabled(Ext_Zbkb),
  ZBKB_RTYPE(rs2, rs1, rd, PACKH) if currentlyEnabled(Ext_Zbkb) <-> 0b0000100 @ encdec_reg(rs2) @ encdec_reg(rs1) @ 0b111 @ encdec_reg(rd) @ 0b0110011 if currentlyEnabled(Ext_Zbkb),
  ZBKB_PACKW(rs2, rs1, rd) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zbkb), $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64)) <-> 0b0000100 @ encdec_reg(rs2) @ encdec_reg(rs1) @ 0b100 @ encdec_reg(rd) @ 0b0111011 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zbkb), $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64)),
  ZIP(rs1, rd) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zbkb), $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 32)) <-> 0b000010001111 @ encdec_reg(rs1) @ 0b001 @ encdec_reg(rd) @ 0b0010011 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zbkb), $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 32)),
  UNZIP(rs1, rd) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zbkb), $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 32)) <-> 0b000010001111 @ encdec_reg(rs1) @ 0b101 @ encdec_reg(rd) @ 0b0010011 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zbkb), $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 32)),
  BREV8(rs1, rd) if currentlyEnabled(Ext_Zbkb) <-> 0b011010000111 @ encdec_reg(rs1) @ 0b101 @ encdec_reg(rd) @ 0b0010011 if currentlyEnabled(Ext_Zbkb),
  XPERM8(rs2, rs1, rd) if currentlyEnabled(Ext_Zbkx) <-> 0b0010100 @ encdec_reg(rs2) @ encdec_reg(rs1) @ 0b100 @ encdec_reg(rd) @ 0b0110011 if currentlyEnabled(Ext_Zbkx),
  XPERM4(rs2, rs1, rd) if currentlyEnabled(Ext_Zbkx) <-> 0b0010100 @ encdec_reg(rs2) @ encdec_reg(rs1) @ 0b010 @ encdec_reg(rd) @ 0b0110011 if currentlyEnabled(Ext_Zbkx),
  VANDN_VV(vm, vs1, vs2, vd) if currentlyEnabled(Ext_Zvkb) <-> 0b000001 @ (vm : bitvector(1)) @ encdec_vreg(vs2) @ encdec_vreg(vs1) @ 0b000 @ encdec_vreg(vd) @ 0b1010111 if currentlyEnabled(Ext_Zvkb),
  VANDN_VX(vm, vs2, rs1, vd) if currentlyEnabled(Ext_Zvkb) <-> 0b000001 @ (vm : bitvector(1)) @ encdec_vreg(vs2) @ encdec_reg(rs1) @ 0b100 @ encdec_vreg(vd) @ 0b1010111 if currentlyEnabled(Ext_Zvkb),
  VBREV_V(vm, vs2, vd) if currentlyEnabled(Ext_Zvbb) <-> 0b010010 @ (vm : bitvector(1)) @ encdec_vreg(vs2) @ 0b01010 @ 0b010 @ encdec_vreg(vd) @ 0b1010111 if currentlyEnabled(Ext_Zvbb),
  VBREV8_V(vm, vs2, vd) if currentlyEnabled(Ext_Zvkb) <-> 0b010010 @ (vm : bitvector(1)) @ encdec_vreg(vs2) @ 0b01000 @ 0b010 @ encdec_vreg(vd) @ 0b1010111 if currentlyEnabled(Ext_Zvkb),
  VREV8_V(vm, vs2, vd) if currentlyEnabled(Ext_Zvkb) <-> 0b010010 @ (vm : bitvector(1)) @ encdec_vreg(vs2) @ 0b01001 @ 0b010 @ encdec_vreg(vd) @ 0b1010111 if currentlyEnabled(Ext_Zvkb),
  VCLZ_V(vm, vs2, vd) if currentlyEnabled(Ext_Zvbb) <-> 0b010010 @ (vm : bitvector(1)) @ encdec_vreg(vs2) @ 0b01100 @ 0b010 @ encdec_vreg(vd) @ 0b1010111 if currentlyEnabled(Ext_Zvbb),
  VCTZ_V(vm, vs2, vd) if currentlyEnabled(Ext_Zvbb) <-> 0b010010 @ (vm : bitvector(1)) @ encdec_vreg(vs2) @ 0b01101 @ 0b010 @ encdec_vreg(vd) @ 0b1010111 if currentlyEnabled(Ext_Zvbb),
  VCPOP_V(vm, vs2, vd) if currentlyEnabled(Ext_Zvbb) <-> 0b010010 @ (vm : bitvector(1)) @ encdec_vreg(vs2) @ 0b01110 @ 0b010 @ encdec_vreg(vd) @ 0b1010111 if currentlyEnabled(Ext_Zvbb),
  VROL_VV(vm, vs1, vs2, vd) if currentlyEnabled(Ext_Zvkb) <-> 0b010101 @ (vm : bitvector(1)) @ encdec_vreg(vs2) @ encdec_vreg(vs1) @ 0b000 @ encdec_vreg(vd) @ 0b1010111 if currentlyEnabled(Ext_Zvkb),
  VROL_VX(vm, vs2, rs1, vd) if currentlyEnabled(Ext_Zvkb) <-> 0b010101 @ (vm : bitvector(1)) @ encdec_vreg(vs2) @ encdec_reg(rs1) @ 0b100 @ encdec_vreg(vd) @ 0b1010111 if currentlyEnabled(Ext_Zvkb),
  VROR_VV(vm, vs1, vs2, vd) if currentlyEnabled(Ext_Zvkb) <-> 0b010100 @ (vm : bitvector(1)) @ encdec_vreg(vs2) @ encdec_vreg(vs1) @ 0b000 @ encdec_vreg(vd) @ 0b1010111 if currentlyEnabled(Ext_Zvkb),
  VROR_VX(vm, vs2, rs1, vd) if currentlyEnabled(Ext_Zvkb) <-> 0b010100 @ (vm : bitvector(1)) @ encdec_vreg(vs2) @ encdec_reg(rs1) @ 0b100 @ encdec_vreg(vd) @ 0b1010111 if currentlyEnabled(Ext_Zvkb),
  VROR_VI(vm, vs2, uimm5 @ (uimm40 : bits(5)), vd) if currentlyEnabled(Ext_Zvkb) <-> 0b01010 @ uimm5 @ (vm : bitvector(1)) @ encdec_vreg(vs2) @ (uimm40 : bits(5)) @ 0b011 @ encdec_vreg(vd) @ 0b1010111 if currentlyEnabled(Ext_Zvkb),
  VWSLL_VV(vm, vs2, vs1, vd) if currentlyEnabled(Ext_Zvbb) <-> 0b110101 @ (vm : bitvector(1)) @ encdec_vreg(vs2) @ encdec_vreg(vs1) @ 0b000 @ encdec_vreg(vd) @ 0b1010111 if currentlyEnabled(Ext_Zvbb),
  VWSLL_VX(vm, vs2, rs1, vd) if currentlyEnabled(Ext_Zvbb) <-> 0b110101 @ (vm : bitvector(1)) @ encdec_vreg(vs2) @ encdec_reg(rs1) @ 0b100 @ encdec_vreg(vd) @ 0b1010111 if currentlyEnabled(Ext_Zvbb),
  VWSLL_VI(vm, vs2, uimm, vd) if currentlyEnabled(Ext_Zvbb) <-> 0b110101 @ (vm : bitvector(1)) @ encdec_vreg(vs2) @ (uimm : bitvector(5)) @ 0b011 @ encdec_vreg(vd) @ 0b1010111 if currentlyEnabled(Ext_Zvbb),
  VCLMUL_VV(vm, vs2, vs1, vd) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zvbc), eq_int(get_sew(), 64) : bool) <-> 0b001100 @ (vm : bitvector(1)) @ encdec_vreg(vs2) @ encdec_vreg(vs1) @ 0b010 @ encdec_vreg(vd) @ 0b1010111 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zvbc), eq_int(get_sew(), 64) : bool),
  VCLMUL_VX(vm, vs2, rs1, vd) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zvbc), eq_int(get_sew(), 64) : bool) <-> 0b001100 @ (vm : bitvector(1)) @ encdec_vreg(vs2) @ encdec_reg(rs1) @ 0b110 @ encdec_vreg(vd) @ 0b1010111 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zvbc), eq_int(get_sew(), 64) : bool),
  VCLMULH_VV(vm, vs2, vs1, vd) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zvbc), eq_int(get_sew(), 64) : bool) <-> 0b001101 @ (vm : bitvector(1)) @ encdec_vreg(vs2) @ encdec_vreg(vs1) @ 0b010 @ encdec_vreg(vd) @ 0b1010111 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zvbc), eq_int(get_sew(), 64) : bool),
  VCLMULH_VX(vm, vs2, rs1, vd) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zvbc), eq_int(get_sew(), 64) : bool) <-> 0b001101 @ (vm : bitvector(1)) @ encdec_vreg(vs2) @ encdec_reg(rs1) @ 0b110 @ encdec_vreg(vd) @ 0b1010111 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zvbc), eq_int(get_sew(), 64) : bool),
  VGHSH_VV(vs2, vs1, vd) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zvkg), and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_int(get_sew(), 32), zvk_check_encdec(128, 4)) : bool) <-> 0b1011001 @ encdec_vreg(vs2) @ encdec_vreg(vs1) @ 0b010 @ encdec_vreg(vd) @ 0b1110111 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zvkg), and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_int(get_sew(), 32), zvk_check_encdec(128, 4)) : bool),
  VGMUL_VV(vs2, vd) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zvkg), and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_int(get_sew(), 32), zvk_check_encdec(128, 4)) : bool) <-> 0b1010001 @ encdec_vreg(vs2) @ 0b10001 @ 0b010 @ encdec_vreg(vd) @ 0b1110111 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zvkg), and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_int(get_sew(), 32), zvk_check_encdec(128, 4)) : bool),
  VAESDF(funct6, vs2, vd) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zvkned), and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_int(get_sew(), 32), $[overloaded { "name" = "&", "is_infix" = true }] and_bool(zvk_check_encdec(128, 4), $[overloaded { "name" = "|", "is_infix" = true }] or_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_anything(funct6, ZVK_VAESDF_VV), zvk_valid_reg_overlap(vs2, vd, get_lmul_pow())))) : bool) <-> encdec_vaesdf(funct6) @ 0b1 @ encdec_vreg(vs2) @ 0b00001 @ 0b010 @ encdec_vreg(vd) @ 0b1110111 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zvkned), and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_int(get_sew(), 32), $[overloaded { "name" = "&", "is_infix" = true }] and_bool(zvk_check_encdec(128, 4), $[overloaded { "name" = "|", "is_infix" = true }] or_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_anything(funct6, ZVK_VAESDF_VV), zvk_valid_reg_overlap(vs2, vd, get_lmul_pow())))) : bool),
  VAESDM(funct6, vs2, vd) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zvkned), and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_int(get_sew(), 32), $[overloaded { "name" = "&", "is_infix" = true }] and_bool(zvk_check_encdec(128, 4), $[overloaded { "name" = "|", "is_infix" = true }] or_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_anything(funct6, ZVK_VAESDM_VV), zvk_valid_reg_overlap(vs2, vd, get_lmul_pow())))) : bool) <-> encdec_vaesdm(funct6) @ 0b1 @ encdec_vreg(vs2) @ 0b00000 @ 0b010 @ encdec_vreg(vd) @ 0b1110111 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zvkned), and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_int(get_sew(), 32), $[overloaded { "name" = "&", "is_infix" = true }] and_bool(zvk_check_encdec(128, 4), $[overloaded { "name" = "|", "is_infix" = true }] or_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_anything(funct6, ZVK_VAESDM_VV), zvk_valid_reg_overlap(vs2, vd, get_lmul_pow())))) : bool),
  VAESEF(funct6, vs2, vd) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zvkned), and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_int(get_sew(), 32), $[overloaded { "name" = "&", "is_infix" = true }] and_bool(zvk_check_encdec(128, 4), $[overloaded { "name" = "|", "is_infix" = true }] or_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_anything(funct6, ZVK_VAESEF_VV), zvk_valid_reg_overlap(vs2, vd, get_lmul_pow())))) : bool) <-> encdec_vaesef(funct6) @ 0b1 @ encdec_vreg(vs2) @ 0b00011 @ 0b010 @ encdec_vreg(vd) @ 0b1110111 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zvkned), and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_int(get_sew(), 32), $[overloaded { "name" = "&", "is_infix" = true }] and_bool(zvk_check_encdec(128, 4), $[overloaded { "name" = "|", "is_infix" = true }] or_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_anything(funct6, ZVK_VAESEF_VV), zvk_valid_reg_overlap(vs2, vd, get_lmul_pow())))) : bool),
  VAESEM(funct6, vs2, vd) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zvkned), and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_int(get_sew(), 32), $[overloaded { "name" = "&", "is_infix" = true }] and_bool(zvk_check_encdec(128, 4), $[overloaded { "name" = "|", "is_infix" = true }] or_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_anything(funct6, ZVK_VAESEM_VV), zvk_valid_reg_overlap(vs2, vd, get_lmul_pow())))) : bool) <-> encdec_vaesem(funct6) @ 0b1 @ encdec_vreg(vs2) @ 0b00010 @ 0b010 @ encdec_vreg(vd) @ 0b1110111 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zvkned), and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_int(get_sew(), 32), $[overloaded { "name" = "&", "is_infix" = true }] and_bool(zvk_check_encdec(128, 4), $[overloaded { "name" = "|", "is_infix" = true }] or_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_anything(funct6, ZVK_VAESEM_VV), zvk_valid_reg_overlap(vs2, vd, get_lmul_pow())))) : bool),
  VAESKF1_VI(vs2, rnd, vd) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zvkned), and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_int(get_sew(), 32), zvk_check_encdec(128, 4)) : bool) <-> 0b1000101 @ encdec_vreg(vs2) @ (rnd : bitvector(5)) @ 0b010 @ encdec_vreg(vd) @ 0b1110111 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zvkned), and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_int(get_sew(), 32), zvk_check_encdec(128, 4)) : bool),
  VAESKF2_VI(vs2, rnd, vd) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zvkned), and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_int(get_sew(), 32), zvk_check_encdec(128, 4)) : bool) <-> 0b1010101 @ encdec_vreg(vs2) @ (rnd : bitvector(5)) @ 0b010 @ encdec_vreg(vd) @ 0b1110111 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zvkned), and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_int(get_sew(), 32), zvk_check_encdec(128, 4)) : bool),
  VAESZ_VS(vs2, vd) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zvkned), and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_int(get_sew(), 32), $[overloaded { "name" = "&", "is_infix" = true }] and_bool(zvk_check_encdec(128, 4), zvk_valid_reg_overlap(vs2, vd, get_lmul_pow()))) : bool) <-> 0b1010011 @ encdec_vreg(vs2) @ 0b00111 @ 0b010 @ encdec_vreg(vd) @ 0b1110111 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zvkned), and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_int(get_sew(), 32), $[overloaded { "name" = "&", "is_infix" = true }] and_bool(zvk_check_encdec(128, 4), zvk_valid_reg_overlap(vs2, vd, get_lmul_pow()))) : bool),
  VSM4K_VI(vs2, uimm, vd) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zvksed), and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_int(get_sew(), 32), zvk_check_encdec(128, 4)) : bool) <-> 0b1000011 @ encdec_vreg(vs2) @ (uimm : bitvector(5)) @ 0b010 @ encdec_vreg(vd) @ 0b1110111 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zvksed), and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_int(get_sew(), 32), zvk_check_encdec(128, 4)) : bool),
  ZVKSM4RTYPE(ZVK_VSM4R_VV, vs2, vd) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zvksed), and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_int(get_sew(), 32), zvk_check_encdec(128, 4)) : bool) <-> 0b1010001 @ encdec_vreg(vs2) @ 0b10000 @ 0b010 @ encdec_vreg(vd) @ 0b1110111 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zvksed), and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_int(get_sew(), 32), zvk_check_encdec(128, 4)) : bool),
  ZVKSM4RTYPE(ZVK_VSM4R_VS, vs2, vd) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zvksed), and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_int(get_sew(), 32), $[overloaded { "name" = "&", "is_infix" = true }] and_bool(zvk_check_encdec(128, 4), zvk_valid_reg_overlap(vs2, vd, get_lmul_pow()))) : bool) <-> 0b1010011 @ encdec_vreg(vs2) @ 0b10000 @ 0b010 @ encdec_vreg(vd) @ 0b1110111 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zvksed), and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_int(get_sew(), 32), $[overloaded { "name" = "&", "is_infix" = true }] and_bool(zvk_check_encdec(128, 4), zvk_valid_reg_overlap(vs2, vd, get_lmul_pow()))) : bool),
  VSHA2MS_VV(vs2, vs1, vd) if $[overloaded { "name" = "|", "is_infix" = true }] or_bool($[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zvknha), eq_int(get_sew(), 32) : bool), $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zvknhb), or_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_int(get_sew(), 32), eq_int(get_sew(), 64) : bool) : bool), zvknhab_check_encdec(vs2, vs1, vd))) <-> 0b1011011 @ encdec_vreg(vs2) @ encdec_vreg(vs1) @ 0b010 @ encdec_vreg(vd) @ 0b1110111 if $[overloaded { "name" = "|", "is_infix" = true }] or_bool($[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zvknha), eq_int(get_sew(), 32) : bool), $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zvknhb), or_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_int(get_sew(), 32), eq_int(get_sew(), 64) : bool) : bool), zvknhab_check_encdec(vs2, vs1, vd))),
  ZVKSHA2TYPE(funct6, vs2, vs1, vd) if $[overloaded { "name" = "|", "is_infix" = true }] or_bool($[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zvknha), eq_int(get_sew(), 32) : bool), $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zvknhb), or_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_int(get_sew(), 32), eq_int(get_sew(), 64) : bool) : bool), zvknhab_check_encdec(vs2, vs1, vd))) <-> encdec_vsha2(funct6) @ 0b1 @ encdec_vreg(vs2) @ encdec_vreg(vs1) @ 0b010 @ encdec_vreg(vd) @ 0b1110111 if $[overloaded { "name" = "|", "is_infix" = true }] or_bool($[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zvknha), eq_int(get_sew(), 32) : bool), $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zvknhb), or_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_int(get_sew(), 32), eq_int(get_sew(), 64) : bool) : bool), zvknhab_check_encdec(vs2, vs1, vd))),
  VSM3ME_VV(vs2, vs1, vd) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zvksh), and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_int(get_sew(), 32), $[overloaded { "name" = "&", "is_infix" = true }] and_bool(zvk_check_encdec(256, 8), zvk_valid_reg_overlap(vs2, vd, get_lmul_pow()))) : bool) <-> 0b1000001 @ encdec_vreg(vs2) @ encdec_vreg(vs1) @ 0b010 @ encdec_vreg(vd) @ 0b1110111 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zvksh), and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_int(get_sew(), 32), $[overloaded { "name" = "&", "is_infix" = true }] and_bool(zvk_check_encdec(256, 8), zvk_valid_reg_overlap(vs2, vd, get_lmul_pow()))) : bool),
  VSM3C_VI(vs2, uimm, vd) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zvksh), and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_int(get_sew(), 32), $[overloaded { "name" = "&", "is_infix" = true }] and_bool(zvk_check_encdec(256, 8), zvk_valid_reg_overlap(vs2, vd, get_lmul_pow()))) : bool) <-> 0b1010111 @ encdec_vreg(vs2) @ (uimm : bitvector(5)) @ 0b010 @ encdec_vreg(vd) @ 0b1110111 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zvksh), and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_int(get_sew(), 32), $[overloaded { "name" = "&", "is_infix" = true }] and_bool(zvk_check_encdec(256, 8), zvk_valid_reg_overlap(vs2, vd, get_lmul_pow()))) : bool),
  CSRReg(csr, rs1, rd, op) if currentlyEnabled(Ext_Zicsr) <-> (csr : bitvector(12)) @ encdec_reg(rs1) @ 0b0 @ encdec_csrop(op) @ encdec_reg(rd) @ 0b1110011 if currentlyEnabled(Ext_Zicsr),
  CSRImm(csr, imm, rd, op) if currentlyEnabled(Ext_Zicsr) <-> (csr : bitvector(12)) @ (imm : bitvector(5)) @ 0b1 @ encdec_csrop(op) @ encdec_reg(rd) @ 0b1110011 if currentlyEnabled(Ext_Zicsr),
  SINVAL_VMA(rs1, rs2) if currentlyEnabled(Ext_Svinval) <-> 0b0001011 @ encdec_reg(rs2) @ encdec_reg(rs1) @ 0b000 @ 0b00000 @ 0b1110011 if currentlyEnabled(Ext_Svinval),
  SFENCE_W_INVAL(()) if currentlyEnabled(Ext_Svinval) <-> 0b0001100 @ 0b00000 @ 0b00000 @ 0b000 @ 0b00000 @ 0b1110011 if currentlyEnabled(Ext_Svinval),
  SFENCE_INVAL_IR(()) if currentlyEnabled(Ext_Svinval) <-> 0b0001100 @ 0b00001 @ 0b00000 @ 0b000 @ 0b00000 @ 0b1110011 if currentlyEnabled(Ext_Svinval),
  WRS(op) if currentlyEnabled(Ext_Zawrs) <-> encdec_wrsop(op) @ 0b00000 @ 0b000 @ 0b00000 @ 0b1110011 if currentlyEnabled(Ext_Zawrs),
  ZICOND_RTYPE(rs2, rs1, rd, op) if currentlyEnabled(Ext_Zicond) <-> 0b0000111 @ encdec_reg(rs2) @ encdec_reg(rs1) @ encdec_zicondop(op) @ encdec_reg(rd) @ 0b0110011 if currentlyEnabled(Ext_Zicond),
  ZICBOM(cbop, rs1) if currentlyEnabled(Ext_Zicbom) <-> encdec_cbop(cbop) @ encdec_reg(rs1) @ 0b010 @ 0b00000 @ 0b0001111 if currentlyEnabled(Ext_Zicbom),
  ZICBOZ(rs1) if currentlyEnabled(Ext_Zicboz) <-> 0b000000000100 @ encdec_reg(rs1) @ 0b010 @ 0b00000 @ 0b0001111 if currentlyEnabled(Ext_Zicboz),
  FENCEI(()) if currentlyEnabled(Ext_Zifencei) <-> 0b000000000000 @ 0b00000 @ 0b001 @ 0b00000 @ 0b0001111 if currentlyEnabled(Ext_Zifencei),
  FCVT_BF16_S(rs1, rm, rd) if currentlyEnabled(Ext_Zfbfmin) <-> 0b01000 @ 0b10 @ 0b01000 @ encdec_freg(rs1) @ encdec_rounding_mode(rm) @ encdec_freg(rd) @ 0b1010011 if currentlyEnabled(Ext_Zfbfmin),
  FCVT_S_BF16(rs1, rm, rd) if currentlyEnabled(Ext_Zfbfmin) <-> 0b01000 @ 0b00 @ 0b00110 @ encdec_freg(rs1) @ encdec_rounding_mode(rm) @ encdec_freg(rd) @ 0b1010011 if currentlyEnabled(Ext_Zfbfmin),
  ZIMOP_MOP_R((mop_30 : bits(1)) @ (mop_27_26 : bits(2)) @ (mop_21_20 : bits(2)), rs1, rd) if currentlyEnabled(Ext_Zimop) <-> 0b1 @ (mop_30 : bits(1)) @ 0b00 @ (mop_27_26 : bits(2)) @ 0b0111 @ (mop_21_20 : bits(2)) @ encdec_reg(rs1) @ 0b100 @ encdec_reg(rd) @ 0b1110011 if currentlyEnabled(Ext_Zimop),
  ZIMOP_MOP_RR((mop_30 : bits(1)) @ (mop_27_26 : bits(2)), rs2, rs1, rd) if currentlyEnabled(Ext_Zimop) <-> 0b1 @ (mop_30 : bits(1)) @ 0b00 @ (mop_27_26 : bits(2)) @ 0b1 @ encdec_reg(rs2) @ encdec_reg(rs1) @ 0b100 @ encdec_reg(rd) @ 0b1110011 if currentlyEnabled(Ext_Zimop),
  ILLEGAL(s) <-> s
}

mapping encdec_compressed = {
  C_NTL(op) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zihintntl), currentlyEnabled(Ext_Zca)) <-> 0b100 @ 0b1 @ 0b00000 @ encdec_ntl(op) @ 0b10 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zihintntl), currentlyEnabled(Ext_Zca)),
  C_NOP((imm5 : bits(1)) @ (imm40 : bits(5))) if currentlyEnabled(Ext_Zca) <-> 0b000 @ (imm5 : bits(1)) @ 0b00000 @ (imm40 : bits(5)) @ 0b01 if currentlyEnabled(Ext_Zca),
  C_ADDI4SPN(rd, (nz96 : bits(4)) @ (nz54 : bits(2)) @ (nz3 : bits(1)) @ (nz2 : bits(1))) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "!=", "is_infix" = true }] neq_bits($[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(nz96, $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(nz54, $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(nz3, nz2))), 0b00000000), currentlyEnabled(Ext_Zca)) <-> 0b000 @ (nz54 : bits(2)) @ (nz96 : bits(4)) @ (nz2 : bits(1)) @ (nz3 : bits(1)) @ encdec_creg(rd) @ 0b00 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "!=", "is_infix" = true }] neq_bits($[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(nz96, $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(nz54, $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(nz3, nz2))), 0b00000000), currentlyEnabled(Ext_Zca)),
  C_LW((ui6 : bits(1)) @ (ui53 : bits(3)) @ (ui2 : bits(1)), rs1, rd) if currentlyEnabled(Ext_Zca) <-> 0b010 @ (ui53 : bits(3)) @ encdec_creg(rs1) @ (ui2 : bits(1)) @ (ui6 : bits(1)) @ encdec_creg(rd) @ 0b00 if currentlyEnabled(Ext_Zca),
  C_LD((ui76 : bits(2)) @ (ui53 : bits(3)), rs1, rd) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64), currentlyEnabled(Ext_Zca)) <-> 0b011 @ (ui53 : bits(3)) @ encdec_creg(rs1) @ (ui76 : bits(2)) @ encdec_creg(rd) @ 0b00 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64), currentlyEnabled(Ext_Zca)),
  C_SW((ui6 : bits(1)) @ (ui53 : bits(3)) @ (ui2 : bits(1)), rs1, rs2) if currentlyEnabled(Ext_Zca) <-> 0b110 @ (ui53 : bits(3)) @ encdec_creg(rs1) @ (ui2 : bits(1)) @ (ui6 : bits(1)) @ encdec_creg(rs2) @ 0b00 if currentlyEnabled(Ext_Zca),
  C_SD((ui76 : bits(2)) @ (ui53 : bits(3)), rs1, rs2) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64), currentlyEnabled(Ext_Zca)) <-> 0b111 @ (ui53 : bits(3)) @ encdec_creg(rs1) @ (ui76 : bits(2)) @ encdec_creg(rs2) @ 0b00 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64), currentlyEnabled(Ext_Zca)),
  C_ADDI((imm5 : bits(1)) @ (imm40 : bits(5)), rsd) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "!=", "is_infix" = true }] neq_anything(rsd, zreg), currentlyEnabled(Ext_Zca)) <-> 0b000 @ (imm5 : bits(1)) @ encdec_reg(rsd) @ (imm40 : bits(5)) @ 0b01 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "!=", "is_infix" = true }] neq_anything(rsd, zreg), currentlyEnabled(Ext_Zca)),
  C_JAL((i11 : bits(1)) @ (i10 : bits(1)) @ (i98 : bits(2)) @ (i7 : bits(1)) @ (i6 : bits(1)) @ (i5 : bits(1)) @ (i4 : bits(1)) @ (i31 : bits(3))) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 32), currentlyEnabled(Ext_Zca)) <-> 0b001 @ (i11 : bits(1)) @ (i4 : bits(1)) @ (i98 : bits(2)) @ (i10 : bits(1)) @ (i6 : bits(1)) @ (i7 : bits(1)) @ (i31 : bits(3)) @ (i5 : bits(1)) @ 0b01 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 32), currentlyEnabled(Ext_Zca)),
  C_ADDIW((imm5 : bits(1)) @ (imm40 : bits(5)), rsd) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "!=", "is_infix" = true }] neq_anything(rsd, zreg), $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64), currentlyEnabled(Ext_Zca))) <-> 0b001 @ (imm5 : bits(1)) @ encdec_reg(rsd) @ (imm40 : bits(5)) @ 0b01 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "!=", "is_infix" = true }] neq_anything(rsd, zreg), $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64), currentlyEnabled(Ext_Zca))),
  C_LI((imm5 : bits(1)) @ (imm40 : bits(5)), rd) if currentlyEnabled(Ext_Zca) <-> 0b010 @ (imm5 : bits(1)) @ encdec_reg(rd) @ (imm40 : bits(5)) @ 0b01 if currentlyEnabled(Ext_Zca),
  C_ADDI16SP((nzi9 : bits(1)) @ (nzi87 : bits(2)) @ (nzi6 : bits(1)) @ (nzi5 : bits(1)) @ (nzi4 : bits(1))) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "!=", "is_infix" = true }] neq_bits($[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(nzi9, $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(nzi87, $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(nzi6, $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(nzi5, nzi4)))), 0b000000), currentlyEnabled(Ext_Zca)) <-> 0b011 @ (nzi9 : bits(1)) @ 0b00010 @ (nzi4 : bits(1)) @ (nzi6 : bits(1)) @ (nzi87 : bits(2)) @ (nzi5 : bits(1)) @ 0b01 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "!=", "is_infix" = true }] neq_bits($[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(nzi9, $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(nzi87, $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(nzi6, $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(nzi5, nzi4)))), 0b000000), currentlyEnabled(Ext_Zca)),
  C_LUI((imm17 : bits(1)) @ (imm1612 : bits(5)), rd) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "!=", "is_infix" = true }] neq_anything(rd, sp), $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "!=", "is_infix" = true }] neq_bits($[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(imm17, imm1612), 0b000000), currentlyEnabled(Ext_Zca))) <-> 0b011 @ (imm17 : bits(1)) @ encdec_reg(rd) @ (imm1612 : bits(5)) @ 0b01 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "!=", "is_infix" = true }] neq_anything(rd, sp), $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "!=", "is_infix" = true }] neq_bits($[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(imm17, imm1612), 0b000000), currentlyEnabled(Ext_Zca))),
  C_SRLI((shamt5 : bits(1)) @ (shamt40 : bits(5)), rsd) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "|", "is_infix" = true }] or_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64), $[overloaded { "name" = "==", "is_infix" = true }] eq_bits(shamt5, 0b0)), currentlyEnabled(Ext_Zca)) <-> 0b100 @ (shamt5 : bits(1)) @ 0b00 @ encdec_creg(rsd) @ (shamt40 : bits(5)) @ 0b01 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "|", "is_infix" = true }] or_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64), $[overloaded { "name" = "==", "is_infix" = true }] eq_bits(shamt5, 0b0)), currentlyEnabled(Ext_Zca)),
  C_SRAI((shamt5 : bits(1)) @ (shamt40 : bits(5)), rsd) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "|", "is_infix" = true }] or_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64), $[overloaded { "name" = "==", "is_infix" = true }] eq_bits(shamt5, 0b0)), currentlyEnabled(Ext_Zca)) <-> 0b100 @ (shamt5 : bits(1)) @ 0b01 @ encdec_creg(rsd) @ (shamt40 : bits(5)) @ 0b01 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "|", "is_infix" = true }] or_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64), $[overloaded { "name" = "==", "is_infix" = true }] eq_bits(shamt5, 0b0)), currentlyEnabled(Ext_Zca)),
  C_ANDI((i5 : bits(1)) @ (i40 : bits(5)), rsd) if currentlyEnabled(Ext_Zca) <-> 0b100 @ (i5 : bits(1)) @ 0b10 @ encdec_creg(rsd) @ (i40 : bits(5)) @ 0b01 if currentlyEnabled(Ext_Zca),
  C_SUB(rsd, rs2) if currentlyEnabled(Ext_Zca) <-> 0b100 @ 0b0 @ 0b11 @ encdec_creg(rsd) @ 0b00 @ encdec_creg(rs2) @ 0b01 if currentlyEnabled(Ext_Zca),
  C_XOR(rsd, rs2) if currentlyEnabled(Ext_Zca) <-> 0b100 @ 0b0 @ 0b11 @ encdec_creg(rsd) @ 0b01 @ encdec_creg(rs2) @ 0b01 if currentlyEnabled(Ext_Zca),
  C_OR(rsd, rs2) if currentlyEnabled(Ext_Zca) <-> 0b100 @ 0b0 @ 0b11 @ encdec_creg(rsd) @ 0b10 @ encdec_creg(rs2) @ 0b01 if currentlyEnabled(Ext_Zca),
  C_AND(rsd, rs2) if currentlyEnabled(Ext_Zca) <-> 0b100 @ 0b0 @ 0b11 @ encdec_creg(rsd) @ 0b11 @ encdec_creg(rs2) @ 0b01 if currentlyEnabled(Ext_Zca),
  C_SUBW(rsd, rs2) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64), currentlyEnabled(Ext_Zca)) <-> 0b100 @ 0b1 @ 0b11 @ encdec_creg(rsd) @ 0b00 @ encdec_creg(rs2) @ 0b01 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64), currentlyEnabled(Ext_Zca)),
  C_ADDW(rsd, rs2) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64), currentlyEnabled(Ext_Zca)) <-> 0b100 @ 0b1 @ 0b11 @ encdec_creg(rsd) @ 0b01 @ encdec_creg(rs2) @ 0b01 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64), currentlyEnabled(Ext_Zca)),
  C_J((i11 : bits(1)) @ (i10 : bits(1)) @ (i98 : bits(2)) @ (i7 : bits(1)) @ (i6 : bits(1)) @ (i5 : bits(1)) @ (i4 : bits(1)) @ (i31 : bits(3))) if currentlyEnabled(Ext_Zca) <-> 0b101 @ (i11 : bits(1)) @ (i4 : bits(1)) @ (i98 : bits(2)) @ (i10 : bits(1)) @ (i6 : bits(1)) @ (i7 : bits(1)) @ (i31 : bits(3)) @ (i5 : bits(1)) @ 0b01 if currentlyEnabled(Ext_Zca),
  C_BEQZ((i8 : bits(1)) @ (i76 : bits(2)) @ (i5 : bits(1)) @ (i43 : bits(2)) @ (i21 : bits(2)), rs) if currentlyEnabled(Ext_Zca) <-> 0b110 @ (i8 : bits(1)) @ (i43 : bits(2)) @ encdec_creg(rs) @ (i76 : bits(2)) @ (i21 : bits(2)) @ (i5 : bits(1)) @ 0b01 if currentlyEnabled(Ext_Zca),
  C_BNEZ((i8 : bits(1)) @ (i76 : bits(2)) @ (i5 : bits(1)) @ (i43 : bits(2)) @ (i21 : bits(2)), rs) if currentlyEnabled(Ext_Zca) <-> 0b111 @ (i8 : bits(1)) @ (i43 : bits(2)) @ encdec_creg(rs) @ (i76 : bits(2)) @ (i21 : bits(2)) @ (i5 : bits(1)) @ 0b01 if currentlyEnabled(Ext_Zca),
  C_SLLI((shamt5 : bits(1)) @ (shamt40 : bits(5)), rsd) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "|", "is_infix" = true }] or_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64), $[overloaded { "name" = "==", "is_infix" = true }] eq_bits(shamt5, 0b0)), currentlyEnabled(Ext_Zca)) <-> 0b000 @ (shamt5 : bits(1)) @ encdec_reg(rsd) @ (shamt40 : bits(5)) @ 0b10 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "|", "is_infix" = true }] or_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64), $[overloaded { "name" = "==", "is_infix" = true }] eq_bits(shamt5, 0b0)), currentlyEnabled(Ext_Zca)),
  C_LWSP((ui76 : bits(2)) @ (ui5 : bits(1)) @ (ui42 : bits(3)), rd) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "!=", "is_infix" = true }] neq_anything(rd, zreg), currentlyEnabled(Ext_Zca)) <-> 0b010 @ (ui5 : bits(1)) @ encdec_reg(rd) @ (ui42 : bits(3)) @ (ui76 : bits(2)) @ 0b10 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "!=", "is_infix" = true }] neq_anything(rd, zreg), currentlyEnabled(Ext_Zca)),
  C_LDSP((ui86 : bits(3)) @ (ui5 : bits(1)) @ (ui43 : bits(2)), rd) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "!=", "is_infix" = true }] neq_anything(rd, zreg), $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64), currentlyEnabled(Ext_Zca))) <-> 0b011 @ (ui5 : bits(1)) @ encdec_reg(rd) @ (ui43 : bits(2)) @ (ui86 : bits(3)) @ 0b10 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "!=", "is_infix" = true }] neq_anything(rd, zreg), $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64), currentlyEnabled(Ext_Zca))),
  C_SWSP((ui76 : bits(2)) @ (ui52 : bits(4)), rs2) if currentlyEnabled(Ext_Zca) <-> 0b110 @ (ui52 : bits(4)) @ (ui76 : bits(2)) @ encdec_reg(rs2) @ 0b10 if currentlyEnabled(Ext_Zca),
  C_SDSP((ui86 : bits(3)) @ (ui53 : bits(3)), rs2) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64), currentlyEnabled(Ext_Zca)) <-> 0b111 @ (ui53 : bits(3)) @ (ui86 : bits(3)) @ encdec_reg(rs2) @ 0b10 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64), currentlyEnabled(Ext_Zca)),
  C_JR(rs1) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "!=", "is_infix" = true }] neq_anything(rs1, zreg), currentlyEnabled(Ext_Zca)) <-> 0b100 @ 0b0 @ encdec_reg(rs1) @ 0b00000 @ 0b10 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "!=", "is_infix" = true }] neq_anything(rs1, zreg), currentlyEnabled(Ext_Zca)),
  C_JALR(rs1) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "!=", "is_infix" = true }] neq_anything(rs1, zreg), currentlyEnabled(Ext_Zca)) <-> 0b100 @ 0b1 @ encdec_reg(rs1) @ 0b00000 @ 0b10 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "!=", "is_infix" = true }] neq_anything(rs1, zreg), currentlyEnabled(Ext_Zca)),
  C_MV(rd, rs2) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "!=", "is_infix" = true }] neq_anything(rs2, zreg), currentlyEnabled(Ext_Zca)) <-> 0b100 @ 0b0 @ encdec_reg(rd) @ encdec_reg(rs2) @ 0b10 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "!=", "is_infix" = true }] neq_anything(rs2, zreg), currentlyEnabled(Ext_Zca)),
  C_EBREAK(()) if currentlyEnabled(Ext_Zca) <-> 0b100 @ 0b1 @ 0b00000 @ 0b00000 @ 0b10 if currentlyEnabled(Ext_Zca),
  C_ADD(rsd, rs2) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "!=", "is_infix" = true }] neq_anything(rs2, zreg), currentlyEnabled(Ext_Zca)) <-> 0b100 @ 0b1 @ encdec_reg(rsd) @ encdec_reg(rs2) @ 0b10 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "!=", "is_infix" = true }] neq_anything(rs2, zreg), currentlyEnabled(Ext_Zca)),
  C_LBU((uimm1 : bits(1)) @ (uimm0 : bits(1)), rdc, rsc1) if currentlyEnabled(Ext_Zcb) <-> 0b100 @ 0b000 @ encdec_creg(rsc1) @ (uimm0 : bits(1)) @ (uimm1 : bits(1)) @ encdec_creg(rdc) @ 0b00 if currentlyEnabled(Ext_Zcb),
  C_LHU((uimm1 : bits(1)) @ 0b0, rdc, rsc1) if currentlyEnabled(Ext_Zcb) <-> 0b100 @ 0b001 @ encdec_creg(rsc1) @ 0b0 @ (uimm1 : bits(1)) @ encdec_creg(rdc) @ 0b00 if currentlyEnabled(Ext_Zcb),
  C_LH((uimm1 : bits(1)) @ 0b0, rdc, rsc1) if currentlyEnabled(Ext_Zcb) <-> 0b100 @ 0b001 @ encdec_creg(rsc1) @ 0b1 @ (uimm1 : bits(1)) @ encdec_creg(rdc) @ 0b00 if currentlyEnabled(Ext_Zcb),
  C_SB((uimm1 : bits(1)) @ (uimm0 : bits(1)), rsc1, rsc2) if currentlyEnabled(Ext_Zcb) <-> 0b100 @ 0b010 @ encdec_creg(rsc1) @ (uimm0 : bits(1)) @ (uimm1 : bits(1)) @ encdec_creg(rsc2) @ 0b00 if currentlyEnabled(Ext_Zcb),
  C_SH((uimm1 : bits(1)) @ 0b0, rsc1, rsc2) if currentlyEnabled(Ext_Zcb) <-> 0b100 @ 0b011 @ encdec_creg(rsc1) @ 0b0 @ (uimm1 : bits(1)) @ encdec_creg(rsc2) @ 0b00 if currentlyEnabled(Ext_Zcb),
  C_ZEXT_B(rsdc) if currentlyEnabled(Ext_Zcb) <-> 0b100 @ 0b111 @ encdec_creg(rsdc) @ 0b11 @ 0b000 @ 0b01 if currentlyEnabled(Ext_Zcb),
  C_SEXT_B(rsdc) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zcb), currentlyEnabled(Ext_Zbb)) <-> 0b100 @ 0b111 @ encdec_creg(rsdc) @ 0b11 @ 0b001 @ 0b01 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zcb), currentlyEnabled(Ext_Zbb)),
  C_ZEXT_H(rsdc) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zcb), currentlyEnabled(Ext_Zbb)) <-> 0b100 @ 0b111 @ encdec_creg(rsdc) @ 0b11 @ 0b010 @ 0b01 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zcb), currentlyEnabled(Ext_Zbb)),
  C_SEXT_H(rsdc) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zcb), currentlyEnabled(Ext_Zbb)) <-> 0b100 @ 0b111 @ encdec_creg(rsdc) @ 0b11 @ 0b011 @ 0b01 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zcb), currentlyEnabled(Ext_Zbb)),
  C_ZEXT_W(rsdc) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zcb), $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zba), $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64))) <-> 0b100 @ 0b111 @ encdec_creg(rsdc) @ 0b11 @ 0b100 @ 0b01 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zcb), $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zba), $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64))),
  C_NOT(rsdc) if currentlyEnabled(Ext_Zcb) <-> 0b100 @ 0b111 @ encdec_creg(rsdc) @ 0b11 @ 0b101 @ 0b01 if currentlyEnabled(Ext_Zcb),
  C_MUL(rsdc, rsc2) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zcb), $[overloaded { "name" = "|", "is_infix" = true }] or_bool(currentlyEnabled(Ext_M), currentlyEnabled(Ext_Zmmul))) <-> 0b100 @ 0b111 @ encdec_creg(rsdc) @ 0b10 @ encdec_creg(rsc2) @ 0b01 if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zcb), $[overloaded { "name" = "|", "is_infix" = true }] or_bool(currentlyEnabled(Ext_M), currentlyEnabled(Ext_Zmmul))),
  C_FLWSP((ui76 : bits(2)) @ (ui5 : bits(1)) @ (ui42 : bits(3)), rd) if currentlyEnabled(Ext_Zcf) <-> 0b011 @ (ui5 : bits(1)) @ encdec_freg(rd) @ (ui42 : bits(3)) @ (ui76 : bits(2)) @ 0b10 if currentlyEnabled(Ext_Zcf),
  C_FSWSP((ui76 : bits(2)) @ (ui52 : bits(4)), rs2) if currentlyEnabled(Ext_Zcf) <-> 0b111 @ (ui52 : bits(4)) @ (ui76 : bits(2)) @ encdec_freg(rs2) @ 0b10 if currentlyEnabled(Ext_Zcf),
  C_FLW((ui6 : bits(1)) @ (ui53 : bits(3)) @ (ui2 : bits(1)), rs1, rd) if currentlyEnabled(Ext_Zcf) <-> 0b011 @ (ui53 : bits(3)) @ encdec_creg(rs1) @ (ui2 : bits(1)) @ (ui6 : bits(1)) @ encdec_cfreg(rd) @ 0b00 if currentlyEnabled(Ext_Zcf),
  C_FSW((ui6 : bits(1)) @ (ui53 : bits(3)) @ (ui2 : bits(1)), rs1, rs2) if currentlyEnabled(Ext_Zcf) <-> 0b111 @ (ui53 : bits(3)) @ encdec_creg(rs1) @ (ui2 : bits(1)) @ (ui6 : bits(1)) @ encdec_cfreg(rs2) @ 0b00 if currentlyEnabled(Ext_Zcf),
  C_FLDSP((ui86 : bits(3)) @ (ui5 : bits(1)) @ (ui43 : bits(2)), rd) if currentlyEnabled(Ext_Zcd) <-> 0b001 @ (ui5 : bits(1)) @ encdec_freg(rd) @ (ui43 : bits(2)) @ (ui86 : bits(3)) @ 0b10 if currentlyEnabled(Ext_Zcd),
  C_FSDSP((ui86 : bits(3)) @ (ui53 : bits(3)), rs2) if currentlyEnabled(Ext_Zcd) <-> 0b101 @ (ui53 : bits(3)) @ (ui86 : bits(3)) @ encdec_freg(rs2) @ 0b10 if currentlyEnabled(Ext_Zcd),
  C_FLD((ui76 : bits(2)) @ (ui53 : bits(3)), rs1, rd) if currentlyEnabled(Ext_Zcd) <-> 0b001 @ (ui53 : bits(3)) @ encdec_creg(rs1) @ (ui76 : bits(2)) @ encdec_cfreg(rd) @ 0b00 if currentlyEnabled(Ext_Zcd),
  C_FSD((ui76 : bits(2)) @ (ui53 : bits(3)), rs1, rs2) if currentlyEnabled(Ext_Zcd) <-> 0b101 @ (ui53 : bits(3)) @ encdec_creg(rs1) @ (ui76 : bits(2)) @ encdec_cfreg(rs2) @ 0b00 if currentlyEnabled(Ext_Zcd),
  ZCMOP(mop) if currentlyEnabled(Ext_Zcmop) <-> 0b01100 @ (mop : bits(3)) @ 0b100000 @ 0b01 if currentlyEnabled(Ext_Zcmop),
  C_ILLEGAL(s) <-> s
}

$[complete]
function execute ZICBOP((cbop, rs1, offset)) = RETIRE_SUCCESS
and execute NTL(_) = RETIRE_SUCCESS
and execute C_NTL(_) = RETIRE_SUCCESS
and execute PAUSE(()) = RETIRE_SUCCESS
and $[split "op"]
execute UTYPE((imm, rd, op)) = {
    let off : xlenbits = sign_extend(sizeof(xlen), $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(imm, 0x000));
    $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(rd, $[complete] match op {
      LUI => off,
      AUIPC => $[overloaded { "name" = "+", "is_infix" = true }] add_bits(get_arch_pc(), off)
    });
    RETIRE_SUCCESS
}
and execute JAL((imm, rd)) = {
    let link_address = get_next_pc();
    $[complete] match jump_to($[overloaded { "name" = "+", "is_infix" = true }] add_bits(PC, sign_extend(sizeof(xlen), imm))) {
      Retire_Success(()) => {
          $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(rd, link_address);
          Retire_Success()
      },
      failure => failure
    }
}
and $[split "op"]
execute BTYPE((imm, rs2, rs1, op)) = {
    let taken : bool = $[complete] match op {
      BEQ => $[overloaded { "name" = "==", "is_infix" = true }] eq_bits($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1), $[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs2)),
      BNE => $[overloaded { "name" = "!=", "is_infix" = true }] neq_bits($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1), $[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs2)),
      BLT => operator <_s($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1), $[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs2)),
      BGE => operator >=_s($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1), $[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs2)),
      BLTU => operator <_u($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1), $[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs2)),
      BGEU => operator >=_u($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1), $[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs2))
    };
    if taken then
      jump_to($[overloaded { "name" = "+", "is_infix" = true }] add_bits(PC, sign_extend(sizeof(xlen), imm)))
    else
      RETIRE_SUCCESS
}
and $[split "op"]
execute ITYPE((imm, rs1, rd, op)) = {
    let immext : xlenbits = sign_extend(sizeof(xlen), imm);
    $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(rd, $[complete] match op {
      ADDI => $[overloaded { "name" = "+", "is_infix" = true }] add_bits($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1), immext),
      SLTI => zero_extend(sizeof(xlen), bool_to_bits(operator <_s($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1), immext))),
      SLTIU => zero_extend(sizeof(xlen), bool_to_bits(operator <_u($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1), immext))),
      ANDI => $[overloaded { "name" = "&", "is_infix" = true }] and_vec($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1), immext),
      ORI => $[overloaded { "name" = "|", "is_infix" = true }] or_vec($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1), immext),
      XORI => $[overloaded { "name" = "^", "is_infix" = true }] xor_vec($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1), immext)
    });
    RETIRE_SUCCESS
}
and $[split "op"]
execute SHIFTIOP((shamt, rs1, rd, op)) = {
    let shamt = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(shamt, $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(log2_xlen, 1), 0);
    $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(rd, $[complete] match op {
      SLLI => $[overloaded { "name" = "<<", "is_infix" = true }] shift_bits_left($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1), shamt),
      SRLI => $[overloaded { "name" = ">>", "is_infix" = true }] shift_bits_right($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1), shamt),
      SRAI => shift_bits_right_arith($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1), shamt)
    });
    RETIRE_SUCCESS
}
and $[split "op"]
execute RTYPE((rs2, rs1, rd, op)) = {
    $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(rd, $[complete] match op {
      ADD => $[overloaded { "name" = "+", "is_infix" = true }] add_bits($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1), $[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs2)),
      SLT => zero_extend(sizeof(xlen), bool_to_bits(operator <_s($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1), $[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs2)))),
      SLTU => zero_extend(sizeof(xlen), bool_to_bits(operator <_u($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1), $[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs2)))),
      AND => $[overloaded { "name" = "&", "is_infix" = true }] and_vec($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1), $[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs2)),
      OR => $[overloaded { "name" = "|", "is_infix" = true }] or_vec($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1), $[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs2)),
      XOR => $[overloaded { "name" = "^", "is_infix" = true }] xor_vec($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1), $[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs2)),
      SLL => $[overloaded { "name" = "<<", "is_infix" = true }] shift_bits_left($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1), $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs2), $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(log2_xlen, 1), 0)),
      SRL => $[overloaded { "name" = ">>", "is_infix" = true }] shift_bits_right($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1), $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs2), $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(log2_xlen, 1), 0)),
      SUB => $[overloaded { "name" = "-", "is_infix" = true }] sub_vec($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1), $[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs2)),
      SRA => shift_bits_right_arith($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1), $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs2), $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(log2_xlen, 1), 0))
    });
    RETIRE_SUCCESS
}
and execute LOAD((imm, rs1, rd, is_unsigned, width)) = {
    let offset : xlenbits = sign_extend(sizeof(xlen), imm);
    assert($[overloaded { "name" = "<=", "is_infix" = true }] lteq_int(width, xlen_bytes), "./extensions/I/base_insts.sail:287.28-287.29");
    $[complete] match vmem_read(rs1, offset, width, Read(Data), false, false, false) {
      Ok(data) => {
          $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(rd, extend_value(is_unsigned, data));
          RETIRE_SUCCESS
      },
      Err(e) => e
    }
}
and execute STORE((imm, rs2, rs1, width)) = {
    let offset : xlenbits = sign_extend(sizeof(xlen), imm);
    assert($[overloaded { "name" = "<=", "is_infix" = true }] lteq_int(width, xlen_bytes), "./extensions/I/base_insts.sail:317.28-317.29");
    let data = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs2), $[overloaded { "name" = "-", "is_infix" = true }] sub_atom($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(width, 8), 1), 0);
    $[complete] match vmem_write(rs1, offset, width, data, Write(Data), false, false, false) {
      Ok(_) => RETIRE_SUCCESS,
      Err(e) => e
    }
}
and execute ADDIW((imm, rs1, rd)) = {
    let result = $[overloaded { "name" = "+", "is_infix" = true }] add_bits($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1), sign_extend(sizeof(xlen), imm));
    $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(rd, sign_extend(sizeof(xlen), $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(result, 31, 0)));
    RETIRE_SUCCESS
}
and $[split "op"]
execute RTYPEW((rs2, rs1, rd, op)) = {
    let rs1_val = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1), 31, 0);
    let rs2_val = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs2), 31, 0);
    let result : bits(32) = $[complete] match op {
      ADDW => $[overloaded { "name" = "+", "is_infix" = true }] add_bits(rs1_val, rs2_val),
      SUBW => $[overloaded { "name" = "-", "is_infix" = true }] sub_vec(rs1_val, rs2_val),
      SLLW => $[overloaded { "name" = "<<", "is_infix" = true }] shift_bits_left(rs1_val, $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(rs2_val, 4, 0)),
      SRLW => $[overloaded { "name" = ">>", "is_infix" = true }] shift_bits_right(rs1_val, $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(rs2_val, 4, 0)),
      SRAW => shift_bits_right_arith(rs1_val, $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(rs2_val, 4, 0))
    };
    $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(rd, sign_extend(sizeof(xlen), result));
    RETIRE_SUCCESS
}
and $[split "op"]
execute SHIFTIWOP((shamt, rs1, rd, op)) = {
    let rs1_val = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1), 31, 0);
    let result : bits(32) = $[complete] match op {
      SLLIW => $[overloaded { "name" = "<<", "is_infix" = true }] shift_bits_left(rs1_val, shamt),
      SRLIW => $[overloaded { "name" = ">>", "is_infix" = true }] shift_bits_right(rs1_val, shamt),
      SRAIW => shift_bits_right_arith(rs1_val, shamt)
    };
    $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(rd, sign_extend(sizeof(xlen), result));
    RETIRE_SUCCESS
}
and execute FENCE((pred, succ)) = {
    let fiom = is_fiom_active();
    let pred = effective_fence_set(pred, fiom);
    let succ = effective_fence_set(succ, fiom);
    $[complete] match (pred, succ) {
      ((_ : bits(2) @ 0b11), (_ : bits(2) @ 0b11)) => sail_barrier(Barrier_RISCV_rw_rw),
      ((_ : bits(2) @ 0b10), (_ : bits(2) @ 0b11)) => sail_barrier(Barrier_RISCV_r_rw),
      ((_ : bits(2) @ 0b10), (_ : bits(2) @ 0b10)) => sail_barrier(Barrier_RISCV_r_r),
      ((_ : bits(2) @ 0b11), (_ : bits(2) @ 0b01)) => sail_barrier(Barrier_RISCV_rw_w),
      ((_ : bits(2) @ 0b01), (_ : bits(2) @ 0b01)) => sail_barrier(Barrier_RISCV_w_w),
      ((_ : bits(2) @ 0b01), (_ : bits(2) @ 0b11)) => sail_barrier(Barrier_RISCV_w_rw),
      ((_ : bits(2) @ 0b11), (_ : bits(2) @ 0b10)) => sail_barrier(Barrier_RISCV_rw_r),
      ((_ : bits(2) @ 0b10), (_ : bits(2) @ 0b01)) => sail_barrier(Barrier_RISCV_r_w),
      ((_ : bits(2) @ 0b01), (_ : bits(2) @ 0b10)) => sail_barrier(Barrier_RISCV_w_r),
      (_ : bits(4), (_ : bits(2) @ 0b00)) => (),
      ((_ : bits(2) @ 0b00), _ : bits(4)) => (),
      _ => {
          print("FIXME: unsupported fence");
          ()
      }
    };
    RETIRE_SUCCESS
}
and execute FENCE_TSO(()) = {
    sail_barrier(Barrier_RISCV_tso);
    RETIRE_SUCCESS
}
and execute ECALL(()) = {
    let trap : ExceptionType = $[complete] match cur_privilege {
      User => E_U_EnvCall(),
      Supervisor => E_S_EnvCall(),
      Machine => E_M_EnvCall(),
      VirtualUser => internal_error("./extensions/I/base_insts.sail", 522, "Hypervisor extension not supported"),
      VirtualSupervisor => internal_error("./extensions/I/base_insts.sail", 523, "Hypervisor extension not supported")
    };
    let t : sync_exception = struct sync_exception { trap = trap, excinfo = None() : option(xlenbits), ext = None() };
    Trap((cur_privilege, CTL_TRAP(t), PC))
}
and execute MRET(()) = {
    if $[overloaded { "name" = "!=", "is_infix" = true }] neq_anything(cur_privilege, Machine) then
      Illegal_Instruction()
    else
      if not(ext_check_xret_priv(Machine)) then Ext_XRET_Priv_Failure() else {
          set_next_pc(exception_handler(cur_privilege, CTL_MRET(), PC));
          RETIRE_SUCCESS
      }
}
and execute SRET(()) = {
    let sret_illegal : bool = $[complete] match cur_privilege {
      User => true,
      Supervisor => $[overloaded { "name" = "|", "is_infix" = true }] or_bool(not(currentlyEnabled(Ext_S)), $[overloaded { "name" = "==", "is_infix" = true }] eq_bits(_get_Mstatus_TSR(mstatus), 0b1)),
      Machine => not(currentlyEnabled(Ext_S)),
      VirtualUser => internal_error("./extensions/I/base_insts.sail", 565, "Hypervisor extension not supported"),
      VirtualSupervisor => internal_error("./extensions/I/base_insts.sail", 566, "Hypervisor extension not supported")
    };
    if sret_illegal then Illegal_Instruction() else
      if not(ext_check_xret_priv(Supervisor)) then Ext_XRET_Priv_Failure()
      else {
          set_next_pc(exception_handler(cur_privilege, CTL_SRET(), PC));
          RETIRE_SUCCESS
      }
}
and execute EBREAK(()) = Memory_Exception((Virtaddr(PC), E_Breakpoint()))
and execute WFI(()) = $[complete] match cur_privilege {
  Machine => Enter_Wait(WAIT_WFI),
  Supervisor => if $[overloaded { "name" = "==", "is_infix" = true }] eq_bits(_get_Mstatus_TW(mstatus), 0b1) then
    Illegal_Instruction()
  else
    Enter_Wait(WAIT_WFI),
  User => Illegal_Instruction(),
  VirtualUser => internal_error("./extensions/I/base_insts.sail", 604, "Hypervisor extension not supported"),
  VirtualSupervisor => internal_error("./extensions/I/base_insts.sail", 605, "Hypervisor extension not supported")
}
and execute SFENCE_VMA((rs1, rs2)) = {
    let addr = if $[overloaded { "name" = "!=", "is_infix" = true }] neq_anything(rs1, zreg) then
      Some($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1))
    else
      None();
    let asid = if $[overloaded { "name" = "!=", "is_infix" = true }] neq_anything(rs2, zreg) then
      Some($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs2), $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(asidlen, 1), 0))
    else
      None();
    $[complete] match cur_privilege {
      User => Illegal_Instruction(),
      Supervisor => $[complete] match _get_Mstatus_TVM(mstatus) {
        0b1 => Illegal_Instruction(),
        _ : bitvector(1) => {
            flush_TLB(asid, addr);
            RETIRE_SUCCESS
        }
      },
      Machine => {
          flush_TLB(asid, addr);
          RETIRE_SUCCESS
      },
      VirtualUser => internal_error("./extensions/I/base_insts.sail", 630, "Hypervisor extension not supported"),
      VirtualSupervisor => internal_error("./extensions/I/base_insts.sail", 631, "Hypervisor extension not supported")
    }
}
and execute FENCE_RESERVED((fm, pred, succ, rs, rd)) = RETIRE_SUCCESS
and execute FENCEI_RESERVED((imm, rs, rd)) = RETIRE_SUCCESS
and execute JALR((imm, rs1, rd)) = {
    let link_address = get_next_pc();
    let target = $[overloaded { "name" = "+", "is_infix" = true }] add_bits($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1), sign_extend(sizeof(xlen), imm));
    $[complete] match jump_to($[overloaded { "name" = "vector_update", "is_infix" = false }] bitvector_update(target, 0, bitzero)) {
      Retire_Success(()) => {
          $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(rd, link_address);
          Retire_Success()
      },
      failure => failure
    }
}
and $[split "op"]
execute AMO((op, aq, rl, rs2, rs1, width, rd)) = {
    let 'width = width;
    assert($[overloaded { "name" = "<=", "is_infix" = true }] lteq_int(width, $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(xlen_bytes, 2)), "./extensions/A/zaamo_insts.sail:62.32-62.33");
    $[complete] match ext_data_get_addr(rs1, zeros(sizeof(xlen)), ReadWrite((Data, Data)), width) {
      Ext_DataAddr_Error(e) => Ext_DataAddr_Check_Failure(e),
      Ext_DataAddr_OK(vaddr) => {
          if not($[overloaded { "name" = "is_aligned_addr", "is_infix" = false }] is_aligned_vaddr(vaddr, width)) then
            Memory_Exception((vaddr, E_SAMO_Addr_Align()))
          else
            $[complete] match translateAddr(vaddr, ReadWrite((Data, Data))) {
              Err((e, _)) => Memory_Exception((vaddr, e)),
              Ok((addr, _)) => {
                  let rs2_val : bits('width * 8) = if $[overloaded { "name" = "<=", "is_infix" = true }] lteq_int(width, xlen_bytes) then
                    trunc(mult_atom($[overloaded { "name" = "__size", "is_infix" = false }] __id(width), 8), $[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs2))
                  else
                    trunc(mult_atom($[overloaded { "name" = "__size", "is_infix" = false }] __id(width), 8), $[overloaded { "name" = "X_pair", "is_infix" = false }] rX_pair_bits(rs2));
                  $[complete] match mem_write_ea(addr, width, $[overloaded { "name" = "&", "is_infix" = true }] and_bool(aq, rl), rl, true) {
                    Err(e) => Memory_Exception((vaddr, e)),
                    Ok(_) => {
                        $[complete] match mem_read(ReadWrite((Data, Data)), addr, width, aq, $[overloaded { "name" = "&", "is_infix" = true }] and_bool(aq, rl), true) {
                          Err(e) => Memory_Exception((vaddr, e)),
                          Ok(loaded) => {
                              let result : bits('width * 8) = $[complete] match op {
                                AMOSWAP => rs2_val,
                                AMOADD => $[overloaded { "name" = "+", "is_infix" = true }] add_bits(rs2_val, loaded),
                                AMOXOR => $[overloaded { "name" = "^", "is_infix" = true }] xor_vec(rs2_val, loaded),
                                AMOAND => $[overloaded { "name" = "&", "is_infix" = true }] and_vec(rs2_val, loaded),
                                AMOOR => $[overloaded { "name" = "|", "is_infix" = true }] or_vec(rs2_val, loaded),
                                AMOMIN => if operator <_s(rs2_val, loaded) then
                                  rs2_val
                                else
                                  loaded,
                                AMOMAX => if operator >_s(rs2_val, loaded) then
                                  rs2_val
                                else
                                  loaded,
                                AMOMINU => if operator <_u(rs2_val, loaded) then
                                  rs2_val
                                else
                                  loaded,
                                AMOMAXU => if operator >_u(rs2_val, loaded) then
                                  rs2_val
                                else
                                  loaded,
                                AMOCAS => rs2_val
                              };
                              if $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_anything(op, AMOCAS), $[overloaded { "name" = "!=", "is_infix" = true }] neq_bits(loaded, if $[overloaded { "name" = "<=", "is_infix" = true }] lteq_int(width, xlen_bytes) then
                                trunc(mult_atom(8, $[overloaded { "name" = "__size", "is_infix" = false }] __id(width)), $[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rd))
                              else
                                trunc(mult_atom(8, $[overloaded { "name" = "__size", "is_infix" = false }] __id(width)), $[overloaded { "name" = "X_pair", "is_infix" = false }] rX_pair_bits(rd)))) then {
                                  if $[overloaded { "name" = "<=", "is_infix" = true }] lteq_int(width, xlen_bytes) then
                                    $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(rd, sign_extend(sizeof(xlen), loaded))
                                  else
                                    $[overloaded { "name" = "X_pair", "is_infix" = false }] $[setter] wX_pair_bits(rd, sign_extend(mult_atom(sizeof(xlen), 2), loaded));
                                  RETIRE_SUCCESS
                              } else {
                                  $[complete] match mem_write_value(addr, width, sign_extend(mult_atom(8, $[overloaded { "name" = "__size", "is_infix" = false }] __id(width)), result), $[overloaded { "name" = "&", "is_infix" = true }] and_bool(aq, rl), rl, true) {
                                    Ok(true) => {
                                        if $[overloaded { "name" = "<=", "is_infix" = true }] lteq_int(width, xlen_bytes) then
                                          $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(rd, sign_extend(sizeof(xlen), loaded))
                                        else
                                          $[overloaded { "name" = "X_pair", "is_infix" = false }] $[setter] wX_pair_bits(rd, sign_extend(mult_atom(sizeof(xlen), 2), loaded));
                                        RETIRE_SUCCESS
                                    },
                                    Ok(false) => {
                                        internal_error("./extensions/A/zaamo_insts.sail", 114, "AMO got false from mem_write_value")
                                    },
                                    Err(e) => Memory_Exception((vaddr, e))
                                  }
                              }
                          }
                        }
                    }
                  }
              }
            }
      }
    }
}
and execute LOADRES((aq, rl, rs1, width, rd)) = {
    assert($[overloaded { "name" = "<=", "is_infix" = true }] lteq_int(width, xlen_bytes), "./extensions/A/zalrsc_insts.sail:39.28-39.29");
    $[complete] match vmem_read(rs1, zeros(sizeof(xlen)), width, Read(Data), aq, $[overloaded { "name" = "&", "is_infix" = true }] and_bool(aq, rl), true) {
      Ok(data) => {
          $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(rd, sign_extend(sizeof(xlen), data));
          RETIRE_SUCCESS
      },
      Err(e) => e
    }
}
and execute STORECON((aq, rl, rs2, rs1, width, rd)) = {
    assert($[overloaded { "name" = "<=", "is_infix" = true }] lteq_int(width, xlen_bytes), "./extensions/A/zalrsc_insts.sail:64.28-64.29");
    let data = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs2), $[overloaded { "name" = "-", "is_infix" = true }] sub_atom($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(width, 8), 1), 0);
    $[complete] match vmem_write(rs1, zeros(sizeof(xlen)), width, data, Write(Data), $[overloaded { "name" = "&", "is_infix" = true }] and_bool(aq, rl), rl, true) {
      Ok(b) => {
          $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(rd, zero_extend(sizeof(xlen), bool_bits_forwards($[overloaded { "name" = "~", "is_infix" = false }] not_bool(b))));
          cancel_reservation();
          RETIRE_SUCCESS
      },
      Err(e) => e
    }
}
and execute MUL((rs2, rs1, rd, mul_op)) = {
    let rs1_bits = $[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1);
    let rs2_bits = $[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs2);
    let rs1_int = if mul_op.signed_rs1 then signed(rs1_bits) else
      unsigned(rs1_bits);
    let rs2_int = if mul_op.signed_rs2 then signed(rs2_bits) else
      unsigned(rs2_bits);
    let result_wide = to_bits_truncate($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(2, xlen), $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(rs1_int, rs2_int));
    $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(rd, if mul_op.high then
      $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(result_wide, $[overloaded { "name" = "-", "is_infix" = true }] sub_atom($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(2, xlen), 1), xlen)
    else
      $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(result_wide, $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(xlen, 1), 0));
    RETIRE_SUCCESS
}
and execute DIV((rs2, rs1, rd, is_unsigned)) = {
    let rs1_bits = $[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1);
    let rs2_bits = $[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs2);
    let rs1_int = if is_unsigned then unsigned(rs1_bits) else signed(rs1_bits);
    let rs2_int = if is_unsigned then unsigned(rs2_bits) else signed(rs2_bits);
    let quotient = if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(rs2_int, 0) then
      -1
    else
      quot_round_zero(rs1_int, rs2_int);
    let quotient = if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(not(is_unsigned), $[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(quotient, 2 ^ sub_atom(xlen, 1))) then
      $[overloaded { "name" = "negate", "is_infix" = false }] negate_atom(2 ^ sub_atom(xlen, 1))
    else
      quotient;
    $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(rd, to_bits_truncate(sizeof(xlen), quotient));
    RETIRE_SUCCESS
}
and execute REM((rs2, rs1, rd, is_unsigned)) = {
    let rs1_bits = $[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1);
    let rs2_bits = $[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs2);
    let rs1_int = if is_unsigned then unsigned(rs1_bits) else signed(rs1_bits);
    let rs2_int = if is_unsigned then unsigned(rs2_bits) else signed(rs2_bits);
    let remainder = if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(rs2_int, 0) then
      rs1_int
    else
      rem_round_zero(rs1_int, rs2_int);
    $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(rd, to_bits_truncate(sizeof(xlen), remainder));
    RETIRE_SUCCESS
}
and execute MULW((rs2, rs1, rd)) = {
    let rs1_bits = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1), 31, 0);
    let rs2_bits = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs2), 31, 0);
    let rs1_int = signed(rs1_bits);
    let rs2_int = signed(rs2_bits);
    let result32 : bits(32) = to_bits_truncate(32, $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(rs1_int, rs2_int));
    $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(rd, sign_extend(sizeof(xlen), result32));
    RETIRE_SUCCESS
}
and execute DIVW((rs2, rs1, rd, is_unsigned)) = {
    let rs1_bits = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1), 31, 0);
    let rs2_bits = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs2), 31, 0);
    let rs1_int = if is_unsigned then unsigned(rs1_bits) else signed(rs1_bits);
    let rs2_int = if is_unsigned then unsigned(rs2_bits) else signed(rs2_bits);
    let quotient = if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(rs2_int, 0) then
      -1
    else
      quot_round_zero(rs1_int, rs2_int);
    let quotient = if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(not(is_unsigned), $[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(quotient, 2 ^ 31)) then
      $[overloaded { "name" = "negate", "is_infix" = false }] negate_atom(2 ^ 31)
    else
      quotient;
    $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(rd, sign_extend(sizeof(xlen), to_bits_truncate(32, quotient)));
    RETIRE_SUCCESS
}
and execute REMW((rs2, rs1, rd, is_unsigned)) = {
    let rs1_bits = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1), 31, 0);
    let rs2_bits = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs2), 31, 0);
    let rs1_int = if is_unsigned then unsigned(rs1_bits) else signed(rs1_bits);
    let rs2_int = if is_unsigned then unsigned(rs2_bits) else signed(rs2_bits);
    let remainder = if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(rs2_int, 0) then
      rs1_int
    else
      rem_round_zero(rs1_int, rs2_int);
    $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(rd, sign_extend(sizeof(xlen), to_bits_truncate(32, remainder)));
    RETIRE_SUCCESS
}
and execute SLLIUW((shamt, rs1, rd)) = {
    $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(rd, $[overloaded { "name" = "<<", "is_infix" = true }] shift_bits_left(zero_extend(sizeof(xlen), $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1), 31, 0)), shamt));
    RETIRE_SUCCESS
}
and execute ZBA_RTYPEUW((rs2, rs1, rd, shamt)) = {
    $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(rd, $[overloaded { "name" = "+", "is_infix" = true }] add_bits($[overloaded { "name" = "<<", "is_infix" = true }] shift_bits_left(zero_extend(sizeof(xlen), $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1), 31, 0)), shamt), $[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs2)));
    RETIRE_SUCCESS
}
and execute ZBA_RTYPE((rs2, rs1, rd, shamt)) = {
    $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(rd, $[overloaded { "name" = "+", "is_infix" = true }] add_bits($[overloaded { "name" = "<<", "is_infix" = true }] shift_bits_left($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1), shamt), $[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs2)));
    RETIRE_SUCCESS
}
and execute RORIW((shamt, rs1, rd)) = {
    $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(rd, sign_extend(sizeof(xlen), $[overloaded { "name" = ">>>", "is_infix" = true }] rotate_bits_right($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1), 31, 0), shamt)));
    RETIRE_SUCCESS
}
and execute RORI((shamt, rs1, rd)) = {
    let shamt = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(shamt, $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(log2_xlen, 1), 0);
    $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(rd, $[overloaded { "name" = ">>>", "is_infix" = true }] rotate_bits_right($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1), shamt));
    RETIRE_SUCCESS
}
and $[split "op"]
execute ZBB_RTYPEW((rs2, rs1, rd, op)) = {
    let rs1_val = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1), 31, 0);
    let shamt = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs2), 4, 0);
    let result : bits(32) = $[complete] match op {
      ROLW => $[overloaded { "name" = "<<<", "is_infix" = true }] rotate_bits_left(rs1_val, shamt),
      RORW => $[overloaded { "name" = ">>>", "is_infix" = true }] rotate_bits_right(rs1_val, shamt)
    };
    $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(rd, sign_extend(sizeof(xlen), result));
    RETIRE_SUCCESS
}
and $[split "op"]
execute ZBB_RTYPE((rs2, rs1, rd, op)) = {
    let rs1_val = $[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1);
    let rs2_val = $[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs2);
    let result : xlenbits = $[complete] match op {
      ANDN => $[overloaded { "name" = "&", "is_infix" = true }] and_vec(rs1_val, $[overloaded { "name" = "~", "is_infix" = false }] not_vec(rs2_val)),
      ORN => $[overloaded { "name" = "|", "is_infix" = true }] or_vec(rs1_val, $[overloaded { "name" = "~", "is_infix" = false }] not_vec(rs2_val)),
      XNOR => $[overloaded { "name" = "~", "is_infix" = false }] not_vec($[overloaded { "name" = "^", "is_infix" = true }] xor_vec(rs1_val, rs2_val)),
      MAX => if operator >_s(rs1_val, rs2_val) then rs1_val else rs2_val,
      MAXU => if operator >_u(rs1_val, rs2_val) then rs1_val else rs2_val,
      MIN => if operator <_s(rs1_val, rs2_val) then rs1_val else rs2_val,
      MINU => if operator <_u(rs1_val, rs2_val) then rs1_val else rs2_val,
      ROL => $[overloaded { "name" = "<<<", "is_infix" = true }] rotate_bits_left(rs1_val, $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(rs2_val, $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(log2_xlen, 1), 0)),
      ROR => $[overloaded { "name" = ">>>", "is_infix" = true }] rotate_bits_right(rs1_val, $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(rs2_val, $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(log2_xlen, 1), 0))
    };
    $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(rd, result);
    RETIRE_SUCCESS
}
and $[split "op"]
execute ZBB_EXTOP((rs1, rd, op)) = {
    let rs1_val = $[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1);
    let result : xlenbits = $[complete] match op {
      SEXTB => sign_extend(sizeof(xlen), $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(rs1_val, 7, 0)),
      SEXTH => sign_extend(sizeof(xlen), $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(rs1_val, 15, 0)),
      ZEXTH => zero_extend(sizeof(xlen), $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(rs1_val, 15, 0))
    };
    $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(rd, result);
    RETIRE_SUCCESS
}
and execute REV8((rs1, rd)) = {
    $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(rd, rev8($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1)));
    RETIRE_SUCCESS
}
and execute ORCB((rs1, rd)) = {
    let rs1_val = $[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1);
    var result : xlenbits = zeros(sizeof(xlen));
    foreach (i from 0 to sub_atom(xlen, 8) by 8 in inc) result[$[overloaded { "name" = "+", "is_infix" = true }] add_atom(i, 7) .. i] = if $[overloaded { "name" = "==", "is_infix" = true }] eq_bits($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(rs1_val, $[overloaded { "name" = "+", "is_infix" = true }] add_atom(i, 7), i), zeros(add_atom(sub_atom(add_atom($[overloaded { "name" = "__size", "is_infix" = false }] __id(i), 7), $[overloaded { "name" = "__size", "is_infix" = false }] __id(i)), 1))) then
      0x00
    else
      0xFF;
    $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(rd, result);
    RETIRE_SUCCESS
}
and execute CPOP((rs1, rd)) = {
    $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(rd, to_bits(sizeof(xlen), count_ones($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1))));
    RETIRE_SUCCESS
}
and execute CPOPW((rs1, rd)) = {
    $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(rd, to_bits(sizeof(xlen), count_ones($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1), 31, 0))));
    RETIRE_SUCCESS
}
and execute CLZ((rs1, rd)) = {
    $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(rd, to_bits(sizeof(xlen), count_leading_zeros($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1))));
    RETIRE_SUCCESS
}
and execute CLZW((rs1, rd)) = {
    $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(rd, to_bits(sizeof(xlen), count_leading_zeros($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1), 31, 0))));
    RETIRE_SUCCESS
}
and execute CTZ((rs1, rd)) = {
    $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(rd, to_bits(sizeof(xlen), count_trailing_zeros($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1))));
    RETIRE_SUCCESS
}
and execute CTZW((rs1, rd)) = {
    $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(rd, to_bits(sizeof(xlen), count_trailing_zeros($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1), 31, 0))));
    RETIRE_SUCCESS
}
and execute CLMUL((rs2, rs1, rd)) = {
    let prod = carryless_mul($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1), $[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs2));
    $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(rd, $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(prod, $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(xlen, 1), 0));
    RETIRE_SUCCESS
}
and execute CLMULH((rs2, rs1, rd)) = {
    let prod = carryless_mul($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1), $[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs2));
    $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(rd, $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(prod, $[overloaded { "name" = "-", "is_infix" = true }] sub_atom($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(2, xlen), 1), xlen));
    RETIRE_SUCCESS
}
and execute CLMULR((rs2, rs1, rd)) = {
    $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(rd, carryless_mulr($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1), $[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs2)));
    RETIRE_SUCCESS
}
and $[split "op"]
execute ZBS_IOP((shamt, rs1, rd, op)) = {
    let rs1_val = $[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1);
    let mask : xlenbits = if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 32) then
      $[overloaded { "name" = "<<", "is_infix" = true }] shift_bits_left(zero_extend(sizeof(xlen), 0b1), $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(shamt, 4, 0))
    else
      $[overloaded { "name" = "<<", "is_infix" = true }] shift_bits_left(zero_extend(sizeof(xlen), 0b1), shamt);
    let result : xlenbits = $[complete] match op {
      BCLRI => $[overloaded { "name" = "&", "is_infix" = true }] and_vec(rs1_val, $[overloaded { "name" = "~", "is_infix" = false }] not_vec(mask)),
      BEXTI => zero_extend(sizeof(xlen), bool_to_bits($[overloaded { "name" = "!=", "is_infix" = true }] neq_bits($[overloaded { "name" = "&", "is_infix" = true }] and_vec(rs1_val, mask), zeros(sizeof(xlen))))),
      BINVI => $[overloaded { "name" = "^", "is_infix" = true }] xor_vec(rs1_val, mask),
      BSETI => $[overloaded { "name" = "|", "is_infix" = true }] or_vec(rs1_val, mask)
    };
    $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(rd, result);
    RETIRE_SUCCESS
}
and $[split "op"]
execute ZBS_RTYPE((rs2, rs1, rd, op)) = {
    let rs1_val = $[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1);
    let rs2_val = $[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs2);
    let mask : xlenbits = if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 32) then
      $[overloaded { "name" = "<<", "is_infix" = true }] shift_bits_left(zero_extend(sizeof(xlen), 0b1), $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(rs2_val, 4, 0))
    else
      $[overloaded { "name" = "<<", "is_infix" = true }] shift_bits_left(zero_extend(sizeof(xlen), 0b1), $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(rs2_val, 5, 0));
    let result : xlenbits = $[complete] match op {
      BCLR => $[overloaded { "name" = "&", "is_infix" = true }] and_vec(rs1_val, $[overloaded { "name" = "~", "is_infix" = false }] not_vec(mask)),
      BEXT => zero_extend(sizeof(xlen), bool_to_bits($[overloaded { "name" = "!=", "is_infix" = true }] neq_bits($[overloaded { "name" = "&", "is_infix" = true }] and_vec(rs1_val, mask), zeros(sizeof(xlen))))),
      BINV => $[overloaded { "name" = "^", "is_infix" = true }] xor_vec(rs1_val, mask),
      BSET => $[overloaded { "name" = "|", "is_infix" = true }] or_vec(rs1_val, mask)
    };
    $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(rd, result);
    RETIRE_SUCCESS
}
and execute C_NOP(_) = RETIRE_SUCCESS
and execute C_ADDI4SPN((rdc, nzimm)) = {
    let imm : bits(12) = $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(0b00, $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(nzimm, 0b00));
    let rd = creg2reg_idx(rdc);
    execute(ITYPE((imm, sp, rd, ADDI)))
}
and execute C_LW((uimm, rsc, rdc)) = {
    let imm : bits(12) = zero_extend(12, $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(uimm, 0b00));
    let rd = creg2reg_idx(rdc);
    let rs = creg2reg_idx(rsc);
    execute(LOAD((imm, rs, rd, false, 4)))
}
and execute C_LD((uimm, rsc, rdc)) = {
    let imm : bits(12) = zero_extend(12, $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(uimm, 0b000));
    let rd = creg2reg_idx(rdc);
    let rs = creg2reg_idx(rsc);
    execute(LOAD((imm, rs, rd, false, 8)))
}
and execute C_SW((uimm, rsc1, rsc2)) = {
    let imm : bits(12) = zero_extend(12, $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(uimm, 0b00));
    let rs1 = creg2reg_idx(rsc1);
    let rs2 = creg2reg_idx(rsc2);
    execute(STORE((imm, rs2, rs1, 4)))
}
and execute C_SD((uimm, rsc1, rsc2)) = {
    let imm : bits(12) = zero_extend(12, $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(uimm, 0b000));
    let rs1 = creg2reg_idx(rsc1);
    let rs2 = creg2reg_idx(rsc2);
    execute(STORE((imm, rs2, rs1, 8)))
}
and execute C_ADDI((imm, rsd)) = {
    let imm : bits(12) = sign_extend(12, imm);
    execute(ITYPE((imm, rsd, rsd, ADDI)))
}
and execute C_JAL(imm) = execute(JAL((sign_extend(21, $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(imm, 0b0)), ra)))
and execute C_ADDIW((imm, rsd)) = execute(ADDIW((sign_extend(12, imm), rsd, rsd)))
and execute C_LI((imm, rd)) = {
    let imm : bits(12) = sign_extend(12, imm);
    execute(ITYPE((imm, zreg, rd, ADDI)))
}
and execute C_ADDI16SP(imm) = {
    let imm : bits(12) = sign_extend(12, $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(imm, 0x0));
    execute(ITYPE((imm, sp, sp, ADDI)))
}
and execute C_LUI((imm, rd)) = {
    let res : bits(20) = sign_extend(20, imm);
    execute(UTYPE((res, rd, LUI)))
}
and execute C_SRLI((shamt, rsd)) = {
    let rsd = creg2reg_idx(rsd);
    execute(SHIFTIOP((shamt, rsd, rsd, SRLI)))
}
and execute C_SRAI((shamt, rsd)) = {
    let rsd = creg2reg_idx(rsd);
    execute(SHIFTIOP((shamt, rsd, rsd, SRAI)))
}
and execute C_ANDI((imm, rsd)) = {
    let rsd = creg2reg_idx(rsd);
    execute(ITYPE((sign_extend(12, imm), rsd, rsd, ANDI)))
}
and execute C_SUB((rsd, rs2)) = {
    let rsd = creg2reg_idx(rsd);
    let rs2 = creg2reg_idx(rs2);
    execute(RTYPE((rs2, rsd, rsd, SUB)))
}
and execute C_XOR((rsd, rs2)) = {
    let rsd = creg2reg_idx(rsd);
    let rs2 = creg2reg_idx(rs2);
    execute(RTYPE((rs2, rsd, rsd, XOR)))
}
and execute C_OR((rsd, rs2)) = {
    let rsd = creg2reg_idx(rsd);
    let rs2 = creg2reg_idx(rs2);
    execute(RTYPE((rs2, rsd, rsd, OR)))
}
and execute C_AND((rsd, rs2)) = {
    let rsd = creg2reg_idx(rsd);
    let rs2 = creg2reg_idx(rs2);
    execute(RTYPE((rs2, rsd, rsd, AND)))
}
and execute C_SUBW((rsd, rs2)) = {
    let rsd = creg2reg_idx(rsd);
    let rs2 = creg2reg_idx(rs2);
    execute(RTYPEW((rs2, rsd, rsd, SUBW)))
}
and execute C_ADDW((rsd, rs2)) = {
    let rsd = creg2reg_idx(rsd);
    let rs2 = creg2reg_idx(rs2);
    execute(RTYPEW((rs2, rsd, rsd, ADDW)))
}
and execute C_J(imm) = execute(JAL((sign_extend(21, $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(imm, 0b0)), zreg)))
and execute C_BEQZ((imm, rs)) = execute(BTYPE((sign_extend(13, $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(imm, 0b0)), zreg, creg2reg_idx(rs), BEQ)))
and execute C_BNEZ((imm, rs)) = execute(BTYPE((sign_extend(13, $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(imm, 0b0)), zreg, creg2reg_idx(rs), BNE)))
and execute C_SLLI((shamt, rsd)) = execute(SHIFTIOP((shamt, rsd, rsd, SLLI)))
and execute C_LWSP((uimm, rd)) = {
    let imm : bits(12) = zero_extend(12, $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(uimm, 0b00));
    execute(LOAD((imm, sp, rd, false, 4)))
}
and execute C_LDSP((uimm, rd)) = {
    let imm : bits(12) = zero_extend(12, $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(uimm, 0b000));
    execute(LOAD((imm, sp, rd, false, 8)))
}
and execute C_SWSP((uimm, rs2)) = {
    let imm : bits(12) = zero_extend(12, $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(uimm, 0b00));
    execute(STORE((imm, rs2, sp, 4)))
}
and execute C_SDSP((uimm, rs2)) = {
    let imm : bits(12) = zero_extend(12, $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(uimm, 0b000));
    execute(STORE((imm, rs2, sp, 8)))
}
and execute C_JR(rs1) = execute(JALR((zeros(12), rs1, zreg)))
and execute C_JALR(rs1) = execute(JALR((zeros(12), rs1, ra)))
and execute C_MV((rd, rs2)) = execute(RTYPE((rs2, zreg, rd, ADD)))
and execute C_EBREAK(()) = execute(EBREAK())
and execute C_ADD((rsd, rs2)) = execute(RTYPE((rs2, rsd, rsd, ADD)))
and execute C_LBU((uimm, rdc, rsc1)) = {
    let imm : bits(12) = zero_extend(12, uimm);
    let rd = creg2reg_idx(rdc);
    let rs1 = creg2reg_idx(rsc1);
    execute(LOAD((imm, rs1, rd, true, 1)))
}
and execute C_LHU((uimm, rdc, rsc1)) = {
    let imm : bits(12) = zero_extend(12, uimm);
    let rd = creg2reg_idx(rdc);
    let rs1 = creg2reg_idx(rsc1);
    execute(LOAD((imm, rs1, rd, true, 2)))
}
and execute C_LH((uimm, rdc, rsc1)) = {
    let imm : bits(12) = zero_extend(12, uimm);
    let rd = creg2reg_idx(rdc);
    let rs1 = creg2reg_idx(rsc1);
    execute(LOAD((imm, rs1, rd, false, 2)))
}
and execute C_SB((uimm, rsc1, rsc2)) = {
    let imm : bits(12) = zero_extend(12, uimm);
    let rs1 = creg2reg_idx(rsc1);
    let rs2 = creg2reg_idx(rsc2);
    execute(STORE((imm, rs2, rs1, 1)))
}
and execute C_SH((uimm, rsc1, rsc2)) = {
    let imm : bits(12) = zero_extend(12, uimm);
    let rs1 = creg2reg_idx(rsc1);
    let rs2 = creg2reg_idx(rsc2);
    execute(STORE((imm, rs2, rs1, 2)))
}
and execute C_ZEXT_B(rsdc) = {
    let rsd = creg2reg_idx(rsdc);
    $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(rsd, zero_extend(sizeof(xlen), $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rsd), 7, 0)));
    RETIRE_SUCCESS
}
and execute C_SEXT_B(rsdc) = {
    let rsd = creg2reg_idx(rsdc);
    execute(ZBB_EXTOP((rsd, rsd, SEXTB)))
}
and execute C_ZEXT_H(rsdc) = {
    let rsd = creg2reg_idx(rsdc);
    execute(ZBB_EXTOP((rsd, rsd, ZEXTH)))
}
and execute C_SEXT_H(rsdc) = {
    let rsd = creg2reg_idx(rsdc);
    execute(ZBB_EXTOP((rsd, rsd, SEXTH)))
}
and execute C_ZEXT_W(rsdc) = {
    let rsd = creg2reg_idx(rsdc);
    execute(ZBA_RTYPEUW((zreg, rsd, rsd, 0b00)))
}
and execute C_NOT(rsdc) = {
    let r = creg2reg_idx(rsdc);
    $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(r, $[overloaded { "name" = "~", "is_infix" = false }] not_vec($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(r)));
    RETIRE_SUCCESS
}
and execute C_MUL((rsdc, rsc2)) = {
    let rd = creg2reg_idx(rsdc);
    let rs = creg2reg_idx(rsc2);
    execute(MUL((rs, rd, rd, struct mul_op { high = false, signed_rs1 = true, signed_rs2 = true })))
}
and execute LOAD_FP((imm, rs1, rd, width)) = {
    assert($[overloaded { "name" = "<=", "is_infix" = true }] lteq_int(width, flen_bytes), "./extensions/FD/fext_insts.sail:293.28-293.29");
    let offset : xlenbits = sign_extend(sizeof(xlen), imm);
    $[complete] match vmem_read(rs1, offset, width, Read(Data), false, false, false) {
      Ok(result) => {
          $[overloaded { "name" = "F", "is_infix" = false }] $[setter] wF_bits(rd, nan_box(mult_atom(if constraint(ext_d_supported) then
            8
          else
            4, 8), result));
          RETIRE_SUCCESS
      },
      Err(e) => e
    }
}
and execute STORE_FP((imm, rs2, rs1, width)) = {
    assert($[overloaded { "name" = "<=", "is_infix" = true }] lteq_int(width, flen_bytes), "./extensions/FD/fext_insts.sail:328.28-328.29");
    let offset : xlenbits = sign_extend(sizeof(xlen), imm);
    let data = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits($[overloaded { "name" = "F", "is_infix" = false }] rF_bits(rs2), $[overloaded { "name" = "-", "is_infix" = true }] sub_atom($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(width, 8), 1), 0);
    $[complete] match vmem_write(rs1, offset, width, data, Write(Data), false, false, false) {
      Ok(true) => RETIRE_SUCCESS,
      Ok(false) => internal_error("./extensions/FD/fext_insts.sail", 334, "store got false from vmem_write"),
      Err(e) => e
    }
}
and $[split "op"]
execute F_MADD_TYPE_S((rs3, rs2, rs1, rm, rd, op)) = {
    let rs1_val_32b = $[overloaded { "name" = "F_or_X_S", "is_infix" = false }] rF_or_X_S(rs1);
    let rs2_val_32b = $[overloaded { "name" = "F_or_X_S", "is_infix" = false }] rF_or_X_S(rs2);
    let rs3_val_32b = $[overloaded { "name" = "F_or_X_S", "is_infix" = false }] rF_or_X_S(rs3);
    $[complete] match select_instr_or_fcsr_rm(rm) {
      None(()) => Illegal_Instruction(),
      Some(rm') => {
          let rm_3b = encdec_rounding_mode_forwards(rm');
          let (fflags, rd_val_32b) : (bits(5), bits(32)) = $[complete] match op {
            FMADD_S => riscv_f32MulAdd(rm_3b, rs1_val_32b, rs2_val_32b, rs3_val_32b),
            FMSUB_S => riscv_f32MulAdd(rm_3b, rs1_val_32b, rs2_val_32b, negate_S(rs3_val_32b)),
            FNMSUB_S => riscv_f32MulAdd(rm_3b, negate_S(rs1_val_32b), rs2_val_32b, rs3_val_32b),
            FNMADD_S => riscv_f32MulAdd(rm_3b, negate_S(rs1_val_32b), rs2_val_32b, negate_S(rs3_val_32b))
          };
          accrue_fflags(fflags);
          $[overloaded { "name" = "F_or_X_S", "is_infix" = false }] $[setter] wF_or_X_S(rd, rd_val_32b);
          RETIRE_SUCCESS
      }
    }
}
and $[split "op"]
execute F_BIN_RM_TYPE_S((rs2, rs1, rm, rd, op)) = {
    let rs1_val_32b = $[overloaded { "name" = "F_or_X_S", "is_infix" = false }] rF_or_X_S(rs1);
    let rs2_val_32b = $[overloaded { "name" = "F_or_X_S", "is_infix" = false }] rF_or_X_S(rs2);
    $[complete] match select_instr_or_fcsr_rm(rm) {
      None(()) => Illegal_Instruction(),
      Some(rm') => {
          let rm_3b = encdec_rounding_mode_forwards(rm');
          let (fflags, rd_val_32b) : (bits(5), bits(32)) = $[complete] match op {
            FADD_S => riscv_f32Add(rm_3b, rs1_val_32b, rs2_val_32b),
            FSUB_S => riscv_f32Sub(rm_3b, rs1_val_32b, rs2_val_32b),
            FMUL_S => riscv_f32Mul(rm_3b, rs1_val_32b, rs2_val_32b),
            FDIV_S => riscv_f32Div(rm_3b, rs1_val_32b, rs2_val_32b)
          };
          accrue_fflags(fflags);
          $[overloaded { "name" = "F_or_X_S", "is_infix" = false }] $[setter] wF_or_X_S(rd, rd_val_32b);
          RETIRE_SUCCESS
      }
    }
}
and execute F_UN_RM_FF_TYPE_S((rs1, rm, rd, FSQRT_S)) = {
    let rs1_val_S = $[overloaded { "name" = "F_or_X_S", "is_infix" = false }] rF_or_X_S(rs1);
    $[complete] match select_instr_or_fcsr_rm(rm) {
      None(()) => Illegal_Instruction(),
      Some(rm') => {
          let rm_3b = encdec_rounding_mode_forwards(rm');
          let (fflags, rd_val_S) = riscv_f32Sqrt(rm_3b, rs1_val_S);
          accrue_fflags(fflags);
          $[overloaded { "name" = "F_or_X_S", "is_infix" = false }] $[setter] wF_or_X_S(rd, rd_val_S);
          RETIRE_SUCCESS
      }
    }
}
and execute F_UN_RM_FX_TYPE_S((rs1, rm, rd, FCVT_W_S)) = {
    let rs1_val_S = $[overloaded { "name" = "F_or_X_S", "is_infix" = false }] rF_or_X_S(rs1);
    $[complete] match select_instr_or_fcsr_rm(rm) {
      None(()) => Illegal_Instruction(),
      Some(rm') => {
          let rm_3b = encdec_rounding_mode_forwards(rm');
          let (fflags, rd_val_W) = riscv_f32ToI32(rm_3b, rs1_val_S);
          accrue_fflags(fflags);
          $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(rd, sign_extend(sizeof(xlen), rd_val_W));
          RETIRE_SUCCESS
      }
    }
}
and execute F_UN_RM_FX_TYPE_S((rs1, rm, rd, FCVT_WU_S)) = {
    let rs1_val_S = $[overloaded { "name" = "F_or_X_S", "is_infix" = false }] rF_or_X_S(rs1);
    $[complete] match select_instr_or_fcsr_rm(rm) {
      None(()) => Illegal_Instruction(),
      Some(rm') => {
          let rm_3b = encdec_rounding_mode_forwards(rm');
          let (fflags, rd_val_WU) = riscv_f32ToUi32(rm_3b, rs1_val_S);
          accrue_fflags(fflags);
          $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(rd, sign_extend(sizeof(xlen), rd_val_WU));
          RETIRE_SUCCESS
      }
    }
}
and execute F_UN_RM_XF_TYPE_S((rs1, rm, rd, FCVT_S_W)) = {
    let rs1_val_W = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1), 31, 0);
    $[complete] match select_instr_or_fcsr_rm(rm) {
      None(()) => Illegal_Instruction(),
      Some(rm') => {
          let rm_3b = encdec_rounding_mode_forwards(rm');
          let (fflags, rd_val_S) = riscv_i32ToF32(rm_3b, rs1_val_W);
          accrue_fflags(fflags);
          $[overloaded { "name" = "F_or_X_S", "is_infix" = false }] $[setter] wF_or_X_S(rd, rd_val_S);
          RETIRE_SUCCESS
      }
    }
}
and execute F_UN_RM_XF_TYPE_S((rs1, rm, rd, FCVT_S_WU)) = {
    let rs1_val_WU = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1), 31, 0);
    $[complete] match select_instr_or_fcsr_rm(rm) {
      None(()) => Illegal_Instruction(),
      Some(rm') => {
          let rm_3b = encdec_rounding_mode_forwards(rm');
          let (fflags, rd_val_S) = riscv_ui32ToF32(rm_3b, rs1_val_WU);
          accrue_fflags(fflags);
          $[overloaded { "name" = "F_or_X_S", "is_infix" = false }] $[setter] wF_or_X_S(rd, rd_val_S);
          RETIRE_SUCCESS
      }
    }
}
and execute F_UN_RM_FX_TYPE_S((rs1, rm, rd, FCVT_L_S)) = {
    assert($[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(xlen, 64), "./extensions/FD/fext_insts.sail:605.19-605.20");
    let rs1_val_S = $[overloaded { "name" = "F_or_X_S", "is_infix" = false }] rF_or_X_S(rs1);
    $[complete] match select_instr_or_fcsr_rm(rm) {
      None(()) => Illegal_Instruction(),
      Some(rm') => {
          let rm_3b = encdec_rounding_mode_forwards(rm');
          let (fflags, rd_val_L) = riscv_f32ToI64(rm_3b, rs1_val_S);
          accrue_fflags(fflags);
          $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(rd, sign_extend(sizeof(xlen), rd_val_L));
          RETIRE_SUCCESS
      }
    }
}
and execute F_UN_RM_FX_TYPE_S((rs1, rm, rd, FCVT_LU_S)) = {
    assert($[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(xlen, 64), "./extensions/FD/fext_insts.sail:621.19-621.20");
    let rs1_val_S = $[overloaded { "name" = "F_or_X_S", "is_infix" = false }] rF_or_X_S(rs1);
    $[complete] match select_instr_or_fcsr_rm(rm) {
      None(()) => Illegal_Instruction(),
      Some(rm') => {
          let rm_3b = encdec_rounding_mode_forwards(rm');
          let (fflags, rd_val_LU) = riscv_f32ToUi64(rm_3b, rs1_val_S);
          accrue_fflags(fflags);
          $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(rd, sign_extend(sizeof(xlen), rd_val_LU));
          RETIRE_SUCCESS
      }
    }
}
and execute F_UN_RM_XF_TYPE_S((rs1, rm, rd, FCVT_S_L)) = {
    assert($[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(xlen, 64), "./extensions/FD/fext_insts.sail:637.19-637.20");
    let rs1_val_L = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1), 63, 0);
    $[complete] match select_instr_or_fcsr_rm(rm) {
      None(()) => Illegal_Instruction(),
      Some(rm') => {
          let rm_3b = encdec_rounding_mode_forwards(rm');
          let (fflags, rd_val_S) = riscv_i64ToF32(rm_3b, rs1_val_L);
          accrue_fflags(fflags);
          $[overloaded { "name" = "F_or_X_S", "is_infix" = false }] $[setter] wF_or_X_S(rd, rd_val_S);
          RETIRE_SUCCESS
      }
    }
}
and execute F_UN_RM_XF_TYPE_S((rs1, rm, rd, FCVT_S_LU)) = {
    assert($[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(xlen, 64), "./extensions/FD/fext_insts.sail:653.19-653.20");
    let rs1_val_LU = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1), 63, 0);
    $[complete] match select_instr_or_fcsr_rm(rm) {
      None(()) => Illegal_Instruction(),
      Some(rm') => {
          let rm_3b = encdec_rounding_mode_forwards(rm');
          let (fflags, rd_val_S) = riscv_ui64ToF32(rm_3b, rs1_val_LU);
          accrue_fflags(fflags);
          $[overloaded { "name" = "F_or_X_S", "is_infix" = false }] $[setter] wF_or_X_S(rd, rd_val_S);
          RETIRE_SUCCESS
      }
    }
}
and execute F_BIN_TYPE_F_S((rs2, rs1, rd, FSGNJ_S)) = {
    let rs1_val_S = $[overloaded { "name" = "F_or_X_S", "is_infix" = false }] rF_or_X_S(rs1);
    let rs2_val_S = $[overloaded { "name" = "F_or_X_S", "is_infix" = false }] rF_or_X_S(rs2);
    let (s1, e1, m1) = fsplit_S(rs1_val_S);
    let (s2, e2, m2) = fsplit_S(rs2_val_S);
    let rd_val_S = fmake_S(s2, e1, m1);
    $[overloaded { "name" = "F_or_X_S", "is_infix" = false }] $[setter] wF_or_X_S(rd, rd_val_S);
    RETIRE_SUCCESS
}
and execute F_BIN_TYPE_F_S((rs2, rs1, rd, FSGNJN_S)) = {
    let rs1_val_S = $[overloaded { "name" = "F_or_X_S", "is_infix" = false }] rF_or_X_S(rs1);
    let rs2_val_S = $[overloaded { "name" = "F_or_X_S", "is_infix" = false }] rF_or_X_S(rs2);
    let (s1, e1, m1) = fsplit_S(rs1_val_S);
    let (s2, e2, m2) = fsplit_S(rs2_val_S);
    let rd_val_S = fmake_S($[overloaded { "name" = "^", "is_infix" = true }] xor_vec(0b1, s2), e1, m1);
    $[overloaded { "name" = "F_or_X_S", "is_infix" = false }] $[setter] wF_or_X_S(rd, rd_val_S);
    RETIRE_SUCCESS
}
and execute F_BIN_TYPE_F_S((rs2, rs1, rd, FSGNJX_S)) = {
    let rs1_val_S = $[overloaded { "name" = "F_or_X_S", "is_infix" = false }] rF_or_X_S(rs1);
    let rs2_val_S = $[overloaded { "name" = "F_or_X_S", "is_infix" = false }] rF_or_X_S(rs2);
    let (s1, e1, m1) = fsplit_S(rs1_val_S);
    let (s2, e2, m2) = fsplit_S(rs2_val_S);
    let rd_val_S = fmake_S($[overloaded { "name" = "^", "is_infix" = true }] xor_vec(s1, s2), e1, m1);
    $[overloaded { "name" = "F_or_X_S", "is_infix" = false }] $[setter] wF_or_X_S(rd, rd_val_S);
    RETIRE_SUCCESS
}
and execute F_BIN_TYPE_F_S((rs2, rs1, rd, FMIN_S)) = {
    let rs1_val_S = $[overloaded { "name" = "F_or_X_S", "is_infix" = false }] rF_or_X_S(rs1);
    let rs2_val_S = $[overloaded { "name" = "F_or_X_S", "is_infix" = false }] rF_or_X_S(rs2);
    let is_quiet = true;
    let (rs1_lt_rs2, fflags) = fle_S(rs1_val_S, rs2_val_S, is_quiet);
    let rd_val_S = if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(f_is_NaN_S(rs1_val_S), f_is_NaN_S(rs2_val_S)) then
      canonical_NaN_S()
    else
      if f_is_NaN_S(rs1_val_S) then rs2_val_S else
        if f_is_NaN_S(rs2_val_S) then rs1_val_S else
          if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(f_is_neg_zero_S(rs1_val_S), f_is_pos_zero_S(rs2_val_S)) then
            rs1_val_S
          else
            if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(f_is_neg_zero_S(rs2_val_S), f_is_pos_zero_S(rs1_val_S)) then
              rs2_val_S
            else
              if rs1_lt_rs2 then rs1_val_S else rs2_val_S;
    accrue_fflags(fflags);
    $[overloaded { "name" = "F_or_X_S", "is_infix" = false }] $[setter] wF_or_X_S(rd, rd_val_S);
    RETIRE_SUCCESS
}
and execute F_BIN_TYPE_F_S((rs2, rs1, rd, FMAX_S)) = {
    let rs1_val_S = $[overloaded { "name" = "F_or_X_S", "is_infix" = false }] rF_or_X_S(rs1);
    let rs2_val_S = $[overloaded { "name" = "F_or_X_S", "is_infix" = false }] rF_or_X_S(rs2);
    let is_quiet = true;
    let (rs2_lt_rs1, fflags) = fle_S(rs2_val_S, rs1_val_S, is_quiet);
    let rd_val_S = if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(f_is_NaN_S(rs1_val_S), f_is_NaN_S(rs2_val_S)) then
      canonical_NaN_S()
    else
      if f_is_NaN_S(rs1_val_S) then rs2_val_S else
        if f_is_NaN_S(rs2_val_S) then rs1_val_S else
          if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(f_is_neg_zero_S(rs1_val_S), f_is_pos_zero_S(rs2_val_S)) then
            rs2_val_S
          else
            if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(f_is_neg_zero_S(rs2_val_S), f_is_pos_zero_S(rs1_val_S)) then
              rs1_val_S
            else
              if rs2_lt_rs1 then rs1_val_S else rs2_val_S;
    accrue_fflags(fflags);
    $[overloaded { "name" = "F_or_X_S", "is_infix" = false }] $[setter] wF_or_X_S(rd, rd_val_S);
    RETIRE_SUCCESS
}
and execute F_BIN_TYPE_X_S((rs2, rs1, rd, FEQ_S)) = {
    let rs1_val_S = $[overloaded { "name" = "F_or_X_S", "is_infix" = false }] rF_or_X_S(rs1);
    let rs2_val_S = $[overloaded { "name" = "F_or_X_S", "is_infix" = false }] rF_or_X_S(rs2);
    let (fflags, rd_val) : (bits_fflags, bool) = riscv_f32Eq(rs1_val_S, rs2_val_S);
    accrue_fflags(fflags);
    $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(rd, zero_extend(sizeof(xlen), bool_to_bits(rd_val)));
    RETIRE_SUCCESS
}
and execute F_BIN_TYPE_X_S((rs2, rs1, rd, FLT_S)) = {
    let rs1_val_S = $[overloaded { "name" = "F_or_X_S", "is_infix" = false }] rF_or_X_S(rs1);
    let rs2_val_S = $[overloaded { "name" = "F_or_X_S", "is_infix" = false }] rF_or_X_S(rs2);
    let (fflags, rd_val) : (bits_fflags, bool) = riscv_f32Lt(rs1_val_S, rs2_val_S);
    accrue_fflags(fflags);
    $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(rd, zero_extend(sizeof(xlen), bool_to_bits(rd_val)));
    RETIRE_SUCCESS
}
and execute F_BIN_TYPE_X_S((rs2, rs1, rd, FLE_S)) = {
    let rs1_val_S = $[overloaded { "name" = "F_or_X_S", "is_infix" = false }] rF_or_X_S(rs1);
    let rs2_val_S = $[overloaded { "name" = "F_or_X_S", "is_infix" = false }] rF_or_X_S(rs2);
    let (fflags, rd_val) : (bits_fflags, bool) = riscv_f32Le(rs1_val_S, rs2_val_S);
    accrue_fflags(fflags);
    $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(rd, zero_extend(sizeof(xlen), bool_to_bits(rd_val)));
    RETIRE_SUCCESS
}
and execute F_UN_TYPE_X_S((rs1, rd, FCLASS_S)) = {
    let rs1_val_S = $[overloaded { "name" = "F_or_X_S", "is_infix" = false }] rF_or_X_S(rs1);
    let rd_val_10b : bits(10) = if f_is_neg_inf_S(rs1_val_S) then 0b0000000001
    else
      if f_is_neg_norm_S(rs1_val_S) then 0b0000000010 else
        if f_is_neg_subnorm_S(rs1_val_S) then 0b0000000100 else
          if f_is_neg_zero_S(rs1_val_S) then 0b0000001000 else
            if f_is_pos_zero_S(rs1_val_S) then 0b0000010000 else
              if f_is_pos_subnorm_S(rs1_val_S) then 0b0000100000 else
                if f_is_pos_norm_S(rs1_val_S) then 0b0001000000 else
                  if f_is_pos_inf_S(rs1_val_S) then 0b0010000000 else
                    if f_is_SNaN_S(rs1_val_S) then 0b0100000000 else
                      if f_is_QNaN_S(rs1_val_S) then 0b1000000000 else zeros(10);
    $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(rd, zero_extend(sizeof(xlen), rd_val_10b));
    RETIRE_SUCCESS
}
and execute F_UN_TYPE_X_S((rs1, rd, FMV_X_W)) = {
    $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(rd, sign_extend(sizeof(xlen), $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits($[overloaded { "name" = "F", "is_infix" = false }] rF_bits(rs1), 31, 0)));
    RETIRE_SUCCESS
}
and execute F_UN_TYPE_F_S((rs1, rd, FMV_W_X)) = {
    $[overloaded { "name" = "F", "is_infix" = false }] $[setter] wF_bits(rd, nan_box(mult_atom(if constraint(ext_d_supported) then
      8
    else
      4, 8), $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1), 31, 0)));
    RETIRE_SUCCESS
}
and execute C_FLWSP((imm, rd)) = {
    let imm : bits(12) = zero_extend(12, $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(imm, 0b00));
    execute(LOAD_FP((imm, sp, rd, 4)))
}
and execute C_FSWSP((uimm, rs2)) = {
    let imm : bits(12) = zero_extend(12, $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(uimm, 0b00));
    execute(STORE_FP((imm, rs2, sp, 4)))
}
and execute C_FLW((uimm, rsc, rdc)) = {
    let imm : bits(12) = zero_extend(12, $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(uimm, 0b00));
    let rd = cfregidx_to_fregidx(rdc);
    let rs = creg2reg_idx(rsc);
    execute(LOAD_FP((imm, rs, rd, 4)))
}
and execute C_FSW((uimm, rsc1, rsc2)) = {
    let imm : bits(12) = zero_extend(12, $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(uimm, 0b00));
    let rs1 = creg2reg_idx(rsc1);
    let rs2 = cfregidx_to_fregidx(rsc2);
    execute(STORE_FP((imm, rs2, rs1, 4)))
}
and $[split "op"]
execute F_MADD_TYPE_D((rs3, rs2, rs1, rm, rd, op)) = {
    let rs1_val_64b = $[overloaded { "name" = "F_or_X_D", "is_infix" = false }] rF_or_X_D(rs1);
    let rs2_val_64b = $[overloaded { "name" = "F_or_X_D", "is_infix" = false }] rF_or_X_D(rs2);
    let rs3_val_64b = $[overloaded { "name" = "F_or_X_D", "is_infix" = false }] rF_or_X_D(rs3);
    $[complete] match select_instr_or_fcsr_rm(rm) {
      None(()) => Illegal_Instruction(),
      Some(rm') => {
          let rm_3b = encdec_rounding_mode_forwards(rm');
          let (fflags, rd_val_64b) : (bits(5), bits(64)) = $[complete] match op {
            FMADD_D => riscv_f64MulAdd(rm_3b, rs1_val_64b, rs2_val_64b, rs3_val_64b),
            FMSUB_D => riscv_f64MulAdd(rm_3b, rs1_val_64b, rs2_val_64b, negate_D(rs3_val_64b)),
            FNMSUB_D => riscv_f64MulAdd(rm_3b, negate_D(rs1_val_64b), rs2_val_64b, rs3_val_64b),
            FNMADD_D => riscv_f64MulAdd(rm_3b, negate_D(rs1_val_64b), rs2_val_64b, negate_D(rs3_val_64b))
          };
          accrue_fflags(fflags);
          $[overloaded { "name" = "F_or_X_D", "is_infix" = false }] $[setter] wF_or_X_D(rd, rd_val_64b);
          RETIRE_SUCCESS
      }
    }
}
and $[split "op"]
execute F_BIN_RM_TYPE_D((rs2, rs1, rm, rd, op)) = {
    let rs1_val_64b = $[overloaded { "name" = "F_or_X_D", "is_infix" = false }] rF_or_X_D(rs1);
    let rs2_val_64b = $[overloaded { "name" = "F_or_X_D", "is_infix" = false }] rF_or_X_D(rs2);
    $[complete] match select_instr_or_fcsr_rm(rm) {
      None(()) => Illegal_Instruction(),
      Some(rm') => {
          let rm_3b = encdec_rounding_mode_forwards(rm');
          let (fflags, rd_val_64b) : (bits(5), bits(64)) = $[complete] match op {
            FADD_D => riscv_f64Add(rm_3b, rs1_val_64b, rs2_val_64b),
            FSUB_D => riscv_f64Sub(rm_3b, rs1_val_64b, rs2_val_64b),
            FMUL_D => riscv_f64Mul(rm_3b, rs1_val_64b, rs2_val_64b),
            FDIV_D => riscv_f64Div(rm_3b, rs1_val_64b, rs2_val_64b)
          };
          accrue_fflags(fflags);
          $[overloaded { "name" = "F_or_X_D", "is_infix" = false }] $[setter] wF_or_X_D(rd, rd_val_64b);
          RETIRE_SUCCESS
      }
    }
}
and execute F_UN_RM_FF_TYPE_D((rs1, rm, rd, FSQRT_D)) = {
    let rs1_val_D = $[overloaded { "name" = "F_or_X_D", "is_infix" = false }] rF_or_X_D(rs1);
    $[complete] match select_instr_or_fcsr_rm(rm) {
      None(()) => Illegal_Instruction(),
      Some(rm') => {
          let rm_3b = encdec_rounding_mode_forwards(rm');
          let (fflags, rd_val_D) = riscv_f64Sqrt(rm_3b, rs1_val_D);
          accrue_fflags(fflags);
          $[overloaded { "name" = "F_or_X_D", "is_infix" = false }] $[setter] wF_or_X_D(rd, rd_val_D);
          RETIRE_SUCCESS
      }
    }
}
and execute F_UN_RM_FX_TYPE_D((rs1, rm, rd, FCVT_W_D)) = {
    let rs1_val_D = $[overloaded { "name" = "F_or_X_D", "is_infix" = false }] rF_or_X_D(rs1);
    $[complete] match select_instr_or_fcsr_rm(rm) {
      None(()) => Illegal_Instruction(),
      Some(rm') => {
          let rm_3b = encdec_rounding_mode_forwards(rm');
          let (fflags, rd_val_W) = riscv_f64ToI32(rm_3b, rs1_val_D);
          accrue_fflags(fflags);
          $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(rd, sign_extend(sizeof(xlen), rd_val_W));
          RETIRE_SUCCESS
      }
    }
}
and execute F_UN_RM_FX_TYPE_D((rs1, rm, rd, FCVT_WU_D)) = {
    let rs1_val_D = $[overloaded { "name" = "F_or_X_D", "is_infix" = false }] rF_or_X_D(rs1);
    $[complete] match select_instr_or_fcsr_rm(rm) {
      None(()) => Illegal_Instruction(),
      Some(rm') => {
          let rm_3b = encdec_rounding_mode_forwards(rm');
          let (fflags, rd_val_WU) = riscv_f64ToUi32(rm_3b, rs1_val_D);
          accrue_fflags(fflags);
          $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(rd, sign_extend(sizeof(xlen), rd_val_WU));
          RETIRE_SUCCESS
      }
    }
}
and execute F_UN_RM_XF_TYPE_D((rs1, rm, rd, FCVT_D_W)) = {
    let rs1_val_W = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1), 31, 0);
    $[complete] match select_instr_or_fcsr_rm(rm) {
      None(()) => Illegal_Instruction(),
      Some(rm') => {
          let rm_3b = encdec_rounding_mode_forwards(rm');
          let (fflags, rd_val_D) = riscv_i32ToF64(rm_3b, rs1_val_W);
          accrue_fflags(fflags);
          $[overloaded { "name" = "F_or_X_D", "is_infix" = false }] $[setter] wF_or_X_D(rd, rd_val_D);
          RETIRE_SUCCESS
      }
    }
}
and execute F_UN_RM_XF_TYPE_D((rs1, rm, rd, FCVT_D_WU)) = {
    let rs1_val_WU = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1), 31, 0);
    $[complete] match select_instr_or_fcsr_rm(rm) {
      None(()) => Illegal_Instruction(),
      Some(rm') => {
          let rm_3b = encdec_rounding_mode_forwards(rm');
          let (fflags, rd_val_D) = riscv_ui32ToF64(rm_3b, rs1_val_WU);
          accrue_fflags(fflags);
          $[overloaded { "name" = "F_or_X_D", "is_infix" = false }] $[setter] wF_or_X_D(rd, rd_val_D);
          RETIRE_SUCCESS
      }
    }
}
and execute F_UN_RM_FF_TYPE_D((rs1, rm, rd, FCVT_S_D)) = {
    let rs1_val_D = $[overloaded { "name" = "F_or_X_D", "is_infix" = false }] rF_or_X_D(rs1);
    $[complete] match select_instr_or_fcsr_rm(rm) {
      None(()) => Illegal_Instruction(),
      Some(rm') => {
          let rm_3b = encdec_rounding_mode_forwards(rm');
          let (fflags, rd_val_S) = riscv_f64ToF32(rm_3b, rs1_val_D);
          accrue_fflags(fflags);
          $[overloaded { "name" = "F_or_X_S", "is_infix" = false }] $[setter] wF_or_X_S(rd, rd_val_S);
          RETIRE_SUCCESS
      }
    }
}
and execute F_UN_RM_FF_TYPE_D((rs1, rm, rd, FCVT_D_S)) = {
    let rs1_val_S = $[overloaded { "name" = "F_or_X_S", "is_infix" = false }] rF_or_X_S(rs1);
    $[complete] match select_instr_or_fcsr_rm(rm) {
      None(()) => Illegal_Instruction(),
      Some(rm') => {
          let rm_3b = encdec_rounding_mode_forwards(rm');
          let (fflags, rd_val_D) = riscv_f32ToF64(rm_3b, rs1_val_S);
          accrue_fflags(fflags);
          $[overloaded { "name" = "F_or_X_D", "is_infix" = false }] $[setter] wF_or_X_D(rd, rd_val_D);
          RETIRE_SUCCESS
      }
    }
}
and execute F_UN_RM_FX_TYPE_D((rs1, rm, rd, FCVT_L_D)) = {
    assert($[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(xlen, 64), "./extensions/FD/dext_insts.sail:548.19-548.20");
    let rs1_val_D = $[overloaded { "name" = "F_or_X_D", "is_infix" = false }] rF_or_X_D(rs1);
    $[complete] match select_instr_or_fcsr_rm(rm) {
      None(()) => Illegal_Instruction(),
      Some(rm') => {
          let rm_3b = encdec_rounding_mode_forwards(rm');
          let (fflags, rd_val_L) = riscv_f64ToI64(rm_3b, rs1_val_D);
          accrue_fflags(fflags);
          $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(rd, sign_extend(sizeof(xlen), rd_val_L));
          RETIRE_SUCCESS
      }
    }
}
and execute F_UN_RM_FX_TYPE_D((rs1, rm, rd, FCVT_LU_D)) = {
    assert($[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(xlen, 64), "./extensions/FD/dext_insts.sail:564.19-564.20");
    let rs1_val_D = $[overloaded { "name" = "F_or_X_D", "is_infix" = false }] rF_or_X_D(rs1);
    $[complete] match select_instr_or_fcsr_rm(rm) {
      None(()) => Illegal_Instruction(),
      Some(rm') => {
          let rm_3b = encdec_rounding_mode_forwards(rm');
          let (fflags, rd_val_LU) = riscv_f64ToUi64(rm_3b, rs1_val_D);
          accrue_fflags(fflags);
          $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(rd, sign_extend(sizeof(xlen), rd_val_LU));
          RETIRE_SUCCESS
      }
    }
}
and execute F_UN_RM_XF_TYPE_D((rs1, rm, rd, FCVT_D_L)) = {
    assert($[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(xlen, 64), "./extensions/FD/dext_insts.sail:580.19-580.20");
    let rs1_val_L = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1), 63, 0);
    $[complete] match select_instr_or_fcsr_rm(rm) {
      None(()) => Illegal_Instruction(),
      Some(rm') => {
          let rm_3b = encdec_rounding_mode_forwards(rm');
          let (fflags, rd_val_D) = riscv_i64ToF64(rm_3b, rs1_val_L);
          accrue_fflags(fflags);
          $[overloaded { "name" = "F_or_X_D", "is_infix" = false }] $[setter] wF_or_X_D(rd, rd_val_D);
          RETIRE_SUCCESS
      }
    }
}
and execute F_UN_RM_XF_TYPE_D((rs1, rm, rd, FCVT_D_LU)) = {
    assert($[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(xlen, 64), "./extensions/FD/dext_insts.sail:596.19-596.20");
    let rs1_val_LU = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1), 63, 0);
    $[complete] match select_instr_or_fcsr_rm(rm) {
      None(()) => Illegal_Instruction(),
      Some(rm') => {
          let rm_3b = encdec_rounding_mode_forwards(rm');
          let (fflags, rd_val_D) = riscv_ui64ToF64(rm_3b, rs1_val_LU);
          accrue_fflags(fflags);
          $[overloaded { "name" = "F_or_X_D", "is_infix" = false }] $[setter] wF_or_X_D(rd, rd_val_D);
          RETIRE_SUCCESS
      }
    }
}
and execute F_BIN_F_TYPE_D((rs2, rs1, rd, FSGNJ_D)) = {
    let rs1_val_D = $[overloaded { "name" = "F_or_X_D", "is_infix" = false }] rF_or_X_D(rs1);
    let rs2_val_D = $[overloaded { "name" = "F_or_X_D", "is_infix" = false }] rF_or_X_D(rs2);
    let (s1, e1, m1) = fsplit_D(rs1_val_D);
    let (s2, e2, m2) = fsplit_D(rs2_val_D);
    let rd_val_D = fmake_D(s2, e1, m1);
    $[overloaded { "name" = "F_or_X_D", "is_infix" = false }] $[setter] wF_or_X_D(rd, rd_val_D);
    RETIRE_SUCCESS
}
and execute F_BIN_F_TYPE_D((rs2, rs1, rd, FSGNJN_D)) = {
    let rs1_val_D = $[overloaded { "name" = "F_or_X_D", "is_infix" = false }] rF_or_X_D(rs1);
    let rs2_val_D = $[overloaded { "name" = "F_or_X_D", "is_infix" = false }] rF_or_X_D(rs2);
    let (s1, e1, m1) = fsplit_D(rs1_val_D);
    let (s2, e2, m2) = fsplit_D(rs2_val_D);
    let rd_val_D = fmake_D($[overloaded { "name" = "^", "is_infix" = true }] xor_vec(0b1, s2), e1, m1);
    $[overloaded { "name" = "F_or_X_D", "is_infix" = false }] $[setter] wF_or_X_D(rd, rd_val_D);
    RETIRE_SUCCESS
}
and execute F_BIN_F_TYPE_D((rs2, rs1, rd, FSGNJX_D)) = {
    let rs1_val_D = $[overloaded { "name" = "F_or_X_D", "is_infix" = false }] rF_or_X_D(rs1);
    let rs2_val_D = $[overloaded { "name" = "F_or_X_D", "is_infix" = false }] rF_or_X_D(rs2);
    let (s1, e1, m1) = fsplit_D(rs1_val_D);
    let (s2, e2, m2) = fsplit_D(rs2_val_D);
    let rd_val_D = fmake_D($[overloaded { "name" = "^", "is_infix" = true }] xor_vec(s1, s2), e1, m1);
    $[overloaded { "name" = "F_or_X_D", "is_infix" = false }] $[setter] wF_or_X_D(rd, rd_val_D);
    RETIRE_SUCCESS
}
and execute F_BIN_F_TYPE_D((rs2, rs1, rd, FMIN_D)) = {
    let rs1_val_D = $[overloaded { "name" = "F_or_X_D", "is_infix" = false }] rF_or_X_D(rs1);
    let rs2_val_D = $[overloaded { "name" = "F_or_X_D", "is_infix" = false }] rF_or_X_D(rs2);
    let is_quiet = true;
    let (rs1_lt_rs2, fflags) = fle_D(rs1_val_D, rs2_val_D, is_quiet);
    let rd_val_D = if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(f_is_NaN_D(rs1_val_D), f_is_NaN_D(rs2_val_D)) then
      canonical_NaN_D()
    else
      if f_is_NaN_D(rs1_val_D) then rs2_val_D else
        if f_is_NaN_D(rs2_val_D) then rs1_val_D else
          if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(f_is_neg_zero_D(rs1_val_D), f_is_pos_zero_D(rs2_val_D)) then
            rs1_val_D
          else
            if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(f_is_neg_zero_D(rs2_val_D), f_is_pos_zero_D(rs1_val_D)) then
              rs2_val_D
            else
              if rs1_lt_rs2 then rs1_val_D else rs2_val_D;
    accrue_fflags(fflags);
    $[overloaded { "name" = "F_or_X_D", "is_infix" = false }] $[setter] wF_or_X_D(rd, rd_val_D);
    RETIRE_SUCCESS
}
and execute F_BIN_F_TYPE_D((rs2, rs1, rd, FMAX_D)) = {
    let rs1_val_D = $[overloaded { "name" = "F_or_X_D", "is_infix" = false }] rF_or_X_D(rs1);
    let rs2_val_D = $[overloaded { "name" = "F_or_X_D", "is_infix" = false }] rF_or_X_D(rs2);
    let is_quiet = true;
    let (rs2_lt_rs1, fflags) = fle_D(rs2_val_D, rs1_val_D, is_quiet);
    let rd_val_D = if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(f_is_NaN_D(rs1_val_D), f_is_NaN_D(rs2_val_D)) then
      canonical_NaN_D()
    else
      if f_is_NaN_D(rs1_val_D) then rs2_val_D else
        if f_is_NaN_D(rs2_val_D) then rs1_val_D else
          if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(f_is_neg_zero_D(rs1_val_D), f_is_pos_zero_D(rs2_val_D)) then
            rs2_val_D
          else
            if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(f_is_neg_zero_D(rs2_val_D), f_is_pos_zero_D(rs1_val_D)) then
              rs1_val_D
            else
              if rs2_lt_rs1 then rs1_val_D else rs2_val_D;
    accrue_fflags(fflags);
    $[overloaded { "name" = "F_or_X_D", "is_infix" = false }] $[setter] wF_or_X_D(rd, rd_val_D);
    RETIRE_SUCCESS
}
and execute F_BIN_X_TYPE_D((rs2, rs1, rd, FEQ_D)) = {
    let rs1_val_D = $[overloaded { "name" = "F_or_X_D", "is_infix" = false }] rF_or_X_D(rs1);
    let rs2_val_D = $[overloaded { "name" = "F_or_X_D", "is_infix" = false }] rF_or_X_D(rs2);
    let (fflags, rd_val) : (bits_fflags, bool) = riscv_f64Eq(rs1_val_D, rs2_val_D);
    accrue_fflags(fflags);
    $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(rd, zero_extend(sizeof(xlen), bool_to_bits(rd_val)));
    RETIRE_SUCCESS
}
and execute F_BIN_X_TYPE_D((rs2, rs1, rd, FLT_D)) = {
    let rs1_val_D = $[overloaded { "name" = "F_or_X_D", "is_infix" = false }] rF_or_X_D(rs1);
    let rs2_val_D = $[overloaded { "name" = "F_or_X_D", "is_infix" = false }] rF_or_X_D(rs2);
    let (fflags, rd_val) : (bits_fflags, bool) = riscv_f64Lt(rs1_val_D, rs2_val_D);
    accrue_fflags(fflags);
    $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(rd, zero_extend(sizeof(xlen), bool_to_bits(rd_val)));
    RETIRE_SUCCESS
}
and execute F_BIN_X_TYPE_D((rs2, rs1, rd, FLE_D)) = {
    let rs1_val_D = $[overloaded { "name" = "F_or_X_D", "is_infix" = false }] rF_or_X_D(rs1);
    let rs2_val_D = $[overloaded { "name" = "F_or_X_D", "is_infix" = false }] rF_or_X_D(rs2);
    let (fflags, rd_val) : (bits_fflags, bool) = riscv_f64Le(rs1_val_D, rs2_val_D);
    accrue_fflags(fflags);
    $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(rd, zero_extend(sizeof(xlen), bool_to_bits(rd_val)));
    RETIRE_SUCCESS
}
and execute F_UN_X_TYPE_D((rs1, rd, FCLASS_D)) = {
    let rs1_val_D = $[overloaded { "name" = "F_or_X_D", "is_infix" = false }] rF_or_X_D(rs1);
    let rd_val_10b : bits(10) = if f_is_neg_inf_D(rs1_val_D) then 0b0000000001
    else
      if f_is_neg_norm_D(rs1_val_D) then 0b0000000010 else
        if f_is_neg_subnorm_D(rs1_val_D) then 0b0000000100 else
          if f_is_neg_zero_D(rs1_val_D) then 0b0000001000 else
            if f_is_pos_zero_D(rs1_val_D) then 0b0000010000 else
              if f_is_pos_subnorm_D(rs1_val_D) then 0b0000100000 else
                if f_is_pos_norm_D(rs1_val_D) then 0b0001000000 else
                  if f_is_pos_inf_D(rs1_val_D) then 0b0010000000 else
                    if f_is_SNaN_D(rs1_val_D) then 0b0100000000 else
                      if f_is_QNaN_D(rs1_val_D) then 0b1000000000 else zeros(10);
    $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(rd, zero_extend(sizeof(xlen), rd_val_10b));
    RETIRE_SUCCESS
}
and execute F_UN_X_TYPE_D((rs1, rd, FMV_X_D)) = {
    assert($[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(xlen, 64), $[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(flen, 64)), "./extensions/FD/dext_insts.sail:878.32-878.33");
    $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(rd, sign_extend(sizeof(xlen), $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits($[overloaded { "name" = "F", "is_infix" = false }] rF_bits(rs1), 63, 0)));
    RETIRE_SUCCESS
}
and execute F_UN_F_TYPE_D((rs1, rd, FMV_D_X)) = {
    assert($[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(xlen, 64), $[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(flen, 64)), "./extensions/FD/dext_insts.sail:884.32-884.33");
    $[overloaded { "name" = "F", "is_infix" = false }] $[setter] wF_bits(rd, nan_box(mult_atom(if constraint(ext_d_supported) then
      8
    else
      4, 8), $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1), 63, 0)));
    RETIRE_SUCCESS
}
and execute C_FLDSP((uimm, rd)) = {
    let imm : bits(12) = zero_extend(12, $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(uimm, 0b000));
    execute(LOAD_FP((imm, sp, rd, 8)))
}
and execute C_FSDSP((uimm, rs2)) = {
    let imm : bits(12) = zero_extend(12, $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(uimm, 0b000));
    execute(STORE_FP((imm, rs2, sp, 8)))
}
and execute C_FLD((uimm, rsc, rdc)) = {
    let imm : bits(12) = zero_extend(12, $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(uimm, 0b000));
    let rd = cfregidx_to_fregidx(rdc);
    let rs = creg2reg_idx(rsc);
    execute(LOAD_FP((imm, rs, rd, 8)))
}
and execute C_FSD((uimm, rsc1, rsc2)) = {
    let imm : bits(12) = zero_extend(12, $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(uimm, 0b000));
    let rs1 = creg2reg_idx(rsc1);
    let rs2 = cfregidx_to_fregidx(rsc2);
    execute(STORE_FP((imm, rs2, rs1, 8)))
}
and $[split "op"]
execute F_BIN_RM_TYPE_H((rs2, rs1, rm, rd, op)) = {
    let rs1_val_16b = $[overloaded { "name" = "F_or_X_H", "is_infix" = false }] rF_or_X_H(rs1);
    let rs2_val_16b = $[overloaded { "name" = "F_or_X_H", "is_infix" = false }] rF_or_X_H(rs2);
    $[complete] match select_instr_or_fcsr_rm(rm) {
      None(()) => return(Illegal_Instruction()),
      Some(rm') => {
          let rm_3b = encdec_rounding_mode_forwards(rm');
          let (fflags, rd_val_16b) : (bits(5), bits(16)) = $[complete] match op {
            FADD_H => riscv_f16Add(rm_3b, rs1_val_16b, rs2_val_16b),
            FSUB_H => riscv_f16Sub(rm_3b, rs1_val_16b, rs2_val_16b),
            FMUL_H => riscv_f16Mul(rm_3b, rs1_val_16b, rs2_val_16b),
            FDIV_H => riscv_f16Div(rm_3b, rs1_val_16b, rs2_val_16b)
          };
          accrue_fflags(fflags);
          $[overloaded { "name" = "F_or_X_H", "is_infix" = false }] $[setter] wF_or_X_H(rd, rd_val_16b);
          RETIRE_SUCCESS
      }
    }
}
and $[split "op"]
execute F_MADD_TYPE_H((rs3, rs2, rs1, rm, rd, op)) = {
    let rs1_val_16b = $[overloaded { "name" = "F_or_X_H", "is_infix" = false }] rF_or_X_H(rs1);
    let rs2_val_16b = $[overloaded { "name" = "F_or_X_H", "is_infix" = false }] rF_or_X_H(rs2);
    let rs3_val_16b = $[overloaded { "name" = "F_or_X_H", "is_infix" = false }] rF_or_X_H(rs3);
    $[complete] match select_instr_or_fcsr_rm(rm) {
      None(()) => Illegal_Instruction(),
      Some(rm') => {
          let rm_3b = encdec_rounding_mode_forwards(rm');
          let (fflags, rd_val_16b) : (bits(5), bits(16)) = $[complete] match op {
            FMADD_H => riscv_f16MulAdd(rm_3b, rs1_val_16b, rs2_val_16b, rs3_val_16b),
            FMSUB_H => riscv_f16MulAdd(rm_3b, rs1_val_16b, rs2_val_16b, negate_H(rs3_val_16b)),
            FNMSUB_H => riscv_f16MulAdd(rm_3b, negate_H(rs1_val_16b), rs2_val_16b, rs3_val_16b),
            FNMADD_H => riscv_f16MulAdd(rm_3b, negate_H(rs1_val_16b), rs2_val_16b, negate_H(rs3_val_16b))
          };
          accrue_fflags(fflags);
          $[overloaded { "name" = "F_or_X_H", "is_infix" = false }] $[setter] wF_or_X_H(rd, rd_val_16b);
          RETIRE_SUCCESS
      }
    }
}
and execute F_BIN_F_TYPE_H((rs2, rs1, rd, FSGNJ_H)) = {
    let rs1_val_H = $[overloaded { "name" = "F_or_X_H", "is_infix" = false }] rF_or_X_H(rs1);
    let rs2_val_H = $[overloaded { "name" = "F_or_X_H", "is_infix" = false }] rF_or_X_H(rs2);
    let (s1, e1, m1) = fsplit_H(rs1_val_H);
    let (s2, e2, m2) = fsplit_H(rs2_val_H);
    let rd_val_H = fmake_H(s2, e1, m1);
    $[overloaded { "name" = "F_or_X_H", "is_infix" = false }] $[setter] wF_or_X_H(rd, rd_val_H);
    RETIRE_SUCCESS
}
and execute F_BIN_F_TYPE_H((rs2, rs1, rd, FSGNJN_H)) = {
    let rs1_val_H = $[overloaded { "name" = "F_or_X_H", "is_infix" = false }] rF_or_X_H(rs1);
    let rs2_val_H = $[overloaded { "name" = "F_or_X_H", "is_infix" = false }] rF_or_X_H(rs2);
    let (s1, e1, m1) = fsplit_H(rs1_val_H);
    let (s2, e2, m2) = fsplit_H(rs2_val_H);
    let rd_val_H = fmake_H($[overloaded { "name" = "^", "is_infix" = true }] xor_vec(0b1, s2), e1, m1);
    $[overloaded { "name" = "F_or_X_H", "is_infix" = false }] $[setter] wF_or_X_H(rd, rd_val_H);
    RETIRE_SUCCESS
}
and execute F_BIN_F_TYPE_H((rs2, rs1, rd, FSGNJX_H)) = {
    let rs1_val_H = $[overloaded { "name" = "F_or_X_H", "is_infix" = false }] rF_or_X_H(rs1);
    let rs2_val_H = $[overloaded { "name" = "F_or_X_H", "is_infix" = false }] rF_or_X_H(rs2);
    let (s1, e1, m1) = fsplit_H(rs1_val_H);
    let (s2, e2, m2) = fsplit_H(rs2_val_H);
    let rd_val_H = fmake_H($[overloaded { "name" = "^", "is_infix" = true }] xor_vec(s1, s2), e1, m1);
    $[overloaded { "name" = "F_or_X_H", "is_infix" = false }] $[setter] wF_or_X_H(rd, rd_val_H);
    RETIRE_SUCCESS
}
and execute F_BIN_F_TYPE_H((rs2, rs1, rd, FMIN_H)) = {
    let rs1_val_H = $[overloaded { "name" = "F_or_X_H", "is_infix" = false }] rF_or_X_H(rs1);
    let rs2_val_H = $[overloaded { "name" = "F_or_X_H", "is_infix" = false }] rF_or_X_H(rs2);
    let is_quiet = true;
    let (rs1_lt_rs2, fflags) = fle_H(rs1_val_H, rs2_val_H, is_quiet);
    let rd_val_H = if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(f_is_NaN_H(rs1_val_H), f_is_NaN_H(rs2_val_H)) then
      canonical_NaN_H()
    else
      if f_is_NaN_H(rs1_val_H) then rs2_val_H else
        if f_is_NaN_H(rs2_val_H) then rs1_val_H else
          if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(f_is_neg_zero_H(rs1_val_H), f_is_pos_zero_H(rs2_val_H)) then
            rs1_val_H
          else
            if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(f_is_neg_zero_H(rs2_val_H), f_is_pos_zero_H(rs1_val_H)) then
              rs2_val_H
            else
              if rs1_lt_rs2 then rs1_val_H else rs2_val_H;
    accrue_fflags(fflags);
    $[overloaded { "name" = "F_or_X_H", "is_infix" = false }] $[setter] wF_or_X_H(rd, rd_val_H);
    RETIRE_SUCCESS
}
and execute F_BIN_F_TYPE_H((rs2, rs1, rd, FMAX_H)) = {
    let rs1_val_H = $[overloaded { "name" = "F_or_X_H", "is_infix" = false }] rF_or_X_H(rs1);
    let rs2_val_H = $[overloaded { "name" = "F_or_X_H", "is_infix" = false }] rF_or_X_H(rs2);
    let is_quiet = true;
    let (rs2_lt_rs1, fflags) = fle_H(rs2_val_H, rs1_val_H, is_quiet);
    let rd_val_H = if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(f_is_NaN_H(rs1_val_H), f_is_NaN_H(rs2_val_H)) then
      canonical_NaN_H()
    else
      if f_is_NaN_H(rs1_val_H) then rs2_val_H else
        if f_is_NaN_H(rs2_val_H) then rs1_val_H else
          if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(f_is_neg_zero_H(rs1_val_H), f_is_pos_zero_H(rs2_val_H)) then
            rs2_val_H
          else
            if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(f_is_neg_zero_H(rs2_val_H), f_is_pos_zero_H(rs1_val_H)) then
              rs1_val_H
            else
              if rs2_lt_rs1 then rs1_val_H else rs2_val_H;
    accrue_fflags(fflags);
    $[overloaded { "name" = "F_or_X_H", "is_infix" = false }] $[setter] wF_or_X_H(rd, rd_val_H);
    RETIRE_SUCCESS
}
and execute F_BIN_X_TYPE_H((rs2, rs1, rd, FEQ_H)) = {
    let rs1_val_H = $[overloaded { "name" = "F_or_X_H", "is_infix" = false }] rF_or_X_H(rs1);
    let rs2_val_H = $[overloaded { "name" = "F_or_X_H", "is_infix" = false }] rF_or_X_H(rs2);
    let (fflags, rd_val) : (bits_fflags, bool) = riscv_f16Eq(rs1_val_H, rs2_val_H);
    accrue_fflags(fflags);
    $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(rd, zero_extend(sizeof(xlen), bool_to_bits(rd_val)));
    RETIRE_SUCCESS
}
and execute F_BIN_X_TYPE_H((rs2, rs1, rd, FLT_H)) = {
    let rs1_val_H = $[overloaded { "name" = "F_or_X_H", "is_infix" = false }] rF_or_X_H(rs1);
    let rs2_val_H = $[overloaded { "name" = "F_or_X_H", "is_infix" = false }] rF_or_X_H(rs2);
    let (fflags, rd_val) : (bits_fflags, bool) = riscv_f16Lt(rs1_val_H, rs2_val_H);
    accrue_fflags(fflags);
    $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(rd, zero_extend(sizeof(xlen), bool_to_bits(rd_val)));
    RETIRE_SUCCESS
}
and execute F_BIN_X_TYPE_H((rs2, rs1, rd, FLE_H)) = {
    let rs1_val_H = $[overloaded { "name" = "F_or_X_H", "is_infix" = false }] rF_or_X_H(rs1);
    let rs2_val_H = $[overloaded { "name" = "F_or_X_H", "is_infix" = false }] rF_or_X_H(rs2);
    let (fflags, rd_val) : (bits_fflags, bool) = riscv_f16Le(rs1_val_H, rs2_val_H);
    accrue_fflags(fflags);
    $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(rd, zero_extend(sizeof(xlen), bool_to_bits(rd_val)));
    RETIRE_SUCCESS
}
and execute F_UN_RM_FF_TYPE_H((rs1, rm, rd, FSQRT_H)) = {
    let rs1_val_H = $[overloaded { "name" = "F_or_X_H", "is_infix" = false }] rF_or_X_H(rs1);
    $[complete] match select_instr_or_fcsr_rm(rm) {
      None(()) => Illegal_Instruction(),
      Some(rm') => {
          let rm_3b = encdec_rounding_mode_forwards(rm');
          let (fflags, rd_val_H) = riscv_f16Sqrt(rm_3b, rs1_val_H);
          accrue_fflags(fflags);
          $[overloaded { "name" = "F_or_X_H", "is_infix" = false }] $[setter] wF_or_X_H(rd, rd_val_H);
          RETIRE_SUCCESS
      }
    }
}
and execute F_UN_RM_FX_TYPE_H((rs1, rm, rd, FCVT_W_H)) = {
    let rs1_val_H = $[overloaded { "name" = "F_or_X_H", "is_infix" = false }] rF_or_X_H(rs1);
    $[complete] match select_instr_or_fcsr_rm(rm) {
      None(()) => Illegal_Instruction(),
      Some(rm') => {
          let rm_3b = encdec_rounding_mode_forwards(rm');
          let (fflags, rd_val_W) = riscv_f16ToI32(rm_3b, rs1_val_H);
          accrue_fflags(fflags);
          $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(rd, sign_extend(sizeof(xlen), rd_val_W));
          RETIRE_SUCCESS
      }
    }
}
and execute F_UN_RM_FX_TYPE_H((rs1, rm, rd, FCVT_WU_H)) = {
    let rs1_val_H = $[overloaded { "name" = "F_or_X_H", "is_infix" = false }] rF_or_X_H(rs1);
    $[complete] match select_instr_or_fcsr_rm(rm) {
      None(()) => Illegal_Instruction(),
      Some(rm') => {
          let rm_3b = encdec_rounding_mode_forwards(rm');
          let (fflags, rd_val_WU) = riscv_f16ToUi32(rm_3b, rs1_val_H);
          accrue_fflags(fflags);
          $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(rd, sign_extend(sizeof(xlen), rd_val_WU));
          RETIRE_SUCCESS
      }
    }
}
and execute F_UN_RM_XF_TYPE_H((rs1, rm, rd, FCVT_H_W)) = {
    let rs1_val_W = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1), 31, 0);
    $[complete] match select_instr_or_fcsr_rm(rm) {
      None(()) => Illegal_Instruction(),
      Some(rm') => {
          let rm_3b = encdec_rounding_mode_forwards(rm');
          let (fflags, rd_val_H) = riscv_i32ToF16(rm_3b, rs1_val_W);
          accrue_fflags(fflags);
          $[overloaded { "name" = "F_or_X_H", "is_infix" = false }] $[setter] wF_or_X_H(rd, rd_val_H);
          RETIRE_SUCCESS
      }
    }
}
and execute F_UN_RM_XF_TYPE_H((rs1, rm, rd, FCVT_H_WU)) = {
    let rs1_val_WU = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1), 31, 0);
    $[complete] match select_instr_or_fcsr_rm(rm) {
      None(()) => Illegal_Instruction(),
      Some(rm') => {
          let rm_3b = encdec_rounding_mode_forwards(rm');
          let (fflags, rd_val_H) = riscv_ui32ToF16(rm_3b, rs1_val_WU);
          accrue_fflags(fflags);
          $[overloaded { "name" = "F_or_X_H", "is_infix" = false }] $[setter] wF_or_X_H(rd, rd_val_H);
          RETIRE_SUCCESS
      }
    }
}
and execute F_UN_RM_FF_TYPE_H((rs1, rm, rd, FCVT_H_S)) = {
    let rs1_val_S = $[overloaded { "name" = "F_or_X_S", "is_infix" = false }] rF_or_X_S(rs1);
    $[complete] match select_instr_or_fcsr_rm(rm) {
      None(()) => Illegal_Instruction(),
      Some(rm') => {
          let rm_3b = encdec_rounding_mode_forwards(rm');
          let (fflags, rd_val_H) = riscv_f32ToF16(rm_3b, rs1_val_S);
          accrue_fflags(fflags);
          $[overloaded { "name" = "F_or_X_H", "is_infix" = false }] $[setter] wF_or_X_H(rd, rd_val_H);
          RETIRE_SUCCESS
      }
    }
}
and execute F_UN_RM_FF_TYPE_H((rs1, rm, rd, FCVT_H_D)) = {
    let rs1_val_D = $[overloaded { "name" = "F_or_X_D", "is_infix" = false }] rF_or_X_D(rs1);
    $[complete] match select_instr_or_fcsr_rm(rm) {
      None(()) => Illegal_Instruction(),
      Some(rm') => {
          let rm_3b = encdec_rounding_mode_forwards(rm');
          let (fflags, rd_val_H) = riscv_f64ToF16(rm_3b, rs1_val_D);
          accrue_fflags(fflags);
          $[overloaded { "name" = "F_or_X_H", "is_infix" = false }] $[setter] wF_or_X_H(rd, rd_val_H);
          RETIRE_SUCCESS
      }
    }
}
and execute F_UN_RM_FF_TYPE_H((rs1, rm, rd, FCVT_S_H)) = {
    let rs1_val_H = $[overloaded { "name" = "F_or_X_H", "is_infix" = false }] rF_or_X_H(rs1);
    $[complete] match select_instr_or_fcsr_rm(rm) {
      None(()) => Illegal_Instruction(),
      Some(rm') => {
          let rm_3b = encdec_rounding_mode_forwards(rm');
          let (fflags, rd_val_S) = riscv_f16ToF32(rm_3b, rs1_val_H);
          accrue_fflags(fflags);
          $[overloaded { "name" = "F_or_X_S", "is_infix" = false }] $[setter] wF_or_X_S(rd, rd_val_S);
          RETIRE_SUCCESS
      }
    }
}
and execute F_UN_RM_FF_TYPE_H((rs1, rm, rd, FCVT_D_H)) = {
    let rs1_val_H = $[overloaded { "name" = "F_or_X_H", "is_infix" = false }] rF_or_X_H(rs1);
    $[complete] match select_instr_or_fcsr_rm(rm) {
      None(()) => Illegal_Instruction(),
      Some(rm') => {
          let rm_3b = encdec_rounding_mode_forwards(rm');
          let (fflags, rd_val_D) = riscv_f16ToF64(rm_3b, rs1_val_H);
          accrue_fflags(fflags);
          $[overloaded { "name" = "F_or_X_D", "is_infix" = false }] $[setter] wF_or_X_D(rd, rd_val_D);
          RETIRE_SUCCESS
      }
    }
}
and execute F_UN_RM_FX_TYPE_H((rs1, rm, rd, FCVT_L_H)) = {
    assert($[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(xlen, 64), "./extensions/FD/zfh_insts.sail:698.19-698.20");
    let rs1_val_H = $[overloaded { "name" = "F_or_X_H", "is_infix" = false }] rF_or_X_H(rs1);
    $[complete] match select_instr_or_fcsr_rm(rm) {
      None(()) => Illegal_Instruction(),
      Some(rm') => {
          let rm_3b = encdec_rounding_mode_forwards(rm');
          let (fflags, rd_val_L) = riscv_f16ToI64(rm_3b, rs1_val_H);
          accrue_fflags(fflags);
          $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(rd, sign_extend(sizeof(xlen), rd_val_L));
          RETIRE_SUCCESS
      }
    }
}
and execute F_UN_RM_FX_TYPE_H((rs1, rm, rd, FCVT_LU_H)) = {
    assert($[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(xlen, 64), "./extensions/FD/zfh_insts.sail:714.19-714.20");
    let rs1_val_H = $[overloaded { "name" = "F_or_X_H", "is_infix" = false }] rF_or_X_H(rs1);
    $[complete] match select_instr_or_fcsr_rm(rm) {
      None(()) => Illegal_Instruction(),
      Some(rm') => {
          let rm_3b = encdec_rounding_mode_forwards(rm');
          let (fflags, rd_val_LU) = riscv_f16ToUi64(rm_3b, rs1_val_H);
          accrue_fflags(fflags);
          $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(rd, sign_extend(sizeof(xlen), rd_val_LU));
          RETIRE_SUCCESS
      }
    }
}
and execute F_UN_RM_XF_TYPE_H((rs1, rm, rd, FCVT_H_L)) = {
    assert($[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(xlen, 64), "./extensions/FD/zfh_insts.sail:730.19-730.20");
    let rs1_val_L = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1), 63, 0);
    $[complete] match select_instr_or_fcsr_rm(rm) {
      None(()) => Illegal_Instruction(),
      Some(rm') => {
          let rm_3b = encdec_rounding_mode_forwards(rm');
          let (fflags, rd_val_H) = riscv_i64ToF16(rm_3b, rs1_val_L);
          accrue_fflags(fflags);
          $[overloaded { "name" = "F_or_X_H", "is_infix" = false }] $[setter] wF_or_X_H(rd, rd_val_H);
          RETIRE_SUCCESS
      }
    }
}
and execute F_UN_RM_XF_TYPE_H((rs1, rm, rd, FCVT_H_LU)) = {
    assert($[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(xlen, 64), "./extensions/FD/zfh_insts.sail:746.19-746.20");
    let rs1_val_LU = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1), 63, 0);
    $[complete] match select_instr_or_fcsr_rm(rm) {
      None(()) => Illegal_Instruction(),
      Some(rm') => {
          let rm_3b = encdec_rounding_mode_forwards(rm');
          let (fflags, rd_val_H) = riscv_ui64ToF16(rm_3b, rs1_val_LU);
          accrue_fflags(fflags);
          $[overloaded { "name" = "F_or_X_H", "is_infix" = false }] $[setter] wF_or_X_H(rd, rd_val_H);
          RETIRE_SUCCESS
      }
    }
}
and execute F_UN_X_TYPE_H((rs1, rd, FCLASS_H)) = {
    let rs1_val_H = $[overloaded { "name" = "F_or_X_H", "is_infix" = false }] rF_or_X_H(rs1);
    let rd_val_10b : bits(10) = if f_is_neg_inf_H(rs1_val_H) then 0b0000000001
    else
      if f_is_neg_norm_H(rs1_val_H) then 0b0000000010 else
        if f_is_neg_subnorm_H(rs1_val_H) then 0b0000000100 else
          if f_is_neg_zero_H(rs1_val_H) then 0b0000001000 else
            if f_is_pos_zero_H(rs1_val_H) then 0b0000010000 else
              if f_is_pos_subnorm_H(rs1_val_H) then 0b0000100000 else
                if f_is_pos_norm_H(rs1_val_H) then 0b0001000000 else
                  if f_is_pos_inf_H(rs1_val_H) then 0b0010000000 else
                    if f_is_SNaN_H(rs1_val_H) then 0b0100000000 else
                      if f_is_QNaN_H(rs1_val_H) then 0b1000000000 else zeros(10);
    $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(rd, zero_extend(sizeof(xlen), rd_val_10b));
    RETIRE_SUCCESS
}
and execute F_UN_X_TYPE_H((rs1, rd, FMV_X_H)) = {
    let rs1_val_H = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits($[overloaded { "name" = "F", "is_infix" = false }] rF_bits(rs1), 15, 0);
    let rd_val_X : xlenbits = sign_extend(sizeof(xlen), rs1_val_H);
    $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(rd, rd_val_X);
    RETIRE_SUCCESS
}
and execute F_UN_F_TYPE_H((rs1, rd, FMV_H_X)) = {
    let rs1_val_X = $[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1);
    let rd_val_H = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(rs1_val_X, 15, 0);
    $[overloaded { "name" = "F", "is_infix" = false }] $[setter] wF_bits(rd, nan_box(mult_atom(if constraint(ext_d_supported) then
      8
    else
      4, 8), rd_val_H));
    RETIRE_SUCCESS
}
and execute FLI_H((constantidx, rd)) = {
    let bits : bits(16) = $[complete] match constantidx {
      0b00000 => {
          0xbc00
      },
      0b00001 => {
          0x0400
      },
      0b00010 => {
          0x0100
      },
      0b00011 => {
          0x0200
      },
      0b00100 => {
          0x1c00
      },
      0b00101 => {
          0x2000
      },
      0b00110 => {
          0x2c00
      },
      0b00111 => {
          0x3000
      },
      0b01000 => {
          0x3400
      },
      0b01001 => {
          0x3500
      },
      0b01010 => {
          0x3600
      },
      0b01011 => {
          0x3700
      },
      0b01100 => {
          0x3800
      },
      0b01101 => {
          0x3900
      },
      0b01110 => {
          0x3a00
      },
      0b01111 => {
          0x3b00
      },
      0b10000 => {
          0x3c00
      },
      0b10001 => {
          0x3d00
      },
      0b10010 => {
          0x3e00
      },
      0b10011 => {
          0x3f00
      },
      0b10100 => {
          0x4000
      },
      0b10101 => {
          0x4100
      },
      0b10110 => {
          0x4200
      },
      0b10111 => {
          0x4400
      },
      0b11000 => {
          0x4800
      },
      0b11001 => {
          0x4c00
      },
      0b11010 => {
          0x5800
      },
      0b11011 => {
          0x5c00
      },
      0b11100 => {
          0x7800
      },
      0b11101 => {
          0x7c00
      },
      0b11110 => {
          0x7c00
      },
      _ : bitvector(5) => {
          canonical_NaN_H()
      }
    };
    $[overloaded { "name" = "F_H", "is_infix" = false }] $[setter] wF_H(rd, bits);
    RETIRE_SUCCESS
}
and execute FLI_S((constantidx, rd)) = {
    let bits : bits(32) = $[complete] match constantidx {
      0b00000 => {
          0xbf800000
      },
      0b00001 => {
          0x00800000
      },
      0b00010 => {
          0x37800000
      },
      0b00011 => {
          0x38000000
      },
      0b00100 => {
          0x3b800000
      },
      0b00101 => {
          0x3c000000
      },
      0b00110 => {
          0x3d800000
      },
      0b00111 => {
          0x3e000000
      },
      0b01000 => {
          0x3e800000
      },
      0b01001 => {
          0x3ea00000
      },
      0b01010 => {
          0x3ec00000
      },
      0b01011 => {
          0x3ee00000
      },
      0b01100 => {
          0x3f000000
      },
      0b01101 => {
          0x3f200000
      },
      0b01110 => {
          0x3f400000
      },
      0b01111 => {
          0x3f600000
      },
      0b10000 => {
          0x3f800000
      },
      0b10001 => {
          0x3fa00000
      },
      0b10010 => {
          0x3fc00000
      },
      0b10011 => {
          0x3fe00000
      },
      0b10100 => {
          0x40000000
      },
      0b10101 => {
          0x40200000
      },
      0b10110 => {
          0x40400000
      },
      0b10111 => {
          0x40800000
      },
      0b11000 => {
          0x41000000
      },
      0b11001 => {
          0x41800000
      },
      0b11010 => {
          0x43000000
      },
      0b11011 => {
          0x43800000
      },
      0b11100 => {
          0x47000000
      },
      0b11101 => {
          0x47800000
      },
      0b11110 => {
          0x7f800000
      },
      _ : bitvector(5) => {
          canonical_NaN_S()
      }
    };
    $[overloaded { "name" = "F_S", "is_infix" = false }] $[setter] wF_S(rd, bits);
    RETIRE_SUCCESS
}
and execute FLI_D((constantidx, rd)) = {
    let bits : bits(64) = $[complete] match constantidx {
      0b00000 => {
          0xbff0000000000000
      },
      0b00001 => {
          0x0010000000000000
      },
      0b00010 => {
          0x3Ef0000000000000
      },
      0b00011 => {
          0x3f00000000000000
      },
      0b00100 => {
          0x3f70000000000000
      },
      0b00101 => {
          0x3f80000000000000
      },
      0b00110 => {
          0x3fb0000000000000
      },
      0b00111 => {
          0x3fc0000000000000
      },
      0b01000 => {
          0x3fd0000000000000
      },
      0b01001 => {
          0x3fd4000000000000
      },
      0b01010 => {
          0x3fd8000000000000
      },
      0b01011 => {
          0x3fdc000000000000
      },
      0b01100 => {
          0x3fe0000000000000
      },
      0b01101 => {
          0x3fe4000000000000
      },
      0b01110 => {
          0x3fe8000000000000
      },
      0b01111 => {
          0x3fec000000000000
      },
      0b10000 => {
          0x3ff0000000000000
      },
      0b10001 => {
          0x3ff4000000000000
      },
      0b10010 => {
          0x3ff8000000000000
      },
      0b10011 => {
          0x3ffc000000000000
      },
      0b10100 => {
          0x4000000000000000
      },
      0b10101 => {
          0x4004000000000000
      },
      0b10110 => {
          0x4008000000000000
      },
      0b10111 => {
          0x4010000000000000
      },
      0b11000 => {
          0x4020000000000000
      },
      0b11001 => {
          0x4030000000000000
      },
      0b11010 => {
          0x4060000000000000
      },
      0b11011 => {
          0x4070000000000000
      },
      0b11100 => {
          0x40e0000000000000
      },
      0b11101 => {
          0x40f0000000000000
      },
      0b11110 => {
          0x7ff0000000000000
      },
      _ : bitvector(5) => {
          canonical_NaN_D()
      }
    };
    $[overloaded { "name" = "F_D", "is_infix" = false }] $[setter] wF_D(rd, bits);
    RETIRE_SUCCESS
}
and execute FMINM_H((rs2, rs1, rd)) = {
    let rs1_val_H = $[overloaded { "name" = "F_H", "is_infix" = false }] rF_H(rs1);
    let rs2_val_H = $[overloaded { "name" = "F_H", "is_infix" = false }] rF_H(rs2);
    let is_quiet = true;
    let (rs1_lt_rs2, fflags) = fle_H(rs1_val_H, rs2_val_H, is_quiet);
    let rd_val_H = if $[overloaded { "name" = "|", "is_infix" = true }] or_bool(f_is_NaN_H(rs1_val_H), f_is_NaN_H(rs2_val_H)) then
      canonical_NaN_H()
    else
      if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(f_is_neg_zero_H(rs1_val_H), f_is_pos_zero_H(rs2_val_H)) then
        rs1_val_H
      else
        if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(f_is_neg_zero_H(rs2_val_H), f_is_pos_zero_H(rs1_val_H)) then
          rs2_val_H
        else
          if rs1_lt_rs2 then rs1_val_H else rs2_val_H;
    accrue_fflags(fflags);
    $[overloaded { "name" = "F_H", "is_infix" = false }] $[setter] wF_H(rd, rd_val_H);
    RETIRE_SUCCESS
}
and execute FMAXM_H((rs2, rs1, rd)) = {
    let rs1_val_H = $[overloaded { "name" = "F_H", "is_infix" = false }] rF_H(rs1);
    let rs2_val_H = $[overloaded { "name" = "F_H", "is_infix" = false }] rF_H(rs2);
    let is_quiet = true;
    let (rs2_lt_rs1, fflags) = fle_H(rs2_val_H, rs1_val_H, is_quiet);
    let rd_val_H = if $[overloaded { "name" = "|", "is_infix" = true }] or_bool(f_is_NaN_H(rs1_val_H), f_is_NaN_H(rs2_val_H)) then
      canonical_NaN_H()
    else
      if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(f_is_neg_zero_H(rs1_val_H), f_is_pos_zero_H(rs2_val_H)) then
        rs2_val_H
      else
        if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(f_is_neg_zero_H(rs2_val_H), f_is_pos_zero_H(rs1_val_H)) then
          rs1_val_H
        else
          if rs2_lt_rs1 then rs1_val_H else rs2_val_H;
    accrue_fflags(fflags);
    $[overloaded { "name" = "F_H", "is_infix" = false }] $[setter] wF_H(rd, rd_val_H);
    RETIRE_SUCCESS
}
and execute FMINM_S((rs2, rs1, rd)) = {
    let rs1_val_S = $[overloaded { "name" = "F_S", "is_infix" = false }] rF_S(rs1);
    let rs2_val_S = $[overloaded { "name" = "F_S", "is_infix" = false }] rF_S(rs2);
    let is_quiet = true;
    let (rs1_lt_rs2, fflags) = fle_S(rs1_val_S, rs2_val_S, is_quiet);
    let rd_val_S = if $[overloaded { "name" = "|", "is_infix" = true }] or_bool(f_is_NaN_S(rs1_val_S), f_is_NaN_S(rs2_val_S)) then
      canonical_NaN_S()
    else
      if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(f_is_neg_zero_S(rs1_val_S), f_is_pos_zero_S(rs2_val_S)) then
        rs1_val_S
      else
        if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(f_is_neg_zero_S(rs2_val_S), f_is_pos_zero_S(rs1_val_S)) then
          rs2_val_S
        else
          if rs1_lt_rs2 then rs1_val_S else rs2_val_S;
    accrue_fflags(fflags);
    $[overloaded { "name" = "F_S", "is_infix" = false }] $[setter] wF_S(rd, rd_val_S);
    RETIRE_SUCCESS
}
and execute FMAXM_S((rs2, rs1, rd)) = {
    let rs1_val_S = $[overloaded { "name" = "F_S", "is_infix" = false }] rF_S(rs1);
    let rs2_val_S = $[overloaded { "name" = "F_S", "is_infix" = false }] rF_S(rs2);
    let is_quiet = true;
    let (rs2_lt_rs1, fflags) = fle_S(rs2_val_S, rs1_val_S, is_quiet);
    let rd_val_S = if $[overloaded { "name" = "|", "is_infix" = true }] or_bool(f_is_NaN_S(rs1_val_S), f_is_NaN_S(rs2_val_S)) then
      canonical_NaN_S()
    else
      if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(f_is_neg_zero_S(rs1_val_S), f_is_pos_zero_S(rs2_val_S)) then
        rs2_val_S
      else
        if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(f_is_neg_zero_S(rs2_val_S), f_is_pos_zero_S(rs1_val_S)) then
          rs1_val_S
        else
          if rs2_lt_rs1 then rs1_val_S else rs2_val_S;
    accrue_fflags(fflags);
    $[overloaded { "name" = "F_S", "is_infix" = false }] $[setter] wF_S(rd, rd_val_S);
    RETIRE_SUCCESS
}
and execute FMINM_D((rs2, rs1, rd)) = {
    let rs1_val_D = $[overloaded { "name" = "F_D", "is_infix" = false }] rF_D(rs1);
    let rs2_val_D = $[overloaded { "name" = "F_D", "is_infix" = false }] rF_D(rs2);
    let is_quiet = true;
    let (rs1_lt_rs2, fflags) = fle_D(rs1_val_D, rs2_val_D, is_quiet);
    let rd_val_D = if $[overloaded { "name" = "|", "is_infix" = true }] or_bool(f_is_NaN_D(rs1_val_D), f_is_NaN_D(rs2_val_D)) then
      canonical_NaN_D()
    else
      if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(f_is_neg_zero_D(rs1_val_D), f_is_pos_zero_D(rs2_val_D)) then
        rs1_val_D
      else
        if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(f_is_neg_zero_D(rs2_val_D), f_is_pos_zero_D(rs1_val_D)) then
          rs2_val_D
        else
          if rs1_lt_rs2 then rs1_val_D else rs2_val_D;
    accrue_fflags(fflags);
    $[overloaded { "name" = "F_D", "is_infix" = false }] $[setter] wF_D(rd, rd_val_D);
    RETIRE_SUCCESS
}
and execute FMAXM_D((rs2, rs1, rd)) = {
    let rs1_val_D = $[overloaded { "name" = "F_D", "is_infix" = false }] rF_D(rs1);
    let rs2_val_D = $[overloaded { "name" = "F_D", "is_infix" = false }] rF_D(rs2);
    let is_quiet = true;
    let (rs2_lt_rs1, fflags) = fle_D(rs2_val_D, rs1_val_D, is_quiet);
    let rd_val_D = if $[overloaded { "name" = "|", "is_infix" = true }] or_bool(f_is_NaN_D(rs1_val_D), f_is_NaN_D(rs2_val_D)) then
      canonical_NaN_D()
    else
      if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(f_is_neg_zero_D(rs1_val_D), f_is_pos_zero_D(rs2_val_D)) then
        rs2_val_D
      else
        if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(f_is_neg_zero_D(rs2_val_D), f_is_pos_zero_D(rs1_val_D)) then
          rs1_val_D
        else
          if rs2_lt_rs1 then rs1_val_D else rs2_val_D;
    accrue_fflags(fflags);
    $[overloaded { "name" = "F_D", "is_infix" = false }] $[setter] wF_D(rd, rd_val_D);
    RETIRE_SUCCESS
}
and execute FROUND_H((rs1, rm, rd)) = {
    let rs1_val_H = $[overloaded { "name" = "F_H", "is_infix" = false }] rF_H(rs1);
    $[complete] match select_instr_or_fcsr_rm(rm) {
      None(()) => Illegal_Instruction(),
      Some(rm') => {
          let rm_3b = encdec_rounding_mode_forwards(rm');
          let (fflags, rd_val_H) = riscv_f16roundToInt(rm_3b, rs1_val_H, false);
          accrue_fflags(fflags);
          $[overloaded { "name" = "F_H", "is_infix" = false }] $[setter] wF_H(rd, rd_val_H);
          RETIRE_SUCCESS
      }
    }
}
and execute FROUNDNX_H((rs1, rm, rd)) = {
    let rs1_val_H = $[overloaded { "name" = "F_H", "is_infix" = false }] rF_H(rs1);
    $[complete] match select_instr_or_fcsr_rm(rm) {
      None(()) => Illegal_Instruction(),
      Some(rm') => {
          let rm_3b = encdec_rounding_mode_forwards(rm');
          let (fflags, rd_val_H) = riscv_f16roundToInt(rm_3b, rs1_val_H, true);
          accrue_fflags(fflags);
          $[overloaded { "name" = "F_H", "is_infix" = false }] $[setter] wF_H(rd, rd_val_H);
          RETIRE_SUCCESS
      }
    }
}
and execute FROUND_S((rs1, rm, rd)) = {
    let rs1_val_S = $[overloaded { "name" = "F_S", "is_infix" = false }] rF_S(rs1);
    $[complete] match select_instr_or_fcsr_rm(rm) {
      None(()) => Illegal_Instruction(),
      Some(rm') => {
          let rm_3b = encdec_rounding_mode_forwards(rm');
          let (fflags, rd_val_S) = riscv_f32roundToInt(rm_3b, rs1_val_S, false);
          accrue_fflags(fflags);
          $[overloaded { "name" = "F_S", "is_infix" = false }] $[setter] wF_S(rd, rd_val_S);
          RETIRE_SUCCESS
      }
    }
}
and execute FROUNDNX_S((rs1, rm, rd)) = {
    let rs1_val_S = $[overloaded { "name" = "F_S", "is_infix" = false }] rF_S(rs1);
    $[complete] match select_instr_or_fcsr_rm(rm) {
      None(()) => Illegal_Instruction(),
      Some(rm') => {
          let rm_3b = encdec_rounding_mode_forwards(rm');
          let (fflags, rd_val_S) = riscv_f32roundToInt(rm_3b, rs1_val_S, true);
          accrue_fflags(fflags);
          $[overloaded { "name" = "F_S", "is_infix" = false }] $[setter] wF_S(rd, rd_val_S);
          RETIRE_SUCCESS
      }
    }
}
and execute FROUND_D((rs1, rm, rd)) = {
    let rs1_val_D = $[overloaded { "name" = "F_D", "is_infix" = false }] rF_D(rs1);
    $[complete] match select_instr_or_fcsr_rm(rm) {
      None(()) => Illegal_Instruction(),
      Some(rm') => {
          let rm_3b = encdec_rounding_mode_forwards(rm');
          let (fflags, rd_val_D) = riscv_f64roundToInt(rm_3b, rs1_val_D, false);
          accrue_fflags(fflags);
          $[overloaded { "name" = "F_D", "is_infix" = false }] $[setter] wF_D(rd, rd_val_D);
          RETIRE_SUCCESS
      }
    }
}
and execute FROUNDNX_D((rs1, rm, rd)) = {
    let rs1_val_D = $[overloaded { "name" = "F_D", "is_infix" = false }] rF_D(rs1);
    $[complete] match select_instr_or_fcsr_rm(rm) {
      None(()) => Illegal_Instruction(),
      Some(rm') => {
          let rm_3b = encdec_rounding_mode_forwards(rm');
          let (fflags, rd_val_D) = riscv_f64roundToInt(rm_3b, rs1_val_D, true);
          accrue_fflags(fflags);
          $[overloaded { "name" = "F_D", "is_infix" = false }] $[setter] wF_D(rd, rd_val_D);
          RETIRE_SUCCESS
      }
    }
}
and execute FMVH_X_D((rs1, rd)) = {
    let rs1_val_D = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits($[overloaded { "name" = "F_D", "is_infix" = false }] rF_D(rs1), 63, 32);
    let rd_val_X : xlenbits = sign_extend(sizeof(xlen), rs1_val_D);
    $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(rd, rd_val_X);
    RETIRE_SUCCESS
}
and execute FMVP_D_X((rs2, rs1, rd)) = {
    let rs1_val_X = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1), 31, 0);
    let rs2_val_X = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs2), 31, 0);
    let rd_val_D = $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(rs2_val_X, rs1_val_X);
    $[overloaded { "name" = "F_D", "is_infix" = false }] $[setter] wF_D(rd, rd_val_D);
    RETIRE_SUCCESS
}
and execute FLEQ_H((rs2, rs1, rd)) = {
    let rs1_val_H = $[overloaded { "name" = "F_H", "is_infix" = false }] rF_H(rs1);
    let rs2_val_H = $[overloaded { "name" = "F_H", "is_infix" = false }] rF_H(rs2);
    let (fflags, rd_val) : (bits_fflags, bool) = riscv_f16Le_quiet(rs1_val_H, rs2_val_H);
    accrue_fflags(fflags);
    $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(rd, zero_extend(sizeof(xlen), bool_to_bits(rd_val)));
    RETIRE_SUCCESS
}
and execute FLTQ_H((rs2, rs1, rd)) = {
    let rs1_val_H = $[overloaded { "name" = "F_H", "is_infix" = false }] rF_H(rs1);
    let rs2_val_H = $[overloaded { "name" = "F_H", "is_infix" = false }] rF_H(rs2);
    let (fflags, rd_val) : (bits_fflags, bool) = riscv_f16Lt_quiet(rs1_val_H, rs2_val_H);
    accrue_fflags(fflags);
    $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(rd, zero_extend(sizeof(xlen), bool_to_bits(rd_val)));
    RETIRE_SUCCESS
}
and execute FLEQ_S((rs2, rs1, rd)) = {
    let rs1_val_S = $[overloaded { "name" = "F_S", "is_infix" = false }] rF_S(rs1);
    let rs2_val_S = $[overloaded { "name" = "F_S", "is_infix" = false }] rF_S(rs2);
    let (fflags, rd_val) : (bits_fflags, bool) = riscv_f32Le_quiet(rs1_val_S, rs2_val_S);
    accrue_fflags(fflags);
    $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(rd, zero_extend(sizeof(xlen), bool_to_bits(rd_val)));
    RETIRE_SUCCESS
}
and execute FLTQ_S((rs2, rs1, rd)) = {
    let rs1_val_S = $[overloaded { "name" = "F_S", "is_infix" = false }] rF_S(rs1);
    let rs2_val_S = $[overloaded { "name" = "F_S", "is_infix" = false }] rF_S(rs2);
    let (fflags, rd_val) : (bits_fflags, bool) = riscv_f32Lt_quiet(rs1_val_S, rs2_val_S);
    accrue_fflags(fflags);
    $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(rd, zero_extend(sizeof(xlen), bool_to_bits(rd_val)));
    RETIRE_SUCCESS
}
and execute FLEQ_D((rs2, rs1, rd)) = {
    let rs1_val_D = $[overloaded { "name" = "F_D", "is_infix" = false }] rF_D(rs1);
    let rs2_val_D = $[overloaded { "name" = "F_D", "is_infix" = false }] rF_D(rs2);
    let (fflags, rd_val) : (bits_fflags, bool) = riscv_f64Le_quiet(rs1_val_D, rs2_val_D);
    accrue_fflags(fflags);
    $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(rd, zero_extend(sizeof(xlen), bool_to_bits(rd_val)));
    RETIRE_SUCCESS
}
and execute FLTQ_D((rs2, rs1, rd)) = {
    let rs1_val_D = $[overloaded { "name" = "F_D", "is_infix" = false }] rF_D(rs1);
    let rs2_val_D = $[overloaded { "name" = "F_D", "is_infix" = false }] rF_D(rs2);
    let (fflags, rd_val) : (bits_fflags, bool) = riscv_f64Lt_quiet(rs1_val_D, rs2_val_D);
    accrue_fflags(fflags);
    $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(rd, zero_extend(sizeof(xlen), bool_to_bits(rd_val)));
    RETIRE_SUCCESS
}
and execute FCVTMOD_W_D((rs1, rd)) = {
    let rs1_val_D = $[overloaded { "name" = "F_D", "is_infix" = false }] rF_D(rs1);
    let (fflags, rd_val) = fcvtmod_helper(rs1_val_D);
    accrue_fflags(fflags);
    $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(rd, sign_extend(sizeof(xlen), rd_val));
    RETIRE_SUCCESS
}
and execute VSETVLI((ma, ta, sew, lmul, rs1, rd)) = {
    let LMUL_pow_ori = get_lmul_pow();
    let SEW_pow_ori = get_sew_pow();
    let ratio_pow_ori = $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(SEW_pow_ori, LMUL_pow_ori);
    if $[overloaded { "name" = "|", "is_infix" = true }] or_bool(is_invalid_lmul_pow(lmul), is_invalid_sew_pow(sew)) then {
        handle_illegal_vtype();
        return(RETIRE_SUCCESS)
    };
    let LMUL_pow_new = lmul_pow_val_forwards(lmul);
    let SEW_pow_new = sew_pow_val_forwards(sew);
    if $[overloaded { "name" = ">", "is_infix" = true }] gt_int(SEW_pow_new, $[overloaded { "name" = "+", "is_infix" = true }] add_atom(LMUL_pow_new, elen_exp)) then {
        handle_illegal_vtype();
        return(RETIRE_SUCCESS)
    };
    let VLMAX = 2 ^ sub_atom($[overloaded { "name" = "+", "is_infix" = true }] add_atom(LMUL_pow_new, vlen_exp), SEW_pow_new);
    if $[overloaded { "name" = "!=", "is_infix" = true }] neq_anything(rs1, zreg) then {
        let rs1_val = $[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1);
        let AVL = unsigned(rs1_val);
        vl = calculate_new_vl(AVL, VLMAX);
        $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(rd, vl)
    } else if $[overloaded { "name" = "!=", "is_infix" = true }] neq_anything(rd, zreg) then {
        vl = to_bits_unsafe(xlen, VLMAX);
        $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(rd, vl)
    } else {
        let ratio_pow_new = $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(SEW_pow_new, LMUL_pow_new);
        let is_legal_vset = $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_int(ratio_pow_new, ratio_pow_ori), valid_vtype());
        if not(is_legal_vset) then {
            handle_illegal_vtype();
            return(RETIRE_SUCCESS)
        };
        ()
    };
    vtype.bits = $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(0b0, $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(zeros($[overloaded { "name" = "-", "is_infix" = true }] sub_atom(xlen, 9)), $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(ma, $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(ta, $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(sew, lmul)))));
    set_vstart(zeros(16));
    $[overloaded { "name" = "csr_write_callback", "is_infix" = false }] csr_name_write_callback("vtype", vtype.bits);
    $[overloaded { "name" = "csr_write_callback", "is_infix" = false }] csr_name_write_callback("vl", vl);
    $[overloaded { "name" = "csr_write_callback", "is_infix" = false }] csr_name_write_callback("vstart", vstart);
    RETIRE_SUCCESS
}
and execute VSETVL((rs2, rs1, rd)) = {
    let LMUL_pow_ori = get_lmul_pow();
    let SEW_pow_ori = get_sew_pow();
    let ratio_pow_ori = $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(SEW_pow_ori, LMUL_pow_ori);
    let vtype_new = Mk_Vtype($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs2));
    if $[overloaded { "name" = "|", "is_infix" = true }] or_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_bits(_get_Vtype_vill(vtype_new), 0b1), $[overloaded { "name" = "!=", "is_infix" = true }] neq_bits(_get_Vtype_reserved(vtype_new), zeros(sub_atom(sizeof(xlen), 9)))) then {
        handle_illegal_vtype();
        return(RETIRE_SUCCESS)
    };
    let ma = _get_Vtype_vma(vtype_new);
    let ta = _get_Vtype_vta(vtype_new);
    let sew = _get_Vtype_vsew(vtype_new);
    let lmul = _get_Vtype_vlmul(vtype_new);
    if $[overloaded { "name" = "|", "is_infix" = true }] or_bool(is_invalid_lmul_pow(lmul), is_invalid_sew_pow(sew)) then {
        handle_illegal_vtype();
        return(RETIRE_SUCCESS)
    };
    let LMUL_pow_new = lmul_pow_val_forwards(lmul);
    let SEW_pow_new = sew_pow_val_forwards(sew);
    if $[overloaded { "name" = ">", "is_infix" = true }] gt_int(SEW_pow_new, $[overloaded { "name" = "+", "is_infix" = true }] add_atom(LMUL_pow_new, elen_exp)) then {
        handle_illegal_vtype();
        return(RETIRE_SUCCESS)
    };
    let VLMAX = 2 ^ sub_atom($[overloaded { "name" = "+", "is_infix" = true }] add_atom(LMUL_pow_new, vlen_exp), SEW_pow_new);
    if $[overloaded { "name" = "!=", "is_infix" = true }] neq_anything(rs1, zreg) then {
        let rs1_val = $[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1);
        let AVL = unsigned(rs1_val);
        vl = calculate_new_vl(AVL, VLMAX);
        $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(rd, vl)
    } else if $[overloaded { "name" = "!=", "is_infix" = true }] neq_anything(rd, zreg) then {
        vl = to_bits_unsafe(xlen, VLMAX);
        $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(rd, vl)
    } else {
        let ratio_pow_new = $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(SEW_pow_new, LMUL_pow_new);
        let is_legal_vset = $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_int(ratio_pow_new, ratio_pow_ori), valid_vtype());
        if not(is_legal_vset) then {
            handle_illegal_vtype();
            return(RETIRE_SUCCESS)
        };
        ()
    };
    vtype.bits = $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(0b0, $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(zeros($[overloaded { "name" = "-", "is_infix" = true }] sub_atom(xlen, 9)), $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(ma, $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(ta, $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(sew, lmul)))));
    set_vstart(zeros(16));
    $[overloaded { "name" = "csr_write_callback", "is_infix" = false }] csr_name_write_callback("vtype", vtype.bits);
    $[overloaded { "name" = "csr_write_callback", "is_infix" = false }] csr_name_write_callback("vl", vl);
    $[overloaded { "name" = "csr_write_callback", "is_infix" = false }] csr_name_write_callback("vstart", vstart);
    RETIRE_SUCCESS
}
and execute VSETIVLI((ma, ta, sew, lmul, uimm, rd)) = {
    if $[overloaded { "name" = "|", "is_infix" = true }] or_bool(is_invalid_lmul_pow(lmul), is_invalid_sew_pow(sew)) then {
        handle_illegal_vtype();
        return(RETIRE_SUCCESS)
    };
    let LMUL_pow_new = lmul_pow_val_forwards(lmul);
    let SEW_pow_new = sew_pow_val_forwards(sew);
    if $[overloaded { "name" = ">", "is_infix" = true }] gt_int(SEW_pow_new, $[overloaded { "name" = "+", "is_infix" = true }] add_atom(LMUL_pow_new, elen_exp)) then {
        handle_illegal_vtype();
        return(RETIRE_SUCCESS)
    };
    let VLMAX = 2 ^ sub_atom($[overloaded { "name" = "+", "is_infix" = true }] add_atom(LMUL_pow_new, vlen_exp), SEW_pow_new);
    let AVL = unsigned(uimm);
    vl = calculate_new_vl(AVL, VLMAX);
    $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(rd, vl);
    vtype.bits = $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(0b0, $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(zeros($[overloaded { "name" = "-", "is_infix" = true }] sub_atom(xlen, 9)), $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(ma, $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(ta, $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(sew, lmul)))));
    set_vstart(zeros(16));
    $[overloaded { "name" = "csr_write_callback", "is_infix" = false }] csr_name_write_callback("vtype", vtype.bits);
    $[overloaded { "name" = "csr_write_callback", "is_infix" = false }] csr_name_write_callback("vl", vl);
    $[overloaded { "name" = "csr_write_callback", "is_infix" = false }] csr_name_write_callback("vstart", vstart);
    RETIRE_SUCCESS
}
and execute VVTYPE((funct6, vm, vs2, vs1, vd)) = {
    let SEW_pow = get_sew_pow();
    let SEW = get_sew();
    let LMUL_pow = get_lmul_pow();
    let num_elem = get_num_elem(LMUL_pow, SEW);
    if illegal_normal(vd, vm) then return(Illegal_Instruction());
    let 'n = num_elem;
    let 'm = SEW;
    let vm_val : bits('n) = read_vmask(num_elem, vm, zvreg);
    let vs1_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);
    let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);
    let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);
    let (initial_result, mask) : (vector('n, bits('m)), bits('n)) = $[complete] match init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val) {
      Ok(v) => v,
      Err(()) => return(Illegal_Instruction())
    };
    var result = initial_result;
    foreach (i from 0 to sub_atom(num_elem, 1) by 1 in inc) {
        if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(mask, i), bitone) then {
            result[i] = $[complete] match funct6 {
              VV_VADD => $[overloaded { "name" = "+", "is_infix" = true }] add_bits($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs1_val, i)),
              VV_VSUB => $[overloaded { "name" = "-", "is_infix" = true }] sub_vec($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs1_val, i)),
              VV_VAND => $[overloaded { "name" = "&", "is_infix" = true }] and_vec($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs1_val, i)),
              VV_VOR => $[overloaded { "name" = "|", "is_infix" = true }] or_vec($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs1_val, i)),
              VV_VXOR => $[overloaded { "name" = "^", "is_infix" = true }] xor_vec($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs1_val, i)),
              VV_VSADDU => unsigned_saturation($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), $[overloaded { "name" = "+", "is_infix" = true }] add_bits(zero_extend($[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), 1), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)), zero_extend($[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), 1), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs1_val, i)))),
              VV_VSADD => signed_saturation($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), $[overloaded { "name" = "+", "is_infix" = true }] add_bits(sign_extend($[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), 1), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)), sign_extend($[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), 1), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs1_val, i)))),
              VV_VSSUBU => {
                  if $[overloaded { "name" = "<", "is_infix" = true }] lt_int(unsigned($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)), unsigned($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs1_val, i))) then
                    zeros($[overloaded { "name" = "__size", "is_infix" = false }] __id(m))
                  else
                    unsigned_saturation($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), $[overloaded { "name" = "-", "is_infix" = true }] sub_vec(zero_extend($[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), 1), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)), zero_extend($[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), 1), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs1_val, i))))
              },
              VV_VSSUB => signed_saturation($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), $[overloaded { "name" = "-", "is_infix" = true }] sub_vec(sign_extend($[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), 1), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)), sign_extend($[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), 1), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs1_val, i)))),
              VV_VSMUL => {
                  let result_mul = to_bits_unsafe($[overloaded { "name" = "*", "is_infix" = true }] mult_atom($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), 2), $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(signed($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)), signed($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs1_val, i))));
                  let rounding_incr = get_fixed_rounding_incr(result_mul, $[overloaded { "name" = "-", "is_infix" = true }] sub_atom($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), 1));
                  let result_wide = $[overloaded { "name" = "+", "is_infix" = true }] add_bits($[overloaded { "name" = ">>", "is_infix" = true }] shiftr(result_mul, $[overloaded { "name" = "-", "is_infix" = true }] sub_atom($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), 1)), zero_extend($[overloaded { "name" = "*", "is_infix" = true }] mult_atom($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), 2), rounding_incr));
                  signed_saturation($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(result_wide, $[overloaded { "name" = "__size", "is_infix" = false }] __id(m), 0))
              },
              VV_VSLL => {
                  let shift_amount = get_shift_amount($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs1_val, i), SEW);
                  $[overloaded { "name" = "<<", "is_infix" = true }] shiftl($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i), shift_amount)
              },
              VV_VSRL => {
                  let shift_amount = get_shift_amount($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs1_val, i), SEW);
                  $[overloaded { "name" = ">>", "is_infix" = true }] shiftr($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i), shift_amount)
              },
              VV_VSRA => {
                  let shift_amount = get_shift_amount($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs1_val, i), SEW);
                  let v_double : bits('m * 2) = sign_extend(mult_atom($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), 2), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i));
                  $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits($[overloaded { "name" = ">>", "is_infix" = true }] shiftr(v_double, shift_amount), $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(SEW, 1), 0)
              },
              VV_VSSRL => {
                  let shift_amount = get_shift_amount($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs1_val, i), SEW);
                  let rounding_incr = get_fixed_rounding_incr($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i), shift_amount);
                  $[overloaded { "name" = "+", "is_infix" = true }] add_bits($[overloaded { "name" = ">>", "is_infix" = true }] shiftr($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i), shift_amount), zero_extend($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), rounding_incr))
              },
              VV_VSSRA => {
                  let shift_amount = get_shift_amount($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs1_val, i), SEW);
                  let rounding_incr = get_fixed_rounding_incr($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i), shift_amount);
                  let v_double : bits('m * 2) = sign_extend(mult_atom($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), 2), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i));
                  $[overloaded { "name" = "+", "is_infix" = true }] add_bits($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits($[overloaded { "name" = ">>", "is_infix" = true }] shiftr(v_double, shift_amount), $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(SEW, 1), 0), zero_extend($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), rounding_incr))
              },
              VV_VMINU => to_bits_unsafe(SEW, $[overloaded { "name" = "min", "is_infix" = false }] min_int(unsigned($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)), unsigned($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs1_val, i)))),
              VV_VMIN => to_bits_unsafe(SEW, $[overloaded { "name" = "min", "is_infix" = false }] min_int(signed($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)), signed($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs1_val, i)))),
              VV_VMAXU => to_bits_unsafe(SEW, $[overloaded { "name" = "max", "is_infix" = false }] max_int(unsigned($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)), unsigned($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs1_val, i)))),
              VV_VMAX => to_bits_unsafe(SEW, $[overloaded { "name" = "max", "is_infix" = false }] max_int(signed($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)), signed($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs1_val, i)))),
              VV_VRGATHER => {
                  if $[overloaded { "name" = "|", "is_infix" = true }] or_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_anything(vs1, vd), $[overloaded { "name" = "==", "is_infix" = true }] eq_anything(vs2, vd)) then return(Illegal_Instruction());
                  let idx = unsigned($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs1_val, i));
                  assert($[overloaded { "name" = ">=", "is_infix" = true }] gteq_int($[overloaded { "name" = "-", "is_infix" = true }] sub_atom($[overloaded { "name" = "+", "is_infix" = true }] add_atom(LMUL_pow, vlen_exp), SEW_pow), 0), "./extensions/V/vext_arith_insts.sail:121.71-121.72");
                  let VLMAX = 2 ^ sub_atom($[overloaded { "name" = "+", "is_infix" = true }] add_atom(LMUL_pow, vlen_exp), SEW_pow);
                  assert($[overloaded { "name" = "<=", "is_infix" = true }] lteq_int(VLMAX, $[overloaded { "name" = "__size", "is_infix" = false }] __id(n)), "./extensions/V/vext_arith_insts.sail:123.48-123.49");
                  if $[overloaded { "name" = "<", "is_infix" = true }] lt_int(idx, VLMAX) then
                    $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, idx)
                  else
                    zeros($[overloaded { "name" = "__size", "is_infix" = false }] __id(m))
              },
              VV_VRGATHEREI16 => {
                  if $[overloaded { "name" = "|", "is_infix" = true }] or_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_anything(vs1, vd), $[overloaded { "name" = "==", "is_infix" = true }] eq_anything(vs2, vd)) then return(Illegal_Instruction());
                  let vs1_new : vector('n, bits(16)) = read_vreg(num_elem, 16, $[overloaded { "name" = "-", "is_infix" = true }] sub_atom($[overloaded { "name" = "+", "is_infix" = true }] add_atom(4, LMUL_pow), SEW_pow), vs1);
                  let idx = unsigned($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs1_new, i));
                  assert($[overloaded { "name" = ">=", "is_infix" = true }] gteq_int($[overloaded { "name" = "-", "is_infix" = true }] sub_atom($[overloaded { "name" = "+", "is_infix" = true }] add_atom(LMUL_pow, vlen_exp), SEW_pow), 0), "./extensions/V/vext_arith_insts.sail:131.71-131.72");
                  let VLMAX = 2 ^ sub_atom($[overloaded { "name" = "+", "is_infix" = true }] add_atom(LMUL_pow, vlen_exp), SEW_pow);
                  assert($[overloaded { "name" = "<=", "is_infix" = true }] lteq_int(VLMAX, $[overloaded { "name" = "__size", "is_infix" = false }] __id(n)), "./extensions/V/vext_arith_insts.sail:133.48-133.49");
                  if $[overloaded { "name" = "<", "is_infix" = true }] lt_int(idx, VLMAX) then
                    $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, idx)
                  else
                    zeros($[overloaded { "name" = "__size", "is_infix" = false }] __id(m))
              }
            }
        };
        ()
    };
    write_vreg(num_elem, SEW, LMUL_pow, vd, result);
    set_vstart(zeros(16));
    RETIRE_SUCCESS
}
and execute NVSTYPE((funct6, vm, vs2, vs1, vd)) = {
    let SEW = get_sew();
    let LMUL_pow = get_lmul_pow();
    let num_elem = get_num_elem(LMUL_pow, SEW);
    let SEW_widen = $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(SEW, 2);
    let LMUL_pow_widen = $[overloaded { "name" = "+", "is_infix" = true }] add_atom(LMUL_pow, 1);
    if $[overloaded { "name" = "|", "is_infix" = true }] or_bool(illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen), not(valid_reg_overlap(vs2, vd, LMUL_pow_widen, LMUL_pow))) then return(Illegal_Instruction());
    assert($[overloaded { "name" = "<=", "is_infix" = true }] lteq_int(SEW_widen, 64), "./extensions/V/vext_arith_insts.sail:196.24-196.25");
    let 'n = num_elem;
    let 'm = SEW;
    let 'o = SEW_widen;
    let vm_val : bits('n) = read_vmask(num_elem, vm, zvreg);
    let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);
    let vs1_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);
    let vs2_val : vector('n, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2);
    let (initial_result, mask) : (vector('n, bits('m)), bits('n)) = $[complete] match init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val) {
      Ok(v) => v,
      Err(()) => return(Illegal_Instruction())
    };
    var result = initial_result;
    foreach (i from 0 to sub_atom(num_elem, 1) by 1 in inc) {
        if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(mask, i), bitone) then {
            result[i] = $[complete] match funct6 {
              NVS_VNSRL => {
                  let shift_amount = get_shift_amount($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs1_val, i), SEW_widen);
                  $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits($[overloaded { "name" = ">>", "is_infix" = true }] shiftr($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i), shift_amount), $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(SEW, 1), 0)
              },
              NVS_VNSRA => {
                  let shift_amount = get_shift_amount($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs1_val, i), SEW_widen);
                  let v_double : bits('o * 2) = sign_extend(mult_atom($[overloaded { "name" = "__size", "is_infix" = false }] __id(o), 2), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i));
                  let arith_shifted : bits('o) = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits($[overloaded { "name" = ">>", "is_infix" = true }] shiftr(v_double, shift_amount), $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(SEW_widen, 1), 0);
                  $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(arith_shifted, $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(SEW, 1), 0)
              }
            }
        };
        ()
    };
    write_vreg(num_elem, SEW, LMUL_pow, vd, result);
    set_vstart(zeros(16));
    RETIRE_SUCCESS
}
and execute NVTYPE((funct6, vm, vs2, vs1, vd)) = {
    let SEW = get_sew();
    let LMUL_pow = get_lmul_pow();
    let num_elem = get_num_elem(LMUL_pow, SEW);
    let SEW_widen = $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(SEW, 2);
    let LMUL_pow_widen = $[overloaded { "name" = "+", "is_infix" = true }] add_atom(LMUL_pow, 1);
    if $[overloaded { "name" = "|", "is_infix" = true }] or_bool(illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen), not(valid_reg_overlap(vs2, vd, LMUL_pow_widen, LMUL_pow))) then return(Illegal_Instruction());
    assert($[overloaded { "name" = "<=", "is_infix" = true }] lteq_int(SEW_widen, 64), "./extensions/V/vext_arith_insts.sail:267.24-267.25");
    let 'n = num_elem;
    let 'm = SEW;
    let 'o = SEW_widen;
    let vm_val : bits('n) = read_vmask(num_elem, vm, zvreg);
    let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);
    let vs1_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);
    let vs2_val : vector('n, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2);
    let (initial_result, mask) : (vector('n, bits('m)), bits('n)) = $[complete] match init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val) {
      Ok(v) => v,
      Err(()) => return(Illegal_Instruction())
    };
    var result = initial_result;
    foreach (i from 0 to sub_atom(num_elem, 1) by 1 in inc) {
        if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(mask, i), bitone) then {
            let shift_amount = get_shift_amount($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs1_val, i), SEW_widen);
            let rounding_incr = get_fixed_rounding_incr($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i), shift_amount);
            result[i] = $[complete] match funct6 {
              NV_VNCLIPU => {
                  let result_wide = $[overloaded { "name" = "+", "is_infix" = true }] add_bits($[overloaded { "name" = ">>", "is_infix" = true }] shiftr($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i), shift_amount), zero_extend($[overloaded { "name" = "__size", "is_infix" = false }] __id(o), rounding_incr));
                  unsigned_saturation($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), result_wide)
              },
              NV_VNCLIP => {
                  let v_double : bits('m * 4) = sign_extend(mult_atom($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), 4), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i));
                  let result_wide = $[overloaded { "name" = "+", "is_infix" = true }] add_bits($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits($[overloaded { "name" = ">>", "is_infix" = true }] shiftr(v_double, shift_amount), $[overloaded { "name" = "-", "is_infix" = true }] sub_atom($[overloaded { "name" = "__size", "is_infix" = false }] __id(o), 1), 0), zero_extend($[overloaded { "name" = "__size", "is_infix" = false }] __id(o), rounding_incr));
                  signed_saturation($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), result_wide)
              }
            }
        };
        ()
    };
    write_vreg(num_elem, SEW, LMUL_pow, vd, result);
    set_vstart(zeros(16));
    RETIRE_SUCCESS
}
and execute MASKTYPEV((vs2, vs1, vd)) = {
    let start_element : nat = $[complete] match get_start_element() {
      Ok(v) => v,
      Err(()) => return(Illegal_Instruction())
    };
    let end_element = get_end_element();
    let SEW = get_sew();
    let LMUL_pow = get_lmul_pow();
    let num_elem = get_num_elem(LMUL_pow, SEW);
    let real_num_elem = if $[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(LMUL_pow, 0) then
      num_elem
    else
      $[overloaded { "name" = "/", "is_infix" = true }] quot_positive_round_zero(num_elem, $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(0, LMUL_pow));
    if illegal_vd_masked(vd) then return(Illegal_Instruction());
    let 'n = num_elem;
    let 'm = SEW;
    let vm_val : bits('n) = read_vmask(num_elem, 0b0, zvreg);
    let vs1_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);
    let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);
    let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);
    var result : vector('n, bits('m)) = vector_init($[overloaded { "name" = "__size", "is_infix" = false }] __id(n), zeros($[overloaded { "name" = "__size", "is_infix" = false }] __id(m)));
    let tail_ag : agtype = get_vtype_vta();
    foreach (i from 0 to sub_atom(num_elem, 1) by 1 in inc) {
        if $[overloaded { "name" = "<", "is_infix" = true }] lt_int(i, start_element) then {
            result[i] = $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vd_val, i)
        } else if $[overloaded { "name" = "|", "is_infix" = true }] or_bool($[overloaded { "name" = ">", "is_infix" = true }] gt_int(i, end_element), $[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(i, real_num_elem)) then {
            result[i] = $[complete] match tail_ag {
              UNDISTURBED => $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vd_val, i),
              AGNOSTIC => $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vd_val, i)
            }
        } else {
            result[i] = if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(vm_val, i), bitone) then
              $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs1_val, i)
            else
              $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)
        }
    };
    write_vreg(num_elem, SEW, LMUL_pow, vd, result);
    set_vstart(zeros(16));
    RETIRE_SUCCESS
}
and execute MOVETYPEV((vs1, vd)) = {
    let SEW = get_sew();
    let LMUL_pow = get_lmul_pow();
    let num_elem = get_num_elem(LMUL_pow, SEW);
    if illegal_vd_unmasked() then return(Illegal_Instruction());
    let 'n = num_elem;
    let 'm = SEW;
    let vs1_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);
    let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);
    let (initial_result, mask) : (vector('n, bits('m)), bits('n)) = $[complete] match init_masked_result(num_elem, SEW, LMUL_pow, vd_val, ones($[overloaded { "name" = "__size", "is_infix" = false }] __id(num_elem))) {
      Ok(v) => v,
      Err(()) => return(Illegal_Instruction())
    };
    var result = initial_result;
    foreach (i from 0 to sub_atom(num_elem, 1) by 1 in inc) {
        if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(mask, i), bitone) then result[i] = $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs1_val, i);
        ()
    };
    write_vreg(num_elem, SEW, LMUL_pow, vd, result);
    set_vstart(zeros(16));
    RETIRE_SUCCESS
}
and execute VXTYPE((funct6, vm, vs2, rs1, vd)) = {
    let SEW = get_sew();
    let LMUL_pow = get_lmul_pow();
    let num_elem = get_num_elem(LMUL_pow, SEW);
    if illegal_normal(vd, vm) then return(Illegal_Instruction());
    let 'n = num_elem;
    let 'm = SEW;
    let vm_val : bits('n) = read_vmask(num_elem, vm, zvreg);
    let rs1_val : bits('m) = get_scalar(rs1, SEW);
    let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);
    let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);
    let (initial_result, mask) : (vector('n, bits('m)), bits('n)) = $[complete] match init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val) {
      Ok(v) => v,
      Err(()) => return(Illegal_Instruction())
    };
    var result = initial_result;
    foreach (i from 0 to sub_atom(num_elem, 1) by 1 in inc) {
        if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(mask, i), bitone) then {
            result[i] = $[complete] match funct6 {
              VX_VADD => $[overloaded { "name" = "+", "is_infix" = true }] add_bits($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i), rs1_val),
              VX_VSUB => $[overloaded { "name" = "-", "is_infix" = true }] sub_vec($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i), rs1_val),
              VX_VRSUB => $[overloaded { "name" = "-", "is_infix" = true }] sub_vec(rs1_val, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)),
              VX_VAND => $[overloaded { "name" = "&", "is_infix" = true }] and_vec($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i), rs1_val),
              VX_VOR => $[overloaded { "name" = "|", "is_infix" = true }] or_vec($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i), rs1_val),
              VX_VXOR => $[overloaded { "name" = "^", "is_infix" = true }] xor_vec($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i), rs1_val),
              VX_VSADDU => unsigned_saturation($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), $[overloaded { "name" = "+", "is_infix" = true }] add_bits(zero_extend($[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), 1), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)), zero_extend($[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), 1), rs1_val))),
              VX_VSADD => signed_saturation($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), $[overloaded { "name" = "+", "is_infix" = true }] add_bits(sign_extend($[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), 1), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)), sign_extend($[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), 1), rs1_val))),
              VX_VSSUBU => {
                  if $[overloaded { "name" = "<", "is_infix" = true }] lt_int(unsigned($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)), unsigned(rs1_val)) then
                    zeros($[overloaded { "name" = "__size", "is_infix" = false }] __id(m))
                  else
                    unsigned_saturation($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), $[overloaded { "name" = "-", "is_infix" = true }] sub_vec(zero_extend($[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), 1), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)), zero_extend($[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), 1), rs1_val)))
              },
              VX_VSSUB => signed_saturation($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), $[overloaded { "name" = "-", "is_infix" = true }] sub_vec(sign_extend($[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), 1), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)), sign_extend($[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), 1), rs1_val))),
              VX_VSMUL => {
                  let result_mul = to_bits_unsafe($[overloaded { "name" = "*", "is_infix" = true }] mult_atom($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), 2), $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(signed($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)), signed(rs1_val)));
                  let rounding_incr = get_fixed_rounding_incr(result_mul, $[overloaded { "name" = "-", "is_infix" = true }] sub_atom($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), 1));
                  let result_wide = $[overloaded { "name" = "+", "is_infix" = true }] add_bits($[overloaded { "name" = ">>", "is_infix" = true }] shiftr(result_mul, $[overloaded { "name" = "-", "is_infix" = true }] sub_atom($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), 1)), zero_extend($[overloaded { "name" = "*", "is_infix" = true }] mult_atom($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), 2), rounding_incr));
                  signed_saturation($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(result_wide, $[overloaded { "name" = "__size", "is_infix" = false }] __id(m), 0))
              },
              VX_VSLL => {
                  let shift_amount = get_shift_amount(rs1_val, SEW);
                  $[overloaded { "name" = "<<", "is_infix" = true }] shiftl($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i), shift_amount)
              },
              VX_VSRL => {
                  let shift_amount = get_shift_amount(rs1_val, SEW);
                  $[overloaded { "name" = ">>", "is_infix" = true }] shiftr($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i), shift_amount)
              },
              VX_VSRA => {
                  let shift_amount = get_shift_amount(rs1_val, SEW);
                  let v_double : bits('m * 2) = sign_extend(mult_atom($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), 2), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i));
                  $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits($[overloaded { "name" = ">>", "is_infix" = true }] shiftr(v_double, shift_amount), $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(SEW, 1), 0)
              },
              VX_VSSRL => {
                  let shift_amount = get_shift_amount(rs1_val, SEW);
                  let rounding_incr = get_fixed_rounding_incr($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i), shift_amount);
                  $[overloaded { "name" = "+", "is_infix" = true }] add_bits($[overloaded { "name" = ">>", "is_infix" = true }] shiftr($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i), shift_amount), zero_extend($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), rounding_incr))
              },
              VX_VSSRA => {
                  let shift_amount = get_shift_amount(rs1_val, SEW);
                  let rounding_incr = get_fixed_rounding_incr($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i), shift_amount);
                  let v_double : bits('m * 2) = sign_extend(mult_atom($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), 2), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i));
                  $[overloaded { "name" = "+", "is_infix" = true }] add_bits($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits($[overloaded { "name" = ">>", "is_infix" = true }] shiftr(v_double, shift_amount), $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(SEW, 1), 0), zero_extend($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), rounding_incr))
              },
              VX_VMINU => to_bits_unsafe(SEW, $[overloaded { "name" = "min", "is_infix" = false }] min_int(unsigned($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)), unsigned(rs1_val))),
              VX_VMIN => to_bits_unsafe(SEW, $[overloaded { "name" = "min", "is_infix" = false }] min_int(signed($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)), signed(rs1_val))),
              VX_VMAXU => to_bits_unsafe(SEW, $[overloaded { "name" = "max", "is_infix" = false }] max_int(unsigned($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)), unsigned(rs1_val))),
              VX_VMAX => to_bits_unsafe(SEW, $[overloaded { "name" = "max", "is_infix" = false }] max_int(signed($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)), signed(rs1_val)))
            }
        };
        ()
    };
    write_vreg(num_elem, SEW, LMUL_pow, vd, result);
    set_vstart(zeros(16));
    RETIRE_SUCCESS
}
and execute NXSTYPE((funct6, vm, vs2, rs1, vd)) = {
    let SEW = get_sew();
    let LMUL_pow = get_lmul_pow();
    let num_elem = get_num_elem(LMUL_pow, SEW);
    let SEW_widen = $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(SEW, 2);
    let LMUL_pow_widen = $[overloaded { "name" = "+", "is_infix" = true }] add_atom(LMUL_pow, 1);
    if $[overloaded { "name" = "|", "is_infix" = true }] or_bool(illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen), not(valid_reg_overlap(vs2, vd, LMUL_pow_widen, LMUL_pow))) then return(Illegal_Instruction());
    assert($[overloaded { "name" = "<=", "is_infix" = true }] lteq_int(SEW_widen, 64), "./extensions/V/vext_arith_insts.sail:565.24-565.25");
    let 'n = num_elem;
    let 'm = SEW;
    let 'o = SEW_widen;
    let vm_val : bits('n) = read_vmask(num_elem, vm, zvreg);
    let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);
    let rs1_val : bits('m) = get_scalar(rs1, SEW);
    let vs2_val : vector('n, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2);
    let (initial_result, mask) : (vector('n, bits('m)), bits('n)) = $[complete] match init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val) {
      Ok(v) => v,
      Err(()) => return(Illegal_Instruction())
    };
    var result = initial_result;
    foreach (i from 0 to sub_atom(num_elem, 1) by 1 in inc) {
        if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(mask, i), bitone) then {
            result[i] = $[complete] match funct6 {
              NXS_VNSRL => {
                  let shift_amount = get_shift_amount(rs1_val, SEW_widen);
                  $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits($[overloaded { "name" = ">>", "is_infix" = true }] shiftr($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i), shift_amount), $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(SEW, 1), 0)
              },
              NXS_VNSRA => {
                  let shift_amount = get_shift_amount(rs1_val, SEW_widen);
                  let v_double : bits('o * 2) = sign_extend(mult_atom($[overloaded { "name" = "__size", "is_infix" = false }] __id(o), 2), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i));
                  let arith_shifted : bits('o) = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits($[overloaded { "name" = ">>", "is_infix" = true }] shiftr(v_double, shift_amount), $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(SEW_widen, 1), 0);
                  $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(arith_shifted, $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(SEW, 1), 0)
              }
            }
        };
        ()
    };
    write_vreg(num_elem, SEW, LMUL_pow, vd, result);
    set_vstart(zeros(16));
    RETIRE_SUCCESS
}
and execute NXTYPE((funct6, vm, vs2, rs1, vd)) = {
    let SEW = get_sew();
    let LMUL_pow = get_lmul_pow();
    let num_elem = get_num_elem(LMUL_pow, SEW);
    let SEW_widen = $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(SEW, 2);
    let LMUL_pow_widen = $[overloaded { "name" = "+", "is_infix" = true }] add_atom(LMUL_pow, 1);
    if $[overloaded { "name" = "|", "is_infix" = true }] or_bool(illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen), not(valid_reg_overlap(vs2, vd, LMUL_pow_widen, LMUL_pow))) then return(Illegal_Instruction());
    assert($[overloaded { "name" = "<=", "is_infix" = true }] lteq_int(SEW_widen, 64), "./extensions/V/vext_arith_insts.sail:636.24-636.25");
    let 'n = num_elem;
    let 'm = SEW;
    let 'o = SEW_widen;
    let vm_val : bits('n) = read_vmask(num_elem, vm, zvreg);
    let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);
    let rs1_val : bits('m) = get_scalar(rs1, SEW);
    let vs2_val : vector('n, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2);
    let (initial_result, mask) : (vector('n, bits('m)), bits('n)) = $[complete] match init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val) {
      Ok(v) => v,
      Err(()) => return(Illegal_Instruction())
    };
    var result = initial_result;
    foreach (i from 0 to sub_atom(num_elem, 1) by 1 in inc) {
        if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(mask, i), bitone) then {
            let shift_amount = get_shift_amount(rs1_val, SEW_widen);
            let rounding_incr = get_fixed_rounding_incr($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i), shift_amount);
            result[i] = $[complete] match funct6 {
              NX_VNCLIPU => {
                  let result_wide = $[overloaded { "name" = "+", "is_infix" = true }] add_bits($[overloaded { "name" = ">>", "is_infix" = true }] shiftr($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i), shift_amount), zero_extend($[overloaded { "name" = "__size", "is_infix" = false }] __id(o), rounding_incr));
                  unsigned_saturation($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), result_wide)
              },
              NX_VNCLIP => {
                  let v_double : bits('m * 4) = sign_extend(mult_atom($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), 4), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i));
                  let result_wide = $[overloaded { "name" = "+", "is_infix" = true }] add_bits($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits($[overloaded { "name" = ">>", "is_infix" = true }] shiftr(v_double, shift_amount), $[overloaded { "name" = "-", "is_infix" = true }] sub_atom($[overloaded { "name" = "__size", "is_infix" = false }] __id(o), 1), 0), zero_extend($[overloaded { "name" = "__size", "is_infix" = false }] __id(o), rounding_incr));
                  signed_saturation($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), result_wide)
              }
            }
        };
        ()
    };
    write_vreg(num_elem, SEW, LMUL_pow, vd, result);
    set_vstart(zeros(16));
    RETIRE_SUCCESS
}
and execute VXSG((funct6, vm, vs2, rs1, vd)) = {
    let SEW_pow = get_sew_pow();
    let SEW = get_sew();
    let LMUL_pow = get_lmul_pow();
    let num_elem = get_num_elem(LMUL_pow, SEW);
    if illegal_normal(vd, vm) then return(Illegal_Instruction());
    let 'n = num_elem;
    let 'm = SEW;
    let vm_val : bits('n) = read_vmask(num_elem, vm, zvreg);
    let rs1_val : nat = unsigned($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1));
    let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);
    let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);
    let (initial_result, mask) : (vector('n, bits('m)), bits('n)) = $[complete] match init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val) {
      Ok(v) => v,
      Err(()) => return(Illegal_Instruction())
    };
    var result = initial_result;
    foreach (i from 0 to sub_atom(num_elem, 1) by 1 in inc) {
        if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(mask, i), bitone) then {
            result[i] = $[complete] match funct6 {
              VX_VSLIDEUP => {
                  if $[overloaded { "name" = "==", "is_infix" = true }] eq_anything(vs2, vd) then return(Illegal_Instruction());
                  if $[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(i, rs1_val) then
                    $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(i, rs1_val))
                  else
                    $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vd_val, i)
              },
              VX_VSLIDEDOWN => {
                  assert($[overloaded { "name" = ">=", "is_infix" = true }] gteq_int($[overloaded { "name" = "-", "is_infix" = true }] sub_atom($[overloaded { "name" = "+", "is_infix" = true }] add_atom(LMUL_pow, vlen_exp), SEW_pow), 0), "./extensions/V/vext_arith_insts.sail:728.69-728.70");
                  let VLMAX = 2 ^ sub_atom($[overloaded { "name" = "+", "is_infix" = true }] add_atom(LMUL_pow, vlen_exp), SEW_pow);
                  assert($[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = ">", "is_infix" = true }] gt_int(VLMAX, 0), $[overloaded { "name" = "<=", "is_infix" = true }] lteq_int(VLMAX, $[overloaded { "name" = "__size", "is_infix" = false }] __id(n))), "./extensions/V/vext_arith_insts.sail:730.58-730.59");
                  if $[overloaded { "name" = "<", "is_infix" = true }] lt_int($[overloaded { "name" = "+", "is_infix" = true }] add_atom(i, rs1_val), VLMAX) then
                    $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, $[overloaded { "name" = "+", "is_infix" = true }] add_atom(i, rs1_val))
                  else
                    zeros($[overloaded { "name" = "__size", "is_infix" = false }] __id(m))
              },
              VX_VRGATHER => {
                  if $[overloaded { "name" = "==", "is_infix" = true }] eq_anything(vs2, vd) then return(Illegal_Instruction());
                  assert($[overloaded { "name" = ">=", "is_infix" = true }] gteq_int($[overloaded { "name" = "-", "is_infix" = true }] sub_atom($[overloaded { "name" = "+", "is_infix" = true }] add_atom(LMUL_pow, vlen_exp), SEW_pow), 0), "./extensions/V/vext_arith_insts.sail:735.69-735.70");
                  let VLMAX = 2 ^ sub_atom($[overloaded { "name" = "+", "is_infix" = true }] add_atom(LMUL_pow, vlen_exp), SEW_pow);
                  assert($[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = ">", "is_infix" = true }] gt_int(VLMAX, 0), $[overloaded { "name" = "<=", "is_infix" = true }] lteq_int(VLMAX, $[overloaded { "name" = "__size", "is_infix" = false }] __id(n))), "./extensions/V/vext_arith_insts.sail:737.58-737.59");
                  if $[overloaded { "name" = "<", "is_infix" = true }] lt_int(rs1_val, VLMAX) then
                    $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, rs1_val)
                  else
                    zeros($[overloaded { "name" = "__size", "is_infix" = false }] __id(m))
              }
            }
        };
        ()
    };
    write_vreg(num_elem, SEW, LMUL_pow, vd, result);
    set_vstart(zeros(16));
    RETIRE_SUCCESS
}
and execute MASKTYPEX((vs2, rs1, vd)) = {
    let start_element : nat = $[complete] match get_start_element() {
      Ok(v) => v,
      Err(()) => return(Illegal_Instruction())
    };
    let end_element = get_end_element();
    let SEW = get_sew();
    let LMUL_pow = get_lmul_pow();
    let num_elem = get_num_elem(LMUL_pow, SEW);
    let real_num_elem = if $[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(LMUL_pow, 0) then
      num_elem
    else
      $[overloaded { "name" = "/", "is_infix" = true }] quot_positive_round_zero(num_elem, $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(0, LMUL_pow));
    if illegal_vd_masked(vd) then return(Illegal_Instruction());
    let 'n = num_elem;
    let 'm = SEW;
    let vm_val : bits('n) = read_vmask(num_elem, 0b0, zvreg);
    let rs1_val : bits('m) = get_scalar(rs1, SEW);
    let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);
    let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);
    var result : vector('n, bits('m)) = vector_init($[overloaded { "name" = "__size", "is_infix" = false }] __id(n), zeros($[overloaded { "name" = "__size", "is_infix" = false }] __id(m)));
    let tail_ag : agtype = get_vtype_vta();
    foreach (i from 0 to sub_atom(num_elem, 1) by 1 in inc) {
        if $[overloaded { "name" = "<", "is_infix" = true }] lt_int(i, start_element) then {
            result[i] = $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vd_val, i)
        } else if $[overloaded { "name" = "|", "is_infix" = true }] or_bool($[overloaded { "name" = ">", "is_infix" = true }] gt_int(i, end_element), $[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(i, real_num_elem)) then {
            result[i] = $[complete] match tail_ag {
              UNDISTURBED => $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vd_val, i),
              AGNOSTIC => $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vd_val, i)
            }
        } else {
            result[i] = if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(vm_val, i), bitone) then
              rs1_val
            else
              $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)
        }
    };
    write_vreg(num_elem, SEW, LMUL_pow, vd, result);
    set_vstart(zeros(16));
    RETIRE_SUCCESS
}
and execute MOVETYPEX((rs1, vd)) = {
    let SEW = get_sew();
    let LMUL_pow = get_lmul_pow();
    let num_elem = get_num_elem(LMUL_pow, SEW);
    if illegal_vd_unmasked() then return(Illegal_Instruction());
    let 'n = num_elem;
    let 'm = SEW;
    let rs1_val : bits('m) = get_scalar(rs1, $[overloaded { "name" = "__size", "is_infix" = false }] __id(m));
    let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);
    let (initial_result, mask) : (vector('n, bits('m)), bits('n)) = $[complete] match init_masked_result(num_elem, SEW, LMUL_pow, vd_val, ones($[overloaded { "name" = "__size", "is_infix" = false }] __id(num_elem))) {
      Ok(v) => v,
      Err(()) => return(Illegal_Instruction())
    };
    var result = initial_result;
    foreach (i from 0 to sub_atom(num_elem, 1) by 1 in inc) {
        if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(mask, i), bitone) then result[i] = rs1_val;
        ()
    };
    write_vreg(num_elem, SEW, LMUL_pow, vd, result);
    set_vstart(zeros(16));
    RETIRE_SUCCESS
}
and execute VITYPE((funct6, vm, vs2, simm, vd)) = {
    let SEW = get_sew();
    let LMUL_pow = get_lmul_pow();
    let num_elem = get_num_elem(LMUL_pow, SEW);
    if illegal_normal(vd, vm) then return(Illegal_Instruction());
    let 'n = num_elem;
    let 'm = SEW;
    let vm_val : bits('n) = read_vmask(num_elem, vm, zvreg);
    let imm_val : bits('m) = sign_extend($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), simm);
    let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);
    let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);
    let (initial_result, mask) : (vector('n, bits('m)), bits('n)) = $[complete] match init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val) {
      Ok(v) => v,
      Err(()) => return(Illegal_Instruction())
    };
    var result = initial_result;
    foreach (i from 0 to sub_atom(num_elem, 1) by 1 in inc) {
        if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(mask, i), bitone) then {
            result[i] = $[complete] match funct6 {
              VI_VADD => $[overloaded { "name" = "+", "is_infix" = true }] add_bits($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i), imm_val),
              VI_VRSUB => $[overloaded { "name" = "-", "is_infix" = true }] sub_vec(imm_val, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)),
              VI_VAND => $[overloaded { "name" = "&", "is_infix" = true }] and_vec($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i), imm_val),
              VI_VOR => $[overloaded { "name" = "|", "is_infix" = true }] or_vec($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i), imm_val),
              VI_VXOR => $[overloaded { "name" = "^", "is_infix" = true }] xor_vec($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i), imm_val),
              VI_VSADDU => unsigned_saturation($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), $[overloaded { "name" = "+", "is_infix" = true }] add_bits(zero_extend($[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), 1), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)), zero_extend($[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), 1), imm_val))),
              VI_VSADD => signed_saturation($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), $[overloaded { "name" = "+", "is_infix" = true }] add_bits(sign_extend($[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), 1), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)), sign_extend($[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), 1), imm_val))),
              VI_VSLL => {
                  let shift_amount = get_shift_amount(zero_extend($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), simm), SEW);
                  $[overloaded { "name" = "<<", "is_infix" = true }] shiftl($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i), shift_amount)
              },
              VI_VSRL => {
                  let shift_amount = get_shift_amount(zero_extend($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), simm), SEW);
                  $[overloaded { "name" = ">>", "is_infix" = true }] shiftr($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i), shift_amount)
              },
              VI_VSRA => {
                  let shift_amount = get_shift_amount(zero_extend($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), simm), SEW);
                  let v_double : bits('m * 2) = sign_extend(mult_atom($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), 2), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i));
                  $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits($[overloaded { "name" = ">>", "is_infix" = true }] shiftr(v_double, shift_amount), $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(SEW, 1), 0)
              },
              VI_VSSRL => {
                  let shift_amount = get_shift_amount(zero_extend($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), simm), SEW);
                  let rounding_incr = get_fixed_rounding_incr($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i), shift_amount);
                  $[overloaded { "name" = "+", "is_infix" = true }] add_bits($[overloaded { "name" = ">>", "is_infix" = true }] shiftr($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i), shift_amount), zero_extend($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), rounding_incr))
              },
              VI_VSSRA => {
                  let shift_amount = get_shift_amount(zero_extend($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), simm), SEW);
                  let rounding_incr = get_fixed_rounding_incr($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i), shift_amount);
                  let v_double : bits('m * 2) = sign_extend(mult_atom($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), 2), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i));
                  $[overloaded { "name" = "+", "is_infix" = true }] add_bits($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits($[overloaded { "name" = ">>", "is_infix" = true }] shiftr(v_double, shift_amount), $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(SEW, 1), 0), zero_extend($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), rounding_incr))
              }
            }
        };
        ()
    };
    write_vreg(num_elem, SEW, LMUL_pow, vd, result);
    set_vstart(zeros(16));
    RETIRE_SUCCESS
}
and execute NISTYPE((funct6, vm, vs2, uimm, vd)) = {
    let SEW = get_sew();
    let LMUL_pow = get_lmul_pow();
    let num_elem = get_num_elem(LMUL_pow, SEW);
    let SEW_widen = $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(SEW, 2);
    let LMUL_pow_widen = $[overloaded { "name" = "+", "is_infix" = true }] add_atom(LMUL_pow, 1);
    if $[overloaded { "name" = "|", "is_infix" = true }] or_bool(illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen), not(valid_reg_overlap(vs2, vd, LMUL_pow_widen, LMUL_pow))) then return(Illegal_Instruction());
    assert($[overloaded { "name" = "<=", "is_infix" = true }] lteq_int(SEW_widen, 64), "./extensions/V/vext_arith_insts.sail:976.24-976.25");
    let 'n = num_elem;
    let 'm = SEW;
    let 'o = SEW_widen;
    let vm_val : bits('n) = read_vmask(num_elem, vm, zvreg);
    let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);
    let imm_val : bits('m) = zero_extend($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), uimm);
    let vs2_val : vector('n, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2);
    let (initial_result, mask) : (vector('n, bits('m)), bits('n)) = $[complete] match init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val) {
      Ok(v) => v,
      Err(()) => return(Illegal_Instruction())
    };
    var result = initial_result;
    foreach (i from 0 to sub_atom(num_elem, 1) by 1 in inc) {
        if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(mask, i), bitone) then {
            result[i] = $[complete] match funct6 {
              NIS_VNSRL => {
                  let shift_amount = get_shift_amount(imm_val, SEW_widen);
                  $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits($[overloaded { "name" = ">>", "is_infix" = true }] shiftr($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i), shift_amount), $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(SEW, 1), 0)
              },
              NIS_VNSRA => {
                  let shift_amount = get_shift_amount(imm_val, SEW_widen);
                  let v_double : bits('o * 2) = sign_extend(mult_atom($[overloaded { "name" = "__size", "is_infix" = false }] __id(o), 2), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i));
                  let arith_shifted : bits('o) = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits($[overloaded { "name" = ">>", "is_infix" = true }] shiftr(v_double, shift_amount), $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(SEW_widen, 1), 0);
                  $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(arith_shifted, $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(SEW, 1), 0)
              }
            }
        };
        ()
    };
    write_vreg(num_elem, SEW, LMUL_pow, vd, result);
    set_vstart(zeros(16));
    RETIRE_SUCCESS
}
and execute NITYPE((funct6, vm, vs2, uimm, vd)) = {
    let SEW = get_sew();
    let LMUL_pow = get_lmul_pow();
    let num_elem = get_num_elem(LMUL_pow, SEW);
    let SEW_widen = $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(SEW, 2);
    let LMUL_pow_widen = $[overloaded { "name" = "+", "is_infix" = true }] add_atom(LMUL_pow, 1);
    if $[overloaded { "name" = "|", "is_infix" = true }] or_bool(illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen), not(valid_reg_overlap(vs2, vd, LMUL_pow_widen, LMUL_pow))) then return(Illegal_Instruction());
    assert($[overloaded { "name" = "<=", "is_infix" = true }] lteq_int(SEW_widen, 64), "./extensions/V/vext_arith_insts.sail:1047.24-1047.25");
    let 'n = num_elem;
    let 'm = SEW;
    let 'o = SEW_widen;
    let vm_val : bits('n) = read_vmask(num_elem, vm, zvreg);
    let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);
    let imm_val : bits('m) = zero_extend($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), uimm);
    let vs2_val : vector('n, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2);
    let (initial_result, mask) : (vector('n, bits('m)), bits('n)) = $[complete] match init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val) {
      Ok(v) => v,
      Err(()) => return(Illegal_Instruction())
    };
    var result = initial_result;
    foreach (i from 0 to sub_atom(num_elem, 1) by 1 in inc) {
        if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(mask, i), bitone) then {
            let shift_amount = get_shift_amount(imm_val, SEW_widen);
            let rounding_incr = get_fixed_rounding_incr($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i), shift_amount);
            result[i] = $[complete] match funct6 {
              NI_VNCLIPU => {
                  let result_wide = $[overloaded { "name" = "+", "is_infix" = true }] add_bits($[overloaded { "name" = ">>", "is_infix" = true }] shiftr($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i), shift_amount), zero_extend($[overloaded { "name" = "__size", "is_infix" = false }] __id(o), rounding_incr));
                  unsigned_saturation($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), result_wide)
              },
              NI_VNCLIP => {
                  let v_double : bits('m * 4) = sign_extend(mult_atom($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), 4), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i));
                  let result_wide = $[overloaded { "name" = "+", "is_infix" = true }] add_bits($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits($[overloaded { "name" = ">>", "is_infix" = true }] shiftr(v_double, shift_amount), $[overloaded { "name" = "-", "is_infix" = true }] sub_atom($[overloaded { "name" = "__size", "is_infix" = false }] __id(o), 1), 0), zero_extend($[overloaded { "name" = "__size", "is_infix" = false }] __id(o), rounding_incr));
                  signed_saturation($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), result_wide)
              }
            }
        };
        ()
    };
    write_vreg(num_elem, SEW, LMUL_pow, vd, result);
    set_vstart(zeros(16));
    RETIRE_SUCCESS
}
and execute VISG((funct6, vm, vs2, simm, vd)) = {
    let SEW_pow = get_sew_pow();
    let SEW = get_sew();
    let LMUL_pow = get_lmul_pow();
    let num_elem = get_num_elem(LMUL_pow, SEW);
    if illegal_normal(vd, vm) then return(Illegal_Instruction());
    let 'n = num_elem;
    let 'm = SEW;
    let vm_val : bits('n) = read_vmask(num_elem, vm, zvreg);
    let imm_val : nat = unsigned(zero_extend(xlen, simm));
    let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);
    let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);
    let (initial_result, mask) : (vector('n, bits('m)), bits('n)) = $[complete] match init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val) {
      Ok(v) => v,
      Err(()) => return(Illegal_Instruction())
    };
    var result = initial_result;
    foreach (i from 0 to sub_atom(num_elem, 1) by 1 in inc) {
        if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(mask, i), bitone) then {
            result[i] = $[complete] match funct6 {
              VI_VSLIDEUP => {
                  if $[overloaded { "name" = "==", "is_infix" = true }] eq_anything(vs2, vd) then return(Illegal_Instruction());
                  if $[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(i, imm_val) then
                    $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(i, imm_val))
                  else
                    $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vd_val, i)
              },
              VI_VSLIDEDOWN => {
                  assert($[overloaded { "name" = ">=", "is_infix" = true }] gteq_int($[overloaded { "name" = "-", "is_infix" = true }] sub_atom($[overloaded { "name" = "+", "is_infix" = true }] add_atom(LMUL_pow, vlen_exp), SEW_pow), 0), "./extensions/V/vext_arith_insts.sail:1139.69-1139.70");
                  let VLMAX = 2 ^ sub_atom($[overloaded { "name" = "+", "is_infix" = true }] add_atom(LMUL_pow, vlen_exp), SEW_pow);
                  assert($[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = ">", "is_infix" = true }] gt_int(VLMAX, 0), $[overloaded { "name" = "<=", "is_infix" = true }] lteq_int(VLMAX, $[overloaded { "name" = "__size", "is_infix" = false }] __id(n))), "./extensions/V/vext_arith_insts.sail:1141.58-1141.59");
                  if $[overloaded { "name" = "<", "is_infix" = true }] lt_int($[overloaded { "name" = "+", "is_infix" = true }] add_atom(i, imm_val), VLMAX) then
                    $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, $[overloaded { "name" = "+", "is_infix" = true }] add_atom(i, imm_val))
                  else
                    zeros($[overloaded { "name" = "__size", "is_infix" = false }] __id(m))
              },
              VI_VRGATHER => {
                  if $[overloaded { "name" = "==", "is_infix" = true }] eq_anything(vs2, vd) then return(Illegal_Instruction());
                  assert($[overloaded { "name" = ">=", "is_infix" = true }] gteq_int($[overloaded { "name" = "-", "is_infix" = true }] sub_atom($[overloaded { "name" = "+", "is_infix" = true }] add_atom(LMUL_pow, vlen_exp), SEW_pow), 0), "./extensions/V/vext_arith_insts.sail:1146.69-1146.70");
                  let VLMAX = 2 ^ sub_atom($[overloaded { "name" = "+", "is_infix" = true }] add_atom(LMUL_pow, vlen_exp), SEW_pow);
                  assert($[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = ">", "is_infix" = true }] gt_int(VLMAX, 0), $[overloaded { "name" = "<=", "is_infix" = true }] lteq_int(VLMAX, $[overloaded { "name" = "__size", "is_infix" = false }] __id(n))), "./extensions/V/vext_arith_insts.sail:1148.58-1148.59");
                  if $[overloaded { "name" = "<", "is_infix" = true }] lt_int(imm_val, VLMAX) then
                    $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, imm_val)
                  else
                    zeros($[overloaded { "name" = "__size", "is_infix" = false }] __id(m))
              }
            }
        };
        ()
    };
    write_vreg(num_elem, SEW, LMUL_pow, vd, result);
    set_vstart(zeros(16));
    RETIRE_SUCCESS
}
and execute MASKTYPEI((vs2, simm, vd)) = {
    let start_element : nat = $[complete] match get_start_element() {
      Ok(v) => v,
      Err(()) => return(Illegal_Instruction())
    };
    let end_element = get_end_element();
    let SEW = get_sew();
    let LMUL_pow = get_lmul_pow();
    let num_elem = get_num_elem(LMUL_pow, SEW);
    let real_num_elem = if $[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(LMUL_pow, 0) then
      num_elem
    else
      $[overloaded { "name" = "/", "is_infix" = true }] quot_positive_round_zero(num_elem, $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(0, LMUL_pow));
    if illegal_vd_masked(vd) then return(Illegal_Instruction());
    let 'n = num_elem;
    let 'm = SEW;
    let vm_val : bits('n) = read_vmask(num_elem, 0b0, zvreg);
    let imm_val : bits('m) = sign_extend($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), simm);
    let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);
    let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);
    var result : vector('n, bits('m)) = vector_init($[overloaded { "name" = "__size", "is_infix" = false }] __id(n), zeros($[overloaded { "name" = "__size", "is_infix" = false }] __id(m)));
    let tail_ag : agtype = get_vtype_vta();
    foreach (i from 0 to sub_atom(num_elem, 1) by 1 in inc) {
        if $[overloaded { "name" = "<", "is_infix" = true }] lt_int(i, start_element) then {
            result[i] = $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vd_val, i)
        } else if $[overloaded { "name" = "|", "is_infix" = true }] or_bool($[overloaded { "name" = ">", "is_infix" = true }] gt_int(i, end_element), $[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(i, real_num_elem)) then {
            result[i] = $[complete] match tail_ag {
              UNDISTURBED => $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vd_val, i),
              AGNOSTIC => $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vd_val, i)
            }
        } else {
            result[i] = if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(vm_val, i), bitone) then
              imm_val
            else
              $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)
        }
    };
    write_vreg(num_elem, SEW, LMUL_pow, vd, result);
    set_vstart(zeros(16));
    RETIRE_SUCCESS
}
and execute MOVETYPEI((vd, simm)) = {
    let SEW = get_sew();
    let LMUL_pow = get_lmul_pow();
    let num_elem = get_num_elem(LMUL_pow, SEW);
    if illegal_vd_unmasked() then return(Illegal_Instruction());
    let 'n = num_elem;
    let 'm = SEW;
    let imm_val : bits('m) = sign_extend($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), simm);
    let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);
    let (initial_result, mask) : (vector('n, bits('m)), bits('n)) = $[complete] match init_masked_result(num_elem, SEW, LMUL_pow, vd_val, ones($[overloaded { "name" = "__size", "is_infix" = false }] __id(num_elem))) {
      Ok(v) => v,
      Err(()) => return(Illegal_Instruction())
    };
    var result = initial_result;
    foreach (i from 0 to sub_atom(num_elem, 1) by 1 in inc) {
        if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(mask, i), bitone) then result[i] = imm_val;
        ()
    };
    write_vreg(num_elem, SEW, LMUL_pow, vd, result);
    set_vstart(zeros(16));
    RETIRE_SUCCESS
}
and execute VMVRTYPE((vs2, nreg, vd)) = {
    let start_element : nat = $[complete] match get_start_element() {
      Ok(v) => v,
      Err(()) => return(Illegal_Instruction())
    };
    let SEW = get_sew();
    let EMUL = nreg;
    let EMUL_pow = log2(EMUL);
    let num_elem = get_num_elem(EMUL_pow, SEW);
    let 'n = num_elem;
    let 'm = SEW;
    let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, EMUL_pow, vs2);
    let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, EMUL_pow, vd);
    var result : vector('n, bits('m)) = vector_init($[overloaded { "name" = "__size", "is_infix" = false }] __id(n), zeros($[overloaded { "name" = "__size", "is_infix" = false }] __id(m)));
    foreach (i from 0 to sub_atom(num_elem, 1) by 1 in inc) {
        result[i] = if $[overloaded { "name" = "<", "is_infix" = true }] lt_int(i, start_element) then
          $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vd_val, i)
        else
          $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)
    };
    write_vreg(num_elem, SEW, EMUL_pow, vd, result);
    set_vstart(zeros(16));
    RETIRE_SUCCESS
}
and execute MVVTYPE((funct6, vm, vs2, vs1, vd)) = {
    let SEW = get_sew();
    let LMUL_pow = get_lmul_pow();
    let num_elem = get_num_elem(LMUL_pow, SEW);
    if illegal_normal(vd, vm) then return(Illegal_Instruction());
    let 'n = num_elem;
    let 'm = SEW;
    let vm_val : bits('n) = read_vmask(num_elem, vm, zvreg);
    let vs1_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);
    let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);
    let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);
    let (initial_result, mask) : (vector('n, bits('m)), bits('n)) = $[complete] match init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val) {
      Ok(v) => v,
      Err(()) => return(Illegal_Instruction())
    };
    var result = initial_result;
    foreach (i from 0 to sub_atom(num_elem, 1) by 1 in inc) {
        if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(mask, i), bitone) then {
            result[i] = $[complete] match funct6 {
              MVV_VAADDU => {
                  let result_add = $[overloaded { "name" = "+", "is_infix" = true }] add_bits(zero_extend($[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), 1), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)), zero_extend($[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), 1), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs1_val, i)));
                  let rounding_incr = get_fixed_rounding_incr(result_add, 1);
                  $[overloaded { "name" = "+", "is_infix" = true }] add_bits($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits($[overloaded { "name" = ">>", "is_infix" = true }] shiftr(result_add, 1), $[overloaded { "name" = "-", "is_infix" = true }] sub_atom($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), 1), 0), zero_extend($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), rounding_incr))
              },
              MVV_VAADD => {
                  let result_add = $[overloaded { "name" = "+", "is_infix" = true }] add_bits(sign_extend($[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), 1), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)), sign_extend($[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), 1), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs1_val, i)));
                  let rounding_incr = get_fixed_rounding_incr(result_add, 1);
                  $[overloaded { "name" = "+", "is_infix" = true }] add_bits($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits($[overloaded { "name" = ">>", "is_infix" = true }] shiftr(result_add, 1), $[overloaded { "name" = "-", "is_infix" = true }] sub_atom($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), 1), 0), zero_extend($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), rounding_incr))
              },
              MVV_VASUBU => {
                  let result_sub = $[overloaded { "name" = "-", "is_infix" = true }] sub_vec(zero_extend($[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), 1), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)), zero_extend($[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), 1), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs1_val, i)));
                  let rounding_incr = get_fixed_rounding_incr(result_sub, 1);
                  $[overloaded { "name" = "+", "is_infix" = true }] add_bits($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits($[overloaded { "name" = ">>", "is_infix" = true }] shiftr(result_sub, 1), $[overloaded { "name" = "-", "is_infix" = true }] sub_atom($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), 1), 0), zero_extend($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), rounding_incr))
              },
              MVV_VASUB => {
                  let result_sub = $[overloaded { "name" = "-", "is_infix" = true }] sub_vec(sign_extend($[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), 1), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)), sign_extend($[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), 1), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs1_val, i)));
                  let rounding_incr = get_fixed_rounding_incr(result_sub, 1);
                  $[overloaded { "name" = "+", "is_infix" = true }] add_bits($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits($[overloaded { "name" = ">>", "is_infix" = true }] shiftr(result_sub, 1), $[overloaded { "name" = "-", "is_infix" = true }] sub_atom($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), 1), 0), zero_extend($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), rounding_incr))
              },
              MVV_VMUL => get_slice_int(SEW, $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(signed($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)), signed($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs1_val, i))), 0),
              MVV_VMULH => get_slice_int(SEW, $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(signed($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)), signed($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs1_val, i))), SEW),
              MVV_VMULHU => get_slice_int(SEW, $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(unsigned($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)), unsigned($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs1_val, i))), SEW),
              MVV_VMULHSU => get_slice_int(SEW, $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(signed($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)), unsigned($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs1_val, i))), SEW),
              MVV_VDIVU => {
                  let divisor = unsigned($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs1_val, i));
                  let dividend = unsigned($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i));
                  let q : int = if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(divisor, 0) then
                    -1
                  else
                    quot_round_zero(dividend, divisor);
                  to_bits_unsafe(SEW, q)
              },
              MVV_VDIV => {
                  let elem_max : int = $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(2 ^ sub_atom(SEW, 1), 1);
                  let elem_min : int = $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(0, 2 ^ sub_atom(SEW, 1));
                  let divisor = signed($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs1_val, i));
                  let dividend = signed($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i));
                  let q : int = if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(divisor, 0) then
                    -1
                  else
                    quot_round_zero(dividend, divisor);
                  let q' : int = if $[overloaded { "name" = ">", "is_infix" = true }] gt_int(q, elem_max) then
                    elem_min
                  else
                    q;
                  to_bits_unsafe(SEW, q')
              },
              MVV_VREMU => {
                  let divisor = unsigned($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs1_val, i));
                  let dividend = unsigned($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i));
                  let r : int = if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(divisor, 0) then
                    dividend
                  else
                    rem_round_zero(dividend, divisor);
                  to_bits_unsafe(SEW, r)
              },
              MVV_VREM => {
                  let divisor = signed($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs1_val, i));
                  let dividend = signed($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i));
                  let r : int = if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(divisor, 0) then
                    dividend
                  else
                    rem_round_zero(dividend, divisor);
                  to_bits_unsafe(SEW, r)
              }
            }
        };
        ()
    };
    write_vreg(num_elem, SEW, LMUL_pow, vd, result);
    set_vstart(zeros(16));
    RETIRE_SUCCESS
}
and execute MVVMATYPE((funct6, vm, vs2, vs1, vd)) = {
    let SEW = get_sew();
    let LMUL_pow = get_lmul_pow();
    let num_elem = get_num_elem(LMUL_pow, SEW);
    if illegal_normal(vd, vm) then return(Illegal_Instruction());
    let 'n = num_elem;
    let 'm = SEW;
    let vm_val : bits('n) = read_vmask(num_elem, vm, zvreg);
    let vs1_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);
    let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);
    let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);
    let (initial_result, mask) : (vector('n, bits('m)), bits('n)) = $[complete] match init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val) {
      Ok(v) => v,
      Err(()) => return(Illegal_Instruction())
    };
    var result = initial_result;
    foreach (i from 0 to sub_atom(num_elem, 1) by 1 in inc) {
        if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(mask, i), bitone) then {
            result[i] = $[complete] match funct6 {
              MVV_VMACC => $[overloaded { "name" = "+", "is_infix" = true }] add_bits(get_slice_int(SEW, $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(signed($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs1_val, i)), signed($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i))), 0), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vd_val, i)),
              MVV_VNMSAC => $[overloaded { "name" = "-", "is_infix" = true }] sub_vec($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vd_val, i), get_slice_int(SEW, $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(signed($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs1_val, i)), signed($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i))), 0)),
              MVV_VMADD => $[overloaded { "name" = "+", "is_infix" = true }] add_bits(get_slice_int(SEW, $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(signed($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs1_val, i)), signed($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vd_val, i))), 0), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)),
              MVV_VNMSUB => $[overloaded { "name" = "-", "is_infix" = true }] sub_vec($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i), get_slice_int(SEW, $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(signed($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs1_val, i)), signed($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vd_val, i))), 0))
            }
        };
        ()
    };
    write_vreg(num_elem, SEW, LMUL_pow, vd, result);
    set_vstart(zeros(16));
    RETIRE_SUCCESS
}
and execute WVVTYPE((funct6, vm, vs2, vs1, vd)) = {
    let SEW = get_sew();
    let LMUL_pow = get_lmul_pow();
    let num_elem = get_num_elem(LMUL_pow, SEW);
    let SEW_widen = $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(SEW, 2);
    let LMUL_pow_widen = $[overloaded { "name" = "+", "is_infix" = true }] add_atom(LMUL_pow, 1);
    if $[overloaded { "name" = "|", "is_infix" = true }] or_bool(illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen), $[overloaded { "name" = "|", "is_infix" = true }] or_bool(not(valid_reg_overlap(vs1, vd, LMUL_pow, LMUL_pow_widen)), not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen)))) then return(Illegal_Instruction());
    assert($[overloaded { "name" = "<=", "is_infix" = true }] lteq_int(SEW_widen, 64), "./extensions/V/vext_arith_insts.sail:1533.24-1533.25");
    let 'n = num_elem;
    let 'm = SEW;
    let 'o = SEW_widen;
    let vm_val : bits('n) = read_vmask(num_elem, vm, zvreg);
    let vd_val : vector('n, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd);
    let vs1_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);
    let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);
    let (initial_result, mask) : (vector('n, bits('o)), bits('n)) = $[complete] match init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val) {
      Ok(v) => v,
      Err(()) => return(Illegal_Instruction())
    };
    var result = initial_result;
    foreach (i from 0 to sub_atom(num_elem, 1) by 1 in inc) {
        if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(mask, i), bitone) then {
            result[i] = $[complete] match funct6 {
              WVV_VADD => to_bits_unsafe(SEW_widen, $[overloaded { "name" = "+", "is_infix" = true }] add_atom(signed($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)), signed($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs1_val, i)))),
              WVV_VSUB => to_bits_unsafe(SEW_widen, $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(signed($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)), signed($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs1_val, i)))),
              WVV_VADDU => to_bits_unsafe(SEW_widen, $[overloaded { "name" = "+", "is_infix" = true }] add_atom(unsigned($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)), unsigned($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs1_val, i)))),
              WVV_VSUBU => to_bits_unsafe(SEW_widen, $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(unsigned($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)), unsigned($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs1_val, i)))),
              WVV_VWMUL => to_bits_unsafe(SEW_widen, $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(signed($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)), signed($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs1_val, i)))),
              WVV_VWMULU => to_bits_unsafe(SEW_widen, $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(unsigned($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)), unsigned($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs1_val, i)))),
              WVV_VWMULSU => to_bits_unsafe(SEW_widen, $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(signed($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)), unsigned($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs1_val, i))))
            }
        };
        ()
    };
    write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result);
    set_vstart(zeros(16));
    RETIRE_SUCCESS
}
and execute WVTYPE((funct6, vm, vs2, vs1, vd)) = {
    let SEW = get_sew();
    let LMUL_pow = get_lmul_pow();
    let num_elem = get_num_elem(LMUL_pow, SEW);
    let SEW_widen = $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(SEW, 2);
    let LMUL_pow_widen = $[overloaded { "name" = "+", "is_infix" = true }] add_atom(LMUL_pow, 1);
    if $[overloaded { "name" = "|", "is_infix" = true }] or_bool(illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen), not(valid_reg_overlap(vs1, vd, LMUL_pow, LMUL_pow_widen))) then return(Illegal_Instruction());
    assert($[overloaded { "name" = "<=", "is_infix" = true }] lteq_int(SEW_widen, 64), "./extensions/V/vext_arith_insts.sail:1607.24-1607.25");
    let 'n = num_elem;
    let 'm = SEW;
    let 'o = SEW_widen;
    let vm_val : bits('n) = read_vmask(num_elem, vm, zvreg);
    let vd_val : vector('n, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd);
    let vs1_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);
    let vs2_val : vector('n, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2);
    let (initial_result, mask) : (vector('n, bits('o)), bits('n)) = $[complete] match init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val) {
      Ok(v) => v,
      Err(()) => return(Illegal_Instruction())
    };
    var result = initial_result;
    foreach (i from 0 to sub_atom(num_elem, 1) by 1 in inc) {
        if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(mask, i), bitone) then {
            result[i] = $[complete] match funct6 {
              WV_VADD => to_bits_unsafe(SEW_widen, $[overloaded { "name" = "+", "is_infix" = true }] add_atom(signed($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)), signed($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs1_val, i)))),
              WV_VSUB => to_bits_unsafe(SEW_widen, $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(signed($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)), signed($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs1_val, i)))),
              WV_VADDU => to_bits_unsafe(SEW_widen, $[overloaded { "name" = "+", "is_infix" = true }] add_atom(unsigned($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)), unsigned($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs1_val, i)))),
              WV_VSUBU => to_bits_unsafe(SEW_widen, $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(unsigned($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)), unsigned($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs1_val, i))))
            }
        };
        ()
    };
    write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result);
    set_vstart(zeros(16));
    RETIRE_SUCCESS
}
and execute WMVVTYPE((funct6, vm, vs2, vs1, vd)) = {
    let SEW = get_sew();
    let LMUL_pow = get_lmul_pow();
    let num_elem = get_num_elem(LMUL_pow, SEW);
    let SEW_widen = $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(SEW, 2);
    let LMUL_pow_widen = $[overloaded { "name" = "+", "is_infix" = true }] add_atom(LMUL_pow, 1);
    if $[overloaded { "name" = "|", "is_infix" = true }] or_bool(illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen), $[overloaded { "name" = "|", "is_infix" = true }] or_bool(not(valid_reg_overlap(vs1, vd, LMUL_pow, LMUL_pow_widen)), not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen)))) then return(Illegal_Instruction());
    assert($[overloaded { "name" = "<=", "is_infix" = true }] lteq_int(SEW_widen, 64), "./extensions/V/vext_arith_insts.sail:1676.24-1676.25");
    let 'n = num_elem;
    let 'm = SEW;
    let 'o = SEW_widen;
    let vm_val : bits('n) = read_vmask(num_elem, vm, zvreg);
    let vd_val : vector('n, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd);
    let vs1_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);
    let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);
    let (initial_result, mask) : (vector('n, bits('o)), bits('n)) = $[complete] match init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val) {
      Ok(v) => v,
      Err(()) => return(Illegal_Instruction())
    };
    var result = initial_result;
    foreach (i from 0 to sub_atom(num_elem, 1) by 1 in inc) {
        if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(mask, i), bitone) then {
            result[i] = $[complete] match funct6 {
              WMVV_VWMACC => $[overloaded { "name" = "+", "is_infix" = true }] add_bits(to_bits_unsafe(SEW_widen, $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(signed($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs1_val, i)), signed($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)))), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vd_val, i)),
              WMVV_VWMACCU => $[overloaded { "name" = "+", "is_infix" = true }] add_bits(to_bits_unsafe(SEW_widen, $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(unsigned($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs1_val, i)), unsigned($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)))), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vd_val, i)),
              WMVV_VWMACCSU => $[overloaded { "name" = "+", "is_infix" = true }] add_bits(to_bits_unsafe(SEW_widen, $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(signed($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs1_val, i)), unsigned($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)))), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vd_val, i))
            }
        };
        ()
    };
    write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result);
    set_vstart(zeros(16));
    RETIRE_SUCCESS
}
and execute VEXTTYPE((funct6, vm, vs2, vd)) = {
    let SEW = get_sew();
    let LMUL_pow = get_lmul_pow();
    let num_elem = get_num_elem(LMUL_pow, SEW);
    let SEW_frac_pow : {1, 2, 3} = $[complete] match funct6 {
      VEXT2_ZVF2 => 1,
      VEXT2_SVF2 => 1,
      VEXT4_ZVF4 => 2,
      VEXT4_SVF4 => 2,
      VEXT8_ZVF8 => 3,
      VEXT8_SVF8 => 3
    };
    let LMUL_pow_div = $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(LMUL_pow, SEW_frac_pow);
    let SEW_div = $[overloaded { "name" = "/", "is_infix" = true }] quot_positive_round_zero(SEW, 2 ^ SEW_frac_pow);
    if $[overloaded { "name" = "|", "is_infix" = true }] or_bool(illegal_variable_width(vd, vm, SEW_div, LMUL_pow_div), not(valid_reg_overlap(vs2, vd, LMUL_pow_div, LMUL_pow))) then return(Illegal_Instruction());
    assert($[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(SEW_div, 8), "./extensions/V/vext_arith_insts.sail:1753.21-1753.22");
    let 'n = num_elem;
    let 'm = SEW;
    let 'o = SEW_div;
    let vm_val : bits('n) = read_vmask(num_elem, vm, zvreg);
    let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);
    let vs2_val : vector('n, bits('o)) = read_vreg(num_elem, SEW_div, LMUL_pow_div, vs2);
    let (initial_result, mask) : (vector('n, bits('m)), bits('n)) = $[complete] match init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val) {
      Ok(v) => v,
      Err(()) => return(Illegal_Instruction())
    };
    var result = initial_result;
    foreach (i from 0 to sub_atom(num_elem, 1) by 1 in inc) {
        if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(mask, i), bitone) then {
            result[i] = $[complete] match funct6 {
              VEXT2_ZVF2 => zero_extend($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)),
              VEXT2_SVF2 => sign_extend($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)),
              VEXT4_ZVF4 => zero_extend($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)),
              VEXT4_SVF4 => sign_extend($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)),
              VEXT8_ZVF8 => zero_extend($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)),
              VEXT8_SVF8 => sign_extend($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i))
            }
        };
        ()
    };
    write_vreg(num_elem, SEW, LMUL_pow, vd, result);
    set_vstart(zeros(16));
    RETIRE_SUCCESS
}
and execute VMVXS((vs2, rd)) = {
    let SEW = get_sew();
    let num_elem = get_num_elem(0, SEW);
    if illegal_vd_unmasked() then return(Illegal_Instruction());
    assert($[overloaded { "name" = ">", "is_infix" = true }] gt_int(num_elem, 0), "./extensions/V/vext_arith_insts.sail:1812.21-1812.22");
    let 'n = num_elem;
    let 'm = SEW;
    let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, 0, vs2);
    $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(rd, if $[overloaded { "name" = "<", "is_infix" = true }] lt_int(xlen, SEW) then
      $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, 0), $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(xlen, 1), 0)
    else
      if $[overloaded { "name" = ">", "is_infix" = true }] gt_int(xlen, SEW) then
        sign_extend(sizeof(xlen), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, 0))
      else
        $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, 0));
    set_vstart(zeros(16));
    RETIRE_SUCCESS
}
and execute MVVCOMPRESS((vs2, vs1, vd)) = {
    let start_element : nat = $[complete] match get_start_element() {
      Ok(v) => v,
      Err(()) => return(Illegal_Instruction())
    };
    let end_element = get_end_element();
    let SEW = get_sew();
    let LMUL_pow = get_lmul_pow();
    let num_elem = get_num_elem(LMUL_pow, SEW);
    if $[overloaded { "name" = "|", "is_infix" = true }] or_bool($[overloaded { "name" = "!=", "is_infix" = true }] neq_int(start_element, 0), $[overloaded { "name" = "|", "is_infix" = true }] or_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_anything(vs1, vd), $[overloaded { "name" = "|", "is_infix" = true }] or_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_anything(vs2, vd), illegal_vd_unmasked()))) then return(Illegal_Instruction());
    let 'n = num_elem;
    let 'm = SEW;
    let vs1_val : bits('n) = read_vmask(num_elem, 0b0, vs1);
    let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);
    let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);
    var result : vector('n, bits('m)) = vector_init($[overloaded { "name" = "__size", "is_infix" = false }] __id(n), zeros($[overloaded { "name" = "__size", "is_infix" = false }] __id(m)));
    var vd_idx : nat = 0;
    foreach (i from 0 to sub_atom(num_elem, 1) by 1 in inc) {
        if $[overloaded { "name" = "<=", "is_infix" = true }] lteq_int(i, end_element) then {
            if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(vs1_val, i), bitone) then {
                let 'p = vd_idx;
                assert($[overloaded { "name" = "<", "is_infix" = true }] lt_int($[overloaded { "name" = "__size", "is_infix" = false }] __id(p), $[overloaded { "name" = "__size", "is_infix" = false }] __id(n)), "./extensions/V/vext_arith_insts.sail:1863.22-1863.23");
                result[$[overloaded { "name" = "__size", "is_infix" = false }] __id(p)] = $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i);
                vd_idx = $[overloaded { "name" = "+", "is_infix" = true }] add_atom(vd_idx, 1)
            };
            ()
        };
        ()
    };
    if $[overloaded { "name" = "<", "is_infix" = true }] lt_int(vd_idx, num_elem) then {
        let tail_ag : agtype = get_vtype_vta();
        let 'p = vd_idx;
        foreach (i from __id(p) to sub_atom(num_elem, 1) by 1 in inc) {
            result[i] = $[complete] match tail_ag {
              UNDISTURBED => $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vd_val, i),
              AGNOSTIC => $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vd_val, i)
            }
        }
    };
    write_vreg(num_elem, SEW, LMUL_pow, vd, result);
    set_vstart(zeros(16));
    RETIRE_SUCCESS
}
and execute MVXTYPE((funct6, vm, vs2, rs1, vd)) = {
    let SEW = get_sew();
    let LMUL_pow = get_lmul_pow();
    let num_elem = get_num_elem(LMUL_pow, SEW);
    if illegal_normal(vd, vm) then return(Illegal_Instruction());
    let 'n = num_elem;
    let 'm = SEW;
    let vm_val : bits('n) = read_vmask(num_elem, vm, zvreg);
    let rs1_val : bits('m) = get_scalar(rs1, SEW);
    let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);
    let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);
    let (initial_result, mask) : (vector('n, bits('m)), bits('n)) = $[complete] match init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val) {
      Ok(v) => v,
      Err(()) => return(Illegal_Instruction())
    };
    var result = initial_result;
    foreach (i from 0 to sub_atom(num_elem, 1) by 1 in inc) {
        if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(mask, i), bitone) then {
            result[i] = $[complete] match funct6 {
              MVX_VAADDU => {
                  let result_add = $[overloaded { "name" = "+", "is_infix" = true }] add_bits(zero_extend($[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), 1), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)), zero_extend($[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), 1), rs1_val));
                  let rounding_incr = get_fixed_rounding_incr(result_add, 1);
                  $[overloaded { "name" = "+", "is_infix" = true }] add_bits($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits($[overloaded { "name" = ">>", "is_infix" = true }] shiftr(result_add, 1), $[overloaded { "name" = "-", "is_infix" = true }] sub_atom($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), 1), 0), zero_extend($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), rounding_incr))
              },
              MVX_VAADD => {
                  let result_add = $[overloaded { "name" = "+", "is_infix" = true }] add_bits(sign_extend($[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), 1), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)), sign_extend($[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), 1), rs1_val));
                  let rounding_incr = get_fixed_rounding_incr(result_add, 1);
                  $[overloaded { "name" = "+", "is_infix" = true }] add_bits($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits($[overloaded { "name" = ">>", "is_infix" = true }] shiftr(result_add, 1), $[overloaded { "name" = "-", "is_infix" = true }] sub_atom($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), 1), 0), zero_extend($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), rounding_incr))
              },
              MVX_VASUBU => {
                  let result_sub = $[overloaded { "name" = "-", "is_infix" = true }] sub_vec(zero_extend($[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), 1), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)), zero_extend($[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), 1), rs1_val));
                  let rounding_incr = get_fixed_rounding_incr(result_sub, 1);
                  $[overloaded { "name" = "+", "is_infix" = true }] add_bits($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits($[overloaded { "name" = ">>", "is_infix" = true }] shiftr(result_sub, 1), $[overloaded { "name" = "-", "is_infix" = true }] sub_atom($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), 1), 0), zero_extend($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), rounding_incr))
              },
              MVX_VASUB => {
                  let result_sub = $[overloaded { "name" = "-", "is_infix" = true }] sub_vec(sign_extend($[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), 1), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)), sign_extend($[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), 1), rs1_val));
                  let rounding_incr = get_fixed_rounding_incr(result_sub, 1);
                  $[overloaded { "name" = "+", "is_infix" = true }] add_bits($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits($[overloaded { "name" = ">>", "is_infix" = true }] shiftr(result_sub, 1), $[overloaded { "name" = "-", "is_infix" = true }] sub_atom($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), 1), 0), zero_extend($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), rounding_incr))
              },
              MVX_VSLIDE1UP => {
                  if $[overloaded { "name" = "==", "is_infix" = true }] eq_anything(vs2, vd) then return(Illegal_Instruction());
                  if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(i, 0) then
                    rs1_val
                  else
                    $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(i, 1))
              },
              MVX_VSLIDE1DOWN => {
                  let last_elem = get_end_element();
                  assert($[overloaded { "name" = "<", "is_infix" = true }] lt_int(last_elem, num_elem), "./extensions/V/vext_arith_insts.sail:1963.57-1963.58");
                  if $[overloaded { "name" = "<", "is_infix" = true }] lt_int(i, last_elem) then
                    $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, $[overloaded { "name" = "+", "is_infix" = true }] add_atom(i, 1))
                  else
                    rs1_val
              },
              MVX_VMUL => get_slice_int(SEW, $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(signed($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)), signed(rs1_val)), 0),
              MVX_VMULH => get_slice_int(SEW, $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(signed($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)), signed(rs1_val)), SEW),
              MVX_VMULHU => get_slice_int(SEW, $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(unsigned($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)), unsigned(rs1_val)), SEW),
              MVX_VMULHSU => get_slice_int(SEW, $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(signed($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)), unsigned(rs1_val)), SEW),
              MVX_VDIVU => {
                  let divisor = unsigned(rs1_val);
                  let dividend = unsigned($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i));
                  let q : int = if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(divisor, 0) then
                    -1
                  else
                    quot_round_zero(dividend, divisor);
                  to_bits_unsafe(SEW, q)
              },
              MVX_VDIV => {
                  let elem_max : int = $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(2 ^ sub_atom(SEW, 1), 1);
                  let elem_min : int = $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(0, 2 ^ sub_atom(SEW, 1));
                  let divisor = signed(rs1_val);
                  let dividend = signed($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i));
                  let q : int = if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(divisor, 0) then
                    -1
                  else
                    quot_round_zero(dividend, divisor);
                  let q' : int = if $[overloaded { "name" = ">", "is_infix" = true }] gt_int(q, elem_max) then
                    elem_min
                  else
                    q;
                  to_bits_unsafe(SEW, q')
              },
              MVX_VREMU => {
                  let divisor = unsigned(rs1_val);
                  let dividend = unsigned($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i));
                  let r : int = if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(divisor, 0) then
                    dividend
                  else
                    rem_round_zero(dividend, divisor);
                  to_bits_unsafe(SEW, r)
              },
              MVX_VREM => {
                  let divisor = signed(rs1_val);
                  let dividend = signed($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i));
                  let r : int = if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(divisor, 0) then
                    dividend
                  else
                    rem_round_zero(dividend, divisor);
                  to_bits_unsafe(SEW, r)
              }
            }
        };
        ()
    };
    write_vreg(num_elem, SEW, LMUL_pow, vd, result);
    set_vstart(zeros(16));
    RETIRE_SUCCESS
}
and execute MVXMATYPE((funct6, vm, vs2, rs1, vd)) = {
    let SEW = get_sew();
    let LMUL_pow = get_lmul_pow();
    let num_elem = get_num_elem(LMUL_pow, SEW);
    if illegal_normal(vd, vm) then return(Illegal_Instruction());
    let 'n = num_elem;
    let 'm = SEW;
    let vm_val : bits('n) = read_vmask(num_elem, vm, zvreg);
    let rs1_val : bits('m) = get_scalar(rs1, SEW);
    let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);
    let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);
    let (initial_result, mask) : (vector('n, bits('m)), bits('n)) = $[complete] match init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val) {
      Ok(v) => v,
      Err(()) => return(Illegal_Instruction())
    };
    var result = initial_result;
    foreach (i from 0 to sub_atom(num_elem, 1) by 1 in inc) {
        if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(mask, i), bitone) then {
            result[i] = $[complete] match funct6 {
              MVX_VMACC => $[overloaded { "name" = "+", "is_infix" = true }] add_bits(get_slice_int(SEW, $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(signed(rs1_val), signed($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i))), 0), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vd_val, i)),
              MVX_VNMSAC => $[overloaded { "name" = "-", "is_infix" = true }] sub_vec($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vd_val, i), get_slice_int(SEW, $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(signed(rs1_val), signed($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i))), 0)),
              MVX_VMADD => $[overloaded { "name" = "+", "is_infix" = true }] add_bits(get_slice_int(SEW, $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(signed(rs1_val), signed($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vd_val, i))), 0), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)),
              MVX_VNMSUB => $[overloaded { "name" = "-", "is_infix" = true }] sub_vec($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i), get_slice_int(SEW, $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(signed(rs1_val), signed($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vd_val, i))), 0))
            }
        };
        ()
    };
    write_vreg(num_elem, SEW, LMUL_pow, vd, result);
    set_vstart(zeros(16));
    RETIRE_SUCCESS
}
and execute WVXTYPE((funct6, vm, vs2, rs1, vd)) = {
    let SEW = get_sew();
    let LMUL_pow = get_lmul_pow();
    let num_elem = get_num_elem(LMUL_pow, SEW);
    let SEW_widen = $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(SEW, 2);
    let LMUL_pow_widen = $[overloaded { "name" = "+", "is_infix" = true }] add_atom(LMUL_pow, 1);
    if $[overloaded { "name" = "|", "is_infix" = true }] or_bool(illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen), not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))) then return(Illegal_Instruction());
    assert($[overloaded { "name" = "<=", "is_infix" = true }] lteq_int(SEW_widen, 64), "./extensions/V/vext_arith_insts.sail:2119.24-2119.25");
    let 'n = num_elem;
    let 'm = SEW;
    let 'o = SEW_widen;
    let vm_val : bits('n) = read_vmask(num_elem, vm, zvreg);
    let vd_val : vector('n, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd);
    let rs1_val : bits('m) = get_scalar(rs1, SEW);
    let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);
    let (initial_result, mask) : (vector('n, bits('o)), bits('n)) = $[complete] match init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val) {
      Ok(v) => v,
      Err(()) => return(Illegal_Instruction())
    };
    var result = initial_result;
    foreach (i from 0 to sub_atom(num_elem, 1) by 1 in inc) {
        if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(mask, i), bitone) then {
            result[i] = $[complete] match funct6 {
              WVX_VADD => to_bits_unsafe(SEW_widen, $[overloaded { "name" = "+", "is_infix" = true }] add_atom(signed($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)), signed(rs1_val))),
              WVX_VSUB => to_bits_unsafe(SEW_widen, $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(signed($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)), signed(rs1_val))),
              WVX_VADDU => to_bits_unsafe(SEW_widen, $[overloaded { "name" = "+", "is_infix" = true }] add_atom(unsigned($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)), unsigned(rs1_val))),
              WVX_VSUBU => to_bits_unsafe(SEW_widen, $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(unsigned($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)), unsigned(rs1_val))),
              WVX_VWMUL => to_bits_unsafe(SEW_widen, $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(signed($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)), signed(rs1_val))),
              WVX_VWMULU => to_bits_unsafe(SEW_widen, $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(unsigned($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)), unsigned(rs1_val))),
              WVX_VWMULSU => to_bits_unsafe(SEW_widen, $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(signed($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)), unsigned(rs1_val)))
            }
        };
        ()
    };
    write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result);
    set_vstart(zeros(16));
    RETIRE_SUCCESS
}
and execute WXTYPE((funct6, vm, vs2, rs1, vd)) = {
    let SEW = get_sew();
    let LMUL_pow = get_lmul_pow();
    let num_elem = get_num_elem(LMUL_pow, SEW);
    let SEW_widen = $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(SEW, 2);
    let LMUL_pow_widen = $[overloaded { "name" = "+", "is_infix" = true }] add_atom(LMUL_pow, 1);
    if illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen) then return(Illegal_Instruction());
    assert($[overloaded { "name" = "<=", "is_infix" = true }] lteq_int(SEW_widen, 64), "./extensions/V/vext_arith_insts.sail:2192.24-2192.25");
    let 'n = num_elem;
    let 'm = SEW;
    let 'o = SEW_widen;
    let vm_val : bits('n) = read_vmask(num_elem, vm, zvreg);
    let vd_val : vector('n, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd);
    let rs1_val : bits('m) = get_scalar(rs1, SEW);
    let vs2_val : vector('n, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2);
    let (initial_result, mask) : (vector('n, bits('o)), bits('n)) = $[complete] match init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val) {
      Ok(v) => v,
      Err(()) => return(Illegal_Instruction())
    };
    var result = initial_result;
    foreach (i from 0 to sub_atom(num_elem, 1) by 1 in inc) {
        if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(mask, i), bitone) then {
            result[i] = $[complete] match funct6 {
              WX_VADD => to_bits_unsafe(SEW_widen, $[overloaded { "name" = "+", "is_infix" = true }] add_atom(signed($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)), signed(rs1_val))),
              WX_VSUB => to_bits_unsafe(SEW_widen, $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(signed($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)), signed(rs1_val))),
              WX_VADDU => to_bits_unsafe(SEW_widen, $[overloaded { "name" = "+", "is_infix" = true }] add_atom(unsigned($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)), unsigned(rs1_val))),
              WX_VSUBU => to_bits_unsafe(SEW_widen, $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(unsigned($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)), unsigned(rs1_val)))
            }
        };
        ()
    };
    write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result);
    set_vstart(zeros(16));
    RETIRE_SUCCESS
}
and execute WMVXTYPE((funct6, vm, vs2, rs1, vd)) = {
    let SEW = get_sew();
    let LMUL_pow = get_lmul_pow();
    let num_elem = get_num_elem(LMUL_pow, SEW);
    let SEW_widen = $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(SEW, 2);
    let LMUL_pow_widen = $[overloaded { "name" = "+", "is_infix" = true }] add_atom(LMUL_pow, 1);
    if $[overloaded { "name" = "|", "is_infix" = true }] or_bool(illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen), not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))) then return(Illegal_Instruction());
    assert($[overloaded { "name" = "<=", "is_infix" = true }] lteq_int(SEW_widen, 64), "./extensions/V/vext_arith_insts.sail:2261.24-2261.25");
    let 'n = num_elem;
    let 'm = SEW;
    let 'o = SEW_widen;
    let vm_val : bits('n) = read_vmask(num_elem, vm, zvreg);
    let vd_val : vector('n, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd);
    let rs1_val : bits('m) = get_scalar(rs1, SEW);
    let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);
    let (initial_result, mask) : (vector('n, bits('o)), bits('n)) = $[complete] match init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val) {
      Ok(v) => v,
      Err(()) => return(Illegal_Instruction())
    };
    var result = initial_result;
    foreach (i from 0 to sub_atom(num_elem, 1) by 1 in inc) {
        if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(mask, i), bitone) then {
            result[i] = $[complete] match funct6 {
              WMVX_VWMACCU => $[overloaded { "name" = "+", "is_infix" = true }] add_bits(to_bits_unsafe(SEW_widen, $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(unsigned(rs1_val), unsigned($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)))), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vd_val, i)),
              WMVX_VWMACC => $[overloaded { "name" = "+", "is_infix" = true }] add_bits(to_bits_unsafe(SEW_widen, $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(signed(rs1_val), signed($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)))), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vd_val, i)),
              WMVX_VWMACCUS => $[overloaded { "name" = "+", "is_infix" = true }] add_bits(to_bits_unsafe(SEW_widen, $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(unsigned(rs1_val), signed($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)))), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vd_val, i)),
              WMVX_VWMACCSU => $[overloaded { "name" = "+", "is_infix" = true }] add_bits(to_bits_unsafe(SEW_widen, $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(signed(rs1_val), unsigned($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)))), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vd_val, i))
            }
        };
        ()
    };
    write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result);
    set_vstart(zeros(16));
    RETIRE_SUCCESS
}
and execute VMVSX((rs1, vd)) = {
    let SEW = get_sew();
    let num_elem = get_num_elem(0, SEW);
    if illegal_vd_unmasked() then return(Illegal_Instruction());
    assert($[overloaded { "name" = ">", "is_infix" = true }] gt_int(num_elem, 0), "./extensions/V/vext_arith_insts.sail:2317.21-2317.22");
    let 'n = num_elem;
    let 'm = SEW;
    let rs1_val : bits('m) = get_scalar(rs1, $[overloaded { "name" = "__size", "is_infix" = false }] __id(m));
    let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, 0, vd);
    let (initial_result, mask) : (vector('n, bits('m)), bits('n)) = $[complete] match init_masked_result(num_elem, SEW, 0, vd_val, ones($[overloaded { "name" = "__size", "is_infix" = false }] __id(num_elem))) {
      Ok(v) => v,
      Err(()) => return(Illegal_Instruction())
    };
    var result = initial_result;
    if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(mask, 0), bitone) then result[0] = rs1_val;
    let tail_ag : agtype = get_vtype_vta();
    foreach (i from 1 to sub_atom(num_elem, 1) by 1 in inc) {
        result[i] = $[complete] match tail_ag {
          UNDISTURBED => $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vd_val, i),
          AGNOSTIC => $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vd_val, i)
        }
    };
    write_vreg(num_elem, SEW, 0, vd, result);
    set_vstart(zeros(16));
    RETIRE_SUCCESS
}
and execute FVVTYPE((funct6, vm, vs2, vs1, vd)) = {
    let rm_3b = _get_Fcsr_FRM(fcsr);
    let SEW = get_sew();
    let LMUL_pow = get_lmul_pow();
    let num_elem = get_num_elem(LMUL_pow, SEW);
    if illegal_fp_normal(vd, vm, SEW, rm_3b) then return(Illegal_Instruction());
    assert($[overloaded { "name" = "!=", "is_infix" = true }] neq_int(SEW, 8), "./extensions/V/vext_fp_insts.sail:41.17-41.18");
    let 'n = num_elem;
    let 'm = SEW;
    let vm_val : bits('n) = read_vmask(num_elem, vm, zvreg);
    let vs1_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);
    let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);
    let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);
    let (initial_result, mask) : (vector('n, bits('m)), bits('n)) = $[complete] match init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val) {
      Ok(v) => v,
      Err(()) => return(Illegal_Instruction())
    };
    var result = initial_result;
    foreach (i from 0 to sub_atom(num_elem, 1) by 1 in inc) {
        if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(mask, i), bitone) then {
            result[i] = $[complete] match funct6 {
              FVV_VADD => fp_add(rm_3b, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs1_val, i)),
              FVV_VSUB => fp_sub(rm_3b, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs1_val, i)),
              FVV_VMIN => fp_min($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs1_val, i)),
              FVV_VMAX => fp_max($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs1_val, i)),
              FVV_VMUL => fp_mul(rm_3b, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs1_val, i)),
              FVV_VDIV => fp_div(rm_3b, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs1_val, i)),
              FVV_VSGNJ => $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat([$[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs1_val, i), $[overloaded { "name" = "-", "is_infix" = true }] sub_atom($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), 1))], $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i), $[overloaded { "name" = "-", "is_infix" = true }] sub_atom($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), 2), 0)),
              FVV_VSGNJN => $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat($[overloaded { "name" = "^", "is_infix" = true }] xor_vec(0b1, [$[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs1_val, i), $[overloaded { "name" = "-", "is_infix" = true }] sub_atom($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), 1))]), $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i), $[overloaded { "name" = "-", "is_infix" = true }] sub_atom($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), 2), 0)),
              FVV_VSGNJX => $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat($[overloaded { "name" = "^", "is_infix" = true }] xor_vec([$[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i), $[overloaded { "name" = "-", "is_infix" = true }] sub_atom($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), 1))], [$[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs1_val, i), $[overloaded { "name" = "-", "is_infix" = true }] sub_atom($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), 1))]), $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i), $[overloaded { "name" = "-", "is_infix" = true }] sub_atom($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), 2), 0))
            }
        };
        ()
    };
    write_vreg(num_elem, SEW, LMUL_pow, vd, result);
    set_vstart(zeros(16));
    RETIRE_SUCCESS
}
and execute FVVMATYPE((funct6, vm, vs2, vs1, vd)) = {
    let rm_3b = _get_Fcsr_FRM(fcsr);
    let SEW = get_sew();
    let LMUL_pow = get_lmul_pow();
    let num_elem = get_num_elem(LMUL_pow, SEW);
    if illegal_fp_normal(vd, vm, SEW, rm_3b) then return(Illegal_Instruction());
    assert($[overloaded { "name" = "!=", "is_infix" = true }] neq_int(SEW, 8), "./extensions/V/vext_fp_insts.sail:119.17-119.18");
    let 'n = num_elem;
    let 'm = SEW;
    let vm_val : bits('n) = read_vmask(num_elem, vm, zvreg);
    let vs1_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);
    let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);
    let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);
    let (initial_result, mask) : (vector('n, bits('m)), bits('n)) = $[complete] match init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val) {
      Ok(v) => v,
      Err(()) => return(Illegal_Instruction())
    };
    var result = initial_result;
    foreach (i from 0 to sub_atom(num_elem, 1) by 1 in inc) {
        if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(mask, i), bitone) then {
            result[i] = $[complete] match funct6 {
              FVV_VMACC => fp_muladd(rm_3b, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs1_val, i), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vd_val, i)),
              FVV_VNMACC => fp_nmulsub(rm_3b, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs1_val, i), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vd_val, i)),
              FVV_VMSAC => fp_mulsub(rm_3b, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs1_val, i), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vd_val, i)),
              FVV_VNMSAC => fp_nmuladd(rm_3b, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs1_val, i), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vd_val, i)),
              FVV_VMADD => fp_muladd(rm_3b, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs1_val, i), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vd_val, i), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)),
              FVV_VNMADD => fp_nmulsub(rm_3b, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs1_val, i), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vd_val, i), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)),
              FVV_VMSUB => fp_mulsub(rm_3b, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs1_val, i), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vd_val, i), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)),
              FVV_VNMSUB => fp_nmuladd(rm_3b, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs1_val, i), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vd_val, i), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i))
            }
        };
        ()
    };
    write_vreg(num_elem, SEW, LMUL_pow, vd, result);
    set_vstart(zeros(16));
    RETIRE_SUCCESS
}
and execute FWVVTYPE((funct6, vm, vs2, vs1, vd)) = {
    let rm_3b = _get_Fcsr_FRM(fcsr);
    let SEW = get_sew();
    let LMUL_pow = get_lmul_pow();
    let num_elem = get_num_elem(LMUL_pow, SEW);
    let SEW_widen = $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(SEW, 2);
    let LMUL_pow_widen = $[overloaded { "name" = "+", "is_infix" = true }] add_atom(LMUL_pow, 1);
    if $[overloaded { "name" = "|", "is_infix" = true }] or_bool(illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen), $[overloaded { "name" = "|", "is_infix" = true }] or_bool(not(valid_reg_overlap(vs1, vd, LMUL_pow, LMUL_pow_widen)), not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen)))) then return(Illegal_Instruction());
    assert($[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(SEW, 16), $[overloaded { "name" = "<=", "is_infix" = true }] lteq_int(SEW_widen, 64)), "./extensions/V/vext_fp_insts.sail:194.36-194.37");
    let 'n = num_elem;
    let 'm = SEW;
    let 'o = SEW_widen;
    let vm_val : bits('n) = read_vmask(num_elem, vm, zvreg);
    let vd_val : vector('n, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd);
    let vs1_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);
    let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);
    let (initial_result, mask) : (vector('n, bits('o)), bits('n)) = $[complete] match init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val) {
      Ok(v) => v,
      Err(()) => return(Illegal_Instruction())
    };
    var result = initial_result;
    foreach (i from 0 to sub_atom(num_elem, 1) by 1 in inc) {
        if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(mask, i), bitone) then {
            result[i] = $[complete] match funct6 {
              FWVV_VADD => fp_add(rm_3b, fp_widen($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)), fp_widen($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs1_val, i))),
              FWVV_VSUB => fp_sub(rm_3b, fp_widen($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)), fp_widen($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs1_val, i))),
              FWVV_VMUL => fp_mul(rm_3b, fp_widen($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)), fp_widen($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs1_val, i)))
            }
        };
        ()
    };
    write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result);
    set_vstart(zeros(16));
    RETIRE_SUCCESS
}
and execute FWVVMATYPE((funct6, vm, vs1, vs2, vd)) = {
    let rm_3b = _get_Fcsr_FRM(fcsr);
    let SEW = get_sew();
    let LMUL_pow = get_lmul_pow();
    let num_elem = get_num_elem(LMUL_pow, SEW);
    let SEW_widen = $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(SEW, 2);
    let LMUL_pow_widen = $[overloaded { "name" = "+", "is_infix" = true }] add_atom(LMUL_pow, 1);
    if $[overloaded { "name" = "|", "is_infix" = true }] or_bool(illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen), $[overloaded { "name" = "|", "is_infix" = true }] or_bool(not(valid_reg_overlap(vs1, vd, LMUL_pow, LMUL_pow_widen)), not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen)))) then return(Illegal_Instruction());
    assert($[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(SEW, 16), $[overloaded { "name" = "<=", "is_infix" = true }] lteq_int(SEW_widen, 64)), "./extensions/V/vext_fp_insts.sail:262.36-262.37");
    let 'n = num_elem;
    let 'm = SEW;
    let 'o = SEW_widen;
    let vm_val : bits('n) = read_vmask(num_elem, vm, zvreg);
    let vd_val : vector('n, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd);
    let vs1_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);
    let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);
    let (initial_result, mask) : (vector('n, bits('o)), bits('n)) = $[complete] match init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val) {
      Ok(v) => v,
      Err(()) => return(Illegal_Instruction())
    };
    var result = initial_result;
    foreach (i from 0 to sub_atom(num_elem, 1) by 1 in inc) {
        if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(mask, i), bitone) then {
            result[i] = $[complete] match funct6 {
              FWVV_VMACC => fp_muladd(rm_3b, fp_widen($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs1_val, i)), fp_widen($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vd_val, i)),
              FWVV_VNMACC => fp_nmulsub(rm_3b, fp_widen($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs1_val, i)), fp_widen($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vd_val, i)),
              FWVV_VMSAC => fp_mulsub(rm_3b, fp_widen($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs1_val, i)), fp_widen($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vd_val, i)),
              FWVV_VNMSAC => fp_nmuladd(rm_3b, fp_widen($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs1_val, i)), fp_widen($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vd_val, i))
            }
        };
        ()
    };
    write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result);
    set_vstart(zeros(16));
    RETIRE_SUCCESS
}
and execute FWVTYPE((funct6, vm, vs2, vs1, vd)) = {
    let rm_3b = _get_Fcsr_FRM(fcsr);
    let SEW = get_sew();
    let LMUL_pow = get_lmul_pow();
    let num_elem = get_num_elem(LMUL_pow, SEW);
    let SEW_widen = $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(SEW, 2);
    let LMUL_pow_widen = $[overloaded { "name" = "+", "is_infix" = true }] add_atom(LMUL_pow, 1);
    if $[overloaded { "name" = "|", "is_infix" = true }] or_bool(illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen), not(valid_reg_overlap(vs1, vd, LMUL_pow, LMUL_pow_widen))) then return(Illegal_Instruction());
    assert($[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(SEW, 16), $[overloaded { "name" = "<=", "is_infix" = true }] lteq_int(SEW_widen, 64)), "./extensions/V/vext_fp_insts.sail:328.36-328.37");
    let 'n = num_elem;
    let 'm = SEW;
    let 'o = SEW_widen;
    let vm_val : bits('n) = read_vmask(num_elem, vm, zvreg);
    let vd_val : vector('n, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd);
    let vs1_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);
    let vs2_val : vector('n, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2);
    let (initial_result, mask) : (vector('n, bits('o)), bits('n)) = $[complete] match init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val) {
      Ok(v) => v,
      Err(()) => return(Illegal_Instruction())
    };
    var result = initial_result;
    foreach (i from 0 to sub_atom(num_elem, 1) by 1 in inc) {
        if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(mask, i), bitone) then {
            result[i] = $[complete] match funct6 {
              FWV_VADD => fp_add(rm_3b, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i), fp_widen($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs1_val, i))),
              FWV_VSUB => fp_sub(rm_3b, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i), fp_widen($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs1_val, i)))
            }
        };
        ()
    };
    write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result);
    set_vstart(zeros(16));
    RETIRE_SUCCESS
}
and execute VFUNARY0((vm, vs2, vfunary0, vd)) = {
    let rm_3b = _get_Fcsr_FRM(fcsr);
    let SEW = get_sew();
    let LMUL_pow = get_lmul_pow();
    let num_elem = get_num_elem(LMUL_pow, SEW);
    if illegal_fp_normal(vd, vm, SEW, rm_3b) then return(Illegal_Instruction());
    assert($[overloaded { "name" = "!=", "is_infix" = true }] neq_int(SEW, 8), "./extensions/V/vext_fp_insts.sail:390.17-390.18");
    let 'n = num_elem;
    let 'm = SEW;
    let vm_val : bits('n) = read_vmask(num_elem, vm, zvreg);
    let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);
    let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);
    let (initial_result, mask) : (vector('n, bits('m)), bits('n)) = $[complete] match init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val) {
      Ok(v) => v,
      Err(()) => return(Illegal_Instruction())
    };
    var result = initial_result;
    foreach (i from 0 to sub_atom(num_elem, 1) by 1 in inc) {
        if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(mask, i), bitone) then {
            result[i] = $[complete] match vfunary0 {
              FV_CVT_XU_F => {
                  let (fflags, elem) : (bits_fflags, bits('m)) = $[complete] match $[overloaded { "name" = "__size", "is_infix" = false }] __id(m) {
                    16 => riscv_f16ToUi16(rm_3b, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)),
                    32 => riscv_f32ToUi32(rm_3b, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)),
                    ($[int_wildcard 64] _) => riscv_f64ToUi64(rm_3b, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i))
                  };
                  accrue_fflags(fflags);
                  elem
              },
              FV_CVT_X_F => {
                  let (fflags, elem) : (bits_fflags, bits('m)) = $[complete] match $[overloaded { "name" = "__size", "is_infix" = false }] __id(m) {
                    16 => riscv_f16ToI16(rm_3b, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)),
                    32 => riscv_f32ToI32(rm_3b, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)),
                    ($[int_wildcard 64] _) => riscv_f64ToI64(rm_3b, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i))
                  };
                  accrue_fflags(fflags);
                  elem
              },
              FV_CVT_F_XU => {
                  let (fflags, elem) : (bits_fflags, bits('m)) = $[complete] match $[overloaded { "name" = "__size", "is_infix" = false }] __id(m) {
                    16 => riscv_ui32ToF16(rm_3b, zero_extend(32, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i))),
                    32 => riscv_ui32ToF32(rm_3b, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)),
                    ($[int_wildcard 64] _) => riscv_ui64ToF64(rm_3b, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i))
                  };
                  accrue_fflags(fflags);
                  elem
              },
              FV_CVT_F_X => {
                  let (fflags, elem) : (bits_fflags, bits('m)) = $[complete] match $[overloaded { "name" = "__size", "is_infix" = false }] __id(m) {
                    16 => riscv_i32ToF16(rm_3b, sign_extend(32, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i))),
                    32 => riscv_i32ToF32(rm_3b, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)),
                    ($[int_wildcard 64] _) => riscv_i64ToF64(rm_3b, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i))
                  };
                  accrue_fflags(fflags);
                  elem
              },
              FV_CVT_RTZ_XU_F => {
                  let (fflags, elem) : (bits_fflags, bits('m)) = $[complete] match $[overloaded { "name" = "__size", "is_infix" = false }] __id(m) {
                    16 => riscv_f16ToUi16(0b001, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)),
                    32 => riscv_f32ToUi32(0b001, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)),
                    ($[int_wildcard 64] _) => riscv_f64ToUi64(0b001, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i))
                  };
                  accrue_fflags(fflags);
                  elem
              },
              FV_CVT_RTZ_X_F => {
                  let (fflags, elem) : (bits_fflags, bits('m)) = $[complete] match $[overloaded { "name" = "__size", "is_infix" = false }] __id(m) {
                    16 => riscv_f16ToI16(0b001, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)),
                    32 => riscv_f32ToI32(0b001, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)),
                    ($[int_wildcard 64] _) => riscv_f64ToI64(0b001, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i))
                  };
                  accrue_fflags(fflags);
                  elem
              }
            }
        };
        ()
    };
    write_vreg(num_elem, SEW, LMUL_pow, vd, result);
    set_vstart(zeros(16));
    RETIRE_SUCCESS
}
and execute VFWUNARY0((vm, vs2, vfwunary0, vd)) = {
    let rm_3b = _get_Fcsr_FRM(fcsr);
    let SEW = get_sew();
    let LMUL_pow = get_lmul_pow();
    let num_elem = get_num_elem(LMUL_pow, SEW);
    let SEW_widen = $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(SEW, 2);
    let LMUL_pow_widen = $[overloaded { "name" = "+", "is_infix" = true }] add_atom(LMUL_pow, 1);
    if $[overloaded { "name" = "|", "is_infix" = true }] or_bool(illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen), not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))) then return(Illegal_Instruction());
    assert($[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(SEW, 8), $[overloaded { "name" = "<=", "is_infix" = true }] lteq_int(SEW_widen, 64)), "./extensions/V/vext_fp_insts.sail:511.35-511.36");
    let 'n = num_elem;
    let 'm = SEW;
    let 'o = SEW_widen;
    let vm_val : bits('n) = read_vmask(num_elem, vm, zvreg);
    let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);
    let vd_val : vector('n, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd);
    let (initial_result, mask) : (vector('n, bits('o)), bits('n)) = $[complete] match init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val) {
      Ok(v) => v,
      Err(()) => return(Illegal_Instruction())
    };
    var result = initial_result;
    foreach (i from 0 to sub_atom(num_elem, 1) by 1 in inc) {
        if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(mask, i), bitone) then {
            result[i] = $[complete] match vfwunary0 {
              FWV_CVT_XU_F => {
                  let (fflags, elem) : (bits_fflags, bits('o)) = $[complete] match $[overloaded { "name" = "__size", "is_infix" = false }] __id(m) {
                    8 => return(Illegal_Instruction()),
                    16 => riscv_f16ToUi32(rm_3b, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)),
                    ($[int_wildcard 32] _) => riscv_f32ToUi64(rm_3b, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i))
                  };
                  accrue_fflags(fflags);
                  elem
              },
              FWV_CVT_X_F => {
                  let (fflags, elem) : (bits_fflags, bits('o)) = $[complete] match $[overloaded { "name" = "__size", "is_infix" = false }] __id(m) {
                    8 => return(Illegal_Instruction()),
                    16 => riscv_f16ToI32(rm_3b, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)),
                    ($[int_wildcard 32] _) => riscv_f32ToI64(rm_3b, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i))
                  };
                  accrue_fflags(fflags);
                  elem
              },
              FWV_CVT_F_XU => {
                  let (fflags, elem) : (bits_fflags, bits('o)) = $[complete] match $[overloaded { "name" = "__size", "is_infix" = false }] __id(m) {
                    8 => riscv_ui32ToF16(rm_3b, zero_extend(32, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i))),
                    16 => riscv_ui32ToF32(rm_3b, zero_extend(32, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i))),
                    ($[int_wildcard 32] _) => riscv_ui32ToF64(rm_3b, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i))
                  };
                  accrue_fflags(fflags);
                  elem
              },
              FWV_CVT_F_X => {
                  let (fflags, elem) : (bits_fflags, bits('o)) = $[complete] match $[overloaded { "name" = "__size", "is_infix" = false }] __id(m) {
                    8 => riscv_i32ToF16(rm_3b, sign_extend(32, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i))),
                    16 => riscv_i32ToF32(rm_3b, sign_extend(32, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i))),
                    ($[int_wildcard 32] _) => riscv_i32ToF64(rm_3b, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i))
                  };
                  accrue_fflags(fflags);
                  elem
              },
              FWV_CVT_F_F => {
                  let (fflags, elem) : (bits_fflags, bits('o)) = $[complete] match $[overloaded { "name" = "__size", "is_infix" = false }] __id(m) {
                    8 => return(Illegal_Instruction()),
                    16 => riscv_f16ToF32(rm_3b, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)),
                    ($[int_wildcard 32] _) => riscv_f32ToF64(rm_3b, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i))
                  };
                  accrue_fflags(fflags);
                  elem
              },
              FWV_CVT_RTZ_XU_F => {
                  let (fflags, elem) : (bits_fflags, bits('o)) = $[complete] match $[overloaded { "name" = "__size", "is_infix" = false }] __id(m) {
                    8 => return(Illegal_Instruction()),
                    16 => riscv_f16ToUi32(0b001, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)),
                    ($[int_wildcard 32] _) => riscv_f32ToUi64(0b001, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i))
                  };
                  accrue_fflags(fflags);
                  elem
              },
              FWV_CVT_RTZ_X_F => {
                  let (fflags, elem) : (bits_fflags, bits('o)) = $[complete] match $[overloaded { "name" = "__size", "is_infix" = false }] __id(m) {
                    8 => return(Illegal_Instruction()),
                    16 => riscv_f16ToI32(0b001, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)),
                    ($[int_wildcard 32] _) => riscv_f32ToI64(0b001, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i))
                  };
                  accrue_fflags(fflags);
                  elem
              }
            }
        };
        ()
    };
    write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result);
    set_vstart(zeros(16));
    RETIRE_SUCCESS
}
and execute VFNUNARY0((vm, vs2, vfnunary0, vd)) = {
    let rm_3b = _get_Fcsr_FRM(fcsr);
    let SEW = get_sew();
    let LMUL_pow = get_lmul_pow();
    let num_elem = get_num_elem(LMUL_pow, SEW);
    let SEW_widen = $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(SEW, 2);
    let LMUL_pow_widen = $[overloaded { "name" = "+", "is_infix" = true }] add_atom(LMUL_pow, 1);
    if $[overloaded { "name" = "|", "is_infix" = true }] or_bool(illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen), not(valid_reg_overlap(vs2, vd, LMUL_pow_widen, LMUL_pow))) then return(Illegal_Instruction());
    assert($[overloaded { "name" = "!=", "is_infix" = true }] neq_int(SEW, 64), "./extensions/V/vext_fp_insts.sail:644.18-644.19");
    let 'n = num_elem;
    let 'm = SEW;
    let 'o = SEW_widen;
    let vm_val : bits('n) = read_vmask(num_elem, vm, zvreg);
    let vs2_val : vector('n, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2);
    let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);
    let (initial_result, mask) : (vector('n, bits('m)), bits('n)) = $[complete] match init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val) {
      Ok(v) => v,
      Err(()) => return(Illegal_Instruction())
    };
    var result = initial_result;
    foreach (i from 0 to sub_atom(num_elem, 1) by 1 in inc) {
        if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(mask, i), bitone) then {
            result[i] = $[complete] match vfnunary0 {
              FNV_CVT_XU_F => {
                  let (fflags, elem) : (bits_fflags, bits('m)) = $[complete] match $[overloaded { "name" = "__size", "is_infix" = false }] __id(m) {
                    8 => riscv_f16ToUi8(rm_3b, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)),
                    16 => riscv_f32ToUi16(rm_3b, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)),
                    ($[int_wildcard 32] _) => riscv_f64ToUi32(rm_3b, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i))
                  };
                  accrue_fflags(fflags);
                  elem
              },
              FNV_CVT_X_F => {
                  let (fflags, elem) : (bits_fflags, bits('m)) = $[complete] match $[overloaded { "name" = "__size", "is_infix" = false }] __id(m) {
                    8 => riscv_f16ToI8(rm_3b, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)),
                    16 => riscv_f32ToI16(rm_3b, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)),
                    ($[int_wildcard 32] _) => riscv_f64ToI32(rm_3b, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i))
                  };
                  accrue_fflags(fflags);
                  elem
              },
              FNV_CVT_F_XU => {
                  let (fflags, elem) : (bits_fflags, bits('m)) = $[complete] match $[overloaded { "name" = "__size", "is_infix" = false }] __id(m) {
                    8 => return(Illegal_Instruction()),
                    16 => riscv_ui32ToF16(rm_3b, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)),
                    ($[int_wildcard 32] _) => riscv_ui64ToF32(rm_3b, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i))
                  };
                  accrue_fflags(fflags);
                  elem
              },
              FNV_CVT_F_X => {
                  let (fflags, elem) : (bits_fflags, bits('m)) = $[complete] match $[overloaded { "name" = "__size", "is_infix" = false }] __id(m) {
                    8 => return(Illegal_Instruction()),
                    16 => riscv_i32ToF16(rm_3b, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)),
                    ($[int_wildcard 32] _) => riscv_i64ToF32(rm_3b, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i))
                  };
                  accrue_fflags(fflags);
                  elem
              },
              FNV_CVT_F_F => {
                  let (fflags, elem) : (bits_fflags, bits('m)) = $[complete] match $[overloaded { "name" = "__size", "is_infix" = false }] __id(m) {
                    8 => return(Illegal_Instruction()),
                    16 => riscv_f32ToF16(rm_3b, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)),
                    ($[int_wildcard 32] _) => riscv_f64ToF32(rm_3b, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i))
                  };
                  accrue_fflags(fflags);
                  elem
              },
              FNV_CVT_ROD_F_F => {
                  let (fflags, elem) : (bits_fflags, bits('m)) = $[complete] match $[overloaded { "name" = "__size", "is_infix" = false }] __id(m) {
                    8 => return(Illegal_Instruction()),
                    16 => riscv_f32ToF16(0b110, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)),
                    ($[int_wildcard 32] _) => riscv_f64ToF32(0b110, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i))
                  };
                  accrue_fflags(fflags);
                  elem
              },
              FNV_CVT_RTZ_XU_F => {
                  let (fflags, elem) : (bits_fflags, bits('m)) = $[complete] match $[overloaded { "name" = "__size", "is_infix" = false }] __id(m) {
                    8 => riscv_f16ToUi8(0b001, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)),
                    16 => riscv_f32ToUi16(0b001, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)),
                    ($[int_wildcard 32] _) => riscv_f64ToUi32(0b001, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i))
                  };
                  accrue_fflags(fflags);
                  elem
              },
              FNV_CVT_RTZ_X_F => {
                  let (fflags, elem) : (bits_fflags, bits('m)) = $[complete] match $[overloaded { "name" = "__size", "is_infix" = false }] __id(m) {
                    8 => riscv_f16ToI8(0b001, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)),
                    16 => riscv_f32ToI16(0b001, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)),
                    ($[int_wildcard 32] _) => riscv_f64ToI32(0b001, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i))
                  };
                  accrue_fflags(fflags);
                  elem
              }
            }
        };
        ()
    };
    write_vreg(num_elem, SEW, LMUL_pow, vd, result);
    set_vstart(zeros(16));
    RETIRE_SUCCESS
}
and execute VFUNARY1((vm, vs2, vfunary1, vd)) = {
    let rm_3b = _get_Fcsr_FRM(fcsr);
    let SEW = get_sew();
    let LMUL_pow = get_lmul_pow();
    let num_elem = get_num_elem(LMUL_pow, SEW);
    if illegal_fp_normal(vd, vm, SEW, rm_3b) then return(Illegal_Instruction());
    assert($[overloaded { "name" = "!=", "is_infix" = true }] neq_int(SEW, 8), "./extensions/V/vext_fp_insts.sail:779.17-779.18");
    let 'n = num_elem;
    let 'm = SEW;
    let vm_val : bits('n) = read_vmask(num_elem, vm, zvreg);
    let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);
    let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);
    let (initial_result, mask) : (vector('n, bits('m)), bits('n)) = $[complete] match init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val) {
      Ok(v) => v,
      Err(()) => return(Illegal_Instruction())
    };
    var result = initial_result;
    foreach (i from 0 to sub_atom(num_elem, 1) by 1 in inc) {
        if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(mask, i), bitone) then {
            result[i] = $[complete] match vfunary1 {
              FVV_VSQRT => {
                  let (fflags, elem) : (bits_fflags, bits('m)) = $[complete] match $[overloaded { "name" = "__size", "is_infix" = false }] __id(m) {
                    16 => riscv_f16Sqrt(rm_3b, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)),
                    32 => riscv_f32Sqrt(rm_3b, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)),
                    ($[int_wildcard 64] _) => riscv_f64Sqrt(rm_3b, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i))
                  };
                  accrue_fflags(fflags);
                  elem
              },
              FVV_VRSQRT7 => {
                  let (fflags, elem) : (bits_fflags, bits('m)) = $[complete] match $[overloaded { "name" = "__size", "is_infix" = false }] __id(m) {
                    16 => riscv_f16Rsqrte7(rm_3b, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)),
                    32 => riscv_f32Rsqrte7(rm_3b, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)),
                    ($[int_wildcard 64] _) => riscv_f64Rsqrte7(rm_3b, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i))
                  };
                  accrue_fflags(fflags);
                  elem
              },
              FVV_VREC7 => {
                  let (fflags, elem) : (bits_fflags, bits('m)) = $[complete] match $[overloaded { "name" = "__size", "is_infix" = false }] __id(m) {
                    16 => riscv_f16Recip7(rm_3b, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)),
                    32 => riscv_f32Recip7(rm_3b, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)),
                    ($[int_wildcard 64] _) => riscv_f64Recip7(rm_3b, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i))
                  };
                  accrue_fflags(fflags);
                  elem
              },
              FVV_VCLASS => fp_class($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i))
            }
        };
        ()
    };
    write_vreg(num_elem, SEW, LMUL_pow, vd, result);
    set_vstart(zeros(16));
    RETIRE_SUCCESS
}
and execute VFMVFS((vs2, rd)) = {
    let rm_3b = _get_Fcsr_FRM(fcsr);
    let SEW = get_sew();
    let num_elem = get_num_elem(0, SEW);
    if $[overloaded { "name" = "|", "is_infix" = true }] or_bool(illegal_fp_vd_unmasked(SEW, rm_3b), $[overloaded { "name" = ">", "is_infix" = true }] gt_int(SEW, flen)) then return(Illegal_Instruction());
    assert($[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = ">", "is_infix" = true }] gt_int(num_elem, 0), $[overloaded { "name" = "!=", "is_infix" = true }] neq_int(SEW, 8)), "./extensions/V/vext_fp_insts.sail:858.32-858.33");
    let 'n = num_elem;
    let 'm = SEW;
    let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, 0, vs2);
    $[complete] match $[overloaded { "name" = "__size", "is_infix" = false }] __id(m) {
      16 => $[overloaded { "name" = "F_H", "is_infix" = false }] $[setter] wF_H(rd, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, 0)),
      32 => $[overloaded { "name" = "F_S", "is_infix" = false }] $[setter] wF_S(rd, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, 0)),
      ($[int_wildcard 64] _) => $[overloaded { "name" = "F_D", "is_infix" = false }] $[setter] wF_D(rd, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, 0))
    };
    set_vstart(zeros(16));
    RETIRE_SUCCESS
}
and execute FVFTYPE((funct6, vm, vs2, rs1, vd)) = {
    let rm_3b = _get_Fcsr_FRM(fcsr);
    let SEW = get_sew();
    let LMUL_pow = get_lmul_pow();
    let num_elem = get_num_elem(LMUL_pow, SEW);
    if illegal_fp_normal(vd, vm, SEW, rm_3b) then return(Illegal_Instruction());
    assert($[overloaded { "name" = "!=", "is_infix" = true }] neq_int(SEW, 8), "./extensions/V/vext_fp_insts.sail:907.17-907.18");
    let 'n = num_elem;
    let 'm = SEW;
    let vm_val : bits('n) = read_vmask(num_elem, vm, zvreg);
    let rs1_val : bits('m) = get_scalar_fp(rs1, $[overloaded { "name" = "__size", "is_infix" = false }] __id(m));
    let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);
    let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);
    let (initial_result, mask) : (vector('n, bits('m)), bits('n)) = $[complete] match init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val) {
      Ok(v) => v,
      Err(()) => return(Illegal_Instruction())
    };
    var result = initial_result;
    foreach (i from 0 to sub_atom(num_elem, 1) by 1 in inc) {
        if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(mask, i), bitone) then {
            result[i] = $[complete] match funct6 {
              VF_VADD => fp_add(rm_3b, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i), rs1_val),
              VF_VSUB => fp_sub(rm_3b, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i), rs1_val),
              VF_VRSUB => fp_sub(rm_3b, rs1_val, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)),
              VF_VMIN => fp_min($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i), rs1_val),
              VF_VMAX => fp_max($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i), rs1_val),
              VF_VMUL => fp_mul(rm_3b, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i), rs1_val),
              VF_VDIV => fp_div(rm_3b, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i), rs1_val),
              VF_VRDIV => fp_div(rm_3b, rs1_val, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)),
              VF_VSGNJ => $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat([$[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(rs1_val, $[overloaded { "name" = "-", "is_infix" = true }] sub_atom($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), 1))], $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i), $[overloaded { "name" = "-", "is_infix" = true }] sub_atom($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), 2), 0)),
              VF_VSGNJN => $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat($[overloaded { "name" = "^", "is_infix" = true }] xor_vec(0b1, [$[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(rs1_val, $[overloaded { "name" = "-", "is_infix" = true }] sub_atom($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), 1))]), $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i), $[overloaded { "name" = "-", "is_infix" = true }] sub_atom($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), 2), 0)),
              VF_VSGNJX => $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat($[overloaded { "name" = "^", "is_infix" = true }] xor_vec([$[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i), $[overloaded { "name" = "-", "is_infix" = true }] sub_atom($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), 1))], [$[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(rs1_val, $[overloaded { "name" = "-", "is_infix" = true }] sub_atom($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), 1))]), $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i), $[overloaded { "name" = "-", "is_infix" = true }] sub_atom($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), 2), 0)),
              VF_VSLIDE1UP => {
                  if $[overloaded { "name" = "==", "is_infix" = true }] eq_anything(vs2, vd) then return(Illegal_Instruction());
                  if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(i, 0) then
                    rs1_val
                  else
                    $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(i, 1))
              },
              VF_VSLIDE1DOWN => {
                  let last_elem = get_end_element();
                  assert($[overloaded { "name" = "<", "is_infix" = true }] lt_int(last_elem, num_elem), "./extensions/V/vext_fp_insts.sail:943.57-943.58");
                  if $[overloaded { "name" = "<", "is_infix" = true }] lt_int(i, last_elem) then
                    $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, $[overloaded { "name" = "+", "is_infix" = true }] add_atom(i, 1))
                  else
                    rs1_val
              }
            }
        };
        ()
    };
    write_vreg(num_elem, SEW, LMUL_pow, vd, result);
    set_vstart(zeros(16));
    RETIRE_SUCCESS
}
and execute FVFMATYPE((funct6, vm, vs2, rs1, vd)) = {
    let rm_3b = _get_Fcsr_FRM(fcsr);
    let SEW = get_sew();
    let LMUL_pow = get_lmul_pow();
    let num_elem = get_num_elem(LMUL_pow, SEW);
    if illegal_fp_normal(vd, vm, SEW, rm_3b) then return(Illegal_Instruction());
    assert($[overloaded { "name" = "!=", "is_infix" = true }] neq_int(SEW, 8), "./extensions/V/vext_fp_insts.sail:1000.17-1000.18");
    let 'n = num_elem;
    let 'm = SEW;
    let vm_val : bits('n) = read_vmask(num_elem, vm, zvreg);
    let rs1_val : bits('m) = get_scalar_fp(rs1, $[overloaded { "name" = "__size", "is_infix" = false }] __id(m));
    let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);
    let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);
    let (initial_result, mask) : (vector('n, bits('m)), bits('n)) = $[complete] match init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val) {
      Ok(v) => v,
      Err(()) => return(Illegal_Instruction())
    };
    var result = initial_result;
    foreach (i from 0 to sub_atom(num_elem, 1) by 1 in inc) {
        if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(mask, i), bitone) then {
            result[i] = $[complete] match funct6 {
              VF_VMACC => fp_muladd(rm_3b, rs1_val, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vd_val, i)),
              VF_VNMACC => fp_nmulsub(rm_3b, rs1_val, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vd_val, i)),
              VF_VMSAC => fp_mulsub(rm_3b, rs1_val, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vd_val, i)),
              VF_VNMSAC => fp_nmuladd(rm_3b, rs1_val, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vd_val, i)),
              VF_VMADD => fp_muladd(rm_3b, rs1_val, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vd_val, i), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)),
              VF_VNMADD => fp_nmulsub(rm_3b, rs1_val, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vd_val, i), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)),
              VF_VMSUB => fp_mulsub(rm_3b, rs1_val, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vd_val, i), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)),
              VF_VNMSUB => fp_nmuladd(rm_3b, rs1_val, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vd_val, i), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i))
            }
        };
        ()
    };
    write_vreg(num_elem, SEW, LMUL_pow, vd, result);
    set_vstart(zeros(16));
    RETIRE_SUCCESS
}
and execute FWVFTYPE((funct6, vm, vs2, rs1, vd)) = {
    let rm_3b = _get_Fcsr_FRM(fcsr);
    let SEW = get_sew();
    let LMUL_pow = get_lmul_pow();
    let num_elem = get_num_elem(LMUL_pow, SEW);
    let SEW_widen = $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(SEW, 2);
    let LMUL_pow_widen = $[overloaded { "name" = "+", "is_infix" = true }] add_atom(LMUL_pow, 1);
    if $[overloaded { "name" = "|", "is_infix" = true }] or_bool(illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen), not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))) then return(Illegal_Instruction());
    assert($[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(SEW, 16), $[overloaded { "name" = "<=", "is_infix" = true }] lteq_int(SEW_widen, 64)), "./extensions/V/vext_fp_insts.sail:1074.36-1074.37");
    let 'n = num_elem;
    let 'm = SEW;
    let 'o = SEW_widen;
    let vm_val : bits('n) = read_vmask(num_elem, vm, zvreg);
    let vd_val : vector('n, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd);
    let rs1_val : bits('m) = get_scalar_fp(rs1, $[overloaded { "name" = "__size", "is_infix" = false }] __id(m));
    let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);
    let (initial_result, mask) : (vector('n, bits('o)), bits('n)) = $[complete] match init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val) {
      Ok(v) => v,
      Err(()) => return(Illegal_Instruction())
    };
    var result = initial_result;
    foreach (i from 0 to sub_atom(num_elem, 1) by 1 in inc) {
        if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(mask, i), bitone) then {
            result[i] = $[complete] match funct6 {
              FWVF_VADD => fp_add(rm_3b, fp_widen($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)), fp_widen(rs1_val)),
              FWVF_VSUB => fp_sub(rm_3b, fp_widen($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)), fp_widen(rs1_val)),
              FWVF_VMUL => fp_mul(rm_3b, fp_widen($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)), fp_widen(rs1_val))
            }
        };
        ()
    };
    write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result);
    set_vstart(zeros(16));
    RETIRE_SUCCESS
}
and execute FWVFMATYPE((funct6, vm, rs1, vs2, vd)) = {
    let rm_3b = _get_Fcsr_FRM(fcsr);
    let SEW = get_sew();
    let LMUL_pow = get_lmul_pow();
    let num_elem = get_num_elem(LMUL_pow, SEW);
    let SEW_widen = $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(SEW, 2);
    let LMUL_pow_widen = $[overloaded { "name" = "+", "is_infix" = true }] add_atom(LMUL_pow, 1);
    if $[overloaded { "name" = "|", "is_infix" = true }] or_bool(illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen), not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))) then return(Illegal_Instruction());
    assert($[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(SEW, 16), $[overloaded { "name" = "<=", "is_infix" = true }] lteq_int(SEW_widen, 64)), "./extensions/V/vext_fp_insts.sail:1141.36-1141.37");
    let 'n = num_elem;
    let 'm = SEW;
    let 'o = SEW_widen;
    let vm_val : bits('n) = read_vmask(num_elem, vm, zvreg);
    let vd_val : vector('n, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd);
    let rs1_val : bits('m) = get_scalar_fp(rs1, $[overloaded { "name" = "__size", "is_infix" = false }] __id(m));
    let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);
    let (initial_result, mask) : (vector('n, bits('o)), bits('n)) = $[complete] match init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val) {
      Ok(v) => v,
      Err(()) => return(Illegal_Instruction())
    };
    var result = initial_result;
    foreach (i from 0 to sub_atom(num_elem, 1) by 1 in inc) {
        if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(mask, i), bitone) then {
            result[i] = $[complete] match funct6 {
              FWVF_VMACC => fp_muladd(rm_3b, fp_widen(rs1_val), fp_widen($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vd_val, i)),
              FWVF_VNMACC => fp_nmulsub(rm_3b, fp_widen(rs1_val), fp_widen($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vd_val, i)),
              FWVF_VMSAC => fp_mulsub(rm_3b, fp_widen(rs1_val), fp_widen($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vd_val, i)),
              FWVF_VNMSAC => fp_nmuladd(rm_3b, fp_widen(rs1_val), fp_widen($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vd_val, i))
            }
        };
        ()
    };
    write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result);
    set_vstart(zeros(16));
    RETIRE_SUCCESS
}
and execute FWFTYPE((funct6, vm, vs2, rs1, vd)) = {
    let rm_3b = _get_Fcsr_FRM(fcsr);
    let SEW = get_sew();
    let LMUL_pow = get_lmul_pow();
    let num_elem = get_num_elem(LMUL_pow, SEW);
    let SEW_widen = $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(SEW, 2);
    let LMUL_pow_widen = $[overloaded { "name" = "+", "is_infix" = true }] add_atom(LMUL_pow, 1);
    if illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen) then return(Illegal_Instruction());
    assert($[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(SEW, 16), $[overloaded { "name" = "<=", "is_infix" = true }] lteq_int(SEW_widen, 64)), "./extensions/V/vext_fp_insts.sail:1206.36-1206.37");
    let 'n = num_elem;
    let 'm = SEW;
    let 'o = SEW_widen;
    let vm_val : bits('n) = read_vmask(num_elem, vm, zvreg);
    let vd_val : vector('n, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd);
    let rs1_val : bits('m) = get_scalar_fp(rs1, $[overloaded { "name" = "__size", "is_infix" = false }] __id(m));
    let vs2_val : vector('n, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2);
    let (initial_result, mask) : (vector('n, bits('o)), bits('n)) = $[complete] match init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val) {
      Ok(v) => v,
      Err(()) => return(Illegal_Instruction())
    };
    var result = initial_result;
    foreach (i from 0 to sub_atom(num_elem, 1) by 1 in inc) {
        if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(mask, i), bitone) then {
            result[i] = $[complete] match funct6 {
              FWF_VADD => fp_add(rm_3b, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i), fp_widen(rs1_val)),
              FWF_VSUB => fp_sub(rm_3b, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i), fp_widen(rs1_val))
            }
        };
        ()
    };
    write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result);
    set_vstart(zeros(16));
    RETIRE_SUCCESS
}
and execute VFMERGE((vs2, rs1, vd)) = {
    let rm_3b = _get_Fcsr_FRM(fcsr);
    let start_element : nat = $[complete] match get_start_element() {
      Ok(v) => v,
      Err(()) => return(Illegal_Instruction())
    };
    let end_element = get_end_element();
    let SEW = get_sew();
    let LMUL_pow = get_lmul_pow();
    let num_elem = get_num_elem(LMUL_pow, SEW);
    let real_num_elem = if $[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(LMUL_pow, 0) then
      num_elem
    else
      $[overloaded { "name" = "/", "is_infix" = true }] quot_positive_round_zero(num_elem, $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(0, LMUL_pow));
    if illegal_fp_vd_masked(vd, SEW, rm_3b) then return(Illegal_Instruction());
    assert($[overloaded { "name" = "!=", "is_infix" = true }] neq_int(SEW, 8), "./extensions/V/vext_fp_insts.sail:1266.17-1266.18");
    let 'n = num_elem;
    let 'm = SEW;
    let vm_val : bits('n) = read_vmask(num_elem, 0b0, zvreg);
    let rs1_val : bits('m) = get_scalar_fp(rs1, $[overloaded { "name" = "__size", "is_infix" = false }] __id(m));
    let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);
    let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);
    var result : vector('n, bits('m)) = vector_init($[overloaded { "name" = "__size", "is_infix" = false }] __id(n), zeros($[overloaded { "name" = "__size", "is_infix" = false }] __id(m)));
    let tail_ag : agtype = get_vtype_vta();
    foreach (i from 0 to sub_atom(num_elem, 1) by 1 in inc) {
        if $[overloaded { "name" = "<", "is_infix" = true }] lt_int(i, start_element) then {
            result[i] = $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vd_val, i)
        } else if $[overloaded { "name" = "|", "is_infix" = true }] or_bool($[overloaded { "name" = ">", "is_infix" = true }] gt_int(i, end_element), $[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(i, real_num_elem)) then {
            result[i] = $[complete] match tail_ag {
              UNDISTURBED => $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vd_val, i),
              AGNOSTIC => $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vd_val, i)
            }
        } else {
            result[i] = if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(vm_val, i), bitone) then
              rs1_val
            else
              $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)
        }
    };
    write_vreg(num_elem, SEW, LMUL_pow, vd, result);
    set_vstart(zeros(16));
    RETIRE_SUCCESS
}
and execute VFMV((rs1, vd)) = {
    let rm_3b = _get_Fcsr_FRM(fcsr);
    let SEW = get_sew();
    let LMUL_pow = get_lmul_pow();
    let num_elem = get_num_elem(LMUL_pow, SEW);
    if illegal_fp_vd_unmasked(SEW, rm_3b) then return(Illegal_Instruction());
    assert($[overloaded { "name" = "!=", "is_infix" = true }] neq_int(SEW, 8), "./extensions/V/vext_fp_insts.sail:1315.17-1315.18");
    let 'n = num_elem;
    let 'm = SEW;
    let rs1_val : bits('m) = get_scalar_fp(rs1, $[overloaded { "name" = "__size", "is_infix" = false }] __id(m));
    let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);
    let (initial_result, mask) : (vector('n, bits('m)), bits('n)) = $[complete] match init_masked_result(num_elem, SEW, LMUL_pow, vd_val, ones($[overloaded { "name" = "__size", "is_infix" = false }] __id(num_elem))) {
      Ok(v) => v,
      Err(()) => return(Illegal_Instruction())
    };
    var result = initial_result;
    foreach (i from 0 to sub_atom(num_elem, 1) by 1 in inc) {
        if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(mask, i), bitone) then result[i] = rs1_val;
        ()
    };
    write_vreg(num_elem, SEW, LMUL_pow, vd, result);
    set_vstart(zeros(16));
    RETIRE_SUCCESS
}
and execute VFMVSF((rs1, vd)) = {
    let rm_3b = _get_Fcsr_FRM(fcsr);
    let SEW = get_sew();
    let num_elem = get_num_elem(0, SEW);
    if illegal_fp_vd_unmasked(SEW, rm_3b) then return(Illegal_Instruction());
    assert($[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = ">", "is_infix" = true }] gt_int(num_elem, 0), $[overloaded { "name" = "!=", "is_infix" = true }] neq_int(SEW, 8)), "./extensions/V/vext_fp_insts.sail:1354.32-1354.33");
    let 'n = num_elem;
    let 'm = SEW;
    let rs1_val : bits('m) = get_scalar_fp(rs1, $[overloaded { "name" = "__size", "is_infix" = false }] __id(m));
    let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, 0, vd);
    let (initial_result, mask) : (vector('n, bits('m)), bits('n)) = $[complete] match init_masked_result(num_elem, SEW, 0, vd_val, ones($[overloaded { "name" = "__size", "is_infix" = false }] __id(num_elem))) {
      Ok(v) => v,
      Err(()) => return(Illegal_Instruction())
    };
    var result = initial_result;
    if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(mask, 0), bitone) then result[0] = rs1_val;
    let tail_ag : agtype = get_vtype_vta();
    foreach (i from 1 to sub_atom(num_elem, 1) by 1 in inc) {
        result[i] = $[complete] match tail_ag {
          UNDISTURBED => $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vd_val, i),
          AGNOSTIC => $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vd_val, i)
        }
    };
    write_vreg(num_elem, SEW, 0, vd, result);
    set_vstart(zeros(16));
    RETIRE_SUCCESS
}
and execute VLSEGTYPE((nf, vm, rs1, width, vd)) = {
    let EEW_pow = vlewidth_pow_forwards(width);
    let load_width_bytes = 2 ^ sub_atom(EEW_pow, 3);
    let EEW = 2 ^ EEW_pow;
    let SEW_pow = get_sew_pow();
    let LMUL_pow = get_lmul_pow();
    let EMUL_pow = $[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "-", "is_infix" = true }] sub_atom(EEW_pow, SEW_pow), LMUL_pow);
    let num_elem = get_num_elem(EMUL_pow, EEW);
    assert($[overloaded { "name" = ">", "is_infix" = true }] gt_int(num_elem, 0), "./extensions/V/vext_mem_insts.sail:86.21-86.22");
    if illegal_load(vd, vm, nf, EEW, EMUL_pow) then return(Illegal_Instruction());
    process_vlseg(nf, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)
}
and execute VLSEGFFTYPE((nf, vm, rs1, width, vd)) = {
    let EEW_pow = vlewidth_pow_forwards(width);
    let load_width_bytes = 2 ^ sub_atom(EEW_pow, 3);
    let EEW = 2 ^ EEW_pow;
    let SEW_pow = get_sew_pow();
    let LMUL_pow = get_lmul_pow();
    let EMUL_pow = $[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "-", "is_infix" = true }] sub_atom(EEW_pow, SEW_pow), LMUL_pow);
    let num_elem = get_num_elem(EMUL_pow, EEW);
    assert($[overloaded { "name" = ">", "is_infix" = true }] gt_int(num_elem, 0), "./extensions/V/vext_mem_insts.sail:164.21-164.22");
    if illegal_load(vd, vm, nf, EEW, EMUL_pow) then return(Illegal_Instruction());
    process_vlsegff(nf, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)
}
and execute VSSEGTYPE((nf, vm, rs1, width, vs3)) = {
    let EEW_pow = vlewidth_pow_forwards(width);
    let load_width_bytes = 2 ^ sub_atom(EEW_pow, 3);
    let EEW = 2 ^ EEW_pow;
    let SEW_pow = get_sew_pow();
    let LMUL_pow = get_lmul_pow();
    let EMUL_pow = $[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "-", "is_infix" = true }] sub_atom(EEW_pow, SEW_pow), LMUL_pow);
    let num_elem = get_num_elem(EMUL_pow, EEW);
    assert($[overloaded { "name" = ">", "is_infix" = true }] gt_int(num_elem, 0), "./extensions/V/vext_mem_insts.sail:222.21-222.22");
    if illegal_store(nf, EEW, EMUL_pow) then return(Illegal_Instruction());
    process_vsseg(nf, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem)
}
and execute VLSSEGTYPE((nf, vm, rs2, rs1, width, vd)) = {
    let EEW_pow = vlewidth_pow_forwards(width);
    let load_width_bytes = 2 ^ sub_atom(EEW_pow, 3);
    let EEW = 2 ^ EEW_pow;
    let SEW_pow = get_sew_pow();
    let LMUL_pow = get_lmul_pow();
    let EMUL_pow = $[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "-", "is_infix" = true }] sub_atom(EEW_pow, SEW_pow), LMUL_pow);
    let num_elem = get_num_elem(EMUL_pow, EEW);
    assert($[overloaded { "name" = ">", "is_infix" = true }] gt_int(num_elem, 0), "./extensions/V/vext_mem_insts.sail:284.21-284.22");
    if illegal_load(vd, vm, nf, EEW, EMUL_pow) then return(Illegal_Instruction());
    process_vlsseg(nf, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)
}
and execute VSSSEGTYPE((nf, vm, rs2, rs1, width, vs3)) = {
    let EEW_pow = vlewidth_pow_forwards(width);
    let EEW = 2 ^ EEW_pow;
    let load_width_bytes = 2 ^ sub_atom(EEW_pow, 3);
    let SEW_pow = get_sew_pow();
    let LMUL_pow = get_lmul_pow();
    let EMUL_pow = $[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "-", "is_infix" = true }] sub_atom(EEW_pow, SEW_pow), LMUL_pow);
    let num_elem = get_num_elem(EMUL_pow, EEW);
    assert($[overloaded { "name" = ">", "is_infix" = true }] gt_int(num_elem, 0), "./extensions/V/vext_mem_insts.sail:343.21-343.22");
    if illegal_store(nf, EEW, EMUL_pow) then return(Illegal_Instruction());
    process_vssseg(nf, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)
}
and execute VLUXSEGTYPE((nf, vm, vs2, rs1, width, vd)) = {
    let EEW_index_pow = vlewidth_pow_forwards(width);
    let EEW_index_bytes = 2 ^ sub_atom(EEW_index_pow, 3);
    let EEW_data_pow = get_sew_pow();
    let EEW_data_bytes = get_sew_bytes();
    let EMUL_data_pow = get_lmul_pow();
    let EMUL_index_pow = $[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "-", "is_infix" = true }] sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow);
    let num_elem = get_num_elem(EMUL_data_pow, $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(EEW_data_bytes, 8));
    assert($[overloaded { "name" = ">", "is_infix" = true }] gt_int(num_elem, 0), "./extensions/V/vext_mem_insts.sail:406.21-406.22");
    if illegal_indexed_load(vd, vm, nf, 2 ^ EEW_index_pow, EMUL_index_pow, EMUL_data_pow) then return(Illegal_Instruction());
    process_vlxseg(nf, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)
}
and execute VLOXSEGTYPE((nf, vm, vs2, rs1, width, vd)) = {
    let EEW_index_pow = vlewidth_pow_forwards(width);
    let EEW_index_bytes = 2 ^ sub_atom(EEW_index_pow, 3);
    let EEW_data_pow = get_sew_pow();
    let EEW_data_bytes = get_sew_bytes();
    let EMUL_data_pow = get_lmul_pow();
    let EMUL_index_pow = $[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "-", "is_infix" = true }] sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow);
    let num_elem = get_num_elem(EMUL_data_pow, $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(EEW_data_bytes, 8));
    assert($[overloaded { "name" = ">", "is_infix" = true }] gt_int(num_elem, 0), "./extensions/V/vext_mem_insts.sail:433.21-433.22");
    if illegal_indexed_load(vd, vm, nf, 2 ^ EEW_index_pow, EMUL_index_pow, EMUL_data_pow) then return(Illegal_Instruction());
    process_vlxseg(nf, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3)
}
and execute VSUXSEGTYPE((nf, vm, vs2, rs1, width, vs3)) = {
    let EEW_index_pow = vlewidth_pow_forwards(width);
    let EEW_index_bytes = 2 ^ sub_atom(EEW_index_pow, 3);
    let EEW_data_pow = get_sew_pow();
    let EEW_data_bytes = get_sew_bytes();
    let EMUL_data_pow = get_lmul_pow();
    let EMUL_index_pow = $[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "-", "is_infix" = true }] sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow);
    let num_elem = get_num_elem(EMUL_data_pow, $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(EEW_data_bytes, 8));
    assert($[overloaded { "name" = ">", "is_infix" = true }] gt_int(num_elem, 0), "./extensions/V/vext_mem_insts.sail:494.21-494.22");
    if illegal_indexed_store(nf, 2 ^ EEW_index_pow, EMUL_index_pow, EMUL_data_pow) then return(Illegal_Instruction());
    process_vsxseg(nf, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)
}
and execute VSOXSEGTYPE((nf, vm, vs2, rs1, width, vs3)) = {
    let EEW_index_pow = vlewidth_pow_forwards(width);
    let EEW_index_bytes = 2 ^ sub_atom(EEW_index_pow, 3);
    let EEW_data_pow = get_sew_pow();
    let EEW_data_bytes = get_sew_bytes();
    let EMUL_data_pow = get_lmul_pow();
    let EMUL_index_pow = $[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "-", "is_infix" = true }] sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow);
    let num_elem = get_num_elem(EMUL_data_pow, $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(EEW_data_bytes, 8));
    assert($[overloaded { "name" = ">", "is_infix" = true }] gt_int(num_elem, 0), "./extensions/V/vext_mem_insts.sail:521.21-521.22");
    if illegal_indexed_store(nf, 2 ^ EEW_index_pow, EMUL_index_pow, EMUL_data_pow) then return(Illegal_Instruction());
    process_vsxseg(nf, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3)
}
and execute VLRETYPE((nf, rs1, width, vd)) = {
    let EEW_pow = vlewidth_pow_forwards(width);
    let load_width_bytes = 2 ^ sub_atom(EEW_pow, 3);
    let EEW = 2 ^ EEW_pow;
    let elem_per_reg = $[overloaded { "name" = "/", "is_infix" = true }] quot_positive_round_zero(vlen, EEW);
    assert($[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(elem_per_reg, 0), "./extensions/V/vext_mem_insts.sail:585.26-585.27");
    process_vlre(nf, vd, load_width_bytes, rs1, elem_per_reg)
}
and execute VSRETYPE((nf, rs1, vs3)) = {
    let load_width_bytes = 1;
    let EEW = 8;
    let elem_per_reg = $[overloaded { "name" = "/", "is_infix" = true }] quot_positive_round_zero(vlen, EEW);
    assert($[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(elem_per_reg, 0), "./extensions/V/vext_mem_insts.sail:650.26-650.27");
    process_vsre(nf, load_width_bytes, rs1, vs3, elem_per_reg)
}
and execute VMTYPE((rs1, vd_or_vs3, op)) = {
    let EEW = 8;
    let EMUL_pow = 0;
    let vl_val = unsigned(vl);
    let evl : int = if $[overloaded { "name" = "==", "is_infix" = true }] eq_int($[overloaded { "name" = "%", "is_infix" = true }] rem_positive_round_zero(vl_val, 8), 0) then
      $[overloaded { "name" = "/", "is_infix" = true }] quot_positive_round_zero(vl_val, 8)
    else
      $[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "/", "is_infix" = true }] quot_positive_round_zero(vl_val, 8), 1);
    let num_elem = get_num_elem(EMUL_pow, EEW);
    if illegal_vd_unmasked() then return(Illegal_Instruction());
    assert($[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(evl, 0), "./extensions/V/vext_mem_insts.sail:715.17-715.18");
    process_vm(vd_or_vs3, rs1, num_elem, evl, op)
}
and execute MMTYPE((funct6, vs2, vs1, vd)) = {
    let SEW = get_sew();
    let LMUL_pow = get_lmul_pow();
    let num_elem = vlen;
    if illegal_vd_unmasked() then return(Illegal_Instruction());
    let 'n = num_elem;
    let 'm = SEW;
    let vs1_val : bits('n) = read_vmask(num_elem, 0b0, vs1);
    let vs2_val : bits('n) = read_vmask(num_elem, 0b0, vs2);
    let vd_val : bits('n) = read_vmask(num_elem, 0b0, vd);
    let (initial_result, mask) : (bits('n), bits('n)) = $[complete] match init_masked_result_carry(num_elem, SEW, 0, vd_val) {
      Ok(v) => v,
      Err(()) => return(Illegal_Instruction())
    };
    var result = initial_result;
    foreach (i from 0 to sub_atom(num_elem, 1) by 1 in inc) {
        if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(mask, i), bitone) then {
            result[i] = $[complete] match funct6 {
              MM_VMAND => $[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access($[overloaded { "name" = "&", "is_infix" = true }] and_vec(vs2_val, vs1_val), i),
              MM_VMNAND => $[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access($[overloaded { "name" = "~", "is_infix" = false }] not_vec($[overloaded { "name" = "&", "is_infix" = true }] and_vec(vs2_val, vs1_val)), i),
              MM_VMANDN => $[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access($[overloaded { "name" = "&", "is_infix" = true }] and_vec(vs2_val, $[overloaded { "name" = "~", "is_infix" = false }] not_vec(vs1_val)), i),
              MM_VMXOR => $[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access($[overloaded { "name" = "^", "is_infix" = true }] xor_vec(vs2_val, vs1_val), i),
              MM_VMOR => $[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access($[overloaded { "name" = "|", "is_infix" = true }] or_vec(vs2_val, vs1_val), i),
              MM_VMNOR => $[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access($[overloaded { "name" = "~", "is_infix" = false }] not_vec($[overloaded { "name" = "|", "is_infix" = true }] or_vec(vs2_val, vs1_val)), i),
              MM_VMORN => $[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access($[overloaded { "name" = "|", "is_infix" = true }] or_vec(vs2_val, $[overloaded { "name" = "~", "is_infix" = false }] not_vec(vs1_val)), i),
              MM_VMXNOR => $[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access($[overloaded { "name" = "~", "is_infix" = false }] not_vec($[overloaded { "name" = "^", "is_infix" = true }] xor_vec(vs2_val, vs1_val)), i)
            }
        };
        ()
    };
    write_vmask(num_elem, vd, result);
    set_vstart(zeros(16));
    RETIRE_SUCCESS
}
and execute VCPOP_M((vm, vs2, rd)) = {
    let SEW = get_sew();
    let LMUL_pow = get_lmul_pow();
    let num_elem = vlen;
    if $[overloaded { "name" = "|", "is_infix" = true }] or_bool(illegal_vd_unmasked(), not(assert_vstart(0))) then return(Illegal_Instruction());
    let 'n = num_elem;
    let 'm = SEW;
    let vm_val : bits('n) = read_vmask(num_elem, vm, zvreg);
    let vs2_val : bits('n) = read_vmask(num_elem, 0b0, vs2);
    let (_, mask) : (bits('n), bits('n)) = $[complete] match init_masked_result_cmp(num_elem, SEW, 0, vs2_val, vm_val) {
      Ok(v) => v,
      Err(()) => return(Illegal_Instruction())
    };
    var count : nat = 0;
    foreach (i from 0 to sub_atom(num_elem, 1) by 1 in inc) {
        if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access($[overloaded { "name" = "&", "is_infix" = true }] and_vec(mask, vs2_val), i), bitone) then count = $[overloaded { "name" = "+", "is_infix" = true }] add_atom(count, 1);
        ()
    };
    $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(rd, to_bits_unsafe(xlen, count));
    set_vstart(zeros(16));
    RETIRE_SUCCESS
}
and execute VFIRST_M((vm, vs2, rd)) = {
    let SEW = get_sew();
    let LMUL_pow = get_lmul_pow();
    let num_elem = vlen;
    if $[overloaded { "name" = "|", "is_infix" = true }] or_bool(illegal_vd_unmasked(), not(assert_vstart(0))) then return(Illegal_Instruction());
    let 'n = num_elem;
    let 'm = SEW;
    let vm_val : bits('n) = read_vmask(num_elem, vm, zvreg);
    let vs2_val : bits('n) = read_vmask(num_elem, 0b0, vs2);
    let (_, mask) : (bits('n), bits('n)) = $[complete] match init_masked_result_cmp(num_elem, SEW, 0, vs2_val, vm_val) {
      Ok(v) => v,
      Err(()) => return(Illegal_Instruction())
    };
    var index : int = -1;
    foreach (i from 0 to sub_atom(num_elem, 1) by 1 in inc) {
        if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(index, -1) then {
            if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access($[overloaded { "name" = "&", "is_infix" = true }] and_vec(mask, vs2_val), i), bitone) then index = i;
            ()
        };
        ()
    };
    $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(rd, to_bits_unsafe(xlen, index));
    set_vstart(zeros(16));
    RETIRE_SUCCESS
}
and execute VMSBF_M((vm, vs2, vd)) = {
    let SEW = get_sew();
    let LMUL_pow = get_lmul_pow();
    let num_elem = vlen;
    if $[overloaded { "name" = "|", "is_infix" = true }] or_bool(illegal_normal(vd, vm), $[overloaded { "name" = "|", "is_infix" = true }] or_bool(not(assert_vstart(0)), $[overloaded { "name" = "==", "is_infix" = true }] eq_anything(vd, vs2))) then return(Illegal_Instruction());
    let 'n = num_elem;
    let 'm = SEW;
    let vm_val : bits('n) = read_vmask(num_elem, vm, zvreg);
    let vs2_val : bits('n) = read_vmask(num_elem, 0b0, vs2);
    let vd_val : bits('n) = read_vmask(num_elem, 0b0, vd);
    let (initial_result, mask) : (bits('n), bits('n)) = $[complete] match init_masked_result_cmp(num_elem, SEW, 0, vd_val, vm_val) {
      Ok(v) => v,
      Err(()) => return(Illegal_Instruction())
    };
    var result = initial_result;
    var found_elem : bool = false;
    foreach (i from 0 to sub_atom(num_elem, 1) by 1 in inc) {
        if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(mask, i), bitone) then {
            if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(vs2_val, i), bitone) then found_elem = true;
            result[i] = bool_to_bit(not(found_elem))
        };
        ()
    };
    write_vmask(num_elem, vd, result);
    set_vstart(zeros(16));
    RETIRE_SUCCESS
}
and execute VMSIF_M((vm, vs2, vd)) = {
    let SEW = get_sew();
    let LMUL_pow = get_lmul_pow();
    let num_elem = vlen;
    if $[overloaded { "name" = "|", "is_infix" = true }] or_bool(illegal_normal(vd, vm), $[overloaded { "name" = "|", "is_infix" = true }] or_bool(not(assert_vstart(0)), $[overloaded { "name" = "==", "is_infix" = true }] eq_anything(vd, vs2))) then return(Illegal_Instruction());
    let 'n = num_elem;
    let 'm = SEW;
    let vm_val : bits('n) = read_vmask(num_elem, vm, zvreg);
    let vs2_val : bits('n) = read_vmask(num_elem, 0b0, vs2);
    let vd_val : bits('n) = read_vmask(num_elem, 0b0, vd);
    let (initial_result, mask) : (bits('n), bits('n)) = $[complete] match init_masked_result_cmp(num_elem, SEW, 0, vd_val, vm_val) {
      Ok(v) => v,
      Err(()) => return(Illegal_Instruction())
    };
    var result = initial_result;
    var found_elem : bool = false;
    foreach (i from 0 to sub_atom(num_elem, 1) by 1 in inc) {
        if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(mask, i), bitone) then {
            result[i] = bool_to_bit(not(found_elem));
            if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(vs2_val, i), bitone) then found_elem = true;
            ()
        };
        ()
    };
    write_vmask(num_elem, vd, result);
    set_vstart(zeros(16));
    RETIRE_SUCCESS
}
and execute VMSOF_M((vm, vs2, vd)) = {
    let SEW = get_sew();
    let LMUL_pow = get_lmul_pow();
    let num_elem = vlen;
    if $[overloaded { "name" = "|", "is_infix" = true }] or_bool(illegal_normal(vd, vm), $[overloaded { "name" = "|", "is_infix" = true }] or_bool(not(assert_vstart(0)), $[overloaded { "name" = "==", "is_infix" = true }] eq_anything(vd, vs2))) then return(Illegal_Instruction());
    let 'n = num_elem;
    let 'm = SEW;
    let vm_val : bits('n) = read_vmask(num_elem, vm, zvreg);
    let vs2_val : bits('n) = read_vmask(num_elem, 0b0, vs2);
    let vd_val : bits('n) = read_vmask(num_elem, 0b0, vd);
    let (initial_result, mask) : (bits('n), bits('n)) = $[complete] match init_masked_result_cmp(num_elem, SEW, 0, vd_val, vm_val) {
      Ok(v) => v,
      Err(()) => return(Illegal_Instruction())
    };
    var result = initial_result;
    var found_elem : bool = false;
    foreach (i from 0 to sub_atom(num_elem, 1) by 1 in inc) {
        if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(mask, i), bitone) then {
            if $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(vs2_val, i), bitone), not(found_elem)) then {
                result[i] = bitone;
                found_elem = true
            } else {
                result[i] = bitzero
            }
        };
        ()
    };
    write_vmask(num_elem, vd, result);
    set_vstart(zeros(16));
    RETIRE_SUCCESS
}
and execute VIOTA_M((vm, vs2, vd)) = {
    let SEW = get_sew();
    let LMUL_pow = get_lmul_pow();
    let num_elem = get_num_elem(LMUL_pow, SEW);
    if $[overloaded { "name" = "|", "is_infix" = true }] or_bool(illegal_normal(vd, vm), $[overloaded { "name" = "|", "is_infix" = true }] or_bool(not(assert_vstart(0)), $[overloaded { "name" = "==", "is_infix" = true }] eq_anything(vd, vs2))) then return(Illegal_Instruction());
    let 'n = num_elem;
    let 'm = SEW;
    let vm_val : bits('n) = read_vmask(num_elem, vm, zvreg);
    let vs2_val : bits('n) = read_vmask(num_elem, 0b0, vs2);
    let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);
    let (initial_result, mask) : (vector('n, bits('m)), bits('n)) = $[complete] match init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val) {
      Ok(v) => v,
      Err(()) => return(Illegal_Instruction())
    };
    var result = initial_result;
    var sum : int = 0;
    foreach (i from 0 to sub_atom(num_elem, 1) by 1 in inc) {
        if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(mask, i), bitone) then {
            result[i] = to_bits_unsafe(SEW, sum);
            if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(vs2_val, i), bitone) then sum = $[overloaded { "name" = "+", "is_infix" = true }] add_atom(sum, 1);
            ()
        };
        ()
    };
    write_vreg(num_elem, SEW, LMUL_pow, vd, result);
    set_vstart(zeros(16));
    RETIRE_SUCCESS
}
and execute VID_V((vm, vd)) = {
    let SEW = get_sew();
    let LMUL_pow = get_lmul_pow();
    let num_elem = get_num_elem(LMUL_pow, SEW);
    if illegal_normal(vd, vm) then return(Illegal_Instruction());
    let 'n = num_elem;
    let 'm = SEW;
    let vm_val : bits('n) = read_vmask(num_elem, vm, zvreg);
    let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);
    let (initial_result, mask) : (vector('n, bits('m)), bits('n)) = $[complete] match init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val) {
      Ok(v) => v,
      Err(()) => return(Illegal_Instruction())
    };
    var result = initial_result;
    foreach (i from 0 to sub_atom(num_elem, 1) by 1 in inc) {
        if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(mask, i), bitone) then result[i] = to_bits_unsafe(SEW, i);
        ()
    };
    write_vreg(num_elem, SEW, LMUL_pow, vd, result);
    set_vstart(zeros(16));
    RETIRE_SUCCESS
}
and execute VVMTYPE((funct6, vs2, vs1, vd)) = {
    let SEW = get_sew();
    let LMUL_pow = get_lmul_pow();
    let num_elem = get_num_elem(LMUL_pow, SEW);
    if illegal_vd_unmasked() then return(Illegal_Instruction());
    let 'n = num_elem;
    let 'm = SEW;
    let vm_val : bits('n) = read_vmask_carry(num_elem, 0b0, zvreg);
    let vs1_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);
    let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);
    let vd_val : bits('n) = read_vmask(num_elem, 0b0, vd);
    let (initial_result, mask) : (bits('n), bits('n)) = $[complete] match init_masked_result_carry(num_elem, SEW, LMUL_pow, vd_val) {
      Ok(v) => v,
      Err(()) => return(Illegal_Instruction())
    };
    var result = initial_result;
    foreach (i from 0 to sub_atom(num_elem, 1) by 1 in inc) {
        if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(mask, i), bitone) then {
            let res : bool = $[complete] match funct6 {
              VVM_VMADC => $[overloaded { "name" = ">", "is_infix" = true }] gt_int($[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "+", "is_infix" = true }] add_atom(unsigned($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)), unsigned($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs1_val, i))), if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(vm_val, i), bitone) then
                1
              else
                0), $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(2 ^ SEW, 1)),
              VVM_VMSBC => $[overloaded { "name" = "<", "is_infix" = true }] lt_int($[overloaded { "name" = "-", "is_infix" = true }] sub_atom($[overloaded { "name" = "-", "is_infix" = true }] sub_atom(unsigned($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)), unsigned($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs1_val, i))), if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(vm_val, i), bitone) then
                1
              else
                0), 0)
            };
            result[i] = bool_to_bit(res)
        };
        ()
    };
    write_vmask(num_elem, vd, result);
    set_vstart(zeros(16));
    RETIRE_SUCCESS
}
and execute VVMCTYPE((funct6, vs2, vs1, vd)) = {
    let SEW = get_sew();
    let LMUL_pow = get_lmul_pow();
    let num_elem = get_num_elem(LMUL_pow, SEW);
    if illegal_vd_unmasked() then return(Illegal_Instruction());
    let 'n = num_elem;
    let 'm = SEW;
    let vs1_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);
    let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);
    let vd_val : bits('n) = read_vmask(num_elem, 0b0, vd);
    let (initial_result, mask) : (bits('n), bits('n)) = $[complete] match init_masked_result_carry(num_elem, SEW, LMUL_pow, vd_val) {
      Ok(v) => v,
      Err(()) => return(Illegal_Instruction())
    };
    var result = initial_result;
    foreach (i from 0 to sub_atom(num_elem, 1) by 1 in inc) {
        if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(mask, i), bitone) then {
            let res : bool = $[complete] match funct6 {
              VVMC_VMADC => $[overloaded { "name" = ">", "is_infix" = true }] gt_int($[overloaded { "name" = "+", "is_infix" = true }] add_atom(unsigned($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)), unsigned($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs1_val, i))), $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(2 ^ SEW, 1)),
              VVMC_VMSBC => $[overloaded { "name" = "<", "is_infix" = true }] lt_int($[overloaded { "name" = "-", "is_infix" = true }] sub_atom(unsigned($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)), unsigned($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs1_val, i))), 0)
            };
            result[i] = bool_to_bit(res)
        };
        ()
    };
    write_vmask(num_elem, vd, result);
    set_vstart(zeros(16));
    RETIRE_SUCCESS
}
and execute VVMSTYPE((funct6, vs2, vs1, vd)) = {
    let SEW = get_sew();
    let LMUL_pow = get_lmul_pow();
    let num_elem = get_num_elem(LMUL_pow, SEW);
    if illegal_vd_masked(vd) then return(Illegal_Instruction());
    let 'n = num_elem;
    let 'm = SEW;
    let vec_trues : bits('n) = ones($[overloaded { "name" = "__size", "is_infix" = false }] __id(n));
    let vm_val : bits('n) = read_vmask_carry(num_elem, 0b0, zvreg);
    let vs1_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);
    let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);
    let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);
    let (initial_result, mask) : (vector('n, bits('m)), bits('n)) = $[complete] match init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vec_trues) {
      Ok(v) => v,
      Err(()) => return(Illegal_Instruction())
    };
    var result = initial_result;
    foreach (i from 0 to sub_atom(num_elem, 1) by 1 in inc) {
        if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(mask, i), bitone) then {
            result[i] = $[complete] match funct6 {
              VVMS_VADC => to_bits_unsafe(SEW, $[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "+", "is_infix" = true }] add_atom(unsigned($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)), unsigned($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs1_val, i))), if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(vm_val, i), bitone) then
                1
              else
                0)),
              VVMS_VSBC => to_bits_unsafe(SEW, $[overloaded { "name" = "-", "is_infix" = true }] sub_atom($[overloaded { "name" = "-", "is_infix" = true }] sub_atom(unsigned($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)), unsigned($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs1_val, i))), if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(vm_val, i), bitone) then
                1
              else
                0))
            }
        };
        ()
    };
    write_vreg(num_elem, SEW, LMUL_pow, vd, result);
    set_vstart(zeros(16));
    RETIRE_SUCCESS
}
and execute VVCMPTYPE((funct6, vm, vs2, vs1, vd)) = {
    let SEW = get_sew();
    let LMUL_pow = get_lmul_pow();
    let num_elem = get_num_elem(LMUL_pow, SEW);
    if illegal_vd_unmasked() then return(Illegal_Instruction());
    let 'n = num_elem;
    let 'm = SEW;
    let vm_val : bits('n) = read_vmask(num_elem, vm, zvreg);
    let vs1_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);
    let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);
    let vd_val : bits('n) = read_vmask(num_elem, 0b0, vd);
    let (initial_result, mask) : (bits('n), bits('n)) = $[complete] match init_masked_result_cmp(num_elem, SEW, LMUL_pow, vd_val, vm_val) {
      Ok(v) => v,
      Err(()) => return(Illegal_Instruction())
    };
    var result = initial_result;
    foreach (i from 0 to sub_atom(num_elem, 1) by 1 in inc) {
        if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(mask, i), bitone) then {
            let res : bool = $[complete] match funct6 {
              VVCMP_VMSEQ => $[overloaded { "name" = "==", "is_infix" = true }] eq_bits($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs1_val, i)),
              VVCMP_VMSNE => $[overloaded { "name" = "!=", "is_infix" = true }] neq_bits($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs1_val, i)),
              VVCMP_VMSLTU => $[overloaded { "name" = "<", "is_infix" = true }] lt_int(unsigned($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)), unsigned($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs1_val, i))),
              VVCMP_VMSLT => $[overloaded { "name" = "<", "is_infix" = true }] lt_int(signed($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)), signed($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs1_val, i))),
              VVCMP_VMSLEU => $[overloaded { "name" = "<=", "is_infix" = true }] lteq_int(unsigned($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)), unsigned($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs1_val, i))),
              VVCMP_VMSLE => $[overloaded { "name" = "<=", "is_infix" = true }] lteq_int(signed($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)), signed($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs1_val, i)))
            };
            result[i] = bool_to_bit(res)
        };
        ()
    };
    write_vmask(num_elem, vd, result);
    set_vstart(zeros(16));
    RETIRE_SUCCESS
}
and execute VXMTYPE((funct6, vs2, rs1, vd)) = {
    let SEW = get_sew();
    let LMUL_pow = get_lmul_pow();
    let num_elem = get_num_elem(LMUL_pow, SEW);
    if illegal_vd_unmasked() then return(Illegal_Instruction());
    let 'n = num_elem;
    let 'm = SEW;
    let vm_val : bits('n) = read_vmask_carry(num_elem, 0b0, zvreg);
    let rs1_val : bits('m) = get_scalar(rs1, SEW);
    let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);
    let vd_val : bits('n) = read_vmask(num_elem, 0b0, vd);
    let (initial_result, mask) : (bits('n), bits('n)) = $[complete] match init_masked_result_carry(num_elem, SEW, LMUL_pow, vd_val) {
      Ok(v) => v,
      Err(()) => return(Illegal_Instruction())
    };
    var result = initial_result;
    foreach (i from 0 to sub_atom(num_elem, 1) by 1 in inc) {
        if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(mask, i), bitone) then {
            let res : bool = $[complete] match funct6 {
              VXM_VMADC => $[overloaded { "name" = ">", "is_infix" = true }] gt_int($[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "+", "is_infix" = true }] add_atom(unsigned($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)), unsigned(rs1_val)), if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(vm_val, i), bitone) then
                1
              else
                0), $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(2 ^ SEW, 1)),
              VXM_VMSBC => $[overloaded { "name" = "<", "is_infix" = true }] lt_int($[overloaded { "name" = "-", "is_infix" = true }] sub_atom($[overloaded { "name" = "-", "is_infix" = true }] sub_atom(unsigned($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)), unsigned(rs1_val)), if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(vm_val, i), bitone) then
                1
              else
                0), 0)
            };
            result[i] = bool_to_bit(res)
        };
        ()
    };
    write_vmask(num_elem, vd, result);
    set_vstart(zeros(16));
    RETIRE_SUCCESS
}
and execute VXMCTYPE((funct6, vs2, rs1, vd)) = {
    let SEW = get_sew();
    let LMUL_pow = get_lmul_pow();
    let num_elem = get_num_elem(LMUL_pow, SEW);
    if illegal_vd_unmasked() then return(Illegal_Instruction());
    let 'n = num_elem;
    let 'm = SEW;
    let rs1_val : bits('m) = get_scalar(rs1, SEW);
    let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);
    let vd_val : bits('n) = read_vmask(num_elem, 0b0, vd);
    let (initial_result, mask) : (bits('n), bits('n)) = $[complete] match init_masked_result_carry(num_elem, SEW, LMUL_pow, vd_val) {
      Ok(v) => v,
      Err(()) => return(Illegal_Instruction())
    };
    var result = initial_result;
    foreach (i from 0 to sub_atom(num_elem, 1) by 1 in inc) {
        if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(mask, i), bitone) then {
            let res : bool = $[complete] match funct6 {
              VXMC_VMADC => $[overloaded { "name" = ">", "is_infix" = true }] gt_int($[overloaded { "name" = "+", "is_infix" = true }] add_atom(unsigned($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)), unsigned(rs1_val)), $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(2 ^ SEW, 1)),
              VXMC_VMSBC => $[overloaded { "name" = "<", "is_infix" = true }] lt_int($[overloaded { "name" = "-", "is_infix" = true }] sub_atom(unsigned($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)), unsigned(rs1_val)), 0)
            };
            result[i] = bool_to_bit(res)
        };
        ()
    };
    write_vmask(num_elem, vd, result);
    set_vstart(zeros(16));
    RETIRE_SUCCESS
}
and execute VXMSTYPE((funct6, vs2, rs1, vd)) = {
    let SEW = get_sew();
    let LMUL_pow = get_lmul_pow();
    let num_elem = get_num_elem(LMUL_pow, SEW);
    if illegal_vd_masked(vd) then return(Illegal_Instruction());
    let 'n = num_elem;
    let 'm = SEW;
    let vec_trues : bits('n) = ones($[overloaded { "name" = "__size", "is_infix" = false }] __id(n));
    let vm_val : bits('n) = read_vmask_carry(num_elem, 0b0, zvreg);
    let rs1_val : bits('m) = get_scalar(rs1, SEW);
    let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);
    let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);
    let (initial_result, mask) : (vector('n, bits('m)), bits('n)) = $[complete] match init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vec_trues) {
      Ok(v) => v,
      Err(()) => return(Illegal_Instruction())
    };
    var result = initial_result;
    foreach (i from 0 to sub_atom(num_elem, 1) by 1 in inc) {
        if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(mask, i), bitone) then {
            result[i] = $[complete] match funct6 {
              VXMS_VADC => to_bits_unsafe(SEW, $[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "+", "is_infix" = true }] add_atom(unsigned($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)), unsigned(rs1_val)), if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(vm_val, i), bitone) then
                1
              else
                0)),
              VXMS_VSBC => to_bits_unsafe(SEW, $[overloaded { "name" = "-", "is_infix" = true }] sub_atom($[overloaded { "name" = "-", "is_infix" = true }] sub_atom(unsigned($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)), unsigned(rs1_val)), if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(vm_val, i), bitone) then
                1
              else
                0))
            }
        };
        ()
    };
    write_vreg(num_elem, SEW, LMUL_pow, vd, result);
    set_vstart(zeros(16));
    RETIRE_SUCCESS
}
and execute VXCMPTYPE((funct6, vm, vs2, rs1, vd)) = {
    let SEW = get_sew();
    let LMUL_pow = get_lmul_pow();
    let num_elem = get_num_elem(LMUL_pow, SEW);
    if illegal_vd_unmasked() then return(Illegal_Instruction());
    let 'n = num_elem;
    let 'm = SEW;
    let vm_val : bits('n) = read_vmask(num_elem, vm, zvreg);
    let rs1_val : bits('m) = get_scalar(rs1, SEW);
    let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);
    let vd_val : bits('n) = read_vmask(num_elem, 0b0, vd);
    let (initial_result, mask) : (bits('n), bits('n)) = $[complete] match init_masked_result_cmp(num_elem, SEW, LMUL_pow, vd_val, vm_val) {
      Ok(v) => v,
      Err(()) => return(Illegal_Instruction())
    };
    var result = initial_result;
    foreach (i from 0 to sub_atom(num_elem, 1) by 1 in inc) {
        if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(mask, i), bitone) then {
            let res : bool = $[complete] match funct6 {
              VXCMP_VMSEQ => $[overloaded { "name" = "==", "is_infix" = true }] eq_bits($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i), rs1_val),
              VXCMP_VMSNE => $[overloaded { "name" = "!=", "is_infix" = true }] neq_bits($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i), rs1_val),
              VXCMP_VMSLTU => $[overloaded { "name" = "<", "is_infix" = true }] lt_int(unsigned($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)), unsigned(rs1_val)),
              VXCMP_VMSLT => $[overloaded { "name" = "<", "is_infix" = true }] lt_int(signed($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)), signed(rs1_val)),
              VXCMP_VMSLEU => $[overloaded { "name" = "<=", "is_infix" = true }] lteq_int(unsigned($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)), unsigned(rs1_val)),
              VXCMP_VMSLE => $[overloaded { "name" = "<=", "is_infix" = true }] lteq_int(signed($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)), signed(rs1_val)),
              VXCMP_VMSGTU => $[overloaded { "name" = ">", "is_infix" = true }] gt_int(unsigned($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)), unsigned(rs1_val)),
              VXCMP_VMSGT => $[overloaded { "name" = ">", "is_infix" = true }] gt_int(signed($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)), signed(rs1_val))
            };
            result[i] = bool_to_bit(res)
        };
        ()
    };
    write_vmask(num_elem, vd, result);
    set_vstart(zeros(16));
    RETIRE_SUCCESS
}
and execute VIMTYPE((funct6, vs2, simm, vd)) = {
    let SEW = get_sew();
    let LMUL_pow = get_lmul_pow();
    let num_elem = get_num_elem(LMUL_pow, SEW);
    if illegal_vd_unmasked() then return(Illegal_Instruction());
    let 'n = num_elem;
    let 'm = SEW;
    let vm_val : bits('n) = read_vmask_carry(num_elem, 0b0, zvreg);
    let imm_val : bits('m) = sign_extend($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), simm);
    let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);
    let vd_val : bits('n) = read_vmask(num_elem, 0b0, vd);
    let (initial_result, mask) : (bits('n), bits('n)) = $[complete] match init_masked_result_carry(num_elem, SEW, LMUL_pow, vd_val) {
      Ok(v) => v,
      Err(()) => return(Illegal_Instruction())
    };
    var result = initial_result;
    foreach (i from 0 to sub_atom(num_elem, 1) by 1 in inc) {
        if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(mask, i), bitone) then {
            let res : bool = $[complete] match funct6 {
              VIM_VMADC => $[overloaded { "name" = ">", "is_infix" = true }] gt_int($[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "+", "is_infix" = true }] add_atom(unsigned($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)), unsigned(imm_val)), if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(vm_val, i), bitone) then
                1
              else
                0), $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(2 ^ SEW, 1))
            };
            result[i] = bool_to_bit(res)
        };
        ()
    };
    write_vmask(num_elem, vd, result);
    set_vstart(zeros(16));
    RETIRE_SUCCESS
}
and execute VIMCTYPE((funct6, vs2, simm, vd)) = {
    let SEW = get_sew();
    let LMUL_pow = get_lmul_pow();
    let num_elem = get_num_elem(LMUL_pow, SEW);
    if illegal_vd_unmasked() then return(Illegal_Instruction());
    let 'n = num_elem;
    let 'm = SEW;
    let imm_val : bits('m) = sign_extend($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), simm);
    let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);
    let vd_val : bits('n) = read_vmask(num_elem, 0b0, vd);
    let (initial_result, mask) : (bits('n), bits('n)) = $[complete] match init_masked_result_carry(num_elem, SEW, LMUL_pow, vd_val) {
      Ok(v) => v,
      Err(()) => return(Illegal_Instruction())
    };
    var result = initial_result;
    foreach (i from 0 to sub_atom(num_elem, 1) by 1 in inc) {
        if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(mask, i), bitone) then {
            let res : bool = $[complete] match funct6 {
              VIMC_VMADC => $[overloaded { "name" = ">", "is_infix" = true }] gt_int($[overloaded { "name" = "+", "is_infix" = true }] add_atom(unsigned($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)), unsigned(imm_val)), $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(2 ^ SEW, 1))
            };
            result[i] = bool_to_bit(res)
        };
        ()
    };
    write_vmask(num_elem, vd, result);
    set_vstart(zeros(16));
    RETIRE_SUCCESS
}
and execute VIMSTYPE((funct6, vs2, simm, vd)) = {
    let SEW = get_sew();
    let LMUL_pow = get_lmul_pow();
    let num_elem = get_num_elem(LMUL_pow, SEW);
    if illegal_vd_masked(vd) then return(Illegal_Instruction());
    let 'n = num_elem;
    let 'm = SEW;
    let vec_trues : bits('n) = ones($[overloaded { "name" = "__size", "is_infix" = false }] __id(n));
    let vm_val : bits('n) = read_vmask_carry(num_elem, 0b0, zvreg);
    let imm_val : bits('m) = sign_extend($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), simm);
    let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);
    let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);
    let (initial_result, mask) : (vector('n, bits('m)), bits('n)) = $[complete] match init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vec_trues) {
      Ok(v) => v,
      Err(()) => return(Illegal_Instruction())
    };
    var result = initial_result;
    foreach (i from 0 to sub_atom(num_elem, 1) by 1 in inc) {
        if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(mask, i), bitone) then {
            result[i] = $[complete] match funct6 {
              VIMS_VADC => to_bits_unsafe(SEW, $[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "+", "is_infix" = true }] add_atom(unsigned($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)), unsigned(imm_val)), if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(vm_val, i), bitone) then
                1
              else
                0))
            }
        };
        ()
    };
    write_vreg(num_elem, SEW, LMUL_pow, vd, result);
    set_vstart(zeros(16));
    RETIRE_SUCCESS
}
and execute VICMPTYPE((funct6, vm, vs2, simm, vd)) = {
    let SEW = get_sew();
    let LMUL_pow = get_lmul_pow();
    let num_elem = get_num_elem(LMUL_pow, SEW);
    if illegal_vd_unmasked() then return(Illegal_Instruction());
    let 'n = num_elem;
    let 'm = SEW;
    let vm_val : bits('n) = read_vmask(num_elem, vm, zvreg);
    let imm_val : bits('m) = sign_extend($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), simm);
    let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);
    let vd_val : bits('n) = read_vmask(num_elem, 0b0, vd);
    let (initial_result, mask) : (bits('n), bits('n)) = $[complete] match init_masked_result_cmp(num_elem, SEW, LMUL_pow, vd_val, vm_val) {
      Ok(v) => v,
      Err(()) => return(Illegal_Instruction())
    };
    var result = initial_result;
    foreach (i from 0 to sub_atom(num_elem, 1) by 1 in inc) {
        if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(mask, i), bitone) then {
            let res : bool = $[complete] match funct6 {
              VICMP_VMSEQ => $[overloaded { "name" = "==", "is_infix" = true }] eq_bits($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i), imm_val),
              VICMP_VMSNE => $[overloaded { "name" = "!=", "is_infix" = true }] neq_bits($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i), imm_val),
              VICMP_VMSLEU => $[overloaded { "name" = "<=", "is_infix" = true }] lteq_int(unsigned($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)), unsigned(imm_val)),
              VICMP_VMSLE => $[overloaded { "name" = "<=", "is_infix" = true }] lteq_int(signed($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)), signed(imm_val)),
              VICMP_VMSGTU => $[overloaded { "name" = ">", "is_infix" = true }] gt_int(unsigned($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)), unsigned(imm_val)),
              VICMP_VMSGT => $[overloaded { "name" = ">", "is_infix" = true }] gt_int(signed($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)), signed(imm_val))
            };
            result[i] = bool_to_bit(res)
        };
        ()
    };
    write_vmask(num_elem, vd, result);
    set_vstart(zeros(16));
    RETIRE_SUCCESS
}
and execute FVVMTYPE((funct6, vm, vs2, vs1, vd)) = {
    let rm_3b = _get_Fcsr_FRM(fcsr);
    let SEW = get_sew();
    let LMUL_pow = get_lmul_pow();
    let num_elem = get_num_elem(LMUL_pow, SEW);
    if illegal_fp_vd_unmasked(SEW, rm_3b) then return(Illegal_Instruction());
    assert($[overloaded { "name" = "!=", "is_infix" = true }] neq_int(SEW, 8), "./extensions/V/vext_fp_vm_insts.sail:36.17-36.18");
    let 'n = num_elem;
    let 'm = SEW;
    let vm_val : bits('n) = read_vmask(num_elem, vm, zvreg);
    let vs1_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);
    let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);
    let vd_val : bits('n) = read_vmask(num_elem, 0b0, vd);
    let (initial_result, mask) : (bits('n), bits('n)) = $[complete] match init_masked_result_cmp(num_elem, SEW, LMUL_pow, vd_val, vm_val) {
      Ok(v) => v,
      Err(()) => return(Illegal_Instruction())
    };
    var result = initial_result;
    foreach (i from 0 to sub_atom(num_elem, 1) by 1 in inc) {
        if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(mask, i), bitone) then {
            let res : bool = $[complete] match funct6 {
              FVVM_VMFEQ => fp_eq($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs1_val, i)),
              FVVM_VMFNE => $[overloaded { "name" = "~", "is_infix" = false }] not_bool(fp_eq($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs1_val, i))),
              FVVM_VMFLE => fp_le($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs1_val, i)),
              FVVM_VMFLT => fp_lt($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs1_val, i))
            };
            result[i] = bool_to_bit(res)
        };
        ()
    };
    write_vmask(num_elem, vd, result);
    set_vstart(zeros(16));
    RETIRE_SUCCESS
}
and execute FVFMTYPE((funct6, vm, vs2, rs1, vd)) = {
    let rm_3b = _get_Fcsr_FRM(fcsr);
    let SEW = get_sew();
    let LMUL_pow = get_lmul_pow();
    let num_elem = get_num_elem(LMUL_pow, SEW);
    if illegal_fp_vd_unmasked(SEW, rm_3b) then return(Illegal_Instruction());
    assert($[overloaded { "name" = "!=", "is_infix" = true }] neq_int(SEW, 8), "./extensions/V/vext_fp_vm_insts.sail:103.17-103.18");
    let 'n = num_elem;
    let 'm = SEW;
    let vm_val : bits('n) = read_vmask(num_elem, vm, zvreg);
    let rs1_val : bits('m) = get_scalar_fp(rs1, $[overloaded { "name" = "__size", "is_infix" = false }] __id(m));
    let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);
    let vd_val : bits('n) = read_vmask(num_elem, 0b0, vd);
    let (initial_result, mask) : (bits('n), bits('n)) = $[complete] match init_masked_result_cmp(num_elem, SEW, LMUL_pow, vd_val, vm_val) {
      Ok(v) => v,
      Err(()) => return(Illegal_Instruction())
    };
    var result = initial_result;
    foreach (i from 0 to sub_atom(num_elem, 1) by 1 in inc) {
        if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(mask, i), bitone) then {
            let res : bool = $[complete] match funct6 {
              VFM_VMFEQ => fp_eq($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i), rs1_val),
              VFM_VMFNE => $[overloaded { "name" = "~", "is_infix" = false }] not_bool(fp_eq($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i), rs1_val)),
              VFM_VMFLE => fp_le($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i), rs1_val),
              VFM_VMFLT => fp_lt($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i), rs1_val),
              VFM_VMFGE => fp_ge($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i), rs1_val),
              VFM_VMFGT => fp_gt($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i), rs1_val)
            };
            result[i] = bool_to_bit(res)
        };
        ()
    };
    write_vmask(num_elem, vd, result);
    set_vstart(zeros(16));
    RETIRE_SUCCESS
}
and execute RIVVTYPE((funct6, vm, vs2, vs1, vd)) = {
    let SEW = get_sew();
    let LMUL_pow = get_lmul_pow();
    let SEW_widen = $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(SEW, 2);
    if illegal_widening_reduction(SEW_widen) then return(Illegal_Instruction());
    assert($[overloaded { "name" = "<=", "is_infix" = true }] lteq_int(SEW_widen, 64), "./extensions/V/vext_red_insts.sail:33.24-33.25");
    let num_elem_vs = get_num_elem(LMUL_pow, SEW);
    let num_elem_vd = get_num_elem(0, SEW_widen);
    if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(unsigned(vl), 0) then return(RETIRE_SUCCESS);
    let 'n = num_elem_vs;
    let 'd = num_elem_vd;
    let 'm = SEW;
    let 'o = SEW_widen;
    let vm_val : bits('n) = read_vmask(num_elem_vs, vm, zvreg);
    let vd_val : vector('d, bits('o)) = read_vreg(num_elem_vd, SEW_widen, 0, vd);
    let vs2_val : vector('n, bits('m)) = read_vreg(num_elem_vs, SEW, LMUL_pow, vs2);
    let mask : bits('n) = $[complete] match init_masked_source(num_elem_vs, LMUL_pow, vm_val) {
      Ok(v) => v,
      Err(()) => return(Illegal_Instruction())
    };
    var sum : bits('o) = read_single_element(SEW_widen, 0, vs1);
    foreach (i from 0 to sub_atom(num_elem_vs, 1) by 1 in inc) {
        if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(mask, i), bitone) then {
            let elem : bits('o) = $[complete] match funct6 {
              IVV_VWREDSUMU => to_bits_unsafe(SEW_widen, unsigned($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i))),
              IVV_VWREDSUM => to_bits_unsafe(SEW_widen, signed($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)))
            };
            sum = $[overloaded { "name" = "+", "is_infix" = true }] add_bits(sum, elem)
        };
        ()
    };
    write_single_element(SEW_widen, 0, vd, sum);
    set_vstart(zeros(16));
    RETIRE_SUCCESS
}
and execute RMVVTYPE((funct6, vm, vs2, vs1, vd)) = {
    let SEW = get_sew();
    let LMUL_pow = get_lmul_pow();
    let num_elem_vs = get_num_elem(LMUL_pow, SEW);
    let num_elem_vd = get_num_elem(0, SEW);
    if illegal_reduction() then return(Illegal_Instruction());
    if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(unsigned(vl), 0) then return(RETIRE_SUCCESS);
    let 'n = num_elem_vs;
    let 'd = num_elem_vd;
    let 'm = SEW;
    let vm_val : bits('n) = read_vmask(num_elem_vs, vm, zvreg);
    let vd_val : vector('d, bits('m)) = read_vreg(num_elem_vd, SEW, 0, vd);
    let vs2_val : vector('n, bits('m)) = read_vreg(num_elem_vs, SEW, LMUL_pow, vs2);
    let mask : bits('n) = $[complete] match init_masked_source(num_elem_vs, LMUL_pow, vm_val) {
      Ok(v) => v,
      Err(()) => return(Illegal_Instruction())
    };
    var sum : bits('m) = read_single_element(SEW, 0, vs1);
    foreach (i from 0 to sub_atom(num_elem_vs, 1) by 1 in inc) {
        if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(mask, i), bitone) then {
            sum = $[complete] match funct6 {
              MVV_VREDSUM => $[overloaded { "name" = "+", "is_infix" = true }] add_bits(sum, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)),
              MVV_VREDAND => $[overloaded { "name" = "&", "is_infix" = true }] and_vec(sum, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)),
              MVV_VREDOR => $[overloaded { "name" = "|", "is_infix" = true }] or_vec(sum, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)),
              MVV_VREDXOR => $[overloaded { "name" = "^", "is_infix" = true }] xor_vec(sum, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)),
              MVV_VREDMIN => to_bits_unsafe(SEW, $[overloaded { "name" = "min", "is_infix" = false }] min_int(signed($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)), signed(sum))),
              MVV_VREDMINU => to_bits_unsafe(SEW, $[overloaded { "name" = "min", "is_infix" = false }] min_int(unsigned($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)), unsigned(sum))),
              MVV_VREDMAX => to_bits_unsafe(SEW, $[overloaded { "name" = "max", "is_infix" = false }] max_int(signed($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)), signed(sum))),
              MVV_VREDMAXU => to_bits_unsafe(SEW, $[overloaded { "name" = "max", "is_infix" = false }] max_int(unsigned($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i)), unsigned(sum)))
            }
        };
        ()
    };
    write_single_element(SEW, 0, vd, sum);
    set_vstart(zeros(16));
    RETIRE_SUCCESS
}
and execute RFVVTYPE((funct6, vm, vs2, vs1, vd)) = {
    let SEW = get_sew();
    let LMUL_pow = get_lmul_pow();
    let num_elem_vs = get_num_elem(LMUL_pow, SEW);
    if $[overloaded { "name" = "|", "is_infix" = true }] or_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_anything(funct6, FVV_VFWREDOSUM), $[overloaded { "name" = "==", "is_infix" = true }] eq_anything(funct6, FVV_VFWREDUSUM)) then
      process_rfvv_widening_reduction(funct6, vm, vs2, vs1, vd, num_elem_vs, SEW, LMUL_pow)
    else
      process_rfvv_single(funct6, vm, vs2, vs1, vd, num_elem_vs, SEW, LMUL_pow)
}
and execute SHA256SIG0((rs1, rd)) = {
    let inb : bits(32) = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1), 31, 0);
    let result : bits(32) = $[overloaded { "name" = "^", "is_infix" = true }] xor_vec($[overloaded { "name" = ">>>", "is_infix" = true }] rotater(inb, 7), $[overloaded { "name" = "^", "is_infix" = true }] xor_vec($[overloaded { "name" = ">>>", "is_infix" = true }] rotater(inb, 18), $[overloaded { "name" = ">>", "is_infix" = true }] shiftr(inb, 3)));
    $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(rd, sign_extend(sizeof(xlen), result));
    RETIRE_SUCCESS
}
and execute SHA256SIG1((rs1, rd)) = {
    let inb : bits(32) = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1), 31, 0);
    let result : bits(32) = $[overloaded { "name" = "^", "is_infix" = true }] xor_vec($[overloaded { "name" = ">>>", "is_infix" = true }] rotater(inb, 17), $[overloaded { "name" = "^", "is_infix" = true }] xor_vec($[overloaded { "name" = ">>>", "is_infix" = true }] rotater(inb, 19), $[overloaded { "name" = ">>", "is_infix" = true }] shiftr(inb, 10)));
    $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(rd, sign_extend(sizeof(xlen), result));
    RETIRE_SUCCESS
}
and execute SHA256SUM0((rs1, rd)) = {
    let inb : bits(32) = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1), 31, 0);
    let result : bits(32) = $[overloaded { "name" = "^", "is_infix" = true }] xor_vec($[overloaded { "name" = ">>>", "is_infix" = true }] rotater(inb, 2), $[overloaded { "name" = "^", "is_infix" = true }] xor_vec($[overloaded { "name" = ">>>", "is_infix" = true }] rotater(inb, 13), $[overloaded { "name" = ">>>", "is_infix" = true }] rotater(inb, 22)));
    $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(rd, sign_extend(sizeof(xlen), result));
    RETIRE_SUCCESS
}
and execute SHA256SUM1((rs1, rd)) = {
    let inb : bits(32) = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1), 31, 0);
    let result : bits(32) = $[overloaded { "name" = "^", "is_infix" = true }] xor_vec($[overloaded { "name" = ">>>", "is_infix" = true }] rotater(inb, 6), $[overloaded { "name" = "^", "is_infix" = true }] xor_vec($[overloaded { "name" = ">>>", "is_infix" = true }] rotater(inb, 11), $[overloaded { "name" = ">>>", "is_infix" = true }] rotater(inb, 25)));
    $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(rd, sign_extend(sizeof(xlen), result));
    RETIRE_SUCCESS
}
and execute AES32ESMI((bs, rs2, rs1, rd)) = {
    let shamt : bits(5) = $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(bs, 0b000);
    let si : bits(8) = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits($[overloaded { "name" = ">>", "is_infix" = true }] shift_bits_right($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs2), shamt), 7, 0);
    let so : bits(8) = aes_sbox_fwd(si);
    let mixed : bits(32) = aes_mixcolumn_byte_fwd(so);
    let result : bits(32) = $[overloaded { "name" = "^", "is_infix" = true }] xor_vec($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1), 31, 0), $[overloaded { "name" = "<<<", "is_infix" = true }] rotate_bits_left(mixed, shamt));
    $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(rd, sign_extend(sizeof(xlen), result));
    RETIRE_SUCCESS
}
and execute AES32ESI((bs, rs2, rs1, rd)) = {
    let shamt : bits(5) = $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(bs, 0b000);
    let si : bits(8) = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits($[overloaded { "name" = ">>", "is_infix" = true }] shift_bits_right($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs2), shamt), 7, 0);
    let so : bits(32) = $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(0x000000, aes_sbox_fwd(si));
    let result : bits(32) = $[overloaded { "name" = "^", "is_infix" = true }] xor_vec($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1), 31, 0), $[overloaded { "name" = "<<<", "is_infix" = true }] rotate_bits_left(so, shamt));
    $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(rd, sign_extend(sizeof(xlen), result));
    RETIRE_SUCCESS
}
and execute AES32DSMI((bs, rs2, rs1, rd)) = {
    let shamt : bits(5) = $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(bs, 0b000);
    let si : bits(8) = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits($[overloaded { "name" = ">>", "is_infix" = true }] shift_bits_right($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs2), shamt), 7, 0);
    let so : bits(8) = aes_sbox_inv(si);
    let mixed : bits(32) = aes_mixcolumn_byte_inv(so);
    let result : bits(32) = $[overloaded { "name" = "^", "is_infix" = true }] xor_vec($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1), 31, 0), $[overloaded { "name" = "<<<", "is_infix" = true }] rotate_bits_left(mixed, shamt));
    $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(rd, sign_extend(sizeof(xlen), result));
    RETIRE_SUCCESS
}
and execute AES32DSI((bs, rs2, rs1, rd)) = {
    let shamt : bits(5) = $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(bs, 0b000);
    let si : bits(8) = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits($[overloaded { "name" = ">>", "is_infix" = true }] shift_bits_right($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs2), shamt), 7, 0);
    let so : bits(32) = $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(0x000000, aes_sbox_inv(si));
    let result : bits(32) = $[overloaded { "name" = "^", "is_infix" = true }] xor_vec($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1), 31, 0), $[overloaded { "name" = "<<<", "is_infix" = true }] rotate_bits_left(so, shamt));
    $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(rd, sign_extend(sizeof(xlen), result));
    RETIRE_SUCCESS
}
and execute SHA512SIG0H((rs2, rs1, rd)) = {
    $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(rd, sign_extend(sizeof(xlen), $[overloaded { "name" = "^", "is_infix" = true }] xor_vec($[overloaded { "name" = ">>", "is_infix" = true }] shiftr($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1), 1), $[overloaded { "name" = "^", "is_infix" = true }] xor_vec($[overloaded { "name" = ">>", "is_infix" = true }] shiftr($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1), 7), $[overloaded { "name" = "^", "is_infix" = true }] xor_vec($[overloaded { "name" = ">>", "is_infix" = true }] shiftr($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1), 8), $[overloaded { "name" = "^", "is_infix" = true }] xor_vec($[overloaded { "name" = "<<", "is_infix" = true }] shiftl($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs2), 31), $[overloaded { "name" = "<<", "is_infix" = true }] shiftl($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs2), 24)))))));
    RETIRE_SUCCESS
}
and execute SHA512SIG0L((rs2, rs1, rd)) = {
    $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(rd, sign_extend(sizeof(xlen), $[overloaded { "name" = "^", "is_infix" = true }] xor_vec($[overloaded { "name" = ">>", "is_infix" = true }] shiftr($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1), 1), $[overloaded { "name" = "^", "is_infix" = true }] xor_vec($[overloaded { "name" = ">>", "is_infix" = true }] shiftr($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1), 7), $[overloaded { "name" = "^", "is_infix" = true }] xor_vec($[overloaded { "name" = ">>", "is_infix" = true }] shiftr($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1), 8), $[overloaded { "name" = "^", "is_infix" = true }] xor_vec($[overloaded { "name" = "<<", "is_infix" = true }] shiftl($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs2), 31), $[overloaded { "name" = "^", "is_infix" = true }] xor_vec($[overloaded { "name" = "<<", "is_infix" = true }] shiftl($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs2), 25), $[overloaded { "name" = "<<", "is_infix" = true }] shiftl($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs2), 24))))))));
    RETIRE_SUCCESS
}
and execute SHA512SIG1H((rs2, rs1, rd)) = {
    $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(rd, sign_extend(sizeof(xlen), $[overloaded { "name" = "^", "is_infix" = true }] xor_vec($[overloaded { "name" = "<<", "is_infix" = true }] shiftl($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1), 3), $[overloaded { "name" = "^", "is_infix" = true }] xor_vec($[overloaded { "name" = ">>", "is_infix" = true }] shiftr($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1), 6), $[overloaded { "name" = "^", "is_infix" = true }] xor_vec($[overloaded { "name" = ">>", "is_infix" = true }] shiftr($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1), 19), $[overloaded { "name" = "^", "is_infix" = true }] xor_vec($[overloaded { "name" = ">>", "is_infix" = true }] shiftr($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs2), 29), $[overloaded { "name" = "<<", "is_infix" = true }] shiftl($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs2), 13)))))));
    RETIRE_SUCCESS
}
and execute SHA512SIG1L((rs2, rs1, rd)) = {
    $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(rd, sign_extend(sizeof(xlen), $[overloaded { "name" = "^", "is_infix" = true }] xor_vec($[overloaded { "name" = "<<", "is_infix" = true }] shiftl($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1), 3), $[overloaded { "name" = "^", "is_infix" = true }] xor_vec($[overloaded { "name" = ">>", "is_infix" = true }] shiftr($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1), 6), $[overloaded { "name" = "^", "is_infix" = true }] xor_vec($[overloaded { "name" = ">>", "is_infix" = true }] shiftr($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1), 19), $[overloaded { "name" = "^", "is_infix" = true }] xor_vec($[overloaded { "name" = ">>", "is_infix" = true }] shiftr($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs2), 29), $[overloaded { "name" = "^", "is_infix" = true }] xor_vec($[overloaded { "name" = "<<", "is_infix" = true }] shiftl($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs2), 26), $[overloaded { "name" = "<<", "is_infix" = true }] shiftl($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs2), 13))))))));
    RETIRE_SUCCESS
}
and execute SHA512SUM0R((rs2, rs1, rd)) = {
    $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(rd, sign_extend(sizeof(xlen), $[overloaded { "name" = "^", "is_infix" = true }] xor_vec($[overloaded { "name" = "<<", "is_infix" = true }] shiftl($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1), 25), $[overloaded { "name" = "^", "is_infix" = true }] xor_vec($[overloaded { "name" = "<<", "is_infix" = true }] shiftl($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1), 30), $[overloaded { "name" = "^", "is_infix" = true }] xor_vec($[overloaded { "name" = ">>", "is_infix" = true }] shiftr($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1), 28), $[overloaded { "name" = "^", "is_infix" = true }] xor_vec($[overloaded { "name" = ">>", "is_infix" = true }] shiftr($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs2), 7), $[overloaded { "name" = "^", "is_infix" = true }] xor_vec($[overloaded { "name" = ">>", "is_infix" = true }] shiftr($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs2), 2), $[overloaded { "name" = "<<", "is_infix" = true }] shiftl($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs2), 4))))))));
    RETIRE_SUCCESS
}
and execute SHA512SUM1R((rs2, rs1, rd)) = {
    $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(rd, sign_extend(sizeof(xlen), $[overloaded { "name" = "^", "is_infix" = true }] xor_vec($[overloaded { "name" = "<<", "is_infix" = true }] shiftl($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1), 23), $[overloaded { "name" = "^", "is_infix" = true }] xor_vec($[overloaded { "name" = ">>", "is_infix" = true }] shiftr($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1), 14), $[overloaded { "name" = "^", "is_infix" = true }] xor_vec($[overloaded { "name" = ">>", "is_infix" = true }] shiftr($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1), 18), $[overloaded { "name" = "^", "is_infix" = true }] xor_vec($[overloaded { "name" = ">>", "is_infix" = true }] shiftr($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs2), 9), $[overloaded { "name" = "^", "is_infix" = true }] xor_vec($[overloaded { "name" = "<<", "is_infix" = true }] shiftl($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs2), 18), $[overloaded { "name" = "<<", "is_infix" = true }] shiftl($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs2), 14))))))));
    RETIRE_SUCCESS
}
and execute AES64KS1I((rnum, rs1, rd)) = {
    assert($[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64), "./extensions/K/zkn_insts.sail:312.19-312.20");
    let prev : bits(32) = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1), 63, 32);
    let subwords : bits(32) = aes_subword_fwd(prev);
    let result : bits(32) = if $[overloaded { "name" = "==", "is_infix" = true }] eq_bits(rnum, 0xA) then
      subwords
    else
      $[overloaded { "name" = "^", "is_infix" = true }] xor_vec($[overloaded { "name" = ">>>", "is_infix" = true }] rotater(subwords, 8), aes_decode_rcon(rnum));
    $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(rd, $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(result, result));
    RETIRE_SUCCESS
}
and execute AES64KS2((rs2, rs1, rd)) = {
    assert($[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64), "./extensions/K/zkn_insts.sail:322.19-322.20");
    let w0 : bits(32) = $[overloaded { "name" = "^", "is_infix" = true }] xor_vec($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1), 63, 32), $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs2), 31, 0));
    let w1 : bits(32) = $[overloaded { "name" = "^", "is_infix" = true }] xor_vec($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1), 63, 32), $[overloaded { "name" = "^", "is_infix" = true }] xor_vec($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs2), 31, 0), $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs2), 63, 32)));
    $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(rd, $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(w1, w0));
    RETIRE_SUCCESS
}
and execute AES64IM((rs1, rd)) = {
    assert($[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64), "./extensions/K/zkn_insts.sail:330.19-330.20");
    let w0 : bits(32) = aes_mixcolumn_inv($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1), 31, 0));
    let w1 : bits(32) = aes_mixcolumn_inv($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1), 63, 32));
    $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(rd, $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(w1, w0));
    RETIRE_SUCCESS
}
and execute AES64ESM((rs2, rs1, rd)) = {
    assert($[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64), "./extensions/K/zkn_insts.sail:338.19-338.20");
    let sr : bits(64) = aes_rv64_shiftrows_fwd($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs2), $[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1));
    let wd : bits(64) = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(sr, 63, 0);
    let sb : bits(64) = aes_apply_fwd_sbox_to_each_byte(wd);
    $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(rd, $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(aes_mixcolumn_fwd($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(sb, 63, 32)), aes_mixcolumn_fwd($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(sb, 31, 0))));
    RETIRE_SUCCESS
}
and execute AES64ES((rs2, rs1, rd)) = {
    assert($[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64), "./extensions/K/zkn_insts.sail:347.19-347.20");
    let sr : bits(64) = aes_rv64_shiftrows_fwd($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs2), $[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1));
    let wd : bits(64) = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(sr, 63, 0);
    $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(rd, aes_apply_fwd_sbox_to_each_byte(wd));
    RETIRE_SUCCESS
}
and execute AES64DSM((rs2, rs1, rd)) = {
    assert($[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64), "./extensions/K/zkn_insts.sail:355.19-355.20");
    let sr : bits(64) = aes_rv64_shiftrows_inv($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs2), $[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1));
    let wd : bits(64) = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(sr, 63, 0);
    let sb : bits(64) = aes_apply_inv_sbox_to_each_byte(wd);
    $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(rd, $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(aes_mixcolumn_inv($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(sb, 63, 32)), aes_mixcolumn_inv($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(sb, 31, 0))));
    RETIRE_SUCCESS
}
and execute AES64DS((rs2, rs1, rd)) = {
    assert($[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64), "./extensions/K/zkn_insts.sail:364.19-364.20");
    let sr : bits(64) = aes_rv64_shiftrows_inv($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs2), $[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1));
    let wd : bits(64) = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(sr, 63, 0);
    $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(rd, aes_apply_inv_sbox_to_each_byte(wd));
    RETIRE_SUCCESS
}
and execute SHA512SIG0((rs1, rd)) = {
    assert($[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64), "./extensions/K/zkn_insts.sail:410.19-410.20");
    let input : bits(64) = $[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1);
    let result : bits(64) = $[overloaded { "name" = "^", "is_infix" = true }] xor_vec($[overloaded { "name" = ">>>", "is_infix" = true }] rotater(input, 1), $[overloaded { "name" = "^", "is_infix" = true }] xor_vec($[overloaded { "name" = ">>>", "is_infix" = true }] rotater(input, 8), $[overloaded { "name" = ">>", "is_infix" = true }] shiftr(input, 7)));
    $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(rd, result);
    RETIRE_SUCCESS
}
and execute SHA512SIG1((rs1, rd)) = {
    assert($[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64), "./extensions/K/zkn_insts.sail:418.19-418.20");
    let input : bits(64) = $[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1);
    let result : bits(64) = $[overloaded { "name" = "^", "is_infix" = true }] xor_vec($[overloaded { "name" = ">>>", "is_infix" = true }] rotater(input, 19), $[overloaded { "name" = "^", "is_infix" = true }] xor_vec($[overloaded { "name" = ">>>", "is_infix" = true }] rotater(input, 61), $[overloaded { "name" = ">>", "is_infix" = true }] shiftr(input, 6)));
    $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(rd, result);
    RETIRE_SUCCESS
}
and execute SHA512SUM0((rs1, rd)) = {
    assert($[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64), "./extensions/K/zkn_insts.sail:426.19-426.20");
    let input : bits(64) = $[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1);
    let result : bits(64) = $[overloaded { "name" = "^", "is_infix" = true }] xor_vec($[overloaded { "name" = ">>>", "is_infix" = true }] rotater(input, 28), $[overloaded { "name" = "^", "is_infix" = true }] xor_vec($[overloaded { "name" = ">>>", "is_infix" = true }] rotater(input, 34), $[overloaded { "name" = ">>>", "is_infix" = true }] rotater(input, 39)));
    $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(rd, result);
    RETIRE_SUCCESS
}
and execute SHA512SUM1((rs1, rd)) = {
    assert($[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64), "./extensions/K/zkn_insts.sail:434.19-434.20");
    let input : bits(64) = $[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1);
    let result : bits(64) = $[overloaded { "name" = "^", "is_infix" = true }] xor_vec($[overloaded { "name" = ">>>", "is_infix" = true }] rotater(input, 14), $[overloaded { "name" = "^", "is_infix" = true }] xor_vec($[overloaded { "name" = ">>>", "is_infix" = true }] rotater(input, 18), $[overloaded { "name" = ">>>", "is_infix" = true }] rotater(input, 41)));
    $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(rd, result);
    RETIRE_SUCCESS
}
and execute SM3P0((rs1, rd)) = {
    let r1 : bits(32) = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1), 31, 0);
    let result : bits(32) = $[overloaded { "name" = "^", "is_infix" = true }] xor_vec(r1, $[overloaded { "name" = "^", "is_infix" = true }] xor_vec($[overloaded { "name" = "<<<", "is_infix" = true }] rotatel(r1, 9), $[overloaded { "name" = "<<<", "is_infix" = true }] rotatel(r1, 17)));
    $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(rd, sign_extend(sizeof(xlen), result));
    RETIRE_SUCCESS
}
and execute SM3P1((rs1, rd)) = {
    let r1 : bits(32) = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1), 31, 0);
    let result : bits(32) = $[overloaded { "name" = "^", "is_infix" = true }] xor_vec(r1, $[overloaded { "name" = "^", "is_infix" = true }] xor_vec($[overloaded { "name" = "<<<", "is_infix" = true }] rotatel(r1, 15), $[overloaded { "name" = "<<<", "is_infix" = true }] rotatel(r1, 23)));
    $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(rd, sign_extend(sizeof(xlen), result));
    RETIRE_SUCCESS
}
and execute SM4ED((bs, rs2, rs1, rd)) = {
    let shamt : bits(5) = $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(bs, 0b000);
    let sb_in : bits(8) = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits($[overloaded { "name" = ">>", "is_infix" = true }] shift_bits_right($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs2), 31, 0), shamt), 7, 0);
    let x : bits(32) = $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(0x000000, sm4_sbox(sb_in));
    let y : bits(32) = $[overloaded { "name" = "^", "is_infix" = true }] xor_vec(x, $[overloaded { "name" = "^", "is_infix" = true }] xor_vec($[overloaded { "name" = "<<", "is_infix" = true }] shiftl(x, 8), $[overloaded { "name" = "^", "is_infix" = true }] xor_vec($[overloaded { "name" = "<<", "is_infix" = true }] shiftl(x, 2), $[overloaded { "name" = "^", "is_infix" = true }] xor_vec($[overloaded { "name" = "<<", "is_infix" = true }] shiftl(x, 18), $[overloaded { "name" = "^", "is_infix" = true }] xor_vec($[overloaded { "name" = "<<", "is_infix" = true }] shiftl($[overloaded { "name" = "&", "is_infix" = true }] and_vec(x, 0x0000003F), 26), $[overloaded { "name" = "<<", "is_infix" = true }] shiftl($[overloaded { "name" = "&", "is_infix" = true }] and_vec(x, 0x000000C0), 10))))));
    let z : bits(32) = $[overloaded { "name" = "<<<", "is_infix" = true }] rotate_bits_left(y, shamt);
    let result : bits(32) = $[overloaded { "name" = "^", "is_infix" = true }] xor_vec(z, $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1), 31, 0));
    $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(rd, sign_extend(sizeof(xlen), result));
    RETIRE_SUCCESS
}
and execute SM4KS((bs, rs2, rs1, rd)) = {
    let shamt : bits(5) = $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(bs, 0b000);
    let sb_in : bits(8) = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits($[overloaded { "name" = ">>", "is_infix" = true }] shift_bits_right($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs2), 31, 0), shamt), 7, 0);
    let x : bits(32) = $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(0x000000, sm4_sbox(sb_in));
    let y : bits(32) = $[overloaded { "name" = "^", "is_infix" = true }] xor_vec(x, $[overloaded { "name" = "^", "is_infix" = true }] xor_vec($[overloaded { "name" = "<<", "is_infix" = true }] shiftl($[overloaded { "name" = "&", "is_infix" = true }] and_vec(x, 0x00000007), 29), $[overloaded { "name" = "^", "is_infix" = true }] xor_vec($[overloaded { "name" = "<<", "is_infix" = true }] shiftl($[overloaded { "name" = "&", "is_infix" = true }] and_vec(x, 0x000000FE), 7), $[overloaded { "name" = "^", "is_infix" = true }] xor_vec($[overloaded { "name" = "<<", "is_infix" = true }] shiftl($[overloaded { "name" = "&", "is_infix" = true }] and_vec(x, 0x00000001), 23), $[overloaded { "name" = "<<", "is_infix" = true }] shiftl($[overloaded { "name" = "&", "is_infix" = true }] and_vec(x, 0x000000F8), 13)))));
    let z : bits(32) = $[overloaded { "name" = "<<<", "is_infix" = true }] rotate_bits_left(y, shamt);
    let result : bits(32) = $[overloaded { "name" = "^", "is_infix" = true }] xor_vec(z, $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1), 31, 0));
    $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(rd, sign_extend(sizeof(xlen), result));
    RETIRE_SUCCESS
}
and $[split "op"]
execute ZBKB_RTYPE((rs2, rs1, rd, op)) = {
    let rs1_val = $[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1);
    let rs2_val = $[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs2);
    let result : xlenbits = $[complete] match op {
      PACK => $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(rs2_val, $[overloaded { "name" = "-", "is_infix" = true }] sub_atom($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(xlen_bytes, 4), 1), 0), $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(rs1_val, $[overloaded { "name" = "-", "is_infix" = true }] sub_atom($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(xlen_bytes, 4), 1), 0)),
      PACKH => zero_extend(sizeof(xlen), $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(rs2_val, 7, 0), $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(rs1_val, 7, 0)))
    };
    $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(rd, result);
    RETIRE_SUCCESS
}
and execute ZBKB_PACKW((rs2, rs1, rd)) = {
    assert($[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64), "./extensions/K/zbkb_insts.sail:51.19-51.20");
    let rs1_val = $[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1);
    let rs2_val = $[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs2);
    let result : bits(32) = $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(rs2_val, 15, 0), $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(rs1_val, 15, 0));
    $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(rd, sign_extend(sizeof(xlen), result));
    RETIRE_SUCCESS
}
and execute ZIP((rs1, rd)) = {
    assert($[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 32), "./extensions/K/zbkb_insts.sail:70.19-70.20");
    let rs1_val = $[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1);
    var result : xlenbits = zeros(sizeof(xlen));
    foreach (i
    from 0
    to sub_atom($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(xlen_bytes, 4), 1)
    by 1
    in inc) {
        result[$[overloaded { "name" = "*", "is_infix" = true }] mult_atom(i, 2)] = $[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(rs1_val, i);
        result[$[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(i, 2), 1)] = $[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(rs1_val, $[overloaded { "name" = "+", "is_infix" = true }] add_atom(i, $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(xlen_bytes, 4)))
    };
    $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(rd, result);
    RETIRE_SUCCESS
}
and execute UNZIP((rs1, rd)) = {
    assert($[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 32), "./extensions/K/zbkb_insts.sail:92.19-92.20");
    let rs1_val = $[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1);
    var result : xlenbits = zeros(sizeof(xlen));
    foreach (i
    from 0
    to sub_atom($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(xlen_bytes, 4), 1)
    by 1
    in inc) {
        result[i] = $[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(rs1_val, $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(i, 2));
        result[$[overloaded { "name" = "+", "is_infix" = true }] add_atom(i, $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(xlen_bytes, 4))] = $[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(rs1_val, $[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(i, 2), 1))
    };
    $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(rd, result);
    RETIRE_SUCCESS
}
and execute BREV8((rs1, rd)) = {
    $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(rd, brev8($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1)));
    RETIRE_SUCCESS
}
and execute XPERM8((rs2, rs1, rd)) = {
    let rs1_val = $[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1);
    let rs2_val = $[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs2);
    var result : xlenbits = zeros(sizeof(xlen));
    foreach (i from 0 to sub_atom(xlen, 8) by 8 in inc) {
        let index = unsigned($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(rs2_val, $[overloaded { "name" = "+", "is_infix" = true }] add_atom(i, 7), i));
        result[$[overloaded { "name" = "+", "is_infix" = true }] add_atom(i, 7) .. i] = if $[overloaded { "name" = "<", "is_infix" = true }] lt_int($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(8, index), xlen) then
          $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(rs1_val, $[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(8, index), 7), $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(8, index))
        else
          zeros(add_atom(sub_atom(add_atom(mult_atom(8, $[overloaded { "name" = "__size", "is_infix" = false }] __id(index)), 7), mult_atom(8, $[overloaded { "name" = "__size", "is_infix" = false }] __id(index))), 1))
    };
    $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(rd, result);
    RETIRE_SUCCESS
}
and execute XPERM4((rs2, rs1, rd)) = {
    let rs1_val = $[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1);
    let rs2_val = $[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs2);
    var result : xlenbits = zeros(sizeof(xlen));
    foreach (i from 0 to sub_atom(xlen, 4) by 4 in inc) {
        let index = unsigned($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(rs2_val, $[overloaded { "name" = "+", "is_infix" = true }] add_atom(i, 3), i));
        result[$[overloaded { "name" = "+", "is_infix" = true }] add_atom(i, 3) .. i] = if $[overloaded { "name" = "<", "is_infix" = true }] lt_int($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(4, index), xlen) then
          $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(rs1_val, $[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(4, index), 3), $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(4, index))
        else
          zeros(add_atom(sub_atom(add_atom(mult_atom(4, $[overloaded { "name" = "__size", "is_infix" = false }] __id(index)), 3), mult_atom(4, $[overloaded { "name" = "__size", "is_infix" = false }] __id(index))), 1))
    };
    $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(rd, result);
    RETIRE_SUCCESS
}
and execute VANDN_VV((vm, vs1, vs2, vd)) = {
    let SEW = get_sew();
    let LMUL_pow = get_lmul_pow();
    let num_elem = get_num_elem(LMUL_pow, SEW);
    let 'n = num_elem;
    let 'm = SEW;
    let vm_val : bits('n) = read_vmask(num_elem, vm, zvreg);
    let vs1_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);
    let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);
    let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);
    let (initial_result, mask) : (vector('n, bits('m)), bits('n)) = $[complete] match init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val) {
      Ok(v) => v,
      Err(()) => return(Illegal_Instruction())
    };
    var result = initial_result;
    foreach (i from 0 to sub_atom(num_elem, 1) by 1 in inc) {
        if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(mask, i), bitone) then result[i] = $[overloaded { "name" = "&", "is_infix" = true }] and_vec($[overloaded { "name" = "~", "is_infix" = false }] not_vec($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs1_val, i)), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i));
        ()
    };
    write_vreg(num_elem, SEW, LMUL_pow, vd, result);
    set_vstart(zeros(16));
    RETIRE_SUCCESS
}
and execute VANDN_VX((vm, vs2, rs1, vd)) = {
    let SEW = get_sew();
    let LMUL_pow = get_lmul_pow();
    let num_elem = get_num_elem(LMUL_pow, SEW);
    let 'n = num_elem;
    let 'm = SEW;
    let vm_val : bits('n) = read_vmask(num_elem, vm, zvreg);
    let rs1_val : bits('m) = get_scalar(rs1, SEW);
    let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);
    let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);
    let (initial_result, mask) : (vector('n, bits('m)), bits('n)) = $[complete] match init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val) {
      Ok(v) => v,
      Err(()) => return(Illegal_Instruction())
    };
    var result = initial_result;
    foreach (i from 0 to sub_atom(num_elem, 1) by 1 in inc) {
        if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(mask, i), bitone) then result[i] = $[overloaded { "name" = "&", "is_infix" = true }] and_vec($[overloaded { "name" = "~", "is_infix" = false }] not_vec(rs1_val), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i));
        ()
    };
    write_vreg(num_elem, SEW, LMUL_pow, vd, result);
    set_vstart(zeros(16));
    RETIRE_SUCCESS
}
and execute VBREV_V((vm, vs2, vd)) = {
    let SEW = get_sew();
    let LMUL_pow = get_lmul_pow();
    let num_elem = get_num_elem(LMUL_pow, SEW);
    let 'n = num_elem;
    let 'm = SEW;
    let vm_val : bits('n) = read_vmask(num_elem, vm, zvreg);
    let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);
    let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);
    let (initial_result, mask) : (vector('n, bits('m)), bits('n)) = $[complete] match init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val) {
      Ok(v) => v,
      Err(()) => return(Illegal_Instruction())
    };
    var result = initial_result;
    foreach (i from 0 to sub_atom(num_elem, 1) by 1 in inc) {
        if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(mask, i), bitone) then {
            var output : bits('m) = zeros($[overloaded { "name" = "__size", "is_infix" = false }] __id(m));
            foreach (j from 0 to sub_atom(SEW, 1) by 1 in inc) output[$[overloaded { "name" = "-", "is_infix" = true }] sub_atom($[overloaded { "name" = "-", "is_infix" = true }] sub_atom(SEW, 1), j)] = $[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i), j);
            result[i] = output
        };
        ()
    };
    write_vreg(num_elem, SEW, LMUL_pow, vd, result);
    set_vstart(zeros(16));
    RETIRE_SUCCESS
}
and execute VBREV8_V((vm, vs2, vd)) = {
    let SEW = get_sew();
    let LMUL_pow = get_lmul_pow();
    let num_elem = get_num_elem(LMUL_pow, SEW);
    let 'n = num_elem;
    let 'm = SEW;
    let vm_val : bits('n) = read_vmask(num_elem, vm, zvreg);
    let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);
    let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);
    let (initial_result, mask) : (vector('n, bits('m)), bits('n)) = $[complete] match init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val) {
      Ok(v) => v,
      Err(()) => return(Illegal_Instruction())
    };
    var result = initial_result;
    foreach (i from 0 to sub_atom(num_elem, 1) by 1 in inc) {
        if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(mask, i), bitone) then {
            result[i] = brev8($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i))
        };
        ()
    };
    write_vreg(num_elem, SEW, LMUL_pow, vd, result);
    set_vstart(zeros(16));
    RETIRE_SUCCESS
}
and execute VREV8_V((vm, vs2, vd)) = {
    let SEW = get_sew();
    let LMUL_pow = get_lmul_pow();
    let num_elem = get_num_elem(LMUL_pow, SEW);
    let 'n = num_elem;
    let 'm = SEW;
    let vm_val : bits('n) = read_vmask(num_elem, vm, zvreg);
    let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);
    let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);
    let (initial_result, mask) : (vector('n, bits('m)), bits('n)) = $[complete] match init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val) {
      Ok(v) => v,
      Err(()) => return(Illegal_Instruction())
    };
    var result = initial_result;
    foreach (i from 0 to sub_atom(num_elem, 1) by 1 in inc) {
        if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(mask, i), bitone) then {
            result[i] = rev8($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i))
        };
        ()
    };
    write_vreg(num_elem, SEW, LMUL_pow, vd, result);
    set_vstart(zeros(16));
    RETIRE_SUCCESS
}
and execute VCLZ_V((vm, vs2, vd)) = {
    let SEW = get_sew();
    let LMUL_pow = get_lmul_pow();
    let num_elem = get_num_elem(LMUL_pow, SEW);
    let 'n = num_elem;
    let 'm = SEW;
    let vm_val : bits('n) = read_vmask(num_elem, vm, zvreg);
    let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);
    let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);
    let (initial_result, mask) : (vector('n, bits('m)), bits('n)) = $[complete] match init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val) {
      Ok(v) => v,
      Err(()) => return(Illegal_Instruction())
    };
    var result = initial_result;
    foreach (i from 0 to sub_atom(num_elem, 1) by 1 in inc) {
        if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(mask, i), bitone) then {
            let clz = count_leading_zeros($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i));
            result[i] = to_bits($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), clz)
        };
        ()
    };
    write_vreg(num_elem, SEW, LMUL_pow, vd, result);
    set_vstart(zeros(16));
    RETIRE_SUCCESS
}
and execute VCTZ_V((vm, vs2, vd)) = {
    let SEW = get_sew();
    let LMUL_pow = get_lmul_pow();
    let num_elem = get_num_elem(LMUL_pow, SEW);
    let 'n = num_elem;
    let 'm = SEW;
    let vm_val : bits('n) = read_vmask(num_elem, vm, zvreg);
    let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);
    let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);
    let (initial_result, mask) : (vector('n, bits('m)), bits('n)) = $[complete] match init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val) {
      Ok(v) => v,
      Err(()) => return(Illegal_Instruction())
    };
    var result = initial_result;
    foreach (i from 0 to sub_atom(num_elem, 1) by 1 in inc) {
        if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(mask, i), bitone) then {
            let ctz = count_trailing_zeros($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i));
            result[i] = to_bits($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), ctz)
        };
        ()
    };
    write_vreg(num_elem, SEW, LMUL_pow, vd, result);
    set_vstart(zeros(16));
    RETIRE_SUCCESS
}
and execute VCPOP_V((vm, vs2, vd)) = {
    let SEW = get_sew();
    let LMUL_pow = get_lmul_pow();
    let num_elem = get_num_elem(LMUL_pow, SEW);
    let 'n = num_elem;
    let 'm = SEW;
    let vm_val : bits('n) = read_vmask(num_elem, vm, zvreg);
    let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);
    let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);
    let (initial_result, mask) : (vector('n, bits('m)), bits('n)) = $[complete] match init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val) {
      Ok(v) => v,
      Err(()) => return(Illegal_Instruction())
    };
    var result = initial_result;
    foreach (i from 0 to sub_atom(num_elem, 1) by 1 in inc) {
        if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(mask, i), bitone) then {
            foreach (j from 0 to sub_atom(SEW, 1) by 1 in inc) {
                if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i), j), bitone) then {
                    result[i] = $[overloaded { "name" = "+", "is_infix" = true }] add_bits_int($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(result, i), 1)
                };
                ()
            }
        };
        ()
    };
    write_vreg(num_elem, SEW, LMUL_pow, vd, result);
    set_vstart(zeros(16));
    RETIRE_SUCCESS
}
and execute VROL_VV((vm, vs1, vs2, vd)) = {
    let SEW_pow = get_sew_pow();
    let SEW = 2 ^ SEW_pow;
    let LMUL_pow = get_lmul_pow();
    let num_elem = get_num_elem(LMUL_pow, SEW);
    let 'n = num_elem;
    let 'm = SEW;
    let vm_val : bits('n) = read_vmask(num_elem, vm, zvreg);
    let vs1_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);
    let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);
    let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);
    let (initial_result, mask) : (vector('n, bits('m)), bits('n)) = $[complete] match init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val) {
      Ok(v) => v,
      Err(()) => return(Illegal_Instruction())
    };
    var result = initial_result;
    foreach (i from 0 to sub_atom(num_elem, 1) by 1 in inc) {
        if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(mask, i), bitone) then result[i] = $[overloaded { "name" = "<<<", "is_infix" = true }] rotate_bits_left($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i), $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs1_val, i), $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(SEW_pow, 1), 0));
        ()
    };
    write_vreg(num_elem, SEW, LMUL_pow, vd, result);
    set_vstart(zeros(16));
    RETIRE_SUCCESS
}
and execute VROL_VX((vm, vs2, rs1, vd)) = {
    let SEW_pow = get_sew_pow();
    let SEW = 2 ^ SEW_pow;
    let LMUL_pow = get_lmul_pow();
    let num_elem = get_num_elem(LMUL_pow, SEW);
    let 'n = num_elem;
    let 'm = SEW;
    let vm_val : bits('n) = read_vmask(num_elem, vm, zvreg);
    let rs1_val : bits('m) = get_scalar(rs1, SEW);
    let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);
    let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);
    let (initial_result, mask) : (vector('n, bits('m)), bits('n)) = $[complete] match init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val) {
      Ok(v) => v,
      Err(()) => return(Illegal_Instruction())
    };
    var result = initial_result;
    foreach (i from 0 to sub_atom(num_elem, 1) by 1 in inc) {
        if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(mask, i), bitone) then result[i] = $[overloaded { "name" = "<<<", "is_infix" = true }] rotate_bits_left($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i), $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(rs1_val, $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(SEW_pow, 1), 0));
        ()
    };
    write_vreg(num_elem, SEW, LMUL_pow, vd, result);
    set_vstart(zeros(16));
    RETIRE_SUCCESS
}
and execute VROR_VV((vm, vs1, vs2, vd)) = {
    let SEW_pow = get_sew_pow();
    let SEW = 2 ^ SEW_pow;
    let LMUL_pow = get_lmul_pow();
    let num_elem = get_num_elem(LMUL_pow, SEW);
    let 'n = num_elem;
    let 'm = SEW;
    let vm_val : bits('n) = read_vmask(num_elem, vm, zvreg);
    let vs1_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);
    let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);
    let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);
    let (initial_result, mask) : (vector('n, bits('m)), bits('n)) = $[complete] match init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val) {
      Ok(v) => v,
      Err(()) => return(Illegal_Instruction())
    };
    var result = initial_result;
    foreach (i from 0 to sub_atom(num_elem, 1) by 1 in inc) {
        if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(mask, i), bitone) then result[i] = $[overloaded { "name" = ">>>", "is_infix" = true }] rotate_bits_right($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i), $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs1_val, i), $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(SEW_pow, 1), 0));
        ()
    };
    write_vreg(num_elem, SEW, LMUL_pow, vd, result);
    set_vstart(zeros(16));
    RETIRE_SUCCESS
}
and execute VROR_VX((vm, vs2, rs1, vd)) = {
    let SEW_pow = get_sew_pow();
    let SEW = 2 ^ SEW_pow;
    let LMUL_pow = get_lmul_pow();
    let num_elem = get_num_elem(LMUL_pow, SEW);
    let 'n = num_elem;
    let 'm = SEW;
    let vm_val : bits('n) = read_vmask(num_elem, vm, zvreg);
    let rs1_val : bits('m) = get_scalar(rs1, SEW);
    let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);
    let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);
    let (initial_result, mask) : (vector('n, bits('m)), bits('n)) = $[complete] match init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val) {
      Ok(v) => v,
      Err(()) => return(Illegal_Instruction())
    };
    var result = initial_result;
    foreach (i from 0 to sub_atom(num_elem, 1) by 1 in inc) {
        if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(mask, i), bitone) then result[i] = $[overloaded { "name" = ">>>", "is_infix" = true }] rotate_bits_right($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i), $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(rs1_val, $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(SEW_pow, 1), 0));
        ()
    };
    write_vreg(num_elem, SEW, LMUL_pow, vd, result);
    set_vstart(zeros(16));
    RETIRE_SUCCESS
}
and execute VROR_VI((vm, vs2, uimm, vd)) = {
    let SEW_pow = get_sew_pow();
    let SEW = 2 ^ SEW_pow;
    let LMUL_pow = get_lmul_pow();
    let num_elem = get_num_elem(LMUL_pow, SEW);
    let 'n = num_elem;
    let 'm = SEW;
    let vm_val : bits('n) = read_vmask(num_elem, vm, zvreg);
    let uimm_val : bits('m) = zero_extend($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), uimm);
    let vs2_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);
    let vd_val : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);
    let (initial_result, mask) : (vector('n, bits('m)), bits('n)) = $[complete] match init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val) {
      Ok(v) => v,
      Err(()) => return(Illegal_Instruction())
    };
    var result = initial_result;
    foreach (i from 0 to sub_atom(num_elem, 1) by 1 in inc) {
        if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(mask, i), bitone) then result[i] = $[overloaded { "name" = ">>>", "is_infix" = true }] rotate_bits_right($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i), $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(uimm_val, $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(SEW_pow, 1), 0));
        ()
    };
    write_vreg(num_elem, SEW, LMUL_pow, vd, result);
    set_vstart(zeros(16));
    RETIRE_SUCCESS
}
and execute VWSLL_VV((vm, vs2, vs1, vd)) = {
    let SEW = get_sew();
    let LMUL_pow = get_lmul_pow();
    let num_elem = get_num_elem(LMUL_pow, SEW);
    let SEW_widen = $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(SEW, 2);
    let LMUL_pow_widen = $[overloaded { "name" = "+", "is_infix" = true }] add_atom(LMUL_pow, 1);
    if $[overloaded { "name" = "|", "is_infix" = true }] or_bool(illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen), $[overloaded { "name" = "|", "is_infix" = true }] or_bool(not(valid_reg_overlap(vs1, vd, LMUL_pow, LMUL_pow_widen)), not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen)))) then return(Illegal_Instruction());
    assert($[overloaded { "name" = "<=", "is_infix" = true }] lteq_int(SEW_widen, 64), "./extensions/vector_crypto/zvbb_insts.sail:528.24-528.25");
    let 'n = num_elem;
    let 'm = SEW;
    let 'o = SEW_widen;
    let vm_val : bits('n) = read_vmask(num_elem, vm, zvreg);
    let vs1_val_vec : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);
    let vs2_val_vec : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);
    let vd_val : vector('n, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd);
    let SEW_widen_bits = to_bits_unsafe(SEW_widen, $[overloaded { "name" = "__size", "is_infix" = false }] __id(o));
    let (initial_result, mask) : (vector('n, bits('o)), bits('n)) = $[complete] match init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val) {
      Ok(v) => v,
      Err(()) => return(Illegal_Instruction())
    };
    var result = initial_result;
    foreach (i from 0 to sub_atom(num_elem, 1) by 1 in inc) {
        if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(mask, i), bitone) then {
            let vs1_val : bits('o) = zero_extend($[overloaded { "name" = "__size", "is_infix" = false }] __id(o), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs1_val_vec, i));
            let vs2_val : bits('o) = zero_extend($[overloaded { "name" = "__size", "is_infix" = false }] __id(o), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val_vec, i));
            result[i] = $[overloaded { "name" = "<<", "is_infix" = true }] shift_bits_left(vs2_val, $[overloaded { "name" = "&", "is_infix" = true }] and_vec(vs1_val, zero_extend($[overloaded { "name" = "__size", "is_infix" = false }] __id(o), $[overloaded { "name" = "-", "is_infix" = true }] sub_vec_int(SEW_widen_bits, 1))))
        };
        ()
    };
    write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result);
    set_vstart(zeros(16));
    RETIRE_SUCCESS
}
and execute VWSLL_VX((vm, vs2, rs1, vd)) = {
    let SEW = get_sew();
    let LMUL_pow = get_lmul_pow();
    let num_elem = get_num_elem(LMUL_pow, SEW);
    let SEW_widen = $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(SEW, 2);
    let LMUL_pow_widen = $[overloaded { "name" = "+", "is_infix" = true }] add_atom(LMUL_pow, 1);
    if $[overloaded { "name" = "|", "is_infix" = true }] or_bool(illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen), not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))) then return(Illegal_Instruction());
    assert($[overloaded { "name" = "<=", "is_infix" = true }] lteq_int(SEW_widen, 64), "./extensions/vector_crypto/zvbb_insts.sail:578.24-578.25");
    let 'n = num_elem;
    let 'm = SEW;
    let 'o = SEW_widen;
    let vm_val : bits('n) = read_vmask(num_elem, vm, zvreg);
    let rs1_val : bits('o) = zero_extend($[overloaded { "name" = "__size", "is_infix" = false }] __id(o), get_scalar(rs1, SEW));
    let vs2_val_vec : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);
    let vd_val : vector('n, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd);
    let SEW_widen_bits = to_bits_unsafe(SEW_widen, $[overloaded { "name" = "__size", "is_infix" = false }] __id(o));
    let (initial_result, mask) : (vector('n, bits('o)), bits('n)) = $[complete] match init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val) {
      Ok(v) => v,
      Err(()) => return(Illegal_Instruction())
    };
    var result = initial_result;
    foreach (i from 0 to sub_atom(num_elem, 1) by 1 in inc) {
        if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(mask, i), bitone) then {
            let vs2_val : bits('o) = zero_extend($[overloaded { "name" = "__size", "is_infix" = false }] __id(o), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val_vec, i));
            result[i] = $[overloaded { "name" = "<<", "is_infix" = true }] shift_bits_left(vs2_val, $[overloaded { "name" = "&", "is_infix" = true }] and_vec(rs1_val, zero_extend($[overloaded { "name" = "__size", "is_infix" = false }] __id(o), $[overloaded { "name" = "-", "is_infix" = true }] sub_vec_int(SEW_widen_bits, 1))))
        };
        ()
    };
    write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result);
    set_vstart(zeros(16));
    RETIRE_SUCCESS
}
and execute VWSLL_VI((vm, vs2, uimm, vd)) = {
    let SEW = get_sew();
    let LMUL_pow = get_lmul_pow();
    let num_elem = get_num_elem(LMUL_pow, SEW);
    let SEW_widen = $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(SEW, 2);
    let LMUL_pow_widen = $[overloaded { "name" = "+", "is_infix" = true }] add_atom(LMUL_pow, 1);
    if $[overloaded { "name" = "|", "is_infix" = true }] or_bool(illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen), not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))) then return(Illegal_Instruction());
    assert($[overloaded { "name" = "<=", "is_infix" = true }] lteq_int(SEW_widen, 64), "./extensions/vector_crypto/zvbb_insts.sail:627.24-627.25");
    let 'n = num_elem;
    let 'm = SEW;
    let 'o = SEW_widen;
    let vm_val : bits('n) = read_vmask(num_elem, vm, zvreg);
    let uimm_val : bits('o) = zero_extend($[overloaded { "name" = "__size", "is_infix" = false }] __id(o), uimm);
    let vs2_val_vec : vector('n, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);
    let vd_val : vector('n, bits('o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd);
    let SEW_widen_bits = to_bits_unsafe(SEW_widen, $[overloaded { "name" = "__size", "is_infix" = false }] __id(o));
    let (initial_result, mask) : (vector('n, bits('o)), bits('n)) = $[complete] match init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val) {
      Ok(v) => v,
      Err(()) => return(Illegal_Instruction())
    };
    var result = initial_result;
    foreach (i from 0 to sub_atom(num_elem, 1) by 1 in inc) {
        if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(mask, i), bitone) then {
            let vs2_val : bits('o) = zero_extend($[overloaded { "name" = "__size", "is_infix" = false }] __id(o), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val_vec, i));
            result[i] = $[overloaded { "name" = "<<", "is_infix" = true }] shift_bits_left(vs2_val, $[overloaded { "name" = "&", "is_infix" = true }] and_vec(uimm_val, zero_extend($[overloaded { "name" = "__size", "is_infix" = false }] __id(o), $[overloaded { "name" = "-", "is_infix" = true }] sub_vec_int(SEW_widen_bits, 1))))
        };
        ()
    };
    write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result);
    set_vstart(zeros(16));
    RETIRE_SUCCESS
}
and execute VCLMUL_VV((vm, vs2, vs1, vd)) = {
    let SEW = get_sew();
    let LMUL_pow = get_lmul_pow();
    let 'n = get_num_elem(LMUL_pow, SEW);
    let 'm = SEW;
    let vm_val : bits('n) = read_vmask($[overloaded { "name" = "__size", "is_infix" = false }] __id(n), vm, zvreg);
    let vd_val : vector('n, bits('m)) = read_vreg($[overloaded { "name" = "__size", "is_infix" = false }] __id(n), SEW, LMUL_pow, vd);
    let vs1_val : vector('n, bits('m)) = read_vreg($[overloaded { "name" = "__size", "is_infix" = false }] __id(n), SEW, LMUL_pow, vs1);
    let vs2_val : vector('n, bits('m)) = read_vreg($[overloaded { "name" = "__size", "is_infix" = false }] __id(n), SEW, LMUL_pow, vs2);
    let (initial_result, mask) : (vector('n, bits('m)), bits('n)) = $[complete] match init_masked_result($[overloaded { "name" = "__size", "is_infix" = false }] __id(n), SEW, LMUL_pow, vd_val, vm_val) {
      Ok(v) => v,
      Err(()) => return(Illegal_Instruction())
    };
    var result = initial_result;
    foreach (i
    from 0
    to sub_atom($[overloaded { "name" = "__size", "is_infix" = false }] __id(n), 1)
    by 1
    in inc) {
        if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(mask, i), bitone) then {
            let prod = carryless_mul($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs1_val, i), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i));
            result[i] = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(prod, $[overloaded { "name" = "-", "is_infix" = true }] sub_atom($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), 1), 0)
        };
        ()
    };
    write_vreg($[overloaded { "name" = "__size", "is_infix" = false }] __id(n), SEW, LMUL_pow, vd, result);
    set_vstart(zeros(16));
    RETIRE_SUCCESS
}
and execute VCLMUL_VX((vm, vs2, rs1, vd)) = {
    let SEW = get_sew();
    let LMUL_pow = get_lmul_pow();
    let 'n = get_num_elem(LMUL_pow, SEW);
    let 'm = SEW;
    let vm_val : bits('n) = read_vmask($[overloaded { "name" = "__size", "is_infix" = false }] __id(n), vm, zvreg);
    let vd_val : vector('n, bits('m)) = read_vreg($[overloaded { "name" = "__size", "is_infix" = false }] __id(n), SEW, LMUL_pow, vd);
    let rs1_val : bits('m) = get_scalar(rs1, SEW);
    let vs2_val : vector('n, bits('m)) = read_vreg($[overloaded { "name" = "__size", "is_infix" = false }] __id(n), SEW, LMUL_pow, vs2);
    let (initial_result, mask) : (vector('n, bits('m)), bits('n)) = $[complete] match init_masked_result($[overloaded { "name" = "__size", "is_infix" = false }] __id(n), SEW, LMUL_pow, vd_val, vm_val) {
      Ok(v) => v,
      Err(()) => return(Illegal_Instruction())
    };
    var result = initial_result;
    foreach (i
    from 0
    to sub_atom($[overloaded { "name" = "__size", "is_infix" = false }] __id(n), 1)
    by 1
    in inc) {
        if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(mask, i), bitone) then {
            let prod = carryless_mul(rs1_val, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i));
            result[i] = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(prod, $[overloaded { "name" = "-", "is_infix" = true }] sub_atom($[overloaded { "name" = "__size", "is_infix" = false }] __id(m), 1), 0)
        };
        ()
    };
    write_vreg($[overloaded { "name" = "__size", "is_infix" = false }] __id(n), SEW, LMUL_pow, vd, result);
    set_vstart(zeros(16));
    RETIRE_SUCCESS
}
and execute VCLMULH_VV((vm, vs2, vs1, vd)) = {
    let SEW = get_sew();
    let LMUL_pow = get_lmul_pow();
    let 'n = get_num_elem(LMUL_pow, SEW);
    let 'm = SEW;
    let vm_val : bits('n) = read_vmask($[overloaded { "name" = "__size", "is_infix" = false }] __id(n), vm, zvreg);
    let vd_val : vector('n, bits('m)) = read_vreg($[overloaded { "name" = "__size", "is_infix" = false }] __id(n), SEW, LMUL_pow, vd);
    let vs1_val : vector('n, bits('m)) = read_vreg($[overloaded { "name" = "__size", "is_infix" = false }] __id(n), SEW, LMUL_pow, vs1);
    let vs2_val : vector('n, bits('m)) = read_vreg($[overloaded { "name" = "__size", "is_infix" = false }] __id(n), SEW, LMUL_pow, vs2);
    let (initial_result, mask) : (vector('n, bits('m)), bits('n)) = $[complete] match init_masked_result($[overloaded { "name" = "__size", "is_infix" = false }] __id(n), SEW, LMUL_pow, vd_val, vm_val) {
      Ok(v) => v,
      Err(()) => return(Illegal_Instruction())
    };
    var result = initial_result;
    foreach (i
    from 0
    to sub_atom($[overloaded { "name" = "__size", "is_infix" = false }] __id(n), 1)
    by 1
    in inc) {
        if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(mask, i), bitone) then {
            let prod = carryless_mul($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs1_val, i), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i));
            result[i] = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(prod, $[overloaded { "name" = "-", "is_infix" = true }] sub_atom($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(2, SEW), 1), SEW)
        };
        ()
    };
    write_vreg($[overloaded { "name" = "__size", "is_infix" = false }] __id(n), SEW, LMUL_pow, vd, result);
    set_vstart(zeros(16));
    RETIRE_SUCCESS
}
and execute VCLMULH_VX((vm, vs2, rs1, vd)) = {
    let SEW = get_sew();
    let LMUL_pow = get_lmul_pow();
    let 'n = get_num_elem(LMUL_pow, SEW);
    let 'm = SEW;
    let vm_val : bits('n) = read_vmask($[overloaded { "name" = "__size", "is_infix" = false }] __id(n), vm, zvreg);
    let vd_val : vector('n, bits('m)) = read_vreg($[overloaded { "name" = "__size", "is_infix" = false }] __id(n), SEW, LMUL_pow, vd);
    let rs1_val : bits('m) = get_scalar(rs1, SEW);
    let vs2_val : vector('n, bits('m)) = read_vreg($[overloaded { "name" = "__size", "is_infix" = false }] __id(n), SEW, LMUL_pow, vs2);
    let (initial_result, mask) : (vector('n, bits('m)), bits('n)) = $[complete] match init_masked_result($[overloaded { "name" = "__size", "is_infix" = false }] __id(n), SEW, LMUL_pow, vd_val, vm_val) {
      Ok(v) => v,
      Err(()) => return(Illegal_Instruction())
    };
    var result = initial_result;
    foreach (i
    from 0
    to sub_atom($[overloaded { "name" = "__size", "is_infix" = false }] __id(n), 1)
    by 1
    in inc) {
        if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(mask, i), bitone) then {
            let prod = carryless_mul(rs1_val, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, i));
            result[i] = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(prod, $[overloaded { "name" = "-", "is_infix" = true }] sub_atom($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(2, SEW), 1), SEW)
        };
        ()
    };
    write_vreg($[overloaded { "name" = "__size", "is_infix" = false }] __id(n), SEW, LMUL_pow, vd, result);
    set_vstart(zeros(16));
    RETIRE_SUCCESS
}
and execute VGHSH_VV((vs2, vs1, vd)) = {
    let SEW = get_sew();
    let LMUL_pow = get_lmul_pow();
    let num_elem = get_num_elem(LMUL_pow, SEW);
    assert($[overloaded { "name" = "==", "is_infix" = true }] eq_int(SEW, 32), "./extensions/vector_crypto/zvkg_insts.sail:22.18-22.19");
    let vs2_val = read_vreg(num_elem, SEW, LMUL_pow, vs2);
    let vs1_val = read_vreg(num_elem, SEW, LMUL_pow, vs1);
    let vd_val = read_vreg(num_elem, SEW, LMUL_pow, vd);
    let eg_len = $[overloaded { "name" = "/", "is_infix" = true }] quot_positive_round_zero(unsigned(vl), 4);
    let eg_start = $[overloaded { "name" = "/", "is_infix" = true }] quot_positive_round_zero(unsigned(vstart), 4);
    foreach (i from eg_start to sub_atom(eg_len, 1) by 1 in inc) {
        assert($[overloaded { "name" = "<", "is_infix" = true }] lt_int($[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(i, 4), 3), num_elem), "./extensions/vector_crypto/zvkg_insts.sail:32.31-32.32");
        let Y : bits(128) = get_velem_quad(vd_val, i);
        let X : bits(128) = get_velem_quad(vs1_val, i);
        var H : bits(128) = brev8(get_velem_quad(vs2_val, i));
        var Z : bits(128) = zeros(128);
        let S : bits(128) = brev8($[overloaded { "name" = "^", "is_infix" = true }] xor_vec(Y, X));
        foreach (b from 0 to 127 by 1 in inc) {
            if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(S, b), bitone) then Z = $[overloaded { "name" = "^", "is_infix" = true }] xor_vec(Z, H);
            let reduce = $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(H, 127), bitone);
            H = $[overloaded { "name" = "<<", "is_infix" = true }] shiftl(H, 1);
            if reduce then H = $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(H, 127, 8), $[overloaded { "name" = "^", "is_infix" = true }] xor_vec($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(H, 7, 0), 0x87));
            ()
        };
        write_velem_quad(vd, SEW, brev8(Z), i)
    };
    set_vstart(zeros(16));
    RETIRE_SUCCESS
}
and execute VGMUL_VV((vs2, vd)) = {
    let SEW = get_sew();
    let LMUL_pow = get_lmul_pow();
    let num_elem = get_num_elem(LMUL_pow, SEW);
    assert($[overloaded { "name" = "==", "is_infix" = true }] eq_int(SEW, 32), "./extensions/vector_crypto/zvkg_insts.sail:70.18-70.19");
    let vs2_val = read_vreg(num_elem, SEW, LMUL_pow, vs2);
    let vd_val = read_vreg(num_elem, SEW, LMUL_pow, vd);
    let eg_len = $[overloaded { "name" = "/", "is_infix" = true }] quot_positive_round_zero(unsigned(vl), 4);
    let eg_start = $[overloaded { "name" = "/", "is_infix" = true }] quot_positive_round_zero(unsigned(vstart), 4);
    foreach (i from eg_start to sub_atom(eg_len, 1) by 1 in inc) {
        assert($[overloaded { "name" = "<", "is_infix" = true }] lt_int($[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(i, 4), 3), num_elem), "./extensions/vector_crypto/zvkg_insts.sail:79.31-79.32");
        let Y : bits(128) = brev8(get_velem_quad(vd_val, i));
        var H : bits(128) = brev8(get_velem_quad(vs2_val, i));
        var Z : bits(128) = zeros(128);
        foreach (b from 0 to 127 by 1 in inc) {
            if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(Y, b), bitone) then Z = $[overloaded { "name" = "^", "is_infix" = true }] xor_vec(Z, H);
            let reduce = $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(H, 127), bitone);
            H = $[overloaded { "name" = "<<", "is_infix" = true }] shiftl(H, 1);
            if reduce then H = $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(H, 127, 8), $[overloaded { "name" = "^", "is_infix" = true }] xor_vec($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(H, 7, 0), 0x87));
            ()
        };
        write_velem_quad(vd, SEW, brev8(Z), i)
    };
    set_vstart(zeros(16));
    RETIRE_SUCCESS
}
and execute VAESDF((funct6, vs2, vd)) = {
    let SEW = get_sew();
    let LMUL_pow = get_lmul_pow();
    let num_elem = get_num_elem(LMUL_pow, SEW);
    assert($[overloaded { "name" = "==", "is_infix" = true }] eq_int(SEW, 32), "./extensions/vector_crypto/zvkned_insts.sail:28.18-28.19");
    let vs2_val = read_vreg(num_elem, SEW, LMUL_pow, vs2);
    let vd_val = read_vreg(num_elem, SEW, LMUL_pow, vd);
    let eg_len = $[overloaded { "name" = "/", "is_infix" = true }] quot_positive_round_zero(unsigned(vl), 4);
    let eg_start = $[overloaded { "name" = "/", "is_infix" = true }] quot_positive_round_zero(unsigned(vstart), 4);
    foreach (i from eg_start to sub_atom(eg_len, 1) by 1 in inc) {
        assert($[overloaded { "name" = "<", "is_infix" = true }] lt_int($[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(i, 4), 3), num_elem), "./extensions/vector_crypto/zvkned_insts.sail:37.31-37.32");
        let state = get_velem_quad(vd_val, i);
        let rkey : bits(128) = $[complete] match funct6 {
          ZVK_VAESDF_VV => get_velem_quad(vs2_val, i),
          ZVK_VAESDF_VS => get_velem_quad(vs2_val, 0)
        };
        let sr = aes_shift_rows_inv(state);
        let sb = aes_subbytes_inv(sr);
        let ark = $[overloaded { "name" = "^", "is_infix" = true }] xor_vec(sb, rkey);
        write_velem_quad(vd, SEW, ark, i)
    };
    set_vstart(zeros(16));
    RETIRE_SUCCESS
}
and execute VAESDM((funct6, vs2, vd)) = {
    let SEW = get_sew();
    let LMUL_pow = get_lmul_pow();
    let num_elem = get_num_elem(LMUL_pow, SEW);
    assert($[overloaded { "name" = "==", "is_infix" = true }] eq_int(SEW, 32), "./extensions/vector_crypto/zvkned_insts.sail:80.18-80.19");
    let vs2_val = read_vreg(num_elem, SEW, LMUL_pow, vs2);
    let vd_val = read_vreg(num_elem, SEW, LMUL_pow, vd);
    let eg_len = $[overloaded { "name" = "/", "is_infix" = true }] quot_positive_round_zero(unsigned(vl), 4);
    let eg_start = $[overloaded { "name" = "/", "is_infix" = true }] quot_positive_round_zero(unsigned(vstart), 4);
    foreach (i from eg_start to sub_atom(eg_len, 1) by 1 in inc) {
        assert($[overloaded { "name" = "<", "is_infix" = true }] lt_int($[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(i, 4), 3), num_elem), "./extensions/vector_crypto/zvkned_insts.sail:89.31-89.32");
        let state = get_velem_quad(vd_val, i);
        let rkey : bits(128) = $[complete] match funct6 {
          ZVK_VAESDM_VV => get_velem_quad(vs2_val, i),
          ZVK_VAESDM_VS => get_velem_quad(vs2_val, 0)
        };
        let sr = aes_shift_rows_inv(state);
        let sb = aes_subbytes_inv(sr);
        let ark = $[overloaded { "name" = "^", "is_infix" = true }] xor_vec(sb, rkey);
        let mix = aes_mixcolumns_inv(ark);
        write_velem_quad(vd, SEW, mix, i)
    };
    set_vstart(zeros(16));
    RETIRE_SUCCESS
}
and execute VAESEF((funct6, vs2, vd)) = {
    let SEW = get_sew();
    let LMUL_pow = get_lmul_pow();
    let num_elem = get_num_elem(LMUL_pow, SEW);
    assert($[overloaded { "name" = "==", "is_infix" = true }] eq_int(SEW, 32), "./extensions/vector_crypto/zvkned_insts.sail:133.18-133.19");
    let vs2_val = read_vreg(num_elem, SEW, LMUL_pow, vs2);
    let vd_val = read_vreg(num_elem, SEW, LMUL_pow, vd);
    let eg_len = $[overloaded { "name" = "/", "is_infix" = true }] quot_positive_round_zero(unsigned(vl), 4);
    let eg_start = $[overloaded { "name" = "/", "is_infix" = true }] quot_positive_round_zero(unsigned(vstart), 4);
    foreach (i from eg_start to sub_atom(eg_len, 1) by 1 in inc) {
        assert($[overloaded { "name" = "<", "is_infix" = true }] lt_int($[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(i, 4), 3), num_elem), "./extensions/vector_crypto/zvkned_insts.sail:142.31-142.32");
        let state = get_velem_quad(vd_val, i);
        let rkey : bits(128) = $[complete] match funct6 {
          ZVK_VAESEF_VV => get_velem_quad(vs2_val, i),
          ZVK_VAESEF_VS => get_velem_quad(vs2_val, 0)
        };
        let sb = aes_subbytes_fwd(state);
        let sr = aes_shift_rows_fwd(sb);
        let ark = $[overloaded { "name" = "^", "is_infix" = true }] xor_vec(sr, rkey);
        write_velem_quad(vd, SEW, ark, i)
    };
    set_vstart(zeros(16));
    RETIRE_SUCCESS
}
and execute VAESEM((funct6, vs2, vd)) = {
    let SEW = get_sew();
    let LMUL_pow = get_lmul_pow();
    let num_elem = get_num_elem(LMUL_pow, SEW);
    assert($[overloaded { "name" = "==", "is_infix" = true }] eq_int(SEW, 32), "./extensions/vector_crypto/zvkned_insts.sail:185.18-185.19");
    let vs2_val = read_vreg(num_elem, SEW, LMUL_pow, vs2);
    let vd_val = read_vreg(num_elem, SEW, LMUL_pow, vd);
    let eg_len = $[overloaded { "name" = "/", "is_infix" = true }] quot_positive_round_zero(unsigned(vl), 4);
    let eg_start = $[overloaded { "name" = "/", "is_infix" = true }] quot_positive_round_zero(unsigned(vstart), 4);
    foreach (i from eg_start to sub_atom(eg_len, 1) by 1 in inc) {
        assert($[overloaded { "name" = "<", "is_infix" = true }] lt_int($[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(i, 4), 3), num_elem), "./extensions/vector_crypto/zvkned_insts.sail:194.31-194.32");
        let state = get_velem_quad(vd_val, i);
        let rkey : bits(128) = $[complete] match funct6 {
          ZVK_VAESEM_VV => get_velem_quad(vs2_val, i),
          ZVK_VAESEM_VS => get_velem_quad(vs2_val, 0)
        };
        let sb = aes_subbytes_fwd(state);
        let sr = aes_shift_rows_fwd(sb);
        let mix = aes_mixcolumns_fwd(sr);
        let ark = $[overloaded { "name" = "^", "is_infix" = true }] xor_vec(mix, rkey);
        write_velem_quad(vd, SEW, ark, i)
    };
    set_vstart(zeros(16));
    RETIRE_SUCCESS
}
and execute VAESKF1_VI((vs2, rnd, vd)) = {
    let SEW = get_sew();
    let LMUL_pow = get_lmul_pow();
    let num_elem = get_num_elem(LMUL_pow, SEW);
    assert($[overloaded { "name" = "==", "is_infix" = true }] eq_int(SEW, 32), "./extensions/vector_crypto/zvkned_insts.sail:232.18-232.19");
    let vs2_val = read_vreg(num_elem, SEW, LMUL_pow, vs2);
    let vd_val = read_vreg(num_elem, SEW, LMUL_pow, vd);
    var rnd_val : bits(5) = rnd;
    if $[overloaded { "name" = "|", "is_infix" = true }] or_bool($[overloaded { "name" = ">", "is_infix" = true }] gt_int(unsigned($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(rnd_val, 3, 0)), 10), eq_int(unsigned($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(rnd_val, 3, 0)), 0) : bool) then rnd_val[3] = not_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(rnd_val, 3));
    let r : bits(4) = $[overloaded { "name" = "-", "is_infix" = true }] sub_vec_int($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(rnd_val, 3, 0), 1);
    var w : vector(4, bits(32)) = vector_init(4, zeros(32));
    let eg_len = $[overloaded { "name" = "/", "is_infix" = true }] quot_positive_round_zero(unsigned(vl), 4);
    let eg_start = $[overloaded { "name" = "/", "is_infix" = true }] quot_positive_round_zero(unsigned(vstart), 4);
    foreach (i from eg_start to sub_atom(eg_len, 1) by 1 in inc) {
        assert($[overloaded { "name" = "<", "is_infix" = true }] lt_int($[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(i, 4), 3), num_elem), "./extensions/vector_crypto/zvkned_insts.sail:250.31-250.32");
        let current_round_key = get_velem_quad_vec(vs2_val, i);
        w[0] = $[overloaded { "name" = "^", "is_infix" = true }] xor_vec(aes_subword_fwd($[overloaded { "name" = ">>>", "is_infix" = true }] rotater($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(current_round_key, 3), 8)), $[overloaded { "name" = "^", "is_infix" = true }] xor_vec(aes_decode_rcon(r), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(current_round_key, 0)));
        w[1] = $[overloaded { "name" = "^", "is_infix" = true }] xor_vec($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(w, 0), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(current_round_key, 1));
        w[2] = $[overloaded { "name" = "^", "is_infix" = true }] xor_vec($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(w, 1), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(current_round_key, 2));
        w[3] = $[overloaded { "name" = "^", "is_infix" = true }] xor_vec($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(w, 2), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(current_round_key, 3));
        write_velem_quad_vec(vd, SEW, w, i)
    };
    set_vstart(zeros(16));
    RETIRE_SUCCESS
}
and execute VAESKF2_VI((vs2, rnd, vd)) = {
    let SEW = get_sew();
    let LMUL_pow = get_lmul_pow();
    let num_elem = get_num_elem(LMUL_pow, SEW);
    assert($[overloaded { "name" = "==", "is_infix" = true }] eq_int(SEW, 32), "./extensions/vector_crypto/zvkned_insts.sail:281.18-281.19");
    let vs2_val = read_vreg(num_elem, SEW, LMUL_pow, vs2);
    let vd_val = read_vreg(num_elem, SEW, LMUL_pow, vd);
    var rnd_val : bits(4) = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(rnd, 3, 0);
    if $[overloaded { "name" = "|", "is_infix" = true }] or_bool($[overloaded { "name" = "<", "is_infix" = true }] lt_int(unsigned(rnd_val), 2), gt_int(unsigned(rnd_val), 14) : bool) then rnd_val[3] = not_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(rnd_val, 3));
    var w : vector(4, bits(32)) = vector_init(4, zeros(32));
    let eg_len = $[overloaded { "name" = "/", "is_infix" = true }] quot_positive_round_zero(unsigned(vl), 4);
    let eg_start = $[overloaded { "name" = "/", "is_infix" = true }] quot_positive_round_zero(unsigned(vstart), 4);
    foreach (i from eg_start to sub_atom(eg_len, 1) by 1 in inc) {
        assert($[overloaded { "name" = "<", "is_infix" = true }] lt_int($[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(i, 4), 3), num_elem), "./extensions/vector_crypto/zvkned_insts.sail:297.31-297.32");
        let current_round_key = get_velem_quad_vec(vs2_val, i);
        let round_key_b = get_velem_quad_vec(vd_val, i);
        w[0] = if $[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(rnd_val, 0), bitone) then
          $[overloaded { "name" = "^", "is_infix" = true }] xor_vec(aes_subword_fwd($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(current_round_key, 3)), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(round_key_b, 0))
        else
          $[overloaded { "name" = "^", "is_infix" = true }] xor_vec(aes_subword_fwd($[overloaded { "name" = ">>>", "is_infix" = true }] rotater($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(current_round_key, 3), 8)), $[overloaded { "name" = "^", "is_infix" = true }] xor_vec(aes_decode_rcon($[overloaded { "name" = "-", "is_infix" = true }] sub_vec_int($[overloaded { "name" = ">>", "is_infix" = true }] shiftr(rnd_val, 1), 1)), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(round_key_b, 0)));
        w[1] = $[overloaded { "name" = "^", "is_infix" = true }] xor_vec($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(w, 0), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(round_key_b, 1));
        w[2] = $[overloaded { "name" = "^", "is_infix" = true }] xor_vec($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(w, 1), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(round_key_b, 2));
        w[3] = $[overloaded { "name" = "^", "is_infix" = true }] xor_vec($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(w, 2), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(round_key_b, 3));
        write_velem_quad_vec(vd, SEW, w, i)
    };
    set_vstart(zeros(16));
    RETIRE_SUCCESS
}
and execute VAESZ_VS((vs2, vd)) = {
    let SEW = get_sew();
    let LMUL_pow = get_lmul_pow();
    let num_elem = get_num_elem(LMUL_pow, SEW);
    assert($[overloaded { "name" = "==", "is_infix" = true }] eq_int(SEW, 32), "./extensions/vector_crypto/zvkned_insts.sail:331.18-331.19");
    let vs2_val = read_vreg(num_elem, SEW, LMUL_pow, vs2);
    let vd_val = read_vreg(num_elem, SEW, LMUL_pow, vd);
    let eg_len = $[overloaded { "name" = "/", "is_infix" = true }] quot_positive_round_zero(unsigned(vl), 4);
    let eg_start = $[overloaded { "name" = "/", "is_infix" = true }] quot_positive_round_zero(unsigned(vstart), 4);
    foreach (i from eg_start to sub_atom(eg_len, 1) by 1 in inc) {
        assert($[overloaded { "name" = "<", "is_infix" = true }] lt_int($[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(i, 4), 3), num_elem), "./extensions/vector_crypto/zvkned_insts.sail:340.31-340.32");
        let state = get_velem_quad(vd_val, i);
        let rkey = get_velem_quad(vs2_val, 0);
        let ark = $[overloaded { "name" = "^", "is_infix" = true }] xor_vec(state, rkey);
        write_velem_quad(vd, SEW, ark, i)
    };
    set_vstart(zeros(16));
    RETIRE_SUCCESS
}
and execute VSM4K_VI((vs2, uimm, vd)) = {
    let SEW = get_sew();
    let LMUL_pow = get_lmul_pow();
    let num_elem = get_num_elem(LMUL_pow, SEW);
    assert($[overloaded { "name" = "==", "is_infix" = true }] eq_int(SEW, 32), "./extensions/vector_crypto/zvksed_insts.sail:22.18-22.19");
    let vs2_val = read_vreg(num_elem, SEW, LMUL_pow, vs2);
    let rnd = $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(0b00, $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(uimm, 2, 0));
    let eg_len = $[overloaded { "name" = "/", "is_infix" = true }] quot_positive_round_zero(unsigned(vl), 4);
    let eg_start = $[overloaded { "name" = "/", "is_infix" = true }] quot_positive_round_zero(unsigned(vstart), 4);
    foreach (i from eg_start to sub_atom(eg_len, 1) by 1 in inc) {
        assert($[overloaded { "name" = "<", "is_infix" = true }] lt_int($[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(i, 4), 3), num_elem), "./extensions/vector_crypto/zvksed_insts.sail:32.31-32.32");
        let rk_in = get_velem_quad_vec(vs2_val, i);
        var rk_out : vector(4, bits(32)) = vector_init(4, zeros(32));
        var B = $[overloaded { "name" = "^", "is_infix" = true }] xor_vec($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(rk_in, 1), $[overloaded { "name" = "^", "is_infix" = true }] xor_vec($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(rk_in, 2), $[overloaded { "name" = "^", "is_infix" = true }] xor_vec($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(rk_in, 3), zvk_sm4_sbox($[overloaded { "name" = "<<", "is_infix" = true }] shiftl(rnd, 2)))));
        var S = zvk_sm4_subword(B);
        rk_out[0] = zvk_round_key($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(rk_in, 0), S);
        B = $[overloaded { "name" = "^", "is_infix" = true }] xor_vec($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(rk_in, 2), $[overloaded { "name" = "^", "is_infix" = true }] xor_vec($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(rk_in, 3), $[overloaded { "name" = "^", "is_infix" = true }] xor_vec($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(rk_out, 0), zvk_sm4_sbox($[overloaded { "name" = "+", "is_infix" = true }] add_bits_int($[overloaded { "name" = "<<", "is_infix" = true }] shiftl(rnd, 2), 1)))));
        S = zvk_sm4_subword(B);
        rk_out[1] = zvk_round_key($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(rk_in, 1), S);
        B = $[overloaded { "name" = "^", "is_infix" = true }] xor_vec($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(rk_in, 3), $[overloaded { "name" = "^", "is_infix" = true }] xor_vec($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(rk_out, 0), $[overloaded { "name" = "^", "is_infix" = true }] xor_vec($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(rk_out, 1), zvk_sm4_sbox($[overloaded { "name" = "+", "is_infix" = true }] add_bits_int($[overloaded { "name" = "<<", "is_infix" = true }] shiftl(rnd, 2), 2)))));
        S = zvk_sm4_subword(B);
        rk_out[2] = zvk_round_key($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(rk_in, 2), S);
        B = $[overloaded { "name" = "^", "is_infix" = true }] xor_vec($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(rk_out, 0), $[overloaded { "name" = "^", "is_infix" = true }] xor_vec($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(rk_out, 1), $[overloaded { "name" = "^", "is_infix" = true }] xor_vec($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(rk_out, 2), zvk_sm4_sbox($[overloaded { "name" = "+", "is_infix" = true }] add_bits_int($[overloaded { "name" = "<<", "is_infix" = true }] shiftl(rnd, 2), 3)))));
        S = zvk_sm4_subword(B);
        rk_out[3] = zvk_round_key($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(rk_in, 3), S);
        write_velem_quad_vec(vd, SEW, rk_out, i)
    };
    set_vstart(zeros(16));
    RETIRE_SUCCESS
}
and execute ZVKSM4RTYPE((funct6, vs2, vd)) = {
    let SEW = get_sew();
    let LMUL_pow = get_lmul_pow();
    let num_elem = get_num_elem(LMUL_pow, SEW);
    assert($[overloaded { "name" = "==", "is_infix" = true }] eq_int(SEW, 32), "./extensions/vector_crypto/zvksed_insts.sail:79.18-79.19");
    let vs2_val = read_vreg(num_elem, SEW, LMUL_pow, vs2);
    let vd_val = read_vreg(num_elem, SEW, LMUL_pow, vd);
    let eg_len = $[overloaded { "name" = "/", "is_infix" = true }] quot_positive_round_zero(unsigned(vl), 4);
    let eg_start = $[overloaded { "name" = "/", "is_infix" = true }] quot_positive_round_zero(unsigned(vstart), 4);
    foreach (i from eg_start to sub_atom(eg_len, 1) by 1 in inc) {
        assert($[overloaded { "name" = "<", "is_infix" = true }] lt_int($[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(i, 4), 3), num_elem), "./extensions/vector_crypto/zvksed_insts.sail:88.31-88.32");
        let rk_in = if $[overloaded { "name" = "==", "is_infix" = true }] eq_anything(funct6, ZVK_VSM4R_VV) then
          get_velem_quad_vec(vs2_val, i)
        else
          get_velem_quad_vec(vs2_val, 0);
        let x_in = get_velem_quad_vec(vd_val, i);
        var x_out : vector(4, bits(32)) = vector_init(4, zeros(32));
        var B = $[overloaded { "name" = "^", "is_infix" = true }] xor_vec($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(x_in, 1), $[overloaded { "name" = "^", "is_infix" = true }] xor_vec($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(x_in, 2), $[overloaded { "name" = "^", "is_infix" = true }] xor_vec($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(x_in, 3), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(rk_in, 0))));
        var S = zvk_sm4_subword(B);
        x_out[0] = zvk_sm4_round($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(x_in, 0), S);
        B = $[overloaded { "name" = "^", "is_infix" = true }] xor_vec($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(x_in, 2), $[overloaded { "name" = "^", "is_infix" = true }] xor_vec($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(x_in, 3), $[overloaded { "name" = "^", "is_infix" = true }] xor_vec($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(x_out, 0), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(rk_in, 1))));
        S = zvk_sm4_subword(B);
        x_out[1] = zvk_sm4_round($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(x_in, 1), S);
        B = $[overloaded { "name" = "^", "is_infix" = true }] xor_vec($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(x_in, 3), $[overloaded { "name" = "^", "is_infix" = true }] xor_vec($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(x_out, 0), $[overloaded { "name" = "^", "is_infix" = true }] xor_vec($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(x_out, 1), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(rk_in, 2))));
        S = zvk_sm4_subword(B);
        x_out[2] = zvk_sm4_round($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(x_in, 2), S);
        B = $[overloaded { "name" = "^", "is_infix" = true }] xor_vec($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(x_out, 0), $[overloaded { "name" = "^", "is_infix" = true }] xor_vec($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(x_out, 1), $[overloaded { "name" = "^", "is_infix" = true }] xor_vec($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(x_out, 2), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(rk_in, 3))));
        S = zvk_sm4_subword(B);
        x_out[3] = zvk_sm4_round($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(x_in, 3), S);
        write_velem_quad_vec(vd, SEW, x_out, i)
    };
    set_vstart(zeros(16));
    RETIRE_SUCCESS
}
and execute VSHA2MS_VV((vs2, vs1, vd)) = {
    let 'SEW = get_sew();
    let LMUL_pow = get_lmul_pow();
    let num_elem = get_num_elem(LMUL_pow, SEW);
    assert($[overloaded { "name" = "|", "is_infix" = true }] or_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_int(SEW, 32), $[overloaded { "name" = "==", "is_infix" = true }] eq_int(SEW, 64)), "./extensions/vector_crypto/zvknhab_insts.sail:26.30-26.31");
    let vs2_val = read_vreg(num_elem, SEW, LMUL_pow, vs2);
    let vs1_val = read_vreg(num_elem, SEW, LMUL_pow, vs1);
    let vd_val = read_vreg(num_elem, SEW, LMUL_pow, vd);
    var w : vector(20, bits('SEW)) = vector_init(20, zeros($[overloaded { "name" = "__size", "is_infix" = false }] __id(SEW)));
    let eg_len = $[overloaded { "name" = "/", "is_infix" = true }] quot_positive_round_zero(unsigned(vl), 4);
    let eg_start = $[overloaded { "name" = "/", "is_infix" = true }] quot_positive_round_zero(unsigned(vstart), 4);
    foreach (i from eg_start to sub_atom(eg_len, 1) by 1 in inc) {
        assert($[overloaded { "name" = "<", "is_infix" = true }] lt_int($[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(i, 4), 3), num_elem), "./extensions/vector_crypto/zvknhab_insts.sail:38.31-38.32");
        w = $[overloaded { "name" = "vector_update", "is_infix" = false }] plain_vector_update($[overloaded { "name" = "vector_update", "is_infix" = false }] plain_vector_update($[overloaded { "name" = "vector_update", "is_infix" = false }] plain_vector_update($[overloaded { "name" = "vector_update", "is_infix" = false }] plain_vector_update($[overloaded { "name" = "vector_update", "is_infix" = false }] plain_vector_update($[overloaded { "name" = "vector_update", "is_infix" = false }] plain_vector_update($[overloaded { "name" = "vector_update", "is_infix" = false }] plain_vector_update($[overloaded { "name" = "vector_update", "is_infix" = false }] plain_vector_update($[overloaded { "name" = "vector_update", "is_infix" = false }] plain_vector_update($[overloaded { "name" = "vector_update", "is_infix" = false }] plain_vector_update($[overloaded { "name" = "vector_update", "is_infix" = false }] plain_vector_update($[overloaded { "name" = "vector_update", "is_infix" = false }] plain_vector_update(w, 0, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vd_val, $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(i, 4))), 1, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vd_val, $[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(i, 4), 1))), 2, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vd_val, $[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(i, 4), 2))), 3, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vd_val, $[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(i, 4), 3))), 4, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(i, 4))), 9, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, $[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(i, 4), 1))), 10, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, $[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(i, 4), 2))), 11, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, $[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(i, 4), 3))), 12, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs1_val, $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(i, 4))), 13, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs1_val, $[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(i, 4), 1))), 14, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs1_val, $[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(i, 4), 2))), 15, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs1_val, $[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(i, 4), 3)));
        w[16] = $[overloaded { "name" = "+", "is_infix" = true }] add_bits($[overloaded { "name" = "+", "is_infix" = true }] add_bits($[overloaded { "name" = "+", "is_infix" = true }] add_bits(zvk_sig1($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(w, 14), SEW), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(w, 9)), zvk_sig0($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(w, 1), SEW)), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(w, 0));
        w[17] = $[overloaded { "name" = "+", "is_infix" = true }] add_bits($[overloaded { "name" = "+", "is_infix" = true }] add_bits($[overloaded { "name" = "+", "is_infix" = true }] add_bits(zvk_sig1($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(w, 15), SEW), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(w, 10)), zvk_sig0($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(w, 2), SEW)), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(w, 1));
        w[18] = $[overloaded { "name" = "+", "is_infix" = true }] add_bits($[overloaded { "name" = "+", "is_infix" = true }] add_bits($[overloaded { "name" = "+", "is_infix" = true }] add_bits(zvk_sig1($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(w, 16), SEW), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(w, 11)), zvk_sig0($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(w, 3), SEW)), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(w, 2));
        w[19] = $[overloaded { "name" = "+", "is_infix" = true }] add_bits($[overloaded { "name" = "+", "is_infix" = true }] add_bits($[overloaded { "name" = "+", "is_infix" = true }] add_bits(zvk_sig1($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(w, 17), SEW), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(w, 12)), zvk_sig0($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(w, 4), SEW)), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(w, 3));
        write_velem_quad(vd, SEW, $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(w, 19), $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(w, 18), $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(w, 17), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(w, 16)))), i)
    };
    set_vstart(zeros(16));
    RETIRE_SUCCESS
}
and execute ZVKSHA2TYPE((funct6, vs2, vs1, vd)) = {
    let SEW = get_sew();
    let LMUL_pow = get_lmul_pow();
    let num_elem = get_num_elem(LMUL_pow, SEW);
    assert($[overloaded { "name" = "|", "is_infix" = true }] or_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_int(SEW, 32), $[overloaded { "name" = "==", "is_infix" = true }] eq_int(SEW, 64)), "./extensions/vector_crypto/zvknhab_insts.sail:93.30-93.31");
    let vs2_val = read_vreg(num_elem, SEW, LMUL_pow, vs2);
    let vs1_val = read_vreg(num_elem, SEW, LMUL_pow, vs1);
    let vd_val = read_vreg(num_elem, SEW, LMUL_pow, vd);
    let eg_len = $[overloaded { "name" = "/", "is_infix" = true }] quot_positive_round_zero(unsigned(vl), 4);
    let eg_start = $[overloaded { "name" = "/", "is_infix" = true }] quot_positive_round_zero(unsigned(vstart), 4);
    foreach (i from eg_start to sub_atom(eg_len, 1) by 1 in inc) {
        assert($[overloaded { "name" = "<", "is_infix" = true }] lt_int($[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(i, 4), 3), num_elem), "./extensions/vector_crypto/zvknhab_insts.sail:103.31-103.32");
        var f = $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, $[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(i, 4), 0));
        var e = $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, $[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(i, 4), 1));
        var b = $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, $[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(i, 4), 2));
        var a = $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, $[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(i, 4), 3));
        var h = $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vd_val, $[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(i, 4), 0));
        var g = $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vd_val, $[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(i, 4), 1));
        var d = $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vd_val, $[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(i, 4), 2));
        var c = $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vd_val, $[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(i, 4), 3));
        let message_sched_plus_c = get_velem_quad(vs1_val, i);
        let w0 = if $[overloaded { "name" = "==", "is_infix" = true }] eq_anything(funct6, ZVK_VSHA2CL_VV) then
          $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(message_sched_plus_c, $[overloaded { "name" = "-", "is_infix" = true }] sub_atom($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(SEW, 1), 1), 0)
        else
          $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(message_sched_plus_c, $[overloaded { "name" = "-", "is_infix" = true }] sub_atom($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(SEW, 3), 1), $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(SEW, 2));
        let w1 = if $[overloaded { "name" = "==", "is_infix" = true }] eq_anything(funct6, ZVK_VSHA2CL_VV) then
          $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(message_sched_plus_c, $[overloaded { "name" = "-", "is_infix" = true }] sub_atom($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(SEW, 2), 1), SEW)
        else
          $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(message_sched_plus_c, $[overloaded { "name" = "-", "is_infix" = true }] sub_atom($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(SEW, 4), 1), $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(SEW, 3));
        var T1 = $[overloaded { "name" = "+", "is_infix" = true }] add_bits($[overloaded { "name" = "+", "is_infix" = true }] add_bits($[overloaded { "name" = "+", "is_infix" = true }] add_bits(h, zvk_sum1(e, SEW)), zvk_ch(e, f, g)), w0);
        var T2 = $[overloaded { "name" = "+", "is_infix" = true }] add_bits(zvk_sum0(a, SEW), zvk_maj(a, b, c));
        h = g;
        g = f;
        f = e;
        e = $[overloaded { "name" = "+", "is_infix" = true }] add_bits(d, T1);
        d = c;
        c = b;
        b = a;
        a = $[overloaded { "name" = "+", "is_infix" = true }] add_bits(T1, T2);
        T1 = $[overloaded { "name" = "+", "is_infix" = true }] add_bits($[overloaded { "name" = "+", "is_infix" = true }] add_bits($[overloaded { "name" = "+", "is_infix" = true }] add_bits(h, zvk_sum1(e, SEW)), zvk_ch(e, f, g)), w1);
        T2 = $[overloaded { "name" = "+", "is_infix" = true }] add_bits(zvk_sum0(a, SEW), zvk_maj(a, b, c));
        h = g;
        g = f;
        f = e;
        e = $[overloaded { "name" = "+", "is_infix" = true }] add_bits(d, T1);
        d = c;
        c = b;
        b = a;
        a = $[overloaded { "name" = "+", "is_infix" = true }] add_bits(T1, T2);
        write_velem_quad(vd, SEW, $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(a, $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(b, $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(e, f))), i)
    };
    set_vstart(zeros(16));
    RETIRE_SUCCESS
}
and execute VSM3ME_VV((vs2, vs1, vd)) = {
    let 'SEW = get_sew();
    let LMUL_pow = get_lmul_pow();
    let num_elem = get_num_elem(LMUL_pow, SEW);
    assert($[overloaded { "name" = "==", "is_infix" = true }] eq_int(SEW, 32), "./extensions/vector_crypto/zvksh_insts.sail:22.18-22.19");
    let vs2_val = read_vreg(num_elem, SEW, LMUL_pow, vs2);
    let vs1_val = read_vreg(num_elem, SEW, LMUL_pow, vs1);
    var w : vector(24, bits(32)) = vector_init(24, zeros(32));
    let eg_len = $[overloaded { "name" = "/", "is_infix" = true }] quot_positive_round_zero(unsigned(vl), 8);
    let eg_start = $[overloaded { "name" = "/", "is_infix" = true }] quot_positive_round_zero(unsigned(vstart), 8);
    foreach (i from eg_start to sub_atom(eg_len, 1) by 1 in inc) {
        assert($[overloaded { "name" = "<", "is_infix" = true }] lt_int($[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(i, 8), 7), num_elem), "./extensions/vector_crypto/zvksh_insts.sail:33.31-33.32");
        foreach (j from 0 to 7 by 1 in inc) {
            w[j] = rev8($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs1_val, $[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(i, 8), j)));
            w[$[overloaded { "name" = "+", "is_infix" = true }] add_atom(j, 8)] = rev8($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(vs2_val, $[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(i, 8), j)))
        };
        foreach (j from 16 to 23 by 1 in inc) w[j] = zvk_sh_w($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(w, $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(j, 16)), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(w, $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(j, 9)), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(w, $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(j, 3)), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(w, $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(j, 13)), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(w, $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(j, 6)));
        write_velem_oct_vec(vd, SEW, vrev8(ediv_int($[overloaded { "name" = "__size", "is_infix" = false }] __id(SEW), 8), [$[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(w, 23), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(w, 22), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(w, 21), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(w, 20), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(w, 19), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(w, 18), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(w, 17), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(w, 16)]), i)
    };
    set_vstart(zeros(16));
    RETIRE_SUCCESS
}
and execute VSM3C_VI((vs2, uimm, vd)) = {
    let SEW = get_sew();
    let LMUL_pow = get_lmul_pow();
    let num_elem = get_num_elem(LMUL_pow, SEW);
    assert($[overloaded { "name" = "==", "is_infix" = true }] eq_int(SEW, 32), "./extensions/vector_crypto/zvksh_insts.sail:65.18-65.19");
    let vs2_val = read_vreg(num_elem, SEW, LMUL_pow, vs2);
    let vd_val = read_vreg(num_elem, SEW, LMUL_pow, vd);
    let rnds = unsigned(uimm);
    let eg_len = $[overloaded { "name" = "/", "is_infix" = true }] quot_positive_round_zero(unsigned(vl), 8);
    let eg_start = $[overloaded { "name" = "/", "is_infix" = true }] quot_positive_round_zero(unsigned(vstart), 8);
    foreach (i from eg_start to sub_atom(eg_len, 1) by 1 in inc) {
        assert($[overloaded { "name" = "<", "is_infix" = true }] lt_int($[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(i, 8), 7), num_elem), "./extensions/vector_crypto/zvksh_insts.sail:76.31-76.32");
        let A_H : vector(8, bits(32)) = vrev8(ediv_int($[overloaded { "name" = "__size", "is_infix" = false }] __id(SEW), 8), get_velem_oct_vec($[overloaded { "name" = "__size", "is_infix" = false }] vector_length(vs2_val), vd_val, i));
        let w : vector(8, bits(32)) = vrev8(ediv_int($[overloaded { "name" = "__size", "is_infix" = false }] __id(SEW), 8), get_velem_oct_vec($[overloaded { "name" = "__size", "is_infix" = false }] vector_length(vs2_val), vs2_val, i));
        let x_0 = $[overloaded { "name" = "^", "is_infix" = true }] xor_vec($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(w, 0), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(w, 4));
        let x_1 = $[overloaded { "name" = "^", "is_infix" = true }] xor_vec($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(w, 1), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(w, 5));
        let A1_H1 = zvk_sm3_round(A_H, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(w, 0), x_0, $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(2, rnds));
        let A2_H2 = zvk_sm3_round(A1_H1, $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(w, 1), x_1, $[overloaded { "name" = "+", "is_infix" = true }] add_atom($[overloaded { "name" = "*", "is_infix" = true }] mult_atom(2, rnds), 1));
        write_velem_oct_vec(vd, SEW, vrev8(ediv_int($[overloaded { "name" = "__size", "is_infix" = false }] __id(SEW), 8), [$[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(A1_H1, 6), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(A2_H2, 6), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(A1_H1, 4), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(A2_H2, 4), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(A1_H1, 2), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(A2_H2, 2), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(A1_H1, 0), $[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(A2_H2, 0)]), i)
    };
    set_vstart(zeros(16));
    RETIRE_SUCCESS
}
and execute CSRReg((csr, rs1, rd, op)) = doCSR(csr, $[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1), rd, op, $[overloaded { "name" = "|", "is_infix" = true }] or_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_anything(op, CSRRW), $[overloaded { "name" = "!=", "is_infix" = true }] neq_anything(rs1, zreg)))
and execute CSRImm((csr, imm, rd, op)) = doCSR(csr, zero_extend(sizeof(xlen), imm), rd, op, $[overloaded { "name" = "|", "is_infix" = true }] or_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_anything(op, CSRRW), $[overloaded { "name" = "!=", "is_infix" = true }] neq_bits(imm, zeros(5))))
and execute SINVAL_VMA((rs1, rs2)) = {
    execute(SFENCE_VMA((rs1, rs2)))
}
and execute SFENCE_W_INVAL(()) = {
    if $[overloaded { "name" = "==", "is_infix" = true }] eq_anything(cur_privilege, User) then
      Illegal_Instruction()
    else
      RETIRE_SUCCESS
}
and execute SFENCE_INVAL_IR(()) = {
    if $[overloaded { "name" = "==", "is_infix" = true }] eq_anything(cur_privilege, User) then
      Illegal_Instruction()
    else
      RETIRE_SUCCESS
}
and execute WRS(WRS_STO) = Enter_Wait(WAIT_WRS_STO)
and execute WRS(WRS_NTO) = Enter_Wait(WAIT_WRS_NTO)
and $[split "op"]
execute ZICOND_RTYPE((rs2, rs1, rd, op)) = {
    let condition : bool = $[complete] match op {
      CZERO_EQZ => $[overloaded { "name" = "==", "is_infix" = true }] eq_bits($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs2), zeros(sizeof(xlen))),
      CZERO_NEQ => $[overloaded { "name" = "!=", "is_infix" = true }] neq_bits($[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs2), zeros(sizeof(xlen)))
    };
    $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(rd, if condition then
      zeros(sizeof(xlen))
    else
      $[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1));
    RETIRE_SUCCESS
}
and execute ZICBOM((CBO_CLEAN, rs1)) = if cbo_clean_flush_enabled(cur_privilege) then
  process_clean_inval(rs1, CBO_CLEAN)
else
  Illegal_Instruction()
and execute ZICBOM((CBO_FLUSH, rs1)) = if cbo_clean_flush_enabled(cur_privilege) then
  process_clean_inval(rs1, CBO_FLUSH)
else
  Illegal_Instruction()
and execute ZICBOM((CBO_INVAL, rs1)) = $[complete] match cbop_priv_check(cur_privilege) {
  CBOP_ILLEGAL => Illegal_Instruction(),
  CBOP_ILLEGAL_VIRTUAL => internal_error("./extensions/Zicbom/zicbom_insts.sail", 153, "unimplemented"),
  CBOP_INVAL_INVAL => process_clean_inval(rs1, CBO_INVAL),
  CBOP_INVAL_FLUSH => process_clean_inval(rs1, CBO_FLUSH)
}
and execute ZICBOZ(rs1) = {
    if cbo_zero_enabled(cur_privilege) then {
        let rs1_val = $[overloaded { "name" = "X", "is_infix" = false }] rX_bits(rs1);
        let cache_block_size = 2 ^ plat_cache_block_size_exp;
        let negative_offset = $[overloaded { "name" = "-", "is_infix" = true }] sub_vec($[overloaded { "name" = "&", "is_infix" = true }] and_vec(rs1_val, $[overloaded { "name" = "~", "is_infix" = false }] not_vec(zero_extend(sizeof(xlen), ones(plat_cache_block_size_exp)))), rs1_val);
        $[complete] match ext_data_get_addr(rs1, negative_offset, Write(Data), cache_block_size) {
          Ext_DataAddr_Error(e) => Ext_DataAddr_Check_Failure(e),
          Ext_DataAddr_OK(vaddr) => {
              $[complete] match translateAddr(vaddr, Write(Data)) {
                Err((e, _)) => Memory_Exception(($[overloaded { "name" = "-", "is_infix" = true }] sub_virtaddr_xlenbits(vaddr, negative_offset), e)),
                Ok((paddr, _)) => {
                    $[complete] match mem_write_ea(paddr, cache_block_size, false, false, false) {
                      Err(e) => Memory_Exception(($[overloaded { "name" = "-", "is_infix" = true }] sub_virtaddr_xlenbits(vaddr, negative_offset), e)),
                      Ok(_) => {
                          $[complete] match mem_write_value(paddr, cache_block_size, zeros(mult_atom(8, 2 ^ __id(plat_cache_block_size_exp))), false, false, false) {
                            Ok(true) => RETIRE_SUCCESS,
                            Ok(false) => internal_error("./extensions/Zicboz/zicboz_insts.sail", 53, "store got false from mem_write_value"),
                            Err(e) => Memory_Exception(($[overloaded { "name" = "-", "is_infix" = true }] sub_virtaddr_xlenbits(vaddr, negative_offset), e))
                          }
                      }
                    }
                }
              }
          }
        }
    } else {
        Illegal_Instruction()
    }
}
and execute FENCEI(()) = {
    RETIRE_SUCCESS
}
and execute FCVT_BF16_S((rs1, rm, rd)) = {
    let rs1_val_S = $[overloaded { "name" = "F_or_X_S", "is_infix" = false }] rF_or_X_S(rs1);
    $[complete] match select_instr_or_fcsr_rm(rm) {
      None(()) => Illegal_Instruction(),
      Some(rm') => {
          let rm_3b = encdec_rounding_mode_forwards(rm');
          let (fflags, rd_val_BF16) = riscv_f32ToBF16(rm_3b, rs1_val_S);
          accrue_fflags(fflags);
          $[overloaded { "name" = "F_BF16", "is_infix" = false }] $[setter] wF_BF16(rd, rd_val_BF16);
          RETIRE_SUCCESS
      }
    }
}
and execute FCVT_S_BF16((rs1, rm, rd)) = {
    if $[overloaded { "name" = "==", "is_infix" = true }] eq_anything(select_instr_or_fcsr_rm(rm), None()) then return(Illegal_Instruction());
    let (fflags, rd_val_S) = bf16_to_f32($[overloaded { "name" = "F_BF16", "is_infix" = false }] rF_BF16(rs1));
    accrue_fflags(fflags);
    $[overloaded { "name" = "F_S", "is_infix" = false }] $[setter] wF_S(rd, rd_val_S);
    RETIRE_SUCCESS
}
and execute ZIMOP_MOP_R((mop, rs1, rd)) = {
    $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(rd, zeros(sizeof(xlen)));
    RETIRE_SUCCESS
}
and execute ZIMOP_MOP_RR((mop, rs2, rs1, rd)) = {
    $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX_bits(rd, zeros(sizeof(xlen)));
    RETIRE_SUCCESS
}
and execute ZCMOP(mop) = {
    RETIRE_SUCCESS
}
and execute ILLEGAL(s) = Illegal_Instruction()
and execute C_ILLEGAL(s) = Illegal_Instruction()

mapping assembly = {
  ZICBOP(cbop, rs1, offset) <-> prefetch_mnemonic(cbop) ^ spc(()) ^ hex_bits_12(offset) ^ "(" ^ opt_spc(()) ^ reg_name(rs1) ^ opt_spc(()) ^ ")",
  NTL(op) <-> "ntl." ^ ntl_name(op),
  C_NTL(op) <-> "c.ntl." ^ ntl_name(op),
  PAUSE(()) <-> "pause",
  UTYPE(imm, rd, op) <-> utype_mnemonic(op) ^ spc(()) ^ reg_name(rd) ^ sep(()) ^ hex_bits_signed_20(imm),
  JAL(imm, rd) <-> "jal" ^ spc(()) ^ reg_name(rd) ^ sep(()) ^ hex_bits_signed_21(imm),
  JALR(imm, rs1, rd) <-> "jalr" ^ spc(()) ^ reg_name(rd) ^ sep(()) ^ hex_bits_signed_12(imm) ^ "(" ^ reg_name(rs1) ^ ")",
  BTYPE(imm, rs2, rs1, op) <-> btype_mnemonic(op) ^ spc(()) ^ reg_name(rs1) ^ sep(()) ^ reg_name(rs2) ^ sep(()) ^ hex_bits_signed_13(imm),
  ITYPE(imm, rs1, rd, op) <-> itype_mnemonic(op) ^ spc(()) ^ reg_name(rd) ^ sep(()) ^ reg_name(rs1) ^ sep(()) ^ hex_bits_signed_12(imm),
  SHIFTIOP(shamt, rs1, rd, op) <-> shiftiop_mnemonic(op) ^ spc(()) ^ reg_name(rd) ^ sep(()) ^ reg_name(rs1) ^ sep(()) ^ hex_bits_6(shamt),
  RTYPE(rs2, rs1, rd, op) <-> rtype_mnemonic(op) ^ spc(()) ^ reg_name(rd) ^ sep(()) ^ reg_name(rs1) ^ sep(()) ^ reg_name(rs2),
  LOAD(imm, rs1, rd, is_unsigned, width) <-> "l" ^ width_mnemonic(width) ^ maybe_u(is_unsigned) ^ spc(()) ^ reg_name(rd) ^ sep(()) ^ hex_bits_signed_12(imm) ^ "(" ^ reg_name(rs1) ^ ")",
  STORE(imm, rs2, rs1, width) <-> "s" ^ width_mnemonic(width) ^ spc(()) ^ reg_name(rs2) ^ sep(()) ^ hex_bits_signed_12(imm) ^ opt_spc(()) ^ "(" ^ opt_spc(()) ^ reg_name(rs1) ^ opt_spc(()) ^ ")",
  ADDIW(imm, rs1, rd) if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64) <-> "addiw" ^ spc(()) ^ reg_name(rd) ^ sep(()) ^ reg_name(rs1) ^ sep(()) ^ hex_bits_signed_12(imm) if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64),
  RTYPEW(rs2, rs1, rd, op) if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64) <-> rtypew_mnemonic(op) ^ spc(()) ^ reg_name(rd) ^ sep(()) ^ reg_name(rs1) ^ sep(()) ^ reg_name(rs2) if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64),
  SHIFTIWOP(shamt, rs1, rd, op) if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64) <-> shiftiwop_mnemonic(op) ^ spc(()) ^ reg_name(rd) ^ sep(()) ^ reg_name(rs1) ^ sep(()) ^ hex_bits_5(shamt) if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64),
  FENCE(pred, succ) <-> "fence" ^ spc(()) ^ fence_bits(pred) ^ sep(()) ^ fence_bits(succ),
  FENCE_TSO(()) <-> "fence.tso",
  ECALL(()) <-> "ecall",
  MRET(()) <-> "mret",
  SRET(()) <-> "sret",
  EBREAK(()) <-> "ebreak",
  WFI(()) <-> "wfi",
  SFENCE_VMA(rs1, rs2) <-> "sfence.vma" ^ spc(()) ^ reg_name(rs1) ^ sep(()) ^ reg_name(rs2),
  FENCE_RESERVED(fm, pred, succ, rs, rd) if $[overloaded { "name" = "|", "is_infix" = true }] or_bool($[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "!=", "is_infix" = true }] neq_bits(fm, 0b0000), $[overloaded { "name" = "!=", "is_infix" = true }] neq_bits(fm, 0b1000)), $[overloaded { "name" = "|", "is_infix" = true }] or_bool($[overloaded { "name" = "!=", "is_infix" = true }] neq_anything(rs, zreg), $[overloaded { "name" = "!=", "is_infix" = true }] neq_anything(rd, zreg))) <-> "fence.reserved." ^ fence_bits(pred) ^ "." ^ fence_bits(succ) ^ "." ^ reg_name(rs) ^ "." ^ reg_name(rd) ^ "." ^ hex_bits_4(fm) if $[overloaded { "name" = "|", "is_infix" = true }] or_bool($[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "!=", "is_infix" = true }] neq_bits(fm, 0b0000), $[overloaded { "name" = "!=", "is_infix" = true }] neq_bits(fm, 0b1000)), $[overloaded { "name" = "|", "is_infix" = true }] or_bool($[overloaded { "name" = "!=", "is_infix" = true }] neq_anything(rs, zreg), $[overloaded { "name" = "!=", "is_infix" = true }] neq_anything(rd, zreg))),
  FENCEI_RESERVED(imm, rs, rd) if $[overloaded { "name" = "|", "is_infix" = true }] or_bool($[overloaded { "name" = "!=", "is_infix" = true }] neq_bits(imm, 0b000000000000), $[overloaded { "name" = "|", "is_infix" = true }] or_bool($[overloaded { "name" = "!=", "is_infix" = true }] neq_anything(rs, zreg), $[overloaded { "name" = "!=", "is_infix" = true }] neq_anything(rd, zreg))) <-> "fence.i.reserved." ^ reg_name(rd) ^ "." ^ reg_name(rs) ^ "." ^ hex_bits_12(imm) if $[overloaded { "name" = "|", "is_infix" = true }] or_bool($[overloaded { "name" = "!=", "is_infix" = true }] neq_bits(imm, 0b000000000000), $[overloaded { "name" = "|", "is_infix" = true }] or_bool($[overloaded { "name" = "!=", "is_infix" = true }] neq_anything(rs, zreg), $[overloaded { "name" = "!=", "is_infix" = true }] neq_anything(rd, zreg))),
  AMO(op, aq, rl, rs2, rs1, width, rd) <-> amo_mnemonic(op) ^ "." ^ width_mnemonic_wide(width) ^ maybe_aqrl((aq, rl)) ^ spc(()) ^ reg_name(rd) ^ sep(()) ^ reg_name(rs2) ^ sep(()) ^ "(" ^ reg_name(rs1) ^ ")",
  LOADRES(aq, rl, rs1, width, rd) <-> "lr." ^ width_mnemonic(width) ^ maybe_aqrl((aq, rl)) ^ spc(()) ^ reg_name(rd) ^ sep(()) ^ "(" ^ reg_name(rs1) ^ ")",
  STORECON(aq, rl, rs2, rs1, width, rd) <-> "sc." ^ width_mnemonic(width) ^ maybe_aqrl((aq, rl)) ^ spc(()) ^ reg_name(rd) ^ sep(()) ^ reg_name(rs2) ^ sep(()) ^ "(" ^ reg_name(rs1) ^ ")",
  MUL(rs2, rs1, rd, mul_op) <-> mul_mnemonic(mul_op) ^ spc(()) ^ reg_name(rd) ^ sep(()) ^ reg_name(rs1) ^ sep(()) ^ reg_name(rs2),
  DIV(rs2, rs1, rd, is_unsigned) <-> "div" ^ maybe_u(is_unsigned) ^ spc(()) ^ reg_name(rd) ^ sep(()) ^ reg_name(rs1) ^ sep(()) ^ reg_name(rs2),
  REM(rs2, rs1, rd, is_unsigned) <-> "rem" ^ maybe_u(is_unsigned) ^ spc(()) ^ reg_name(rd) ^ sep(()) ^ reg_name(rs1) ^ sep(()) ^ reg_name(rs2),
  MULW(rs2, rs1, rd) if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64) <-> "mulw" ^ spc(()) ^ reg_name(rd) ^ sep(()) ^ reg_name(rs1) ^ sep(()) ^ reg_name(rs2) if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64),
  DIVW(rs2, rs1, rd, is_unsigned) if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64) <-> "div" ^ maybe_u(is_unsigned) ^ "w" ^ spc(()) ^ reg_name(rd) ^ sep(()) ^ reg_name(rs1) ^ sep(()) ^ reg_name(rs2) if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64),
  REMW(rs2, rs1, rd, is_unsigned) if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64) <-> "rem" ^ maybe_u(is_unsigned) ^ "w" ^ spc(()) ^ reg_name(rd) ^ sep(()) ^ reg_name(rs1) ^ sep(()) ^ reg_name(rs2) if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64),
  SLLIUW(shamt, rs1, rd) <-> "slli.uw" ^ spc(()) ^ reg_name(rd) ^ sep(()) ^ reg_name(rs1) ^ sep(()) ^ hex_bits_6(shamt),
  ZBA_RTYPEUW(rs2, rs1, rd, shamt) <-> zba_rtypeuw_mnemonic(shamt) ^ spc(()) ^ reg_name(rd) ^ sep(()) ^ reg_name(rs1) ^ sep(()) ^ reg_name(rs2),
  ZBA_RTYPE(rs2, rs1, rd, shamt) <-> zba_rtype_mnemonic(shamt) ^ spc(()) ^ reg_name(rd) ^ sep(()) ^ reg_name(rs1) ^ sep(()) ^ reg_name(rs2),
  RORIW(shamt, rs1, rd) <-> "roriw" ^ spc(()) ^ reg_name(rd) ^ sep(()) ^ reg_name(rs1) ^ sep(()) ^ hex_bits_5(shamt),
  RORI(shamt, rs1, rd) <-> "rori" ^ spc(()) ^ reg_name(rd) ^ sep(()) ^ reg_name(rs1) ^ sep(()) ^ hex_bits_6(shamt),
  ZBB_RTYPEW(rs2, rs1, rd, op) <-> zbb_rtypew_mnemonic(op) ^ spc(()) ^ reg_name(rd) ^ sep(()) ^ reg_name(rs1) ^ sep(()) ^ reg_name(rs2),
  ZBB_RTYPE(rs2, rs1, rd, op) <-> zbb_rtype_mnemonic(op) ^ spc(()) ^ reg_name(rd) ^ sep(()) ^ reg_name(rs1) ^ sep(()) ^ reg_name(rs2),
  ZBB_EXTOP(rs1, rd, op) <-> zbb_extop_mnemonic(op) ^ spc(()) ^ reg_name(rd) ^ sep(()) ^ reg_name(rs1),
  REV8(rs1, rd) <-> "rev8" ^ spc(()) ^ reg_name(rd) ^ sep(()) ^ reg_name(rs1),
  ORCB(rs1, rd) <-> "orc.b" ^ spc(()) ^ reg_name(rd) ^ sep(()) ^ reg_name(rs1),
  CPOP(rs1, rd) <-> "cpop" ^ spc(()) ^ reg_name(rd) ^ sep(()) ^ reg_name(rs1),
  CPOPW(rs1, rd) <-> "cpopw" ^ spc(()) ^ reg_name(rd) ^ sep(()) ^ reg_name(rs1),
  CLZ(rs1, rd) <-> "clz" ^ spc(()) ^ reg_name(rd) ^ sep(()) ^ reg_name(rs1),
  CLZW(rs1, rd) <-> "clzw" ^ spc(()) ^ reg_name(rd) ^ sep(()) ^ reg_name(rs1),
  CTZ(rs1, rd) <-> "ctz" ^ spc(()) ^ reg_name(rd) ^ sep(()) ^ reg_name(rs1),
  CTZW(rs1, rd) <-> "ctzw" ^ spc(()) ^ reg_name(rd) ^ sep(()) ^ reg_name(rs1),
  CLMUL(rs2, rs1, rd) <-> "clmul" ^ spc(()) ^ reg_name(rd) ^ sep(()) ^ reg_name(rs1) ^ sep(()) ^ reg_name(rs2),
  CLMULH(rs2, rs1, rd) <-> "clmulh" ^ spc(()) ^ reg_name(rd) ^ sep(()) ^ reg_name(rs1) ^ sep(()) ^ reg_name(rs2),
  CLMULR(rs2, rs1, rd) <-> "clmulr" ^ spc(()) ^ reg_name(rd) ^ sep(()) ^ reg_name(rs1) ^ sep(()) ^ reg_name(rs2),
  ZBS_IOP(shamt, rs1, rd, op) <-> zbs_iop_mnemonic(op) ^ spc(()) ^ reg_name(rd) ^ sep(()) ^ reg_name(rs1) ^ sep(()) ^ hex_bits_6(shamt),
  ZBS_RTYPE(rs2, rs1, rd, op) <-> zbs_rtype_mnemonic(op) ^ spc(()) ^ reg_name(rd) ^ sep(()) ^ reg_name(rs1) ^ sep(()) ^ reg_name(rs2),
  C_NOP(0b000000) <-> "c.nop",
  C_NOP(imm) if $[overloaded { "name" = "!=", "is_infix" = true }] neq_bits(imm, zeros(6)) <-> "c.nop" ^ spc(()) ^ hex_bits_signed_6(imm) if $[overloaded { "name" = "!=", "is_infix" = true }] neq_bits(imm, zeros(6)),
  C_ADDI4SPN(rdc, nzimm) if $[overloaded { "name" = "!=", "is_infix" = true }] neq_bits(nzimm, 0b00000000) <-> "c.addi4spn" ^ spc(()) ^ creg_name(rdc) ^ sep(()) ^ sp_reg_name(()) ^ sep(()) ^ hex_bits_10((nzimm : bitvector(8)) @ 0b00) if $[overloaded { "name" = "!=", "is_infix" = true }] neq_bits(nzimm, 0b00000000),
  C_LW(uimm, rsc, rdc) <-> "c.lw" ^ spc(()) ^ creg_name(rdc) ^ sep(()) ^ hex_bits_7((uimm : bitvector(5)) @ 0b00) ^ "(" ^ creg_name(rsc) ^ ")",
  C_LD(uimm, rsc, rdc) if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64) <-> "c.ld" ^ spc(()) ^ creg_name(rdc) ^ sep(()) ^ hex_bits_8((uimm : bitvector(5)) @ 0b000) ^ "(" ^ creg_name(rsc) ^ ")" if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64),
  C_SW(uimm, rsc1, rsc2) <-> "c.sw" ^ spc(()) ^ creg_name(rsc2) ^ sep(()) ^ hex_bits_7((uimm : bitvector(5)) @ 0b00) ^ "(" ^ creg_name(rsc1) ^ ")",
  C_SD(uimm, rsc1, rsc2) if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64) <-> "c.sd" ^ spc(()) ^ creg_name(rsc2) ^ sep(()) ^ hex_bits_8((uimm : bitvector(5)) @ 0b000) ^ "(" ^ creg_name(rsc1) ^ ")" if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64),
  C_ADDI(imm, rsd) if $[overloaded { "name" = "!=", "is_infix" = true }] neq_anything(rsd, zreg) <-> "c.addi" ^ spc(()) ^ reg_name(rsd) ^ sep(()) ^ hex_bits_signed_6(imm) if $[overloaded { "name" = "!=", "is_infix" = true }] neq_anything(rsd, zreg),
  C_JAL(imm) if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 32) <-> "c.jal" ^ spc(()) ^ hex_bits_signed_12((imm : bitvector(11)) @ 0b0) if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 32),
  C_ADDIW(imm, rsd) if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64) <-> "c.addiw" ^ spc(()) ^ reg_name(rsd) ^ sep(()) ^ hex_bits_signed_6(imm) if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64),
  C_LI(imm, rd) <-> "c.li" ^ spc(()) ^ reg_name(rd) ^ sep(()) ^ hex_bits_signed_6(imm),
  C_ADDI16SP(imm) if $[overloaded { "name" = "!=", "is_infix" = true }] neq_bits(imm, 0b000000) <-> "c.addi16sp" ^ spc(()) ^ sp_reg_name(()) ^ sep(()) ^ hex_bits_signed_10((imm : bitvector(6)) @ 0x0) if $[overloaded { "name" = "!=", "is_infix" = true }] neq_bits(imm, 0b000000),
  C_LUI(imm, rd) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "!=", "is_infix" = true }] neq_anything(rd, sp), $[overloaded { "name" = "!=", "is_infix" = true }] neq_bits(imm, 0b000000)) <-> "c.lui" ^ spc(()) ^ reg_name(rd) ^ sep(()) ^ hex_bits_signed_6(imm) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "!=", "is_infix" = true }] neq_anything(rd, sp), $[overloaded { "name" = "!=", "is_infix" = true }] neq_bits(imm, 0b000000)),
  C_SRLI(shamt, rsd) <-> "c.srli" ^ spc(()) ^ creg_name(rsd) ^ sep(()) ^ hex_bits_6(shamt),
  C_SRAI(shamt, rsd) <-> "c.srai" ^ spc(()) ^ creg_name(rsd) ^ sep(()) ^ hex_bits_6(shamt),
  C_ANDI(imm, rsd) <-> "c.andi" ^ spc(()) ^ creg_name(rsd) ^ sep(()) ^ hex_bits_signed_6(imm),
  C_SUB(rsd, rs2) <-> "c.sub" ^ spc(()) ^ creg_name(rsd) ^ sep(()) ^ creg_name(rs2),
  C_XOR(rsd, rs2) <-> "c.xor" ^ spc(()) ^ creg_name(rsd) ^ sep(()) ^ creg_name(rs2),
  C_OR(rsd, rs2) <-> "c.or" ^ spc(()) ^ creg_name(rsd) ^ sep(()) ^ creg_name(rs2),
  C_AND(rsd, rs2) <-> "c.and" ^ spc(()) ^ creg_name(rsd) ^ sep(()) ^ creg_name(rs2),
  C_SUBW(rsd, rs2) if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64) <-> "c.subw" ^ spc(()) ^ creg_name(rsd) ^ sep(()) ^ creg_name(rs2) if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64),
  C_ADDW(rsd, rs2) if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64) <-> "c.addw" ^ spc(()) ^ creg_name(rsd) ^ sep(()) ^ creg_name(rs2) if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64),
  C_J(imm) <-> "c.j" ^ spc(()) ^ hex_bits_signed_12((imm : bitvector(11)) @ 0b0),
  C_BEQZ(imm, rs) <-> "c.beqz" ^ spc(()) ^ creg_name(rs) ^ sep(()) ^ hex_bits_signed_9((imm : bitvector(8)) @ 0b0),
  C_BNEZ(imm, rs) <-> "c.bnez" ^ spc(()) ^ creg_name(rs) ^ sep(()) ^ hex_bits_signed_9((imm : bitvector(8)) @ 0b0),
  C_SLLI(shamt, rsd) <-> "c.slli" ^ spc(()) ^ reg_name(rsd) ^ sep(()) ^ hex_bits_6(shamt),
  C_LWSP(uimm, rd) if $[overloaded { "name" = "!=", "is_infix" = true }] neq_anything(rd, zreg) <-> "c.lwsp" ^ spc(()) ^ reg_name(rd) ^ sep(()) ^ hex_bits_8((uimm : bitvector(6)) @ 0b00) ^ "(" ^ sp_reg_name(()) ^ ")" if $[overloaded { "name" = "!=", "is_infix" = true }] neq_anything(rd, zreg),
  C_LDSP(uimm, rd) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "!=", "is_infix" = true }] neq_anything(rd, zreg), $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64)) <-> "c.ldsp" ^ spc(()) ^ reg_name(rd) ^ sep(()) ^ hex_bits_9((uimm : bitvector(6)) @ 0b000) ^ "(" ^ sp_reg_name(()) ^ ")" if $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "!=", "is_infix" = true }] neq_anything(rd, zreg), $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64)),
  C_SWSP(uimm, rs2) <-> "c.swsp" ^ spc(()) ^ reg_name(rs2) ^ sep(()) ^ hex_bits_8((uimm : bitvector(6)) @ 0b00) ^ "(" ^ sp_reg_name(()) ^ ")",
  C_SDSP(uimm, rs2) if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64) <-> "c.sdsp" ^ spc(()) ^ reg_name(rs2) ^ sep(()) ^ hex_bits_9((uimm : bitvector(6)) @ 0b000) ^ "(" ^ sp_reg_name(()) ^ ")" if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64),
  C_JR(rs1) if $[overloaded { "name" = "!=", "is_infix" = true }] neq_anything(rs1, zreg) <-> "c.jr" ^ spc(()) ^ reg_name(rs1) if $[overloaded { "name" = "!=", "is_infix" = true }] neq_anything(rs1, zreg),
  C_JALR(rs1) if $[overloaded { "name" = "!=", "is_infix" = true }] neq_anything(rs1, zreg) <-> "c.jalr" ^ spc(()) ^ reg_name(rs1) if $[overloaded { "name" = "!=", "is_infix" = true }] neq_anything(rs1, zreg),
  C_MV(rd, rs2) if $[overloaded { "name" = "!=", "is_infix" = true }] neq_anything(rs2, zreg) <-> "c.mv" ^ spc(()) ^ reg_name(rd) ^ sep(()) ^ reg_name(rs2) if $[overloaded { "name" = "!=", "is_infix" = true }] neq_anything(rs2, zreg),
  C_EBREAK(()) <-> "c.ebreak",
  C_ADD(rsd, rs2) if $[overloaded { "name" = "!=", "is_infix" = true }] neq_anything(rs2, zreg) <-> "c.add" ^ spc(()) ^ reg_name(rsd) ^ sep(()) ^ reg_name(rs2) if $[overloaded { "name" = "!=", "is_infix" = true }] neq_anything(rs2, zreg),
  C_LBU(uimm, rdc, rsc1) <-> "c.lbu" ^ spc(()) ^ creg_name(rdc) ^ sep(()) ^ hex_bits_2(uimm) ^ opt_spc(()) ^ "(" ^ opt_spc(()) ^ creg_name(rsc1) ^ opt_spc(()) ^ ")",
  C_LHU(uimm, rdc, rsc1) <-> "c.lhu" ^ spc(()) ^ creg_name(rdc) ^ sep(()) ^ hex_bits_2(uimm) ^ opt_spc(()) ^ "(" ^ opt_spc(()) ^ creg_name(rsc1) ^ opt_spc(()) ^ ")",
  C_LH(uimm, rdc, rsc1) <-> "c.lh" ^ spc(()) ^ creg_name(rdc) ^ sep(()) ^ hex_bits_2(uimm) ^ opt_spc(()) ^ "(" ^ opt_spc(()) ^ creg_name(rsc1) ^ opt_spc(()) ^ ")",
  C_SB(uimm, rsc1, rsc2) <-> "c.sb" ^ spc(()) ^ creg_name(rsc2) ^ sep(()) ^ hex_bits_2(uimm) ^ opt_spc(()) ^ "(" ^ opt_spc(()) ^ creg_name(rsc1) ^ opt_spc(()) ^ ")",
  C_SH(uimm, rsc1, rsc2) <-> "c.sh" ^ spc(()) ^ creg_name(rsc2) ^ sep(()) ^ hex_bits_2(uimm) ^ opt_spc(()) ^ "(" ^ opt_spc(()) ^ creg_name(rsc1) ^ opt_spc(()) ^ ")",
  C_ZEXT_B(rsdc) <-> "c.zext.b" ^ spc(()) ^ creg_name(rsdc),
  C_SEXT_B(rsdc) <-> "c.sext.b" ^ spc(()) ^ creg_name(rsdc),
  C_ZEXT_H(rsdc) <-> "c.zext.h" ^ spc(()) ^ creg_name(rsdc),
  C_SEXT_H(rsdc) <-> "c.sext.h" ^ spc(()) ^ creg_name(rsdc),
  C_ZEXT_W(rsdc) <-> "c.zext.w" ^ spc(()) ^ creg_name(rsdc),
  C_NOT(rsdc) <-> "c.not" ^ spc(()) ^ creg_name(rsdc),
  C_MUL(rsdc, rsc2) <-> "c.mul" ^ spc(()) ^ creg_name(rsdc) ^ sep(()) ^ creg_name(rsc2),
  LOAD_FP(imm, rs1, rd, width) <-> "fl" ^ width_mnemonic(width) ^ spc(()) ^ freg_or_reg_name(rd) ^ sep(()) ^ hex_bits_signed_12(imm) ^ opt_spc(()) ^ "(" ^ opt_spc(()) ^ reg_name(rs1) ^ opt_spc(()) ^ ")",
  STORE_FP(imm, rs2, rs1, width) <-> "fs" ^ width_mnemonic(width) ^ spc(()) ^ freg_name(rs2) ^ sep(()) ^ hex_bits_signed_12(imm) ^ opt_spc(()) ^ "(" ^ opt_spc(()) ^ reg_name(rs1) ^ opt_spc(()) ^ ")",
  F_MADD_TYPE_S(rs3, rs2, rs1, rm, rd, op) <-> f_madd_type_mnemonic_S(op) ^ spc(()) ^ freg_or_reg_name(rd) ^ sep(()) ^ freg_or_reg_name(rs1) ^ sep(()) ^ freg_or_reg_name(rs2) ^ sep(()) ^ freg_or_reg_name(rs3) ^ sep(()) ^ frm_mnemonic(rm),
  F_BIN_RM_TYPE_S(rs2, rs1, rm, rd, op) <-> f_bin_rm_type_mnemonic_S(op) ^ spc(()) ^ freg_or_reg_name(rd) ^ sep(()) ^ freg_or_reg_name(rs1) ^ sep(()) ^ freg_or_reg_name(rs2) ^ sep(()) ^ frm_mnemonic(rm),
  F_UN_RM_FF_TYPE_S(rs1, rm, rd, FSQRT_S) <-> "fsqrt.s" ^ spc(()) ^ freg_or_reg_name(rd) ^ sep(()) ^ freg_or_reg_name(rs1) ^ sep(()) ^ frm_mnemonic(rm),
  F_UN_RM_FX_TYPE_S(rs1, rm, rd, op) <-> f_un_rm_fx_type_mnemonic_S(op) ^ spc(()) ^ reg_name(rd) ^ sep(()) ^ freg_or_reg_name(rs1) ^ sep(()) ^ frm_mnemonic(rm),
  F_UN_RM_XF_TYPE_S(rs1, rm, rd, op) <-> f_un_rm_xf_type_mnemonic_S(op) ^ spc(()) ^ freg_or_reg_name(rd) ^ sep(()) ^ reg_name(rs1) ^ sep(()) ^ frm_mnemonic(rm),
  F_BIN_TYPE_F_S(rs2, rs1, rd, op) <-> f_bin_type_mnemonic_f_S(op) ^ spc(()) ^ freg_or_reg_name(rd) ^ sep(()) ^ freg_or_reg_name(rs1) ^ sep(()) ^ freg_or_reg_name(rs2),
  F_BIN_TYPE_X_S(rs2, rs1, rd, op) <-> f_bin_type_mnemonic_x_S(op) ^ spc(()) ^ reg_name(rd) ^ sep(()) ^ freg_or_reg_name(rs1) ^ sep(()) ^ freg_or_reg_name(rs2),
  F_UN_TYPE_X_S(rs1, rd, op) <-> f_un_type_mnemonic_x_S(op) ^ spc(()) ^ reg_name(rd) ^ sep(()) ^ freg_name(rs1),
  F_UN_TYPE_F_S(rs1, rd, op) <-> f_un_type_mnemonic_f_S(op) ^ spc(()) ^ freg_name(rd) ^ sep(()) ^ reg_name(rs1),
  C_FLWSP(imm, rd) if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 32) <-> "c.flwsp" ^ spc(()) ^ freg_name(rd) ^ sep(()) ^ hex_bits_8((imm : bitvector(6)) @ 0b00) ^ "(" ^ sp_reg_name(()) ^ ")" if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 32),
  C_FSWSP(uimm, rs2) if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 32) <-> "c.fswsp" ^ spc(()) ^ freg_name(rs2) ^ sep(()) ^ hex_bits_8((uimm : bitvector(6)) @ 0b00) ^ "(" ^ sp_reg_name(()) ^ ")" if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 32),
  C_FLW(uimm, rsc, rdc) if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 32) <-> "c.flw" ^ spc(()) ^ cfreg_name(rdc) ^ sep(()) ^ hex_bits_7((uimm : bitvector(5)) @ 0b00) ^ "(" ^ creg_name(rsc) ^ ")" if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 32),
  C_FSW(uimm, rsc1, rsc2) if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 32) <-> "c.fsw" ^ spc(()) ^ cfreg_name(rsc2) ^ sep(()) ^ hex_bits_7((uimm : bitvector(5)) @ 0b00) ^ "(" ^ creg_name(rsc1) ^ ")" if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 32),
  F_MADD_TYPE_D(rs3, rs2, rs1, rm, rd, op) <-> f_madd_type_mnemonic_D(op) ^ spc(()) ^ freg_or_reg_name(rd) ^ sep(()) ^ freg_or_reg_name(rs1) ^ sep(()) ^ freg_or_reg_name(rs2) ^ sep(()) ^ freg_or_reg_name(rs3) ^ sep(()) ^ frm_mnemonic(rm),
  F_BIN_RM_TYPE_D(rs2, rs1, rm, rd, op) <-> f_bin_rm_type_mnemonic_D(op) ^ spc(()) ^ freg_or_reg_name(rd) ^ sep(()) ^ freg_or_reg_name(rs1) ^ sep(()) ^ freg_or_reg_name(rs2) ^ sep(()) ^ frm_mnemonic(rm),
  F_UN_RM_FF_TYPE_D(rs1, rm, rd, op) <-> f_un_rm_ff_type_mnemonic_D(op) ^ spc(()) ^ freg_or_reg_name(rd) ^ sep(()) ^ freg_or_reg_name(rs1) ^ sep(()) ^ frm_mnemonic(rm),
  F_UN_RM_FX_TYPE_D(rs1, rm, rd, op) <-> f_un_rm_fx_type_mnemonic_D(op) ^ spc(()) ^ reg_name(rd) ^ sep(()) ^ freg_or_reg_name(rs1) ^ sep(()) ^ frm_mnemonic(rm),
  F_UN_RM_XF_TYPE_D(rs1, rm, rd, op) <-> f_un_rm_xf_type_mnemonic_D(op) ^ spc(()) ^ freg_or_reg_name(rd) ^ sep(()) ^ reg_name(rs1) ^ sep(()) ^ frm_mnemonic(rm),
  F_BIN_F_TYPE_D(rs2, rs1, rd, op) <-> f_bin_f_type_mnemonic_D(op) ^ spc(()) ^ freg_or_reg_name(rd) ^ sep(()) ^ freg_or_reg_name(rs1) ^ sep(()) ^ freg_or_reg_name(rs2),
  F_BIN_X_TYPE_D(rs2, rs1, rd, op) <-> f_bin_x_type_mnemonic_D(op) ^ spc(()) ^ reg_name(rd) ^ sep(()) ^ freg_or_reg_name(rs1) ^ sep(()) ^ freg_or_reg_name(rs2),
  F_UN_X_TYPE_D(rs1, rd, op) <-> f_un_x_type_mnemonic_D(op) ^ spc(()) ^ reg_name(rd) ^ sep(()) ^ freg_name(rs1),
  F_UN_F_TYPE_D(rs1, rd, op) <-> f_un_f_type_mnemonic_D(op) ^ spc(()) ^ freg_name(rd) ^ sep(()) ^ reg_name(rs1),
  C_FLDSP(uimm, rd) <-> "c.fldsp" ^ spc(()) ^ freg_name(rd) ^ sep(()) ^ hex_bits_9((uimm : bitvector(6)) @ 0b000) ^ "(" ^ sp_reg_name(()) ^ ")",
  C_FSDSP(uimm, rs2) <-> "c.fsdsp" ^ spc(()) ^ freg_name(rs2) ^ sep(()) ^ hex_bits_9((uimm : bitvector(6)) @ 0b000) ^ "(" ^ sp_reg_name(()) ^ ")",
  C_FLD(uimm, rsc, rdc) <-> "c.fld" ^ spc(()) ^ cfreg_name(rdc) ^ sep(()) ^ hex_bits_8((uimm : bitvector(5)) @ 0b000) ^ "(" ^ creg_name(rsc) ^ ")",
  C_FSD(uimm, rsc1, rsc2) <-> "c.fsd" ^ spc(()) ^ cfreg_name(rsc2) ^ sep(()) ^ hex_bits_8((uimm : bitvector(5)) @ 0b000) ^ "(" ^ creg_name(rsc1) ^ ")",
  F_BIN_RM_TYPE_H(rs2, rs1, rm, rd, op) <-> f_bin_rm_type_mnemonic_H(op) ^ spc(()) ^ freg_or_reg_name(rd) ^ sep(()) ^ freg_or_reg_name(rs1) ^ sep(()) ^ freg_or_reg_name(rs2) ^ sep(()) ^ frm_mnemonic(rm),
  F_MADD_TYPE_H(rs3, rs2, rs1, rm, rd, op) <-> f_madd_type_mnemonic_H(op) ^ spc(()) ^ freg_or_reg_name(rd) ^ sep(()) ^ freg_or_reg_name(rs1) ^ sep(()) ^ freg_or_reg_name(rs2) ^ sep(()) ^ freg_or_reg_name(rs3) ^ sep(()) ^ frm_mnemonic(rm),
  F_BIN_F_TYPE_H(rs2, rs1, rd, op) <-> f_bin_f_type_mnemonic_H(op) ^ spc(()) ^ freg_or_reg_name(rd) ^ sep(()) ^ freg_or_reg_name(rs1) ^ sep(()) ^ freg_or_reg_name(rs2),
  F_BIN_X_TYPE_H(rs2, rs1, rd, op) <-> f_bin_x_type_mnemonic_H(op) ^ spc(()) ^ reg_name(rd) ^ sep(()) ^ freg_or_reg_name(rs1) ^ sep(()) ^ freg_or_reg_name(rs2),
  F_UN_RM_FF_TYPE_H(rs1, rm, rd, op) <-> f_un_rm_ff_type_mnemonic_H(op) ^ spc(()) ^ freg_or_reg_name(rd) ^ sep(()) ^ freg_or_reg_name(rs1) ^ sep(()) ^ frm_mnemonic(rm),
  F_UN_RM_FX_TYPE_H(rs1, rm, rd, op) <-> f_un_rm_fx_type_mnemonic_H(op) ^ spc(()) ^ reg_name(rd) ^ sep(()) ^ freg_or_reg_name(rs1) ^ sep(()) ^ frm_mnemonic(rm),
  F_UN_RM_XF_TYPE_H(rs1, rm, rd, op) <-> f_un_rm_xf_type_mnemonic_H(op) ^ spc(()) ^ freg_or_reg_name(rd) ^ sep(()) ^ reg_name(rs1) ^ sep(()) ^ frm_mnemonic(rm),
  F_UN_F_TYPE_H(rs1, rd, op) <-> f_un_f_type_mnemonic_H(op) ^ spc(()) ^ freg_name(rd) ^ sep(()) ^ reg_name(rs1),
  F_UN_X_TYPE_H(rs1, rd, op) <-> f_un_x_type_mnemonic_H(op) ^ spc(()) ^ reg_name(rd) ^ sep(()) ^ freg_name(rs1),
  FLI_H(constantidx, rd) <-> "fli.h" ^ spc(()) ^ freg_name(rd) ^ sep(()) ^ hex_bits_5(constantidx),
  FLI_S(constantidx, rd) <-> "fli.s" ^ spc(()) ^ freg_name(rd) ^ sep(()) ^ hex_bits_5(constantidx),
  FLI_D(constantidx, rd) <-> "fli.d" ^ spc(()) ^ freg_name(rd) ^ sep(()) ^ hex_bits_5(constantidx),
  FMINM_H(rs2, rs1, rd) <-> "fminm.h" ^ spc(()) ^ freg_name(rd) ^ sep(()) ^ freg_name(rs1) ^ sep(()) ^ freg_name(rs2),
  FMAXM_H(rs2, rs1, rd) <-> "fmaxm.h" ^ spc(()) ^ freg_name(rd) ^ sep(()) ^ freg_name(rs1) ^ sep(()) ^ freg_name(rs2),
  FMINM_S(rs2, rs1, rd) <-> "fminm.s" ^ spc(()) ^ freg_name(rd) ^ sep(()) ^ freg_name(rs1) ^ sep(()) ^ freg_name(rs2),
  FMAXM_S(rs2, rs1, rd) <-> "fmaxm.s" ^ spc(()) ^ freg_name(rd) ^ sep(()) ^ freg_name(rs1) ^ sep(()) ^ freg_name(rs2),
  FMINM_D(rs2, rs1, rd) <-> "fminm.d" ^ spc(()) ^ freg_name(rd) ^ sep(()) ^ freg_name(rs1) ^ sep(()) ^ freg_name(rs2),
  FMAXM_D(rs2, rs1, rd) <-> "fmaxm.d" ^ spc(()) ^ freg_name(rd) ^ sep(()) ^ freg_name(rs1) ^ sep(()) ^ freg_name(rs2),
  FROUND_H(rs1, rm, rd) <-> "fround.h" ^ spc(()) ^ freg_name(rd) ^ sep(()) ^ freg_name(rs1) ^ sep(()) ^ frm_mnemonic(rm),
  FROUNDNX_H(rs1, rm, rd) <-> "froundnx.h" ^ spc(()) ^ freg_name(rd) ^ sep(()) ^ freg_name(rs1) ^ sep(()) ^ frm_mnemonic(rm),
  FROUND_S(rs1, rm, rd) <-> "fround.s" ^ spc(()) ^ freg_name(rd) ^ sep(()) ^ freg_name(rs1) ^ sep(()) ^ frm_mnemonic(rm),
  FROUNDNX_S(rs1, rm, rd) <-> "froundnx.s" ^ spc(()) ^ freg_name(rd) ^ sep(()) ^ freg_name(rs1) ^ sep(()) ^ frm_mnemonic(rm),
  FROUND_D(rs1, rm, rd) <-> "fround.d" ^ spc(()) ^ freg_name(rd) ^ sep(()) ^ freg_name(rs1) ^ sep(()) ^ frm_mnemonic(rm),
  FROUNDNX_D(rs1, rm, rd) <-> "froundnx.d" ^ spc(()) ^ freg_name(rd) ^ sep(()) ^ freg_name(rs1) ^ sep(()) ^ frm_mnemonic(rm),
  FMVH_X_D(rs1, rd) <-> "fmvh.x.d" ^ spc(()) ^ reg_name(rd) ^ sep(()) ^ freg_name(rs1),
  FMVP_D_X(rs2, rs1, rd) <-> "fmvp.d.x" ^ spc(()) ^ freg_name(rd) ^ sep(()) ^ reg_name(rs1) ^ sep(()) ^ reg_name(rs2),
  FLEQ_H(rs2, rs1, rd) <-> "fleq.h" ^ spc(()) ^ reg_name(rd) ^ sep(()) ^ freg_name(rs1) ^ sep(()) ^ freg_name(rs2),
  FLTQ_H(rs2, rs1, rd) <-> "fltq.h" ^ spc(()) ^ reg_name(rd) ^ sep(()) ^ freg_name(rs1) ^ sep(()) ^ freg_name(rs2),
  FLEQ_S(rs2, rs1, rd) <-> "fleq.s" ^ spc(()) ^ reg_name(rd) ^ sep(()) ^ freg_name(rs1) ^ sep(()) ^ freg_name(rs2),
  FLTQ_S(rs2, rs1, rd) <-> "fltq.s" ^ spc(()) ^ reg_name(rd) ^ sep(()) ^ freg_name(rs1) ^ sep(()) ^ freg_name(rs2),
  FLEQ_D(rs2, rs1, rd) <-> "fleq.d" ^ spc(()) ^ reg_name(rd) ^ sep(()) ^ freg_name(rs1) ^ sep(()) ^ freg_name(rs2),
  FLTQ_D(rs2, rs1, rd) <-> "fltq.d" ^ spc(()) ^ reg_name(rd) ^ sep(()) ^ freg_name(rs1) ^ sep(()) ^ freg_name(rs2),
  FCVTMOD_W_D(rs1, rd) <-> "fcvtmod.w.d" ^ spc(()) ^ reg_name(rd) ^ sep(()) ^ freg_name(rs1) ^ sep(()) ^ "rtz",
  VSETVLI(ma, ta, sew, lmul, rs1, rd) <-> "vsetvli" ^ spc(()) ^ reg_name(rd) ^ sep(()) ^ reg_name(rs1) ^ sep(()) ^ vtype_assembly((ma, ta, sew, lmul)),
  VSETVL(rs2, rs1, rd) <-> "vsetvl" ^ spc(()) ^ reg_name(rd) ^ sep(()) ^ reg_name(rs1) ^ sep(()) ^ reg_name(rs2),
  VSETIVLI(ma, ta, sew, lmul, uimm, rd) <-> "vsetivli" ^ spc(()) ^ reg_name(rd) ^ sep(()) ^ hex_bits_5(uimm) ^ sep(()) ^ vtype_assembly((ma, ta, sew, lmul)),
  VVTYPE(funct6, vm, vs2, vs1, vd) <-> vvtype_mnemonic(funct6) ^ spc(()) ^ vreg_name(vd) ^ sep(()) ^ vreg_name(vs2) ^ sep(()) ^ vreg_name(vs1) ^ maybe_vmask(vm),
  NVSTYPE(funct6, vm, vs2, vs1, vd) <-> nvstype_mnemonic(funct6) ^ spc(()) ^ vreg_name(vd) ^ sep(()) ^ vreg_name(vs2) ^ sep(()) ^ vreg_name(vs1) ^ maybe_vmask(vm),
  NVTYPE(funct6, vm, vs2, vs1, vd) <-> nvtype_mnemonic(funct6) ^ spc(()) ^ vreg_name(vd) ^ sep(()) ^ vreg_name(vs2) ^ sep(()) ^ vreg_name(vs1) ^ maybe_vmask(vm),
  MASKTYPEV(vs2, vs1, vd) <-> "vmerge.vvm" ^ spc(()) ^ vreg_name(vd) ^ sep(()) ^ vreg_name(vs2) ^ sep(()) ^ vreg_name(vs1) ^ sep(()) ^ "v0",
  MOVETYPEV(vs1, vd) <-> "vmv.v.v" ^ spc(()) ^ vreg_name(vd) ^ sep(()) ^ vreg_name(vs1),
  VXTYPE(funct6, vm, vs2, rs1, vd) <-> vxtype_mnemonic(funct6) ^ spc(()) ^ vreg_name(vd) ^ sep(()) ^ vreg_name(vs2) ^ sep(()) ^ reg_name(rs1) ^ maybe_vmask(vm),
  NXSTYPE(funct6, vm, vs2, rs1, vd) <-> nxstype_mnemonic(funct6) ^ spc(()) ^ vreg_name(vd) ^ sep(()) ^ vreg_name(vs2) ^ sep(()) ^ reg_name(rs1) ^ maybe_vmask(vm),
  NXTYPE(funct6, vm, vs2, rs1, vd) <-> nxtype_mnemonic(funct6) ^ spc(()) ^ vreg_name(vd) ^ sep(()) ^ vreg_name(vs2) ^ sep(()) ^ reg_name(rs1) ^ maybe_vmask(vm),
  VXSG(funct6, vm, vs2, rs1, vd) <-> vxsg_mnemonic(funct6) ^ spc(()) ^ vreg_name(vd) ^ sep(()) ^ vreg_name(vs2) ^ sep(()) ^ reg_name(rs1) ^ maybe_vmask(vm),
  MASKTYPEX(vs2, rs1, vd) <-> "vmerge.vxm" ^ spc(()) ^ vreg_name(vd) ^ sep(()) ^ vreg_name(vs2) ^ sep(()) ^ reg_name(rs1) ^ sep(()) ^ "v0",
  MOVETYPEX(rs1, vd) <-> "vmv.v.x" ^ spc(()) ^ vreg_name(vd) ^ sep(()) ^ reg_name(rs1),
  VITYPE(funct6, vm, vs2, simm, vd) <-> vitype_mnemonic(funct6) ^ spc(()) ^ vreg_name(vd) ^ sep(()) ^ vreg_name(vs2) ^ sep(()) ^ hex_bits_signed_5(simm) ^ maybe_vmask(vm),
  NISTYPE(funct6, vm, vs2, uimm, vd) <-> nistype_mnemonic(funct6) ^ spc(()) ^ vreg_name(vd) ^ sep(()) ^ vreg_name(vs2) ^ sep(()) ^ hex_bits_5(uimm) ^ maybe_vmask(vm),
  NITYPE(funct6, vm, vs2, uimm, vd) <-> nitype_mnemonic(funct6) ^ spc(()) ^ vreg_name(vd) ^ sep(()) ^ vreg_name(vs2) ^ sep(()) ^ hex_bits_5(uimm) ^ maybe_vmask(vm),
  VISG(funct6, vm, vs2, simm, vd) <-> visg_mnemonic(funct6) ^ spc(()) ^ vreg_name(vd) ^ sep(()) ^ vreg_name(vs2) ^ sep(()) ^ hex_bits_signed_5(simm) ^ maybe_vmask(vm),
  MASKTYPEI(vs2, simm, vd) <-> "vmerge.vim" ^ spc(()) ^ vreg_name(vd) ^ sep(()) ^ vreg_name(vs2) ^ sep(()) ^ hex_bits_signed_5(simm) ^ sep(()) ^ "v0",
  MOVETYPEI(vd, simm) <-> "vmv.v.i" ^ spc(()) ^ vreg_name(vd) ^ sep(()) ^ hex_bits_signed_5(simm),
  VMVRTYPE(vs2, nreg, vd) <-> "vmv" ^ nreg_string(nreg) ^ "r.v" ^ spc(()) ^ vreg_name(vd) ^ sep(()) ^ vreg_name(vs2),
  MVVTYPE(funct6, vm, vs2, vs1, vd) <-> mvvtype_mnemonic(funct6) ^ spc(()) ^ vreg_name(vd) ^ sep(()) ^ vreg_name(vs2) ^ sep(()) ^ vreg_name(vs1) ^ maybe_vmask(vm),
  MVVMATYPE(funct6, vm, vs2, vs1, vd) <-> mvvmatype_mnemonic(funct6) ^ spc(()) ^ vreg_name(vd) ^ sep(()) ^ vreg_name(vs1) ^ sep(()) ^ vreg_name(vs2) ^ maybe_vmask(vm),
  WVVTYPE(funct6, vm, vs2, vs1, vd) <-> wvvtype_mnemonic(funct6) ^ spc(()) ^ vreg_name(vd) ^ sep(()) ^ vreg_name(vs2) ^ sep(()) ^ vreg_name(vs1) ^ maybe_vmask(vm),
  WVTYPE(funct6, vm, vs2, vs1, vd) <-> wvtype_mnemonic(funct6) ^ spc(()) ^ vreg_name(vd) ^ sep(()) ^ vreg_name(vs2) ^ sep(()) ^ vreg_name(vs1) ^ maybe_vmask(vm),
  WMVVTYPE(funct6, vm, vs2, vs1, vd) <-> wmvvtype_mnemonic(funct6) ^ spc(()) ^ vreg_name(vd) ^ sep(()) ^ vreg_name(vs1) ^ sep(()) ^ vreg_name(vs2) ^ maybe_vmask(vm),
  VEXTTYPE(funct6, vm, vs2, vd) <-> vexttype_mnemonic(funct6) ^ spc(()) ^ vreg_name(vd) ^ sep(()) ^ vreg_name(vs2) ^ maybe_vmask(vm),
  VMVXS(vs2, rd) <-> "vmv.x.s" ^ spc(()) ^ reg_name(rd) ^ sep(()) ^ vreg_name(vs2),
  MVVCOMPRESS(vs2, vs1, vd) <-> "vcompress.vm" ^ spc(()) ^ vreg_name(vd) ^ sep(()) ^ vreg_name(vs2) ^ sep(()) ^ vreg_name(vs1),
  MVXTYPE(funct6, vm, vs2, rs1, vd) <-> mvxtype_mnemonic(funct6) ^ spc(()) ^ vreg_name(vd) ^ sep(()) ^ vreg_name(vs2) ^ sep(()) ^ reg_name(rs1) ^ maybe_vmask(vm),
  MVXMATYPE(funct6, vm, vs2, rs1, vd) <-> mvxmatype_mnemonic(funct6) ^ spc(()) ^ vreg_name(vd) ^ sep(()) ^ reg_name(rs1) ^ sep(()) ^ vreg_name(vs2) ^ maybe_vmask(vm),
  WVXTYPE(funct6, vm, vs2, rs1, vd) <-> wvxtype_mnemonic(funct6) ^ spc(()) ^ vreg_name(vd) ^ sep(()) ^ vreg_name(vs2) ^ sep(()) ^ reg_name(rs1) ^ maybe_vmask(vm),
  WXTYPE(funct6, vm, vs2, rs1, vd) <-> wxtype_mnemonic(funct6) ^ spc(()) ^ vreg_name(vd) ^ sep(()) ^ vreg_name(vs2) ^ sep(()) ^ reg_name(rs1) ^ maybe_vmask(vm),
  WMVXTYPE(funct6, vm, vs2, rs1, vd) <-> wmvxtype_mnemonic(funct6) ^ spc(()) ^ vreg_name(vd) ^ sep(()) ^ reg_name(rs1) ^ sep(()) ^ vreg_name(vs2) ^ maybe_vmask(vm),
  VMVSX(rs1, vd) <-> "vmv.s.x" ^ spc(()) ^ vreg_name(vd) ^ sep(()) ^ reg_name(rs1),
  FVVTYPE(funct6, vm, vs2, vs1, vd) <-> fvvtype_mnemonic(funct6) ^ spc(()) ^ vreg_name(vd) ^ sep(()) ^ vreg_name(vs2) ^ sep(()) ^ vreg_name(vs1) ^ maybe_vmask(vm),
  FVVMATYPE(funct6, vm, vs2, vs1, vd) <-> fvvmatype_mnemonic(funct6) ^ spc(()) ^ vreg_name(vd) ^ sep(()) ^ vreg_name(vs1) ^ sep(()) ^ vreg_name(vs2) ^ maybe_vmask(vm),
  FWVVTYPE(funct6, vm, vs2, vs1, vd) <-> fwvvtype_mnemonic(funct6) ^ spc(()) ^ vreg_name(vd) ^ sep(()) ^ vreg_name(vs2) ^ sep(()) ^ vreg_name(vs1) ^ maybe_vmask(vm),
  FWVVMATYPE(funct6, vm, vs1, vs2, vd) <-> fwvvmatype_mnemonic(funct6) ^ spc(()) ^ vreg_name(vd) ^ sep(()) ^ vreg_name(vs1) ^ sep(()) ^ vreg_name(vs2) ^ maybe_vmask(vm),
  FWVTYPE(funct6, vm, vs2, vs1, vd) <-> fwvtype_mnemonic(funct6) ^ spc(()) ^ vreg_name(vd) ^ sep(()) ^ vreg_name(vs2) ^ sep(()) ^ vreg_name(vs1) ^ maybe_vmask(vm),
  VFUNARY0(vm, vs2, vfunary0, vd) <-> vfunary0_mnemonic(vfunary0) ^ spc(()) ^ vreg_name(vd) ^ sep(()) ^ vreg_name(vs2) ^ maybe_vmask(vm),
  VFWUNARY0(vm, vs2, vfwunary0, vd) <-> vfwunary0_mnemonic(vfwunary0) ^ spc(()) ^ vreg_name(vd) ^ sep(()) ^ vreg_name(vs2) ^ maybe_vmask(vm),
  VFNUNARY0(vm, vs2, vfnunary0, vd) <-> vfnunary0_mnemonic(vfnunary0) ^ spc(()) ^ vreg_name(vd) ^ sep(()) ^ vreg_name(vs2) ^ maybe_vmask(vm),
  VFUNARY1(vm, vs2, vfunary1, vd) <-> vfunary1_mnemonic(vfunary1) ^ spc(()) ^ vreg_name(vd) ^ sep(()) ^ vreg_name(vs2) ^ maybe_vmask(vm),
  VFMVFS(vs2, rd) <-> "vfmv.f.s" ^ spc(()) ^ freg_name(rd) ^ sep(()) ^ vreg_name(vs2),
  FVFTYPE(funct6, vm, vs2, rs1, vd) <-> fvftype_mnemonic(funct6) ^ spc(()) ^ vreg_name(vd) ^ sep(()) ^ vreg_name(vs2) ^ sep(()) ^ freg_name(rs1) ^ maybe_vmask(vm),
  FVFMATYPE(funct6, vm, vs2, rs1, vd) <-> fvfmatype_mnemonic(funct6) ^ spc(()) ^ vreg_name(vd) ^ sep(()) ^ freg_name(rs1) ^ sep(()) ^ vreg_name(vs2) ^ maybe_vmask(vm),
  FWVFTYPE(funct6, vm, vs2, rs1, vd) <-> fwvftype_mnemonic(funct6) ^ spc(()) ^ vreg_name(vd) ^ sep(()) ^ vreg_name(vs2) ^ sep(()) ^ freg_name(rs1) ^ maybe_vmask(vm),
  FWVFMATYPE(funct6, vm, rs1, vs2, vd) <-> fwvfmatype_mnemonic(funct6) ^ spc(()) ^ vreg_name(vd) ^ sep(()) ^ freg_name(rs1) ^ sep(()) ^ vreg_name(vs2) ^ maybe_vmask(vm),
  FWFTYPE(funct6, vm, vs2, rs1, vd) <-> fwftype_mnemonic(funct6) ^ spc(()) ^ vreg_name(vd) ^ sep(()) ^ vreg_name(vs2) ^ sep(()) ^ freg_name(rs1) ^ maybe_vmask(vm),
  VFMERGE(vs2, rs1, vd) <-> "vfmerge.vfm" ^ spc(()) ^ vreg_name(vd) ^ sep(()) ^ vreg_name(vs2) ^ sep(()) ^ freg_name(rs1) ^ sep(()) ^ "v0",
  VFMV(rs1, vd) <-> "vfmv.v.f" ^ spc(()) ^ vreg_name(vd) ^ sep(()) ^ freg_name(rs1),
  VFMVSF(rs1, vd) <-> "vfmv.s.f" ^ spc(()) ^ vreg_name(vd) ^ sep(()) ^ freg_name(rs1),
  VLSEGTYPE(nf, vm, rs1, width, vd) <-> "vl" ^ nfields_string(nf) ^ "e" ^ vlewidth_bitsnumberstr(width) ^ ".v" ^ spc(()) ^ vreg_name(vd) ^ sep(()) ^ "(" ^ reg_name(rs1) ^ ")" ^ maybe_vmask(vm),
  VLSEGFFTYPE(nf, vm, rs1, width, vd) <-> "vl" ^ nfields_string(nf) ^ "e" ^ vlewidth_bitsnumberstr(width) ^ "ff.v" ^ spc(()) ^ vreg_name(vd) ^ sep(()) ^ "(" ^ reg_name(rs1) ^ ")" ^ maybe_vmask(vm),
  VSSEGTYPE(nf, vm, rs1, width, vs3) <-> "vs" ^ nfields_string(nf) ^ "e" ^ vlewidth_bitsnumberstr(width) ^ ".v" ^ spc(()) ^ vreg_name(vs3) ^ sep(()) ^ "(" ^ reg_name(rs1) ^ ")" ^ maybe_vmask(vm),
  VLSSEGTYPE(nf, vm, rs2, rs1, width, vd) <-> "vls" ^ nfields_string(nf) ^ "e" ^ vlewidth_bitsnumberstr(width) ^ ".v" ^ spc(()) ^ vreg_name(vd) ^ sep(()) ^ "(" ^ reg_name(rs1) ^ ")" ^ sep(()) ^ reg_name(rs2) ^ maybe_vmask(vm),
  VSSSEGTYPE(nf, vm, rs2, rs1, width, vs3) <-> "vss" ^ nfields_string(nf) ^ "e" ^ vlewidth_bitsnumberstr(width) ^ ".v" ^ spc(()) ^ vreg_name(vs3) ^ sep(()) ^ "(" ^ reg_name(rs1) ^ ")" ^ sep(()) ^ reg_name(rs2) ^ maybe_vmask(vm),
  VLUXSEGTYPE(nf, vm, vs2, rs1, width, vd) <-> "vlux" ^ nfields_string(nf) ^ "ei" ^ vlewidth_bitsnumberstr(width) ^ ".v" ^ spc(()) ^ vreg_name(vd) ^ sep(()) ^ "(" ^ reg_name(rs1) ^ ")" ^ sep(()) ^ vreg_name(vs2) ^ maybe_vmask(vm),
  VLOXSEGTYPE(nf, vm, vs2, rs1, width, vd) <-> "vlox" ^ nfields_string(nf) ^ "ei" ^ vlewidth_bitsnumberstr(width) ^ ".v" ^ spc(()) ^ vreg_name(vd) ^ sep(()) ^ "(" ^ reg_name(rs1) ^ ")" ^ sep(()) ^ vreg_name(vs2) ^ maybe_vmask(vm),
  VSUXSEGTYPE(nf, vm, vs2, rs1, width, vs3) <-> "vsux" ^ nfields_string(nf) ^ "ei" ^ vlewidth_bitsnumberstr(width) ^ ".v" ^ spc(()) ^ vreg_name(vs3) ^ sep(()) ^ "(" ^ reg_name(rs1) ^ ")" ^ sep(()) ^ vreg_name(vs2) ^ maybe_vmask(vm),
  VSOXSEGTYPE(nf, vm, vs2, rs1, width, vs3) <-> "vsox" ^ nfields_string(nf) ^ "ei" ^ vlewidth_bitsnumberstr(width) ^ ".v" ^ spc(()) ^ vreg_name(vs3) ^ sep(()) ^ "(" ^ reg_name(rs1) ^ ")" ^ sep(()) ^ vreg_name(vs2) ^ maybe_vmask(vm),
  VLRETYPE(nf, rs1, width, vd) <-> "vl" ^ nfields_pow2_string(nf) ^ "re" ^ vlewidth_bitsnumberstr(width) ^ ".v" ^ spc(()) ^ vreg_name(vd) ^ sep(()) ^ "(" ^ reg_name(rs1) ^ ")",
  VSRETYPE(nf, rs1, vs3) <-> "vs" ^ nfields_pow2_string(nf) ^ "r.v" ^ spc(()) ^ vreg_name(vs3) ^ sep(()) ^ "(" ^ reg_name(rs1) ^ ")",
  VMTYPE(rs1, vd_or_vs3, op) <-> vmtype_mnemonic(op) ^ spc(()) ^ vreg_name(vd_or_vs3) ^ sep(()) ^ "(" ^ reg_name(rs1) ^ ")",
  MMTYPE(funct6, vs2, vs1, vd) <-> mmtype_mnemonic(funct6) ^ spc(()) ^ vreg_name(vd) ^ sep(()) ^ vreg_name(vs2) ^ sep(()) ^ vreg_name(vs1),
  VCPOP_M(vm, vs2, rd) <-> "vcpop.m" ^ spc(()) ^ reg_name(rd) ^ sep(()) ^ vreg_name(vs2) ^ maybe_vmask(vm),
  VFIRST_M(vm, vs2, rd) <-> "vfirst.m" ^ spc(()) ^ reg_name(rd) ^ sep(()) ^ vreg_name(vs2) ^ maybe_vmask(vm),
  VMSBF_M(vm, vs2, vd) <-> "vmsbf.m" ^ spc(()) ^ vreg_name(vd) ^ sep(()) ^ vreg_name(vs2) ^ maybe_vmask(vm),
  VMSIF_M(vm, vs2, vd) <-> "vmsif.m" ^ spc(()) ^ vreg_name(vd) ^ sep(()) ^ vreg_name(vs2) ^ maybe_vmask(vm),
  VMSOF_M(vm, vs2, vd) <-> "vmsof.m" ^ spc(()) ^ vreg_name(vd) ^ sep(()) ^ vreg_name(vs2) ^ maybe_vmask(vm),
  VIOTA_M(vm, vs2, vd) <-> "viota.m" ^ spc(()) ^ vreg_name(vd) ^ sep(()) ^ vreg_name(vs2) ^ maybe_vmask(vm),
  VID_V(vm, vd) <-> "vid.v" ^ spc(()) ^ vreg_name(vd) ^ maybe_vmask(vm),
  VVMTYPE(funct6, vs2, vs1, vd) <-> vvmtype_mnemonic(funct6) ^ spc(()) ^ vreg_name(vd) ^ sep(()) ^ vreg_name(vs2) ^ sep(()) ^ vreg_name(vs1) ^ sep(()) ^ "v0",
  VVMCTYPE(funct6, vs2, vs1, vd) <-> vvmctype_mnemonic(funct6) ^ spc(()) ^ vreg_name(vd) ^ sep(()) ^ vreg_name(vs2) ^ sep(()) ^ vreg_name(vs1),
  VVMSTYPE(funct6, vs2, vs1, vd) <-> vvmstype_mnemonic(funct6) ^ spc(()) ^ vreg_name(vd) ^ sep(()) ^ vreg_name(vs2) ^ sep(()) ^ vreg_name(vs1) ^ sep(()) ^ "v0",
  VVCMPTYPE(funct6, vm, vs2, vs1, vd) <-> vvcmptype_mnemonic(funct6) ^ spc(()) ^ vreg_name(vd) ^ sep(()) ^ vreg_name(vs2) ^ sep(()) ^ vreg_name(vs1) ^ maybe_vmask(vm),
  VXMTYPE(funct6, vs2, rs1, vd) <-> vxmtype_mnemonic(funct6) ^ spc(()) ^ vreg_name(vd) ^ sep(()) ^ vreg_name(vs2) ^ sep(()) ^ reg_name(rs1) ^ sep(()) ^ "v0",
  VXMCTYPE(funct6, vs2, rs1, vd) <-> vxmctype_mnemonic(funct6) ^ spc(()) ^ vreg_name(vd) ^ sep(()) ^ vreg_name(vs2) ^ sep(()) ^ reg_name(rs1),
  VXMSTYPE(funct6, vs2, rs1, vd) <-> vxmstype_mnemonic(funct6) ^ spc(()) ^ vreg_name(vd) ^ sep(()) ^ vreg_name(vs2) ^ sep(()) ^ reg_name(rs1) ^ sep(()) ^ "v0",
  VXCMPTYPE(funct6, vm, vs2, rs1, vd) <-> vxcmptype_mnemonic(funct6) ^ spc(()) ^ vreg_name(vd) ^ sep(()) ^ vreg_name(vs2) ^ sep(()) ^ reg_name(rs1) ^ maybe_vmask(vm),
  VIMTYPE(funct6, vs2, simm, vd) <-> vimtype_mnemonic(funct6) ^ spc(()) ^ vreg_name(vd) ^ sep(()) ^ vreg_name(vs2) ^ sep(()) ^ hex_bits_signed_5(simm) ^ sep(()) ^ "v0",
  VIMCTYPE(funct6, vs2, simm, vd) <-> vimctype_mnemonic(funct6) ^ spc(()) ^ vreg_name(vd) ^ sep(()) ^ vreg_name(vs2) ^ sep(()) ^ hex_bits_signed_5(simm),
  VIMSTYPE(funct6, vs2, simm, vd) <-> vimstype_mnemonic(funct6) ^ spc(()) ^ vreg_name(vd) ^ sep(()) ^ vreg_name(vs2) ^ sep(()) ^ hex_bits_signed_5(simm) ^ sep(()) ^ "v0",
  VICMPTYPE(funct6, vm, vs2, simm, vd) <-> vicmptype_mnemonic(funct6) ^ spc(()) ^ vreg_name(vd) ^ sep(()) ^ vreg_name(vs2) ^ sep(()) ^ hex_bits_signed_5(simm) ^ maybe_vmask(vm),
  FVVMTYPE(funct6, vm, vs2, vs1, vd) <-> fvvmtype_mnemonic(funct6) ^ spc(()) ^ vreg_name(vd) ^ sep(()) ^ vreg_name(vs2) ^ sep(()) ^ vreg_name(vs1) ^ maybe_vmask(vm),
  FVFMTYPE(funct6, vm, vs2, rs1, vd) <-> fvfmtype_mnemonic(funct6) ^ spc(()) ^ vreg_name(vd) ^ sep(()) ^ vreg_name(vs2) ^ sep(()) ^ freg_name(rs1) ^ maybe_vmask(vm),
  RIVVTYPE(funct6, vm, vs2, vs1, vd) <-> rivvtype_mnemonic(funct6) ^ spc(()) ^ vreg_name(vd) ^ sep(()) ^ vreg_name(vs2) ^ sep(()) ^ vreg_name(vs1) ^ maybe_vmask(vm),
  RMVVTYPE(funct6, vm, vs2, vs1, vd) <-> rmvvtype_mnemonic(funct6) ^ spc(()) ^ vreg_name(vd) ^ sep(()) ^ vreg_name(vs2) ^ sep(()) ^ vreg_name(vs1) ^ maybe_vmask(vm),
  RFVVTYPE(funct6, vm, vs2, vs1, vd) <-> rfvvtype_mnemonic(funct6) ^ spc(()) ^ vreg_name(vd) ^ sep(()) ^ vreg_name(vs2) ^ sep(()) ^ vreg_name(vs1) ^ maybe_vmask(vm),
  SHA256SIG0(rs1, rd) <-> "sha256sig0" ^ spc(()) ^ reg_name(rd) ^ sep(()) ^ reg_name(rs1),
  SHA256SIG1(rs1, rd) <-> "sha256sig1" ^ spc(()) ^ reg_name(rd) ^ sep(()) ^ reg_name(rs1),
  SHA256SUM0(rs1, rd) <-> "sha256sum0" ^ spc(()) ^ reg_name(rd) ^ sep(()) ^ reg_name(rs1),
  SHA256SUM1(rs1, rd) <-> "sha256sum1" ^ spc(()) ^ reg_name(rd) ^ sep(()) ^ reg_name(rs1),
  AES32ESMI(bs, rs2, rs1, rd) <-> "aes32esmi" ^ spc(()) ^ reg_name(rd) ^ sep(()) ^ reg_name(rs1) ^ sep(()) ^ reg_name(rs2) ^ sep(()) ^ hex_bits_2(bs),
  AES32ESI(bs, rs2, rs1, rd) <-> "aes32esi" ^ spc(()) ^ reg_name(rd) ^ sep(()) ^ reg_name(rs1) ^ sep(()) ^ reg_name(rs2) ^ sep(()) ^ hex_bits_2(bs),
  AES32DSMI(bs, rs2, rs1, rd) <-> "aes32dsmi" ^ spc(()) ^ reg_name(rd) ^ sep(()) ^ reg_name(rs1) ^ sep(()) ^ reg_name(rs2) ^ sep(()) ^ hex_bits_2(bs),
  AES32DSI(bs, rs2, rs1, rd) <-> "aes32dsi" ^ spc(()) ^ reg_name(rd) ^ sep(()) ^ reg_name(rs1) ^ sep(()) ^ reg_name(rs2) ^ sep(()) ^ hex_bits_2(bs),
  SHA512SIG0L(rs2, rs1, rd) <-> "sha512sig0l" ^ spc(()) ^ reg_name(rd) ^ sep(()) ^ reg_name(rs1) ^ sep(()) ^ reg_name(rs2),
  SHA512SIG0H(rs2, rs1, rd) <-> "sha512sig0h" ^ spc(()) ^ reg_name(rd) ^ sep(()) ^ reg_name(rs1) ^ sep(()) ^ reg_name(rs2),
  SHA512SIG1L(rs2, rs1, rd) <-> "sha512sig1l" ^ spc(()) ^ reg_name(rd) ^ sep(()) ^ reg_name(rs1) ^ sep(()) ^ reg_name(rs2),
  SHA512SIG1H(rs2, rs1, rd) <-> "sha512sig1h" ^ spc(()) ^ reg_name(rd) ^ sep(()) ^ reg_name(rs1) ^ sep(()) ^ reg_name(rs2),
  SHA512SUM0R(rs2, rs1, rd) <-> "sha512sum0r" ^ spc(()) ^ reg_name(rd) ^ sep(()) ^ reg_name(rs1) ^ sep(()) ^ reg_name(rs2),
  SHA512SUM1R(rs2, rs1, rd) <-> "sha512sum1r" ^ spc(()) ^ reg_name(rd) ^ sep(()) ^ reg_name(rs1) ^ sep(()) ^ reg_name(rs2),
  AES64KS1I(rnum, rs1, rd) <-> "aes64ks1i" ^ spc(()) ^ reg_name(rd) ^ sep(()) ^ reg_name(rs1) ^ sep(()) ^ hex_bits_4(rnum),
  AES64KS2(rs2, rs1, rd) <-> "aes64ks2" ^ spc(()) ^ reg_name(rd) ^ sep(()) ^ reg_name(rs1) ^ sep(()) ^ reg_name(rs2),
  AES64IM(rs1, rd) <-> "aes64im" ^ spc(()) ^ reg_name(rd) ^ sep(()) ^ reg_name(rs1),
  AES64ESM(rs2, rs1, rd) <-> "aes64esm" ^ spc(()) ^ reg_name(rd) ^ sep(()) ^ reg_name(rs1) ^ sep(()) ^ reg_name(rs2),
  AES64ES(rs2, rs1, rd) <-> "aes64es" ^ spc(()) ^ reg_name(rd) ^ sep(()) ^ reg_name(rs1) ^ sep(()) ^ reg_name(rs2),
  AES64DSM(rs2, rs1, rd) <-> "aes64dsm" ^ spc(()) ^ reg_name(rd) ^ sep(()) ^ reg_name(rs1) ^ sep(()) ^ reg_name(rs2),
  AES64DS(rs2, rs1, rd) <-> "aes64ds" ^ spc(()) ^ reg_name(rd) ^ sep(()) ^ reg_name(rs1) ^ sep(()) ^ reg_name(rs2),
  SHA512SIG0(rs1, rd) <-> "sha512sig0" ^ spc(()) ^ reg_name(rd) ^ sep(()) ^ reg_name(rs1),
  SHA512SIG1(rs1, rd) <-> "sha512sig1" ^ spc(()) ^ reg_name(rd) ^ sep(()) ^ reg_name(rs1),
  SHA512SUM0(rs1, rd) <-> "sha512sum0" ^ spc(()) ^ reg_name(rd) ^ sep(()) ^ reg_name(rs1),
  SHA512SUM1(rs1, rd) <-> "sha512sum1" ^ spc(()) ^ reg_name(rd) ^ sep(()) ^ reg_name(rs1),
  SM3P0(rs1, rd) <-> "sm3p0" ^ spc(()) ^ reg_name(rd) ^ sep(()) ^ reg_name(rs1),
  SM3P1(rs1, rd) <-> "sm3p1" ^ spc(()) ^ reg_name(rd) ^ sep(()) ^ reg_name(rs1),
  SM4ED(bs, rs2, rs1, rd) <-> "sm4ed" ^ spc(()) ^ reg_name(rd) ^ sep(()) ^ reg_name(rs1) ^ sep(()) ^ reg_name(rs2) ^ sep(()) ^ hex_bits_2(bs),
  SM4KS(bs, rs2, rs1, rd) <-> "sm4ks" ^ spc(()) ^ reg_name(rd) ^ sep(()) ^ reg_name(rs1) ^ sep(()) ^ reg_name(rs2) ^ sep(()) ^ hex_bits_2(bs),
  ZBKB_RTYPE(rs2, rs1, rd, op) <-> zbkb_rtype_mnemonic(op) ^ spc(()) ^ reg_name(rd) ^ sep(()) ^ reg_name(rs1) ^ sep(()) ^ reg_name(rs2),
  ZBKB_PACKW(rs2, rs1, rd) <-> "packw" ^ spc(()) ^ reg_name(rd) ^ sep(()) ^ reg_name(rs1) ^ sep(()) ^ reg_name(rs2),
  ZIP(rs1, rd) <-> "zip" ^ spc(()) ^ reg_name(rd) ^ sep(()) ^ reg_name(rs1),
  UNZIP(rs1, rd) <-> "unzip" ^ spc(()) ^ reg_name(rd) ^ sep(()) ^ reg_name(rs1),
  BREV8(rs1, rd) <-> "brev8" ^ spc(()) ^ reg_name(rd) ^ sep(()) ^ reg_name(rs1),
  XPERM8(rs2, rs1, rd) <-> "xperm8" ^ spc(()) ^ reg_name(rd) ^ sep(()) ^ reg_name(rs1) ^ sep(()) ^ reg_name(rs2),
  XPERM4(rs2, rs1, rd) <-> "xperm4" ^ spc(()) ^ reg_name(rd) ^ sep(()) ^ reg_name(rs1) ^ sep(()) ^ reg_name(rs2),
  VANDN_VV(vm, vs1, vs2, vd) <-> "vandn.vv" ^ spc(()) ^ vreg_name(vd) ^ sep(()) ^ vreg_name(vs2) ^ sep(()) ^ vreg_name(vs1) ^ maybe_vmask(vm),
  VANDN_VX(vm, vs2, rs1, vd) <-> "vandn.vx" ^ spc(()) ^ vreg_name(vd) ^ sep(()) ^ vreg_name(vs2) ^ sep(()) ^ reg_name(rs1) ^ maybe_vmask(vm),
  VBREV_V(vm, vs2, vd) <-> "vbrev.v" ^ spc(()) ^ vreg_name(vd) ^ sep(()) ^ vreg_name(vs2) ^ maybe_vmask(vm),
  VBREV8_V(vm, vs2, vd) <-> "vbrev8.v" ^ spc(()) ^ vreg_name(vd) ^ sep(()) ^ vreg_name(vs2) ^ maybe_vmask(vm),
  VREV8_V(vm, vs2, vd) <-> "vrev8.v" ^ spc(()) ^ vreg_name(vd) ^ sep(()) ^ vreg_name(vs2) ^ maybe_vmask(vm),
  VCLZ_V(vm, vs2, vd) <-> "vclz.v" ^ spc(()) ^ vreg_name(vd) ^ sep(()) ^ vreg_name(vs2) ^ maybe_vmask(vm),
  VCTZ_V(vm, vs2, vd) <-> "vctz.v" ^ spc(()) ^ vreg_name(vd) ^ sep(()) ^ vreg_name(vs2) ^ maybe_vmask(vm),
  VCPOP_V(vm, vs2, vd) <-> "vcpop.v" ^ spc(()) ^ vreg_name(vd) ^ sep(()) ^ vreg_name(vs2) ^ maybe_vmask(vm),
  VROL_VV(vm, vs1, vs2, vd) <-> "vrol.vv" ^ spc(()) ^ vreg_name(vd) ^ sep(()) ^ vreg_name(vs2) ^ sep(()) ^ vreg_name(vs1) ^ maybe_vmask(vm),
  VROL_VX(vm, vs2, rs1, vd) <-> "vrol.vx" ^ spc(()) ^ vreg_name(vd) ^ sep(()) ^ vreg_name(vs2) ^ sep(()) ^ reg_name(rs1) ^ maybe_vmask(vm),
  VROR_VV(vm, vs1, vs2, vd) <-> "vror.vv" ^ spc(()) ^ vreg_name(vd) ^ sep(()) ^ vreg_name(vs2) ^ sep(()) ^ vreg_name(vs1) ^ maybe_vmask(vm),
  VROR_VX(vm, vs2, rs1, vd) <-> "vror.vx" ^ spc(()) ^ vreg_name(vd) ^ sep(()) ^ vreg_name(vs2) ^ sep(()) ^ reg_name(rs1) ^ maybe_vmask(vm),
  VROR_VI(vm, vs2, uimm, vd) <-> "vror.vi" ^ spc(()) ^ vreg_name(vd) ^ sep(()) ^ vreg_name(vs2) ^ sep(()) ^ hex_bits_6(uimm) ^ maybe_vmask(vm),
  VWSLL_VV(vm, vs2, vs1, vd) <-> "vwsll.vv" ^ spc(()) ^ vreg_name(vd) ^ sep(()) ^ vreg_name(vs2) ^ sep(()) ^ vreg_name(vs1) ^ maybe_vmask(vm),
  VWSLL_VX(vm, vs2, rs1, vd) <-> "vwsll.vx" ^ spc(()) ^ vreg_name(vd) ^ sep(()) ^ vreg_name(vs2) ^ sep(()) ^ reg_name(rs1) ^ maybe_vmask(vm),
  VWSLL_VI(vm, vs2, uimm, vd) <-> "vwsll.vi" ^ spc(()) ^ vreg_name(vd) ^ sep(()) ^ vreg_name(vs2) ^ sep(()) ^ hex_bits_5(uimm) ^ maybe_vmask(vm),
  VCLMUL_VV(vm, vs2, vs1, vd) <-> "vclmul.vv" ^ spc(()) ^ vreg_name(vd) ^ sep(()) ^ vreg_name(vs2) ^ sep(()) ^ vreg_name(vs1) ^ maybe_vmask(vm),
  VCLMUL_VX(vm, vs2, rs1, vd) <-> "vclmul.vx" ^ spc(()) ^ vreg_name(vd) ^ sep(()) ^ vreg_name(vs2) ^ sep(()) ^ reg_name(rs1) ^ maybe_vmask(vm),
  VCLMULH_VV(vm, vs2, vs1, vd) <-> "vclmulh.vv" ^ spc(()) ^ vreg_name(vd) ^ sep(()) ^ vreg_name(vs2) ^ sep(()) ^ vreg_name(vs1) ^ maybe_vmask(vm),
  VCLMULH_VX(vm, vs2, rs1, vd) <-> "vclmulh.vx" ^ spc(()) ^ vreg_name(vd) ^ sep(()) ^ vreg_name(vs2) ^ sep(()) ^ reg_name(rs1) ^ maybe_vmask(vm),
  VGHSH_VV(vs2, vs1, vd) <-> "vghsh.vv" ^ spc(()) ^ vreg_name(vd) ^ sep(()) ^ vreg_name(vs2) ^ sep(()) ^ vreg_name(vs1),
  VGMUL_VV(vs2, vd) <-> "vgmul.vv" ^ spc(()) ^ vreg_name(vd) ^ sep(()) ^ vreg_name(vs2),
  VAESDF(funct6, vs2, vd) <-> vaesdf_mnemonic(funct6) ^ spc(()) ^ vreg_name(vd) ^ sep(()) ^ vreg_name(vs2),
  VAESDM(funct6, vs2, vd) <-> vaesdm_mnemonic(funct6) ^ spc(()) ^ vreg_name(vd) ^ sep(()) ^ vreg_name(vs2),
  VAESEF(funct6, vs2, vd) <-> vaesef_mnemonic(funct6) ^ spc(()) ^ vreg_name(vd) ^ sep(()) ^ vreg_name(vs2),
  VAESEM(funct6, vs2, vd) <-> vaesem_mnemonic(funct6) ^ spc(()) ^ vreg_name(vd) ^ sep(()) ^ vreg_name(vs2),
  VAESKF1_VI(vs2, rnd, vd) <-> "vaeskf1.vi" ^ spc(()) ^ vreg_name(vd) ^ sep(()) ^ vreg_name(vs2) ^ sep(()) ^ hex_bits_5(rnd),
  VAESKF2_VI(vs2, rnd, vd) <-> "vaeskf2.vi" ^ spc(()) ^ vreg_name(vd) ^ sep(()) ^ vreg_name(vs2) ^ sep(()) ^ hex_bits_5(rnd),
  VAESZ_VS(vs2, vd) <-> "vaesz.vs" ^ spc(()) ^ vreg_name(vd) ^ sep(()) ^ vreg_name(vs2),
  VSM4K_VI(vs2, uimm, vd) <-> "vsm4k.vi" ^ spc(()) ^ vreg_name(vd) ^ sep(()) ^ vreg_name(vs2) ^ sep(()) ^ hex_bits_5(uimm),
  ZVKSM4RTYPE(funct6, vs2, vd) <-> vsm4r_mnemonic(funct6) ^ spc(()) ^ vreg_name(vd) ^ sep(()) ^ vreg_name(vs2),
  VSHA2MS_VV(vs2, vs1, vd) <-> "vsha2ms.vv" ^ spc(()) ^ vreg_name(vd) ^ sep(()) ^ vreg_name(vs2) ^ sep(()) ^ vreg_name(vs1),
  ZVKSHA2TYPE(funct6, vs2, vs1, vd) <-> vsha2_mnemonic(funct6) ^ spc(()) ^ vreg_name(vd) ^ sep(()) ^ vreg_name(vs2) ^ sep(()) ^ vreg_name(vs1),
  VSM3ME_VV(vs2, vs1, vd) <-> "vsm3me.vv" ^ spc(()) ^ vreg_name(vd) ^ sep(()) ^ vreg_name(vs2) ^ sep(()) ^ vreg_name(vs1),
  VSM3C_VI(vs2, uimm, vd) <-> "vsm3c.vi" ^ spc(()) ^ vreg_name(vd) ^ sep(()) ^ vreg_name(vs2) ^ sep(()) ^ hex_bits_5(uimm),
  CSRImm(csr, imm, rd, op) <-> csr_mnemonic(op) ^ "i" ^ spc(()) ^ reg_name(rd) ^ sep(()) ^ csr_name_map(csr) ^ sep(()) ^ hex_bits_5(imm),
  CSRReg(csr, rs1, rd, op) <-> csr_mnemonic(op) ^ spc(()) ^ reg_name(rd) ^ sep(()) ^ csr_name_map(csr) ^ sep(()) ^ reg_name(rs1),
  SINVAL_VMA(rs1, rs2) <-> "sinval.vma" ^ spc(()) ^ reg_name(rs1) ^ sep(()) ^ reg_name(rs2),
  SFENCE_W_INVAL(()) <-> "sfence.w.inval",
  SFENCE_INVAL_IR(()) <-> "sfence.inval.ir",
  WRS(WRS_STO) <-> "wrs.sto",
  WRS(WRS_NTO) <-> "wrs.nto",
  ZICOND_RTYPE(rs2, rs1, rd, op) <-> zicond_mnemonic(op) ^ spc(()) ^ reg_name(rd) ^ sep(()) ^ reg_name(rs1) ^ sep(()) ^ reg_name(rs2),
  ZICBOM(cbop, rs1) <-> cbop_mnemonic(cbop) ^ spc(()) ^ "(" ^ opt_spc(()) ^ reg_name(rs1) ^ opt_spc(()) ^ ")",
  ZICBOZ(rs1) <-> "cbo.zero" ^ spc(()) ^ "(" ^ opt_spc(()) ^ reg_name(rs1) ^ opt_spc(()) ^ ")",
  FENCEI(()) <-> "fence.i",
  FCVT_BF16_S(rs1, rm, rd) <-> "fcvt.bf16.s" ^ spc(()) ^ freg_name(rd) ^ sep(()) ^ freg_name(rs1) ^ sep(()) ^ frm_mnemonic(rm),
  FCVT_S_BF16(rs1, rm, rd) <-> "fcvt.s.bf16" ^ spc(()) ^ freg_name(rd) ^ sep(()) ^ freg_name(rs1) ^ sep(()) ^ frm_mnemonic(rm),
  ZIMOP_MOP_R(mop, rs1, rd) <-> "mop.r." ^ dec_bits_5(mop) ^ spc(()) ^ reg_name(rd) ^ sep(()) ^ reg_name(rs1),
  ZIMOP_MOP_RR(mop, rs2, rs1, rd) <-> "mop.rr." ^ dec_bits_3(mop) ^ spc(()) ^ reg_name(rd) ^ sep(()) ^ reg_name(rs1) ^ sep(()) ^ reg_name(rs2),
  ZCMOP(mop) <-> "c.mop." ^ dec_bits_4((mop : bitvector(3)) @ 0b1),
  ILLEGAL(s) <-> "illegal" ^ spc(()) ^ hex_bits_32(s),
  C_ILLEGAL(s) <-> "c.illegal" ^ spc(()) ^ hex_bits_16(s)
}

val print_insn : instruction -> string

$[complete]
function print_insn insn = assembly_forwards(insn)

overload to_str = {print_insn}

mapping csr_name_map = {
  0x301 <-> "misa",
  0x300 <-> "mstatus",
  0x310 <-> "mstatush",
  0x747 <-> "mseccfg",
  0x757 <-> "mseccfgh",
  0x30A <-> "menvcfg",
  0x31A <-> "menvcfgh",
  0x10A <-> "senvcfg",
  0x304 <-> "mie",
  0x344 <-> "mip",
  0x302 <-> "medeleg",
  0x312 <-> "medelegh",
  0x303 <-> "mideleg",
  0x342 <-> "mcause",
  0x343 <-> "mtval",
  0x340 <-> "mscratch",
  0x106 <-> "scounteren",
  0x306 <-> "mcounteren",
  0x320 <-> "mcountinhibit",
  0xF11 <-> "mvendorid",
  0xF12 <-> "marchid",
  0xF13 <-> "mimpid",
  0xF14 <-> "mhartid",
  0xF15 <-> "mconfigptr",
  0x100 <-> "sstatus",
  0x144 <-> "sip",
  0x104 <-> "sie",
  0x140 <-> "sscratch",
  0x142 <-> "scause",
  0x143 <-> "stval",
  0x7a0 <-> "tselect",
  0x7a1 <-> "tdata1",
  0x7a2 <-> "tdata2",
  0x7a3 <-> "tdata3",
  0x105 <-> "stvec",
  0x141 <-> "sepc",
  0x305 <-> "mtvec",
  0x341 <-> "mepc",
  0x3A0 <-> "pmpcfg0",
  0x3A1 <-> "pmpcfg1",
  0x3A2 <-> "pmpcfg2",
  0x3A3 <-> "pmpcfg3",
  0x3A4 <-> "pmpcfg4",
  0x3A5 <-> "pmpcfg5",
  0x3A6 <-> "pmpcfg6",
  0x3A7 <-> "pmpcfg7",
  0x3A8 <-> "pmpcfg8",
  0x3A9 <-> "pmpcfg9",
  0x3AA <-> "pmpcfg10",
  0x3AB <-> "pmpcfg11",
  0x3AC <-> "pmpcfg12",
  0x3AD <-> "pmpcfg13",
  0x3AE <-> "pmpcfg14",
  0x3AF <-> "pmpcfg15",
  0x3B0 <-> "pmpaddr0",
  0x3B1 <-> "pmpaddr1",
  0x3B2 <-> "pmpaddr2",
  0x3B3 <-> "pmpaddr3",
  0x3B4 <-> "pmpaddr4",
  0x3B5 <-> "pmpaddr5",
  0x3B6 <-> "pmpaddr6",
  0x3B7 <-> "pmpaddr7",
  0x3B8 <-> "pmpaddr8",
  0x3B9 <-> "pmpaddr9",
  0x3BA <-> "pmpaddr10",
  0x3BB <-> "pmpaddr11",
  0x3BC <-> "pmpaddr12",
  0x3BD <-> "pmpaddr13",
  0x3BE <-> "pmpaddr14",
  0x3BF <-> "pmpaddr15",
  0x3C0 <-> "pmpaddr16",
  0x3C1 <-> "pmpaddr17",
  0x3C2 <-> "pmpaddr18",
  0x3C3 <-> "pmpaddr19",
  0x3C4 <-> "pmpaddr20",
  0x3C5 <-> "pmpaddr21",
  0x3C6 <-> "pmpaddr22",
  0x3C7 <-> "pmpaddr23",
  0x3C8 <-> "pmpaddr24",
  0x3C9 <-> "pmpaddr25",
  0x3CA <-> "pmpaddr26",
  0x3CB <-> "pmpaddr27",
  0x3CC <-> "pmpaddr28",
  0x3CD <-> "pmpaddr29",
  0x3CE <-> "pmpaddr30",
  0x3CF <-> "pmpaddr31",
  0x3D0 <-> "pmpaddr32",
  0x3D1 <-> "pmpaddr33",
  0x3D2 <-> "pmpaddr34",
  0x3D3 <-> "pmpaddr35",
  0x3D4 <-> "pmpaddr36",
  0x3D5 <-> "pmpaddr37",
  0x3D6 <-> "pmpaddr38",
  0x3D7 <-> "pmpaddr39",
  0x3D8 <-> "pmpaddr40",
  0x3D9 <-> "pmpaddr41",
  0x3DA <-> "pmpaddr42",
  0x3DB <-> "pmpaddr43",
  0x3DC <-> "pmpaddr44",
  0x3DD <-> "pmpaddr45",
  0x3DE <-> "pmpaddr46",
  0x3DF <-> "pmpaddr47",
  0x3E0 <-> "pmpaddr48",
  0x3E1 <-> "pmpaddr49",
  0x3E2 <-> "pmpaddr50",
  0x3E3 <-> "pmpaddr51",
  0x3E4 <-> "pmpaddr52",
  0x3E5 <-> "pmpaddr53",
  0x3E6 <-> "pmpaddr54",
  0x3E7 <-> "pmpaddr55",
  0x3E8 <-> "pmpaddr56",
  0x3E9 <-> "pmpaddr57",
  0x3EA <-> "pmpaddr58",
  0x3EB <-> "pmpaddr59",
  0x3EC <-> "pmpaddr60",
  0x3ED <-> "pmpaddr61",
  0x3EE <-> "pmpaddr62",
  0x3EF <-> "pmpaddr63",
  0x001 <-> "fflags",
  0x002 <-> "frm",
  0x003 <-> "fcsr",
  0x008 <-> "vstart",
  0x009 <-> "vxsat",
  0x00A <-> "vxrm",
  0x00F <-> "vcsr",
  0xC20 <-> "vl",
  0xC21 <-> "vtype",
  0xC22 <-> "vlenb",
  0x321 <-> "mcyclecfg",
  0x721 <-> "mcyclecfgh",
  0x322 <-> "minstretcfg",
  0x722 <-> "minstretcfgh",
  0x180 <-> "satp",
  0x015 <-> "seed",
  0xC03 <-> "hpmcounter3",
  0xC04 <-> "hpmcounter4",
  0xC05 <-> "hpmcounter5",
  0xC06 <-> "hpmcounter6",
  0xC07 <-> "hpmcounter7",
  0xC08 <-> "hpmcounter8",
  0xC09 <-> "hpmcounter9",
  0xC0A <-> "hpmcounter10",
  0xC0B <-> "hpmcounter11",
  0xC0C <-> "hpmcounter12",
  0xC0D <-> "hpmcounter13",
  0xC0E <-> "hpmcounter14",
  0xC0F <-> "hpmcounter15",
  0xC10 <-> "hpmcounter16",
  0xC11 <-> "hpmcounter17",
  0xC12 <-> "hpmcounter18",
  0xC13 <-> "hpmcounter19",
  0xC14 <-> "hpmcounter20",
  0xC15 <-> "hpmcounter21",
  0xC16 <-> "hpmcounter22",
  0xC17 <-> "hpmcounter23",
  0xC18 <-> "hpmcounter24",
  0xC19 <-> "hpmcounter25",
  0xC1A <-> "hpmcounter26",
  0xC1B <-> "hpmcounter27",
  0xC1C <-> "hpmcounter28",
  0xC1D <-> "hpmcounter29",
  0xC1E <-> "hpmcounter30",
  0xC1F <-> "hpmcounter31",
  0xC83 <-> "hpmcounter3h",
  0xC84 <-> "hpmcounter4h",
  0xC85 <-> "hpmcounter5h",
  0xC86 <-> "hpmcounter6h",
  0xC87 <-> "hpmcounter7h",
  0xC88 <-> "hpmcounter8h",
  0xC89 <-> "hpmcounter9h",
  0xC8A <-> "hpmcounter10h",
  0xC8B <-> "hpmcounter11h",
  0xC8C <-> "hpmcounter12h",
  0xC8D <-> "hpmcounter13h",
  0xC8E <-> "hpmcounter14h",
  0xC8F <-> "hpmcounter15h",
  0xC90 <-> "hpmcounter16h",
  0xC91 <-> "hpmcounter17h",
  0xC92 <-> "hpmcounter18h",
  0xC93 <-> "hpmcounter19h",
  0xC94 <-> "hpmcounter20h",
  0xC95 <-> "hpmcounter21h",
  0xC96 <-> "hpmcounter22h",
  0xC97 <-> "hpmcounter23h",
  0xC98 <-> "hpmcounter24h",
  0xC99 <-> "hpmcounter25h",
  0xC9A <-> "hpmcounter26h",
  0xC9B <-> "hpmcounter27h",
  0xC9C <-> "hpmcounter28h",
  0xC9D <-> "hpmcounter29h",
  0xC9E <-> "hpmcounter30h",
  0xC9F <-> "hpmcounter31h",
  0x323 <-> "mhpmevent3",
  0x324 <-> "mhpmevent4",
  0x325 <-> "mhpmevent5",
  0x326 <-> "mhpmevent6",
  0x327 <-> "mhpmevent7",
  0x328 <-> "mhpmevent8",
  0x329 <-> "mhpmevent9",
  0x32A <-> "mhpmevent10",
  0x32B <-> "mhpmevent11",
  0x32C <-> "mhpmevent12",
  0x32D <-> "mhpmevent13",
  0x32E <-> "mhpmevent14",
  0x32F <-> "mhpmevent15",
  0x330 <-> "mhpmevent16",
  0x331 <-> "mhpmevent17",
  0x332 <-> "mhpmevent18",
  0x333 <-> "mhpmevent19",
  0x334 <-> "mhpmevent20",
  0x335 <-> "mhpmevent21",
  0x336 <-> "mhpmevent22",
  0x337 <-> "mhpmevent23",
  0x338 <-> "mhpmevent24",
  0x339 <-> "mhpmevent25",
  0x33A <-> "mhpmevent26",
  0x33B <-> "mhpmevent27",
  0x33C <-> "mhpmevent28",
  0x33D <-> "mhpmevent29",
  0x33E <-> "mhpmevent30",
  0x33F <-> "mhpmevent31",
  0xB03 <-> "mhpmcounter3",
  0xB04 <-> "mhpmcounter4",
  0xB05 <-> "mhpmcounter5",
  0xB06 <-> "mhpmcounter6",
  0xB07 <-> "mhpmcounter7",
  0xB08 <-> "mhpmcounter8",
  0xB09 <-> "mhpmcounter9",
  0xB0A <-> "mhpmcounter10",
  0xB0B <-> "mhpmcounter11",
  0xB0C <-> "mhpmcounter12",
  0xB0D <-> "mhpmcounter13",
  0xB0E <-> "mhpmcounter14",
  0xB0F <-> "mhpmcounter15",
  0xB10 <-> "mhpmcounter16",
  0xB11 <-> "mhpmcounter17",
  0xB12 <-> "mhpmcounter18",
  0xB13 <-> "mhpmcounter19",
  0xB14 <-> "mhpmcounter20",
  0xB15 <-> "mhpmcounter21",
  0xB16 <-> "mhpmcounter22",
  0xB17 <-> "mhpmcounter23",
  0xB18 <-> "mhpmcounter24",
  0xB19 <-> "mhpmcounter25",
  0xB1A <-> "mhpmcounter26",
  0xB1B <-> "mhpmcounter27",
  0xB1C <-> "mhpmcounter28",
  0xB1D <-> "mhpmcounter29",
  0xB1E <-> "mhpmcounter30",
  0xB1F <-> "mhpmcounter31",
  0xB83 <-> "mhpmcounter3h",
  0xB84 <-> "mhpmcounter4h",
  0xB85 <-> "mhpmcounter5h",
  0xB86 <-> "mhpmcounter6h",
  0xB87 <-> "mhpmcounter7h",
  0xB88 <-> "mhpmcounter8h",
  0xB89 <-> "mhpmcounter9h",
  0xB8A <-> "mhpmcounter10h",
  0xB8B <-> "mhpmcounter11h",
  0xB8C <-> "mhpmcounter12h",
  0xB8D <-> "mhpmcounter13h",
  0xB8E <-> "mhpmcounter14h",
  0xB8F <-> "mhpmcounter15h",
  0xB90 <-> "mhpmcounter16h",
  0xB91 <-> "mhpmcounter17h",
  0xB92 <-> "mhpmcounter18h",
  0xB93 <-> "mhpmcounter19h",
  0xB94 <-> "mhpmcounter20h",
  0xB95 <-> "mhpmcounter21h",
  0xB96 <-> "mhpmcounter22h",
  0xB97 <-> "mhpmcounter23h",
  0xB98 <-> "mhpmcounter24h",
  0xB99 <-> "mhpmcounter25h",
  0xB9A <-> "mhpmcounter26h",
  0xB9B <-> "mhpmcounter27h",
  0xB9C <-> "mhpmcounter28h",
  0xB9D <-> "mhpmcounter29h",
  0xB9E <-> "mhpmcounter30h",
  0xB9F <-> "mhpmcounter31h",
  0x723 <-> "mhpmevent3h",
  0x724 <-> "mhpmevent4h",
  0x725 <-> "mhpmevent5h",
  0x726 <-> "mhpmevent6h",
  0x727 <-> "mhpmevent7h",
  0x728 <-> "mhpmevent8h",
  0x729 <-> "mhpmevent9h",
  0x72A <-> "mhpmevent10h",
  0x72B <-> "mhpmevent11h",
  0x72C <-> "mhpmevent12h",
  0x72D <-> "mhpmevent13h",
  0x72E <-> "mhpmevent14h",
  0x72F <-> "mhpmevent15h",
  0x730 <-> "mhpmevent16h",
  0x731 <-> "mhpmevent17h",
  0x732 <-> "mhpmevent18h",
  0x733 <-> "mhpmevent19h",
  0x734 <-> "mhpmevent20h",
  0x735 <-> "mhpmevent21h",
  0x736 <-> "mhpmevent22h",
  0x737 <-> "mhpmevent23h",
  0x738 <-> "mhpmevent24h",
  0x739 <-> "mhpmevent25h",
  0x73A <-> "mhpmevent26h",
  0x73B <-> "mhpmevent27h",
  0x73C <-> "mhpmevent28h",
  0x73D <-> "mhpmevent29h",
  0x73E <-> "mhpmevent30h",
  0x73F <-> "mhpmevent31h",
  0xDA0 <-> "scountovf",
  0x14D <-> "stimecmp",
  0x15D <-> "stimecmph",
  0xC00 <-> "cycle",
  0xC01 <-> "time",
  0xC02 <-> "instret",
  0xC80 <-> "cycleh",
  0xC81 <-> "timeh",
  0xC82 <-> "instreth",
  0xB00 <-> "mcycle",
  0xB02 <-> "minstret",
  0xB80 <-> "mcycleh",
  0xB82 <-> "minstreth",
  reg <-> hex_bits_12(reg)
}

$[complete]
function is_CSR_accessible (0x301, _, _) = true
and is_CSR_accessible (0x300, _, _) = true
and is_CSR_accessible (0x310, _, _) = $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 32)
and is_CSR_accessible (0x747, _, _) = currentlyEnabled(Ext_Zkr)
and is_CSR_accessible (0x757, _, _) = $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zkr), $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 32))
and is_CSR_accessible (0x30A, _, _) = currentlyEnabled(Ext_U)
and is_CSR_accessible (0x31A, _, _) = $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_U), $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 32))
and is_CSR_accessible (0x10A, _, _) = currentlyEnabled(Ext_S)
and is_CSR_accessible (0x304, _, _) = true
and is_CSR_accessible (0x344, _, _) = true
and is_CSR_accessible (0x302, _, _) = currentlyEnabled(Ext_S)
and is_CSR_accessible (0x312, _, _) = $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_S), $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 32))
and is_CSR_accessible (0x303, _, _) = currentlyEnabled(Ext_S)
and is_CSR_accessible (0x342, _, _) = true
and is_CSR_accessible (0x343, _, _) = true
and is_CSR_accessible (0x340, _, _) = true
and is_CSR_accessible (0x106, _, _) = currentlyEnabled(Ext_S)
and is_CSR_accessible (0x306, _, _) = currentlyEnabled(Ext_U)
and is_CSR_accessible (0x320, _, _) = true
and is_CSR_accessible (0xf11, _, _) = true
and is_CSR_accessible (0xf12, _, _) = true
and is_CSR_accessible (0xf13, _, _) = true
and is_CSR_accessible (0xf14, _, _) = true
and is_CSR_accessible (0xf15, _, _) = true
and is_CSR_accessible (0x100, _, _) = currentlyEnabled(Ext_S)
and is_CSR_accessible (0x144, _, _) = currentlyEnabled(Ext_S)
and is_CSR_accessible (0x104, _, _) = currentlyEnabled(Ext_S)
and is_CSR_accessible (0x140, _, _) = currentlyEnabled(Ext_S)
and is_CSR_accessible (0x142, _, _) = currentlyEnabled(Ext_S)
and is_CSR_accessible (0x143, _, _) = currentlyEnabled(Ext_S)
and is_CSR_accessible (0x7a0, _, _) = true
and is_CSR_accessible (0x105, _, _) = currentlyEnabled(Ext_S)
and is_CSR_accessible (0x141, _, _) = currentlyEnabled(Ext_S)
and is_CSR_accessible (0x305, _, _) = true
and is_CSR_accessible (0x341, _, _) = true
and is_CSR_accessible ((0x3A @ idx : bits(4)), _, _) = $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = ">", "is_infix" = true }] gt_int(sys_pmp_count, $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(4, unsigned(idx))), $[overloaded { "name" = "|", "is_infix" = true }] or_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(idx, 0), bitzero), $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 32)))
and is_CSR_accessible ((0x3B @ idx : bits(4)), _, _) = $[overloaded { "name" = ">", "is_infix" = true }] gt_int(sys_pmp_count, unsigned($[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(0b00, idx)))
and is_CSR_accessible ((0x3C @ idx : bits(4)), _, _) = $[overloaded { "name" = ">", "is_infix" = true }] gt_int(sys_pmp_count, unsigned($[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(0b01, idx)))
and is_CSR_accessible ((0x3D @ idx : bits(4)), _, _) = $[overloaded { "name" = ">", "is_infix" = true }] gt_int(sys_pmp_count, unsigned($[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(0b10, idx)))
and is_CSR_accessible ((0x3E @ idx : bits(4)), _, _) = $[overloaded { "name" = ">", "is_infix" = true }] gt_int(sys_pmp_count, unsigned($[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(0b11, idx)))
and is_CSR_accessible (0x001, _, _) = $[overloaded { "name" = "|", "is_infix" = true }] or_bool(currentlyEnabled(Ext_F), currentlyEnabled(Ext_Zfinx))
and is_CSR_accessible (0x002, _, _) = $[overloaded { "name" = "|", "is_infix" = true }] or_bool(currentlyEnabled(Ext_F), currentlyEnabled(Ext_Zfinx))
and is_CSR_accessible (0x003, _, _) = $[overloaded { "name" = "|", "is_infix" = true }] or_bool(currentlyEnabled(Ext_F), currentlyEnabled(Ext_Zfinx))
and is_CSR_accessible (0x008, _, _) = currentlyEnabled(Ext_V)
and is_CSR_accessible (0x009, _, _) = currentlyEnabled(Ext_V)
and is_CSR_accessible (0x00A, _, _) = currentlyEnabled(Ext_V)
and is_CSR_accessible (0x00F, _, _) = currentlyEnabled(Ext_V)
and is_CSR_accessible (0xC20, _, _) = currentlyEnabled(Ext_V)
and is_CSR_accessible (0xC21, _, _) = currentlyEnabled(Ext_V)
and is_CSR_accessible (0xC22, _, _) = currentlyEnabled(Ext_V)
and is_CSR_accessible (0x321, _, _) = currentlyEnabled(Ext_Smcntrpmf)
and is_CSR_accessible (0x721, _, _) = $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Smcntrpmf), $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 32))
and is_CSR_accessible (0x322, _, _) = currentlyEnabled(Ext_Smcntrpmf)
and is_CSR_accessible (0x722, _, _) = $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Smcntrpmf), $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 32))
and is_CSR_accessible (0x180, priv, _) = $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_S), not($[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_anything(priv, Supervisor), $[overloaded { "name" = "==", "is_infix" = true }] eq_bits(_get_Mstatus_TVM(mstatus), 0b1))))
and is_CSR_accessible (0x015, priv, is_write) = $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zkr), $[overloaded { "name" = "&", "is_infix" = true }] and_bool(is_write, ($[complete] match priv {
  Machine => true,
  Supervisor => $[overloaded { "name" = "==", "is_infix" = true }] eq_bits(_get_Seccfg_SSEED(mseccfg), 0b1),
  User => $[overloaded { "name" = "==", "is_infix" = true }] eq_bits(_get_Seccfg_USEED(mseccfg), 0b1),
  VirtualSupervisor => internal_error("./extensions/K/zkr_control.sail", 52, "Hypervisor extension not supported"),
  VirtualUser => internal_error("./extensions/K/zkr_control.sail", 53, "Hypervisor extension not supported")
}) : bool))
and is_CSR_accessible (((0b0011001 @ index : bits(5)), _, _) if $[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(unsigned(index), 3)) = currentlyEnabled(Ext_Zihpm)
and is_CSR_accessible (((0b1011000 @ index : bits(5)), _, _) if $[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(unsigned(index), 3)) = currentlyEnabled(Ext_Zihpm)
and is_CSR_accessible (((0b1011100 @ index : bits(5)), _, _) if $[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(unsigned(index), 3)) = $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zihpm), $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 32))
and is_CSR_accessible (((0b1100000 @ index : bits(5)), priv, _) if $[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(unsigned(index), 3)) = $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zihpm), $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_U), counter_enabled(unsigned(index), priv)))
and is_CSR_accessible (((0b1100100 @ index : bits(5)), priv, _) if $[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(unsigned(index), 3)) = $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zihpm), $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_U), $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 32), counter_enabled(unsigned(index), priv))))
and is_CSR_accessible (((0b0111001 @ index : bits(5)), _, _) if $[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(unsigned(index), 3)) = $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Sscofpmf), $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 32))
and is_CSR_accessible (0xDA0, _, _) = $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Sscofpmf), currentlyEnabled(Ext_S))
and is_CSR_accessible (0x14D, priv, _) = $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_S), $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Sstc), sstc_CSRs_accessible(priv)))
and is_CSR_accessible (0x15D, priv, _) = $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_S), $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Sstc), $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 32), sstc_CSRs_accessible(priv))))
and is_CSR_accessible (0xC00, priv, _) = $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zicntr), counter_enabled(0, priv))
and is_CSR_accessible (0xC01, priv, _) = $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zicntr), counter_enabled(1, priv))
and is_CSR_accessible (0xC02, priv, _) = $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zicntr), counter_enabled(2, priv))
and is_CSR_accessible (0xC80, priv, _) = $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zicntr), $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 32), counter_enabled(0, priv)))
and is_CSR_accessible (0xC81, priv, _) = $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zicntr), $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 32), counter_enabled(1, priv)))
and is_CSR_accessible (0xC82, priv, _) = $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zicntr), $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 32), counter_enabled(2, priv)))
and is_CSR_accessible (0xB00, _, _) = currentlyEnabled(Ext_Zicntr)
and is_CSR_accessible (0xB02, _, _) = currentlyEnabled(Ext_Zicntr)
and is_CSR_accessible (0xB80, _, _) = $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zicntr), $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 32))
and is_CSR_accessible (0xB82, _, _) = $[overloaded { "name" = "&", "is_infix" = true }] and_bool(currentlyEnabled(Ext_Zicntr), $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 32))
and is_CSR_accessible _ = false

$[complete]
function read_CSR 0x301 = misa.bits
and read_CSR 0x300 = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(mstatus.bits, $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(xlen, 1), 0)
and read_CSR (0x310 if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 32)) = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(mstatus.bits, 63, 32)
and read_CSR 0x747 = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(mseccfg.bits, $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(xlen, 1), 0)
and read_CSR (0x757 if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 32)) = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(mseccfg.bits, 63, 32)
and read_CSR 0x30A = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(menvcfg.bits, $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(xlen, 1), 0)
and read_CSR (0x31A if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 32)) = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(menvcfg.bits, 63, 32)
and read_CSR 0x10A = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(senvcfg.bits, $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(xlen, 1), 0)
and read_CSR 0x304 = mie.bits
and read_CSR 0x344 = mip.bits
and read_CSR 0x302 = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(medeleg.bits, $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(xlen, 1), 0)
and read_CSR (0x312 if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 32)) = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(medeleg.bits, 63, 32)
and read_CSR 0x303 = mideleg.bits
and read_CSR 0x342 = mcause.bits
and read_CSR 0x343 = mtval
and read_CSR 0x340 = mscratch
and read_CSR 0x106 = zero_extend(sizeof(xlen), scounteren.bits)
and read_CSR 0x306 = zero_extend(sizeof(xlen), mcounteren.bits)
and read_CSR 0x320 = zero_extend(sizeof(xlen), mcountinhibit.bits)
and read_CSR 0xF11 = zero_extend(sizeof(xlen), mvendorid)
and read_CSR 0xF12 = marchid
and read_CSR 0xF13 = mimpid
and read_CSR 0xF14 = mhartid
and read_CSR 0xF15 = mconfigptr
and read_CSR 0x100 = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(lower_mstatus(mstatus).bits, $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(xlen, 1), 0)
and read_CSR 0x144 = lower_mip(mip, mideleg).bits
and read_CSR 0x104 = lower_mie(mie, mideleg).bits
and read_CSR 0x140 = sscratch
and read_CSR 0x142 = scause.bits
and read_CSR 0x143 = stval
and read_CSR 0x7a0 = $[overloaded { "name" = "~", "is_infix" = false }] not_vec(tselect)
and read_CSR 0x105 = get_stvec()
and read_CSR 0x141 = get_xepc(Supervisor)
and read_CSR 0x305 = get_mtvec()
and read_CSR 0x341 = get_xepc(Machine)
and read_CSR ((0x3A @ idx : bits(4)) if $[overloaded { "name" = "|", "is_infix" = true }] or_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(idx, 0), bitzero), $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 32))) = pmpReadCfgReg(unsigned(idx))
and read_CSR (0x3B @ idx : bits(4)) = pmpReadAddrReg(unsigned($[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(0b00, idx)))
and read_CSR (0x3C @ idx : bits(4)) = pmpReadAddrReg(unsigned($[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(0b01, idx)))
and read_CSR (0x3D @ idx : bits(4)) = pmpReadAddrReg(unsigned($[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(0b10, idx)))
and read_CSR (0x3E @ idx : bits(4)) = pmpReadAddrReg(unsigned($[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(0b11, idx)))
and read_CSR 0x001 = zero_extend(sizeof(xlen), _get_Fcsr_FFLAGS(fcsr))
and read_CSR 0x002 = zero_extend(sizeof(xlen), _get_Fcsr_FRM(fcsr))
and read_CSR 0x003 = zero_extend(sizeof(xlen), fcsr.bits)
and read_CSR 0x008 = vstart
and read_CSR 0x009 = zero_extend(sizeof(xlen), _get_Vcsr_vxsat(vcsr))
and read_CSR 0x00A = zero_extend(sizeof(xlen), _get_Vcsr_vxrm(vcsr))
and read_CSR 0x00F = zero_extend(sizeof(xlen), vcsr.bits)
and read_CSR 0xC20 = vl
and read_CSR 0xC21 = vtype.bits
and read_CSR 0xC22 = VLENB
and read_CSR 0x321 = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(mcyclecfg.bits, $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(xlen, 1), 0)
and read_CSR (0x721 if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 32)) = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(mcyclecfg.bits, 63, 32)
and read_CSR 0x322 = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(minstretcfg.bits, $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(xlen, 1), 0)
and read_CSR (0x722 if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 32)) = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(minstretcfg.bits, 63, 32)
and read_CSR 0x180 = satp
and read_CSR 0x015 = read_seed_csr()
and read_CSR ((0b0011001 @ index : bits(5)) if $[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(unsigned(index), 3)) = read_mhpmevent(hpmidx_from_bits(index))
and read_CSR ((0b1011000 @ index : bits(5)) if $[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(unsigned(index), 3)) = read_mhpmcounter(hpmidx_from_bits(index))
and read_CSR ((0b1011100 @ index : bits(5)) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 32), gteq_int(unsigned(index), 3) : bool)) = read_mhpmcounterh(hpmidx_from_bits(index))
and read_CSR ((0b1100000 @ index : bits(5)) if $[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(unsigned(index), 3)) = read_mhpmcounter(hpmidx_from_bits(index))
and read_CSR ((0b1100100 @ index : bits(5)) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 32), gteq_int(unsigned(index), 3) : bool)) = read_mhpmcounterh(hpmidx_from_bits(index))
and read_CSR ((0b0111001 @ index : bits(5)) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 32), gteq_int(unsigned(index), 3) : bool)) = read_mhpmeventh(hpmidx_from_bits(index))
and read_CSR 0xDA0 = zero_extend(sizeof(xlen), get_scountovf(cur_privilege))
and read_CSR 0x14D = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(stimecmp, $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(xlen, 1), 0)
and read_CSR (0x15D if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 32)) = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(stimecmp, 63, 32)
and read_CSR 0xC00 = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(mcycle, $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(xlen, 1), 0)
and read_CSR 0xC01 = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(mtime, $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(xlen, 1), 0)
and read_CSR 0xC02 = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(minstret, $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(xlen, 1), 0)
and read_CSR (0xC80 if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 32)) = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(mcycle, 63, 32)
and read_CSR (0xC81 if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 32)) = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(mtime, 63, 32)
and read_CSR (0xC82 if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 32)) = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(minstret, 63, 32)
and read_CSR 0xB00 = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(mcycle, $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(xlen, 1), 0)
and read_CSR 0xB02 = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(minstret, $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(xlen, 1), 0)
and read_CSR (0xB80 if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 32)) = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(mcycle, 63, 32)
and read_CSR (0xB82 if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 32)) = $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(minstret, 63, 32)
and read_CSR csr = {
    internal_error("./postlude/csr_end.sail", 17, $[overloaded { "name" = "^", "is_infix" = true }] concat_str("Read from CSR that does not exist: ", bits_str(csr)))
}

$[complete]
function write_CSR (0x301, value) = {
    misa = legalize_misa(misa, value);
    Ok(misa.bits)
}
and write_CSR ((0x300, value) if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64)) = {
    mstatus = legalize_mstatus(mstatus, value);
    Ok(mstatus.bits)
}
and write_CSR ((0x300, value) if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 32)) = {
    mstatus = legalize_mstatus(mstatus, $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(mstatus.bits, 63, 32), value));
    Ok($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(mstatus.bits, 31, 0))
}
and write_CSR ((0x310, value) if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 32)) = {
    mstatus = legalize_mstatus(mstatus, $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(value, $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(mstatus.bits, 31, 0)));
    Ok($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(mstatus.bits, 63, 32))
}
and write_CSR ((0x747, value) if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 32)) = {
    mseccfg = legalize_mseccfg(mseccfg, $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(mseccfg.bits, 63, 32), value));
    Ok($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(mseccfg.bits, 31, 0))
}
and write_CSR ((0x747, value) if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64)) = {
    mseccfg = legalize_mseccfg(mseccfg, value);
    Ok(mseccfg.bits)
}
and write_CSR ((0x757, value) if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 32)) = {
    mseccfg = legalize_mseccfg(mseccfg, $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(value, $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(mseccfg.bits, 31, 0)));
    Ok($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(mseccfg.bits, 63, 32))
}
and write_CSR ((0x30A, value) if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 32)) = {
    menvcfg = legalize_menvcfg(menvcfg, $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(menvcfg.bits, 63, 32), value));
    Ok($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(menvcfg.bits, 31, 0))
}
and write_CSR ((0x30A, value) if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64)) = {
    menvcfg = legalize_menvcfg(menvcfg, value);
    Ok(menvcfg.bits)
}
and write_CSR ((0x31A, value) if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 32)) = {
    menvcfg = legalize_menvcfg(menvcfg, $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(value, $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(menvcfg.bits, 31, 0)));
    Ok($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(menvcfg.bits, 63, 32))
}
and write_CSR (0x10A, value) = {
    senvcfg = legalize_senvcfg(senvcfg, zero_extend(sizeof(xlen), value));
    Ok($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(senvcfg.bits, $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(xlen, 1), 0))
}
and write_CSR (0x304, value) = {
    mie = legalize_mie(mie, value);
    Ok(mie.bits)
}
and write_CSR (0x344, value) = {
    mip = legalize_mip(mip, value);
    Ok(mip.bits)
}
and write_CSR ((0x302, value) if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64)) = {
    medeleg = legalize_medeleg(medeleg, value);
    Ok(medeleg.bits)
}
and write_CSR ((0x302, value) if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 32)) = {
    medeleg = legalize_medeleg(medeleg, $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(medeleg.bits, 63, 32), value));
    Ok($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(medeleg.bits, 31, 0))
}
and write_CSR ((0x312, value) if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 32)) = {
    medeleg = legalize_medeleg(medeleg, $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(value, $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(medeleg.bits, 31, 0)));
    Ok($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(medeleg.bits, 63, 32))
}
and write_CSR (0x303, value) = {
    mideleg = legalize_mideleg(mideleg, value);
    Ok(mideleg.bits)
}
and write_CSR (0x342, value) = {
    mcause.bits = value;
    Ok(mcause.bits)
}
and write_CSR (0x343, value) = {
    mtval = value;
    Ok(mtval)
}
and write_CSR (0x340, value) = {
    mscratch = value;
    Ok(mscratch)
}
and write_CSR (0x106, value) = {
    scounteren = legalize_scounteren(scounteren, value);
    Ok(zero_extend(sizeof(xlen), scounteren.bits))
}
and write_CSR (0x306, value) = {
    mcounteren = legalize_mcounteren(mcounteren, value);
    Ok(zero_extend(sizeof(xlen), mcounteren.bits))
}
and write_CSR (0x320, value) = {
    mcountinhibit = legalize_mcountinhibit(mcountinhibit, value);
    Ok(zero_extend(sizeof(xlen), mcountinhibit.bits))
}
and write_CSR (0x100, value) = {
    mstatus = legalize_sstatus(mstatus, value);
    Ok($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(lower_mstatus(mstatus).bits, $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(xlen, 1), 0))
}
and write_CSR (0x144, value) = {
    mip = legalize_sip(mip, mideleg, value);
    Ok(lower_mip(mip, mideleg).bits)
}
and write_CSR (0x104, value) = {
    mie = legalize_sie(mie, mideleg, value);
    Ok(lower_mie(mie, mideleg).bits)
}
and write_CSR (0x140, value) = {
    sscratch = value;
    Ok(sscratch)
}
and write_CSR (0x142, value) = {
    scause.bits = value;
    Ok(scause.bits)
}
and write_CSR (0x143, value) = {
    stval = value;
    Ok(stval)
}
and write_CSR (0x7a0, value) = {
    tselect = value;
    Ok(tselect)
}
and write_CSR (0x105, value) = {
    Ok(set_stvec(value))
}
and write_CSR (0x141, value) = {
    Ok(set_xepc(Supervisor, value))
}
and write_CSR (0x305, value) = {
    Ok(set_mtvec(value))
}
and write_CSR (0x341, value) = {
    Ok(set_xepc(Machine, value))
}
and write_CSR (((0x3A @ idx : bits(4)), value) if $[overloaded { "name" = "|", "is_infix" = true }] or_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_bit($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(idx, 0), bitzero), $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 32))) = {
    let idx = unsigned(idx);
    pmpWriteCfgReg(idx, value);
    Ok(pmpReadCfgReg(idx))
}
and write_CSR ((0x3B @ idx : bits(4)), value) = {
    let idx = unsigned($[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(0b00, idx));
    pmpWriteAddrReg(idx, value);
    Ok(pmpReadAddrReg(idx))
}
and write_CSR ((0x3C @ idx : bits(4)), value) = {
    let idx = unsigned($[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(0b01, idx));
    pmpWriteAddrReg(idx, value);
    Ok(pmpReadAddrReg(idx))
}
and write_CSR ((0x3D @ idx : bits(4)), value) = {
    let idx = unsigned($[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(0b10, idx));
    pmpWriteAddrReg(idx, value);
    Ok(pmpReadAddrReg(idx))
}
and write_CSR ((0x3E @ idx : bits(4)), value) = {
    let idx = unsigned($[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(0b11, idx));
    pmpWriteAddrReg(idx, value);
    Ok(pmpReadAddrReg(idx))
}
and write_CSR (0x001, value) = {
    write_fcsr(_get_Fcsr_FRM(fcsr), $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(value, 4, 0));
    Ok(zero_extend(sizeof(xlen), _get_Fcsr_FFLAGS(fcsr)))
}
and write_CSR (0x002, value) = {
    write_fcsr($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(value, 2, 0), _get_Fcsr_FFLAGS(fcsr));
    Ok(zero_extend(sizeof(xlen), _get_Fcsr_FRM(fcsr)))
}
and write_CSR (0x003, value) = {
    write_fcsr($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(value, 7, 5), $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(value, 4, 0));
    Ok(zero_extend(sizeof(xlen), fcsr.bits))
}
and write_CSR (0x008, value) = {
    set_vstart($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(value, 15, 0));
    Ok(vstart)
}
and write_CSR (0x009, value) = {
    ext_write_vcsr(_get_Vcsr_vxrm(vcsr), $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(value, 0, 0));
    Ok(zero_extend(sizeof(xlen), _get_Vcsr_vxsat(vcsr)))
}
and write_CSR (0x00A, value) = {
    ext_write_vcsr($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(value, 1, 0), _get_Vcsr_vxsat(vcsr));
    Ok(zero_extend(sizeof(xlen), _get_Vcsr_vxrm(vcsr)))
}
and write_CSR (0x00F, value) = {
    ext_write_vcsr($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(value, 2, 1), $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(value, 0, 0));
    Ok(zero_extend(sizeof(xlen), vcsr.bits))
}
and write_CSR ((0x321, value) if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64)) = {
    mcyclecfg = legalize_smcntrpmf(mcyclecfg, value);
    Ok(mcyclecfg.bits)
}
and write_CSR ((0x321, value) if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 32)) = {
    mcyclecfg = legalize_smcntrpmf(mcyclecfg, $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(mcyclecfg.bits, 63, 32), value));
    Ok($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(mcyclecfg.bits, $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(xlen, 1), 0))
}
and write_CSR ((0x721, value) if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 32)) = {
    mcyclecfg = legalize_smcntrpmf(mcyclecfg, $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(value, $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(mcyclecfg.bits, 31, 0)));
    Ok($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(mcyclecfg.bits, 63, 32))
}
and write_CSR ((0x322, value) if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64)) = {
    minstretcfg = legalize_smcntrpmf(minstretcfg, value);
    Ok($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(minstretcfg.bits, $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(xlen, 1), 0))
}
and write_CSR ((0x322, value) if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 32)) = {
    minstretcfg = legalize_smcntrpmf(minstretcfg, $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(minstretcfg.bits, 63, 32), value));
    Ok($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(minstretcfg.bits, $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(xlen, 1), 0))
}
and write_CSR ((0x722, value) if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 32)) = {
    minstretcfg = legalize_smcntrpmf(minstretcfg, $[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(value, $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(minstretcfg.bits, 31, 0)));
    Ok($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(minstretcfg.bits, 63, 32))
}
and write_CSR (0x180, value) = {
    satp = legalize_satp(cur_architecture(), satp, value);
    Ok(satp)
}
and write_CSR (0x015, value) = Ok(write_seed_csr())
and write_CSR (((0b0011001 @ index : bits(5)), value) if $[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(unsigned(index), 3)) = {
    let index = hpmidx_from_bits(index);
    write_mhpmevent(index, value);
    Ok(read_mhpmevent(index))
}
and write_CSR (((0b1011000 @ index : bits(5)), value) if $[overloaded { "name" = ">=", "is_infix" = true }] gteq_int(unsigned(index), 3)) = {
    let index = hpmidx_from_bits(index);
    write_mhpmcounter(index, value);
    Ok(read_mhpmcounter(index))
}
and write_CSR (((0b1011100 @ index : bits(5)), value) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 32), gteq_int(unsigned(index), 3) : bool)) = {
    let index = hpmidx_from_bits(index);
    write_mhpmcounterh(index, value);
    Ok(read_mhpmcounterh(index))
}
and write_CSR (((0b0111001 @ index : bits(5)), value) if $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 32), gteq_int(unsigned(index), 3) : bool)) = {
    let index = hpmidx_from_bits(index);
    write_mhpmeventh(index, value);
    Ok(read_mhpmeventh(index))
}
and write_CSR (0x14D, value) = {
    stimecmp[$[overloaded { "name" = "-", "is_infix" = true }] sub_atom(xlen, 1) .. 0] = value;
    Ok($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(stimecmp, $[overloaded { "name" = "-", "is_infix" = true }] sub_atom(xlen, 1), 0))
}
and write_CSR ((0x15D, value) if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 32)) = {
    stimecmp[63 .. 32] = value;
    Ok($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(stimecmp, 63, 32))
}
and write_CSR (0xB00, value) = {
    mcycle[$[overloaded { "name" = "-", "is_infix" = true }] sub_atom(xlen, 1) .. 0] = value;
    Ok(value)
}
and write_CSR (0xB02, value) = {
    minstret[$[overloaded { "name" = "-", "is_infix" = true }] sub_atom(xlen, 1) .. 0] = value;
    minstret_increment = false;
    Ok(value)
}
and write_CSR ((0xB80, value) if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 32)) = {
    mcycle[63 .. 32] = value;
    Ok(value)
}
and write_CSR ((0xB82, value) if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 32)) = {
    minstret[63 .. 32] = value;
    minstret_increment = false;
    Ok(value)
}
and write_CSR (csr, _) = {
    internal_error("./postlude/csr_end.sail", 23, $[overloaded { "name" = "^", "is_infix" = true }] concat_str("Write to CSR that does not exist: ", bits_str(csr)))
}

union HartState = {HART_ACTIVE : unit, HART_WAITING : (WaitReason, instbits)}

val hart_is_active : HartState -> bool

$[complete]
function hart_is_active s : HartState = $[complete] match s {
  HART_ACTIVE(()) => true,
  HART_WAITING(_) => false
}

val hart_is_waiting : HartState -> bool

$[complete]
function hart_is_waiting s : HartState = $[complete] match s {
  HART_ACTIVE(()) => false,
  HART_WAITING(_) => true
}

union FetchResult = {
  F_Ext_Error : ext_fetch_addr_error,
  F_Base : word,
  F_RVC : half,
  F_Error : (ExceptionType, xlenbits)
}

val ext_fetch_hook : FetchResult -> FetchResult

$[complete]
function ext_fetch_hook f : FetchResult = f

val ext_pre_step_hook : unit -> unit

$[complete]
function ext_pre_step_hook () = ()

val ext_post_step_hook : unit -> unit

$[complete]
function ext_post_step_hook () = ()

val ext_reset : unit -> unit

$[complete]
function ext_reset () = ()

val ext_decode_compressed : bitvector(16) -> instruction

$[complete]
function ext_decode_compressed bv = encdec_compressed_backwards(bv)

val ext_decode : bitvector(32) -> instruction

$[complete]
function ext_decode bv = encdec_backwards(bv)

val rvfi_fetch : unit -> FetchResult

$[complete]
function rvfi_fetch () = {
    rvfi_inst_data.bits[63 .. 0] = minstret;
    rvfi_pc_data.bits[63 .. 0] = zero_extend(64, get_arch_pc());
    rvfi_inst_data.bits[159 .. 152] = zero_extend(8, privLevel_to_bits(cur_privilege));
    rvfi_inst_data.bits[167 .. 160] = zero_extend(8, _get_Misa_MXL(misa));
    $[complete] match ext_fetch_check_pc(PC, PC) {
      Some(e) => return(F_Ext_Error(e)),
      None(()) => ()
    };
    if $[overloaded { "name" = "|", "is_infix" = true }] or_bool($[overloaded { "name" = "!=", "is_infix" = true }] neq_anything($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(PC, 0), bitzero), $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "!=", "is_infix" = true }] neq_anything($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(PC, 1), bitzero), not(currentlyEnabled(Ext_Zca)))) then return(F_Error((E_Fetch_Addr_Align(), PC)));
    $[complete] match translateAddr(Virtaddr(PC), InstructionFetch()) {
      Err((e, _)) => return(F_Error((e, PC))),
      Ok((_, _)) => ()
    };
    let i = _get_RVFI_DII_Instruction_Packet_rvfi_insn(rvfi_instruction);
    rvfi_inst_data.bits[127 .. 64] = zero_extend(64, i);
    if $[overloaded { "name" = "!=", "is_infix" = true }] neq_bits($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(i, 1, 0), 0b11) then return(F_RVC($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(i, 15, 0)));
    let PC_hi = $[overloaded { "name" = "+", "is_infix" = true }] add_bits_int(PC, 2);
    $[complete] match ext_fetch_check_pc(PC, PC_hi) {
      Some(e) => return(F_Ext_Error(e)),
      None(()) => ()
    };
    $[complete] match translateAddr(Virtaddr(PC_hi), InstructionFetch()) {
      Err((e, _)) => F_Error((e, PC)),
      Ok((_, _)) => F_Base(i)
    }
}

val isRVC : bitvector(16) -> bool

$[complete]
function isRVC h : half = not($[overloaded { "name" = "==", "is_infix" = true }] eq_bits($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(h, 1, 0), 0b11))

val fetch : unit -> FetchResult

$[complete]
function fetch () = {
    if get_config_rvfi() then return(rvfi_fetch());
    $[complete] match ext_fetch_check_pc(PC, PC) {
      Some(e) => return(F_Ext_Error(e)),
      None(()) => ()
    };
    if $[overloaded { "name" = "|", "is_infix" = true }] or_bool($[overloaded { "name" = "!=", "is_infix" = true }] neq_anything($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(PC, 0), bitzero), $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "!=", "is_infix" = true }] neq_anything($[overloaded { "name" = "vector_access", "is_infix" = false }] bitvector_access(PC, 1), bitzero), not(currentlyEnabled(Ext_Zca)))) then return(F_Error((E_Fetch_Addr_Align(), PC)));
    $[complete] match translateAddr(Virtaddr(PC), InstructionFetch()) {
      Err((e, _)) => F_Error((e, PC)),
      Ok((ppclo, _)) => {
          $[complete] match mem_read(InstructionFetch(), ppclo, 2, false, false, false) {
            Err(e) => F_Error((e, PC)),
            Ok(ilo) => if isRVC(ilo) then F_RVC(ilo) else {
                let PC_hi = $[overloaded { "name" = "+", "is_infix" = true }] add_bits_int(PC, 2);
                $[complete] match ext_fetch_check_pc(PC, PC_hi) {
                  Some(e) => return(F_Ext_Error(e)),
                  None(()) => ()
                };
                $[complete] match translateAddr(Virtaddr(PC_hi), InstructionFetch()) {
                  Err((e, _)) => F_Error((e, PC_hi)),
                  Ok((ppchi, _)) => $[complete] match mem_read(InstructionFetch(), ppchi, 2, false, false, false) {
                    Err(e) => F_Error((e, PC_hi)),
                    Ok(ihi) => F_Base($[overloaded { "name" = "append", "is_infix" = false }] bitvector_concat(ihi, ilo))
                  }
                }
            }
          }
      }
    }
}

register hart_state : HartState = HART_ACTIVE()

union Step = {
  Step_Pending_Interrupt : (InterruptType, Privilege),
  Step_Ext_Fetch_Failure : ext_fetch_addr_error,
  Step_Fetch_Failure : (virtaddr, ExceptionType),
  Step_Execute : (ExecutionResult, instbits),
  Step_Waiting : WaitReason
}

val run_hart_waiting : (int, WaitReason, bitvector(32), bool) -> Step

$[complete]
function run_hart_waiting (step_no : int, wr : WaitReason, instbits : instbits, exit_wait : bool) = {
    if shouldWakeForInterrupt() then {
        if get_config_print_instr() then print_log($[overloaded { "name" = "^", "is_infix" = true }] concat_str("interrupt exit from ", $[overloaded { "name" = "^", "is_infix" = true }] concat_str(wait_name_forwards(wr), $[overloaded { "name" = "^", "is_infix" = true }] concat_str(" state at PC ", bits_str(PC)))));
        hart_state = HART_ACTIVE();
        return(Step_Execute((Retire_Success(), instbits)))
    };
    $[complete] match (wr, valid_reservation(), exit_wait) {
      (WAIT_WRS_STO, false, _) => {
          if get_config_print_instr() then print_log($[overloaded { "name" = "^", "is_infix" = true }] concat_str("reservation invalid exit from ", $[overloaded { "name" = "^", "is_infix" = true }] concat_str(wait_name_forwards(WAIT_WRS_STO), $[overloaded { "name" = "^", "is_infix" = true }] concat_str(" state at PC ", bits_str(PC)))));
          hart_state = HART_ACTIVE();
          Step_Execute((Retire_Success(), instbits))
      },
      (WAIT_WRS_NTO, false, _) => {
          if get_config_print_instr() then print_log($[overloaded { "name" = "^", "is_infix" = true }] concat_str("reservation invalid exit from ", $[overloaded { "name" = "^", "is_infix" = true }] concat_str(wait_name_forwards(WAIT_WRS_NTO), $[overloaded { "name" = "^", "is_infix" = true }] concat_str(" state at PC ", bits_str(PC)))));
          hart_state = HART_ACTIVE();
          Step_Execute((Retire_Success(), instbits))
      },
      (WAIT_WFI, _, true) => {
          if get_config_print_instr() then print_log($[overloaded { "name" = "^", "is_infix" = true }] concat_str("forced exit from ", $[overloaded { "name" = "^", "is_infix" = true }] concat_str(wait_name_forwards(WAIT_WFI), $[overloaded { "name" = "^", "is_infix" = true }] concat_str(" state at PC ", bits_str(PC)))));
          hart_state = HART_ACTIVE();
          if $[overloaded { "name" = "|", "is_infix" = true }] or_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_anything(cur_privilege, Machine), $[overloaded { "name" = "==", "is_infix" = true }] eq_bits(_get_Mstatus_TW(mstatus), 0b0)) then
            Step_Execute((Retire_Success(), instbits))
          else
            Step_Execute((Illegal_Instruction(), instbits))
      },
      (WAIT_WRS_STO, _, true) => {
          if get_config_print_instr() then print_log($[overloaded { "name" = "^", "is_infix" = true }] concat_str("timed-out exit from ", $[overloaded { "name" = "^", "is_infix" = true }] concat_str(wait_name_forwards(WAIT_WRS_STO), $[overloaded { "name" = "^", "is_infix" = true }] concat_str(" state at PC ", bits_str(PC)))));
          hart_state = HART_ACTIVE();
          Step_Execute((Retire_Success(), instbits))
      },
      (WAIT_WRS_NTO, _, true) => {
          if get_config_print_instr() then print_log($[overloaded { "name" = "^", "is_infix" = true }] concat_str("timed-out exit from ", $[overloaded { "name" = "^", "is_infix" = true }] concat_str(wait_name_forwards(WAIT_WRS_NTO), $[overloaded { "name" = "^", "is_infix" = true }] concat_str(" state at PC ", bits_str(PC)))));
          hart_state = HART_ACTIVE();
          if $[overloaded { "name" = "|", "is_infix" = true }] or_bool($[overloaded { "name" = "==", "is_infix" = true }] eq_anything(cur_privilege, Machine), $[overloaded { "name" = "==", "is_infix" = true }] eq_bits(_get_Mstatus_TW(mstatus), 0b0)) then
            Step_Execute((Retire_Success(), instbits))
          else
            Step_Execute((Illegal_Instruction(), instbits))
      },
      (_, _, false) => {
          if get_config_print_instr() then print_log($[overloaded { "name" = "^", "is_infix" = true }] concat_str("remaining in ", $[overloaded { "name" = "^", "is_infix" = true }] concat_str(wait_name_forwards(wr), $[overloaded { "name" = "^", "is_infix" = true }] concat_str(" state at PC ", bits_str(PC)))));
          Step_Waiting(wr)
      }
    }
}

val run_hart_active : nat -> Step

$[complete]
function run_hart_active step_no : nat = {
    $[complete] match dispatchInterrupt(cur_privilege) {
      Some((intr, priv)) => Step_Pending_Interrupt((intr, priv)),
      None(()) => $[complete] match ext_fetch_hook(fetch()) {
        F_Ext_Error(e) => Step_Ext_Fetch_Failure(e),
        F_Error((e, addr)) => Step_Fetch_Failure((Virtaddr(addr), e)),
        F_RVC(h) => {
            sail_instr_announce(h);
            let instbits : instbits = zero_extend(32, h);
            let instruction = ext_decode_compressed(h);
            if get_config_print_instr() then {
                print_log_instr($[overloaded { "name" = "^", "is_infix" = true }] concat_str("[", $[overloaded { "name" = "^", "is_infix" = true }] concat_str(dec_str(step_no), $[overloaded { "name" = "^", "is_infix" = true }] concat_str("] [", $[overloaded { "name" = "^", "is_infix" = true }] concat_str($[overloaded { "name" = "to_str", "is_infix" = false }] privLevel_to_str(cur_privilege), $[overloaded { "name" = "^", "is_infix" = true }] concat_str("]: ", $[overloaded { "name" = "^", "is_infix" = true }] concat_str(bits_str(PC), $[overloaded { "name" = "^", "is_infix" = true }] concat_str(" (", $[overloaded { "name" = "^", "is_infix" = true }] concat_str(bits_str(h), $[overloaded { "name" = "^", "is_infix" = true }] concat_str(") ", $[overloaded { "name" = "to_str", "is_infix" = false }] print_insn(instruction)))))))))), zero_extend(64, PC))
            };
            if currentlyEnabled(Ext_Zca) then {
                nextPC = $[overloaded { "name" = "+", "is_infix" = true }] add_bits_int(PC, 2);
                let r = execute(instruction);
                Step_Execute((r, instbits))
            } else {
                Step_Execute((Illegal_Instruction(), instbits))
            }
        },
        F_Base(w) => {
            sail_instr_announce(w);
            let instbits : instbits = zero_extend(32, w);
            let instruction = ext_decode(w);
            if get_config_print_instr() then {
                print_log_instr($[overloaded { "name" = "^", "is_infix" = true }] concat_str("[", $[overloaded { "name" = "^", "is_infix" = true }] concat_str(dec_str(step_no), $[overloaded { "name" = "^", "is_infix" = true }] concat_str("] [", $[overloaded { "name" = "^", "is_infix" = true }] concat_str($[overloaded { "name" = "to_str", "is_infix" = false }] privLevel_to_str(cur_privilege), $[overloaded { "name" = "^", "is_infix" = true }] concat_str("]: ", $[overloaded { "name" = "^", "is_infix" = true }] concat_str(bits_str(PC), $[overloaded { "name" = "^", "is_infix" = true }] concat_str(" (", $[overloaded { "name" = "^", "is_infix" = true }] concat_str(bits_str(w), $[overloaded { "name" = "^", "is_infix" = true }] concat_str(") ", $[overloaded { "name" = "to_str", "is_infix" = false }] print_insn(instruction)))))))))), zero_extend(64, PC))
            };
            nextPC = $[overloaded { "name" = "+", "is_infix" = true }] add_bits_int(PC, 4);
            let r = execute(instruction);
            Step_Execute((r, instbits))
        }
      }
    }
}

val wait_is_nop : WaitReason -> bool

$[complete]
function wait_is_nop wr : WaitReason = $[complete] match wr {
  WAIT_WFI => config platform.wfi_is_nop,
  WAIT_WRS_STO => config extensions.Zawrs.sto.is_nop,
  WAIT_WRS_NTO => config extensions.Zawrs.nto.is_nop
}

val try_step : (nat, bool) -> bool

$[complete]
function try_step (step_no : nat, exit_wait : bool) = {
    ext_pre_step_hook();
    minstret_increment = should_inc_minstret(cur_privilege);
    let step_val : Step = $[complete] match hart_state {
      HART_WAITING((wr, instbits)) => run_hart_waiting(step_no, wr, instbits, exit_wait),
      HART_ACTIVE(()) => run_hart_active(step_no)
    };
    $[complete] match step_val {
      Step_Pending_Interrupt((intr, priv)) => {
          if get_config_print_instr() then print_bits("Handling interrupt: ", interruptType_to_bits(intr));
          handle_interrupt(intr, priv)
      },
      Step_Ext_Fetch_Failure(e) => ext_handle_fetch_check_error(e),
      Step_Fetch_Failure((vaddr, e)) => handle_exception($[overloaded { "name" = "bits_of", "is_infix" = false }] bits_of_virtaddr(vaddr), e),
      Step_Waiting(_) => assert(hart_is_waiting(hart_state), "cannot be Waiting in a non-Wait state"),
      Step_Execute((Retire_Success(()), _)) => assert(hart_is_active(hart_state), "./postlude/step.sail:188.74-188.75"),
      Step_Execute((Trap((priv, ctl, pc)), _)) => set_next_pc(exception_handler(priv, ctl, pc)),
      Step_Execute((Memory_Exception((vaddr, e)), _)) => handle_exception($[overloaded { "name" = "bits_of", "is_infix" = false }] bits_of_virtaddr(vaddr), e),
      Step_Execute((Illegal_Instruction(()), instbits)) => handle_exception(zero_extend(sizeof(xlen), instbits), E_Illegal_Instr()),
      Step_Execute((Enter_Wait(wr), instbits)) => {
          if wait_is_nop(wr) then {
              assert(hart_is_active(hart_state), "./postlude/step.sail:196.41-196.42")
          } else {
              if get_config_print_instr() then print_log($[overloaded { "name" = "^", "is_infix" = true }] concat_str("entering ", $[overloaded { "name" = "^", "is_infix" = true }] concat_str(wait_name_forwards(wr), $[overloaded { "name" = "^", "is_infix" = true }] concat_str(" state at PC ", bits_str(PC)))));
              hart_state = HART_WAITING((wr, instbits))
          }
      },
      Step_Execute((Ext_CSR_Check_Failure(()), _)) => ext_check_CSR_fail(),
      Step_Execute((Ext_ControlAddr_Check_Failure(e), _)) => ext_handle_control_check_error(e),
      Step_Execute((Ext_DataAddr_Check_Failure(e), _)) => ext_handle_data_check_error(e),
      Step_Execute((Ext_XRET_Priv_Failure(()), _)) => ext_fail_xret_priv()
    };
    $[complete] match hart_state {
      HART_WAITING(_) => true,
      HART_ACTIVE(()) => {
          tick_pc();
          let retired : bool = $[complete] match step_val {
            Step_Execute((Retire_Success(()), _)) => true,
            Step_Execute((Enter_Wait(wr), _)) if wait_is_nop(wr) => true,
            _ => false
          };
          if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(retired, minstret_increment) then minstret = $[overloaded { "name" = "+", "is_infix" = true }] add_bits_int(minstret, 1);
          if get_config_rvfi() then {
              rvfi_pc_data.bits[127 .. 64] = zero_extend(64, get_arch_pc())
          };
          ext_post_step_hook();
          false
      }
    }
}

val loop : unit -> unit

$[complete]
function loop () : unit = {
    var i : nat = 0;
    var step_no : nat = 0;
    while not(htif_done) do {
        let stepped = try_step(step_no, true);
        if stepped then {
            step_no = $[overloaded { "name" = "+", "is_infix" = true }] add_atom(step_no, 1);
            if get_config_print_instr() then {
                print_step()
            };
            sail_end_cycle()
        };
        if htif_done then {
            let exit_val = unsigned(htif_exit_code);
            if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(exit_val, 0) then
              print("SUCCESS")
            else
              print_int("FAILURE: ", exit_val)
        } else {
            i = $[overloaded { "name" = "+", "is_infix" = true }] add_atom(i, 1);
            if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(i, plat_insns_per_tick) then {
                tick_clock();
                i = 0
            };
            ()
        }
    }
}

val check_privs : unit -> bool

$[complete]
function check_privs () = {
    if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(hartSupports(Ext_S), not(hartSupports(Ext_U))) then {
        print_endline("User mode (U) should be enabled if supervisor mode (S) is enabled.");
        return(false)
    };
    true
}

val check_mmu_config : unit -> bool

$[complete]
function check_mmu_config () = {
    var valid : bool = true;
    if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64) then {
        if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(not(hartSupports(Ext_S)), $[overloaded { "name" = "|", "is_infix" = true }] or_bool(hartSupports(Ext_Sv57), $[overloaded { "name" = "|", "is_infix" = true }] or_bool(hartSupports(Ext_Sv48), hartSupports(Ext_Sv39)))) then {
            valid = false;
            print_endline("Supervisor mode (S) disabled but one of (Sv57, Sv48, Sv39) is enabled: cannot support address translation without supervisor mode.")
        };
        if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(hartSupports(Ext_Sv57), not(hartSupports(Ext_Sv48))) then {
            valid = false;
            print_endline("Sv57 is enabled but Sv48 is disabled: supporting Sv57 requires supporting Sv48.")
        };
        if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(hartSupports(Ext_Sv48), not(hartSupports(Ext_Sv39))) then {
            valid = false;
            print_endline("Sv48 is enabled but Sv39 is disabled: supporting Sv48 requires supporting Sv39.")
        };
        if hartSupports(Ext_Sv32) then {
            valid = false;
            print_endline("Sv32 is enabled: Sv32 is not supported on RV64.")
        };
        ()
    } else {
        assert($[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 32), "./postlude/validate_config.sail:43.21-43.22");
        if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(not(hartSupports(Ext_S)), hartSupports(Ext_Sv32)) then {
            valid = false;
            print_endline("Supervisor mode (S) is disabled but Sv32 is enabled: cannot support address translation without supervisor mode.")
        };
        if $[overloaded { "name" = "|", "is_infix" = true }] or_bool(hartSupports(Ext_Sv39), $[overloaded { "name" = "|", "is_infix" = true }] or_bool(hartSupports(Ext_Sv48), hartSupports(Ext_Sv57))) then {
            valid = false;
            print_endline("One or more of Sv39/Sv48/Sv57 is enabled: these are not supported on RV32.")
        };
        ()
    };
    if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(hartSupports(Ext_Svrsw60t59b), not(hartSupports(Ext_Sv39))) then {
        valid = false;
        print_endline("Svrsw60t59b is enabled but Sv39 is disabled: supporting Svrsw60t59b requires supporting Sv39.")
    };
    valid
}

val check_vlen_elen : unit -> bool

$[complete]
function check_vlen_elen () = {
    if $[overloaded { "name" = "<", "is_infix" = true }] lt_int(vlen_exp : nat, elen_exp : nat) then {
        print_endline($[overloaded { "name" = "^", "is_infix" = true }] concat_str("VLEN (set to 2^", $[overloaded { "name" = "^", "is_infix" = true }] concat_str(dec_str(vlen_exp), $[overloaded { "name" = "^", "is_infix" = true }] concat_str(") cannot be less than ELEN (set to 2^", $[overloaded { "name" = "^", "is_infix" = true }] concat_str(dec_str(elen_exp), ").")))));
        return(false)
    };
    if $[overloaded { "name" = "|", "is_infix" = true }] or_bool($[overloaded { "name" = "<", "is_infix" = true }] lt_int(vlen_exp : nat, 3), gt_int(vlen_exp : nat, 16) : bool) then {
        print_endline($[overloaded { "name" = "^", "is_infix" = true }] concat_str("VLEN set to 2^", $[overloaded { "name" = "^", "is_infix" = true }] concat_str(dec_str(vlen_exp), " but must be within [2^3, 2^16].")));
        return(false)
    };
    if $[overloaded { "name" = "|", "is_infix" = true }] or_bool($[overloaded { "name" = "<", "is_infix" = true }] lt_int(elen_exp : nat, 3), gt_int(elen_exp : nat, 16) : bool) then {
        print_endline($[overloaded { "name" = "^", "is_infix" = true }] concat_str("ELEN set to 2^", $[overloaded { "name" = "^", "is_infix" = true }] concat_str(dec_str(elen_exp), " but must be within [2^3, 2^16].")));
        return(false)
    };
    true
}

val has_overlap : (nat, nat, nat, nat) -> bool

$[complete]
function has_overlap (a_lo : nat, a_hi : nat, b_lo : nat, b_hi : nat) = {
    not($[overloaded { "name" = "|", "is_infix" = true }] or_bool($[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "<", "is_infix" = true }] lt_int(a_lo, b_lo), $[overloaded { "name" = "<", "is_infix" = true }] lt_int(a_hi, b_lo)), $[overloaded { "name" = "&", "is_infix" = true }] and_bool($[overloaded { "name" = "<", "is_infix" = true }] lt_int(b_lo, a_lo), $[overloaded { "name" = "<", "is_infix" = true }] lt_int(b_hi, a_lo))))
}

val check_mem_layout : unit -> bool

$[complete]
function check_mem_layout () = {
    var valid : bool = true;
    let ram_lo = unsigned(plat_ram_base);
    let ram_hi = $[overloaded { "name" = "+", "is_infix" = true }] add_atom(unsigned(plat_ram_base), unsigned(plat_ram_size));
    let rom_lo = unsigned(plat_rom_base);
    let rom_hi = $[overloaded { "name" = "+", "is_infix" = true }] add_atom(unsigned(plat_rom_base), unsigned(plat_rom_size));
    let clint_lo = unsigned(plat_clint_base);
    let clint_hi = $[overloaded { "name" = "+", "is_infix" = true }] add_atom(unsigned(plat_clint_base), unsigned(plat_clint_size));
    if has_overlap(rom_lo, rom_hi, ram_lo, ram_hi) then {
        valid = false;
        print_endline("The RAM and ROM regions overlap.")
    };
    if has_overlap(clint_lo, clint_hi, rom_lo, rom_hi) then {
        valid = false;
        print_endline("The Clint and ROM regions overlap.")
    };
    if has_overlap(clint_lo, clint_hi, ram_lo, ram_hi) then {
        valid = false;
        print_endline("The Clint and RAM regions overlap.")
    };
    valid
}

val check_pmp : unit -> bool

$[complete]
function check_pmp () = {
    var valid : bool = true;
    if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(config memory.pmp.na4_supported : bool, $[overloaded { "name" = "!=", "is_infix" = true }] neq_int(sys_pmp_grain, 0)) then {
        valid = false;
        print_endline("NA4 is not supported if the PMP grain G is non-zero.")
    };
    valid
}

val check_bfloat16 : unit -> bool

$[complete]
function check_bfloat16 () = {
    var valid : bool = true;
    if $[overloaded { "name" = "&", "is_infix" = true }] and_bool(hartSupports(Ext_Zfbfmin), not(hartSupports(Ext_F))) then {
        valid = false;
        print_endline("Zfbfmin extension requires F extension")
    };
    valid
}

val config_is_valid : unit -> bool

$[complete]
function config_is_valid () = {
    $[overloaded { "name" = "&", "is_infix" = true }] and_bool(check_privs(), $[overloaded { "name" = "&", "is_infix" = true }] and_bool(check_mmu_config(), $[overloaded { "name" = "&", "is_infix" = true }] and_bool(check_mem_layout(), $[overloaded { "name" = "&", "is_infix" = true }] and_bool(check_vlen_elen(), $[overloaded { "name" = "&", "is_infix" = true }] and_bool(check_pmp(), check_bfloat16())))))
}

val mmu_type : unit -> string

$[complete]
function mmu_type () = {
    if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 32) then {
        if hartSupports(Ext_Sv32) then "sv32" else "none"
    } else {
        assert($[overloaded { "name" = "==", "is_infix" = true }] eq_int(xlen, 64), "./postlude/device_tree.sail:14.21-14.22");
        if hartSupports(Ext_Sv57) then "sv57" else
          if hartSupports(Ext_Sv48) then "sv48" else
            if hartSupports(Ext_Sv39) then "sv39" else "none"
    }
}

val generate_isa_base : unit -> string

$[complete]
function generate_isa_base () = {
    $[overloaded { "name" = "^", "is_infix" = true }] concat_str("rv", $[overloaded { "name" = "^", "is_infix" = true }] concat_str(dec_str(xlen), "i"))
}

$[undefined_gen "skip"]
$[no_enum_number_conversions]
enum ISA_Format = {Canonical_Lowercase, DeviceTree_ISA_Extensions}

val undefined_ISA_Format : unit -> ISA_Format

$[complete]
function undefined_ISA_Format () = internal_pick([|Canonical_Lowercase, DeviceTree_ISA_Extensions|])

val ISA_Format_of_num : forall ('e : Int), (0 <= 'e & 'e <= 1).
  int('e) -> ISA_Format

$[complete]
function ISA_Format_of_num arg# = $[complete] match arg# {
  0 => Canonical_Lowercase,
  _ => DeviceTree_ISA_Extensions
}

val num_of_ISA_Format : ISA_Format -> {('e : Int), (0 <= 'e & 'e <= 1). int('e)}

$[complete]
function num_of_ISA_Format arg# = $[complete] match arg# {
  Canonical_Lowercase => 0,
  DeviceTree_ISA_Extensions => 1
}

val ext_wrap : (extension, ISA_Format) -> string

$[complete]
function ext_wrap (ext : extension, fmt : ISA_Format) = {
    if not(hartSupports(ext)) then return("");
    let s = extensionName_forwards(ext);
    $[complete] match fmt {
      Canonical_Lowercase => if $[overloaded { "name" = "==", "is_infix" = true }] eq_int(string_length(s), 1) then
        s
      else
        $[overloaded { "name" = "^", "is_infix" = true }] concat_str("_", s),
      DeviceTree_ISA_Extensions => $[overloaded { "name" = "^", "is_infix" = true }] concat_str(", \"", $[overloaded { "name" = "^", "is_infix" = true }] concat_str(s, "\""))
    }
}

val generate_isa_string : ISA_Format -> string

$[complete]
function generate_isa_string fmt : ISA_Format = {
    var isa_string : string = $[complete] match fmt {
      Canonical_Lowercase => $[overloaded { "name" = "^", "is_infix" = true }] concat_str("rv", $[overloaded { "name" = "^", "is_infix" = true }] concat_str(dec_str(xlen), "i")),
      DeviceTree_ISA_Extensions => "\"i\""
    };
    foreach (i
    from sub_atom($[overloaded { "name" = "length", "is_infix" = false }] vector_length(extensions_ordered_for_isa_string), 1)
    to 0
    by 1
    in dec) isa_string = $[overloaded { "name" = "^", "is_infix" = true }] concat_str(isa_string, ext_wrap($[overloaded { "name" = "vector_access", "is_infix" = false }] plain_vector_access(extensions_ordered_for_isa_string, i), fmt));
    isa_string
}

val generate_dts : unit -> string

$[complete]
function generate_dts () = {
    let clock_freq : nat = config platform.clock_frequency;
    let ram_base_hi = unsigned($[overloaded { "name" = ">>", "is_infix" = true }] shiftr(plat_ram_base, 32));
    let ram_base_lo = unsigned($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(plat_ram_base, 31, 0));
    let ram_size_hi = unsigned($[overloaded { "name" = ">>", "is_infix" = true }] shiftr(plat_ram_size, 32));
    let ram_size_lo = unsigned($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(plat_ram_size, 31, 0));
    let clint_base_hi = unsigned($[overloaded { "name" = ">>", "is_infix" = true }] shiftr(plat_clint_base, 32));
    let clint_base_lo = unsigned($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(plat_clint_base, 31, 0));
    let clint_size_hi = unsigned($[overloaded { "name" = ">>", "is_infix" = true }] shiftr(plat_clint_size, 32));
    let clint_size_lo = unsigned($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(plat_clint_size, 31, 0));
    $[overloaded { "name" = "^", "is_infix" = true }] concat_str("/dts-v1/;\n", $[overloaded { "name" = "^", "is_infix" = true }] concat_str("\n", $[overloaded { "name" = "^", "is_infix" = true }] concat_str("/ {\n", $[overloaded { "name" = "^", "is_infix" = true }] concat_str("  #address-cells = <2>;\n", $[overloaded { "name" = "^", "is_infix" = true }] concat_str("  #size-cells = <2>;\n", $[overloaded { "name" = "^", "is_infix" = true }] concat_str("  compatible = \"ucbbar,spike-bare-dev\";\n", $[overloaded { "name" = "^", "is_infix" = true }] concat_str("  model = \"ucbbar,spike-bare\";\n", $[overloaded { "name" = "^", "is_infix" = true }] concat_str("  chosen {\n", $[overloaded { "name" = "^", "is_infix" = true }] concat_str("    bootargs = \"console=hvc0 earlycon=sbi\";\n", $[overloaded { "name" = "^", "is_infix" = true }] concat_str("  };\n", $[overloaded { "name" = "^", "is_infix" = true }] concat_str("  cpus {\n", $[overloaded { "name" = "^", "is_infix" = true }] concat_str("    #address-cells = <1>;\n", $[overloaded { "name" = "^", "is_infix" = true }] concat_str("    #size-cells = <0>;\n", $[overloaded { "name" = "^", "is_infix" = true }] concat_str("    timebase-frequency = <", $[overloaded { "name" = "^", "is_infix" = true }] concat_str(dec_str($[overloaded { "name" = "/", "is_infix" = true }] quot_positive_round_zero(clock_freq, plat_insns_per_tick)), $[overloaded { "name" = "^", "is_infix" = true }] concat_str(">;\n", $[overloaded { "name" = "^", "is_infix" = true }] concat_str("    CPU0: cpu@0 {\n", $[overloaded { "name" = "^", "is_infix" = true }] concat_str("      device_type = \"cpu\";\n", $[overloaded { "name" = "^", "is_infix" = true }] concat_str("      reg = <0>;\n", $[overloaded { "name" = "^", "is_infix" = true }] concat_str("      status = \"okay\";\n", $[overloaded { "name" = "^", "is_infix" = true }] concat_str("      compatible = \"riscv\";\n", $[overloaded { "name" = "^", "is_infix" = true }] concat_str("      riscv,isa-base = \"", $[overloaded { "name" = "^", "is_infix" = true }] concat_str(generate_isa_base(), $[overloaded { "name" = "^", "is_infix" = true }] concat_str("\";\n", $[overloaded { "name" = "^", "is_infix" = true }] concat_str("      riscv,isa = \"", $[overloaded { "name" = "^", "is_infix" = true }] concat_str(generate_isa_string(Canonical_Lowercase), $[overloaded { "name" = "^", "is_infix" = true }] concat_str("\";\n", $[overloaded { "name" = "^", "is_infix" = true }] concat_str("      riscv,isa-extensions = ", $[overloaded { "name" = "^", "is_infix" = true }] concat_str(generate_isa_string(DeviceTree_ISA_Extensions), $[overloaded { "name" = "^", "is_infix" = true }] concat_str(";\n", $[overloaded { "name" = "^", "is_infix" = true }] concat_str("      mmu-type = \"riscv,", $[overloaded { "name" = "^", "is_infix" = true }] concat_str(mmu_type(), $[overloaded { "name" = "^", "is_infix" = true }] concat_str("\";\n", $[overloaded { "name" = "^", "is_infix" = true }] concat_str("      clock-frequency = <", $[overloaded { "name" = "^", "is_infix" = true }] concat_str(dec_str(clock_freq), $[overloaded { "name" = "^", "is_infix" = true }] concat_str(">;\n", $[overloaded { "name" = "^", "is_infix" = true }] concat_str("      CPU0_intc: interrupt-controller {\n", $[overloaded { "name" = "^", "is_infix" = true }] concat_str("        #address-cells = <2>;\n", $[overloaded { "name" = "^", "is_infix" = true }] concat_str("        #interrupt-cells = <1>;\n", $[overloaded { "name" = "^", "is_infix" = true }] concat_str("        interrupt-controller;\n", $[overloaded { "name" = "^", "is_infix" = true }] concat_str("        compatible = \"riscv,cpu-intc\";\n", $[overloaded { "name" = "^", "is_infix" = true }] concat_str("      };\n", $[overloaded { "name" = "^", "is_infix" = true }] concat_str("    };\n", $[overloaded { "name" = "^", "is_infix" = true }] concat_str("  };\n", $[overloaded { "name" = "^", "is_infix" = true }] concat_str("  memory@", $[overloaded { "name" = "^", "is_infix" = true }] concat_str(string_drop(hex_str(unsigned(plat_ram_base)), 2), $[overloaded { "name" = "^", "is_infix" = true }] concat_str(" {\n", $[overloaded { "name" = "^", "is_infix" = true }] concat_str("    device_type = \"memory\";\n", $[overloaded { "name" = "^", "is_infix" = true }] concat_str("    reg = <", $[overloaded { "name" = "^", "is_infix" = true }] concat_str(hex_str(ram_base_hi), $[overloaded { "name" = "^", "is_infix" = true }] concat_str(" ", $[overloaded { "name" = "^", "is_infix" = true }] concat_str(hex_str(ram_base_lo), $[overloaded { "name" = "^", "is_infix" = true }] concat_str(" ", $[overloaded { "name" = "^", "is_infix" = true }] concat_str(hex_str(ram_size_hi), $[overloaded { "name" = "^", "is_infix" = true }] concat_str(" ", $[overloaded { "name" = "^", "is_infix" = true }] concat_str(hex_str(ram_size_lo), $[overloaded { "name" = "^", "is_infix" = true }] concat_str(">;\n", $[overloaded { "name" = "^", "is_infix" = true }] concat_str("  };\n", $[overloaded { "name" = "^", "is_infix" = true }] concat_str("  soc {\n", $[overloaded { "name" = "^", "is_infix" = true }] concat_str("    #address-cells = <2>;\n", $[overloaded { "name" = "^", "is_infix" = true }] concat_str("    #size-cells = <2>;\n", $[overloaded { "name" = "^", "is_infix" = true }] concat_str("    compatible = \"ucbbar,spike-bare-soc\", \"simple-bus\";\n", $[overloaded { "name" = "^", "is_infix" = true }] concat_str("    ranges;\n", $[overloaded { "name" = "^", "is_infix" = true }] concat_str("    clint@", $[overloaded { "name" = "^", "is_infix" = true }] concat_str(string_drop(hex_str(unsigned(plat_clint_base)), 2), $[overloaded { "name" = "^", "is_infix" = true }] concat_str(" {\n", $[overloaded { "name" = "^", "is_infix" = true }] concat_str("      compatible = \"riscv,clint0\";\n", $[overloaded { "name" = "^", "is_infix" = true }] concat_str("      interrupts-extended = <&CPU0_intc 3 &CPU0_intc 7>;\n", $[overloaded { "name" = "^", "is_infix" = true }] concat_str("      reg = <", $[overloaded { "name" = "^", "is_infix" = true }] concat_str(hex_str(clint_base_hi), $[overloaded { "name" = "^", "is_infix" = true }] concat_str(" ", $[overloaded { "name" = "^", "is_infix" = true }] concat_str(hex_str(clint_base_lo), $[overloaded { "name" = "^", "is_infix" = true }] concat_str(" ", $[overloaded { "name" = "^", "is_infix" = true }] concat_str(hex_str(clint_size_hi), $[overloaded { "name" = "^", "is_infix" = true }] concat_str(" ", $[overloaded { "name" = "^", "is_infix" = true }] concat_str(hex_str(clint_size_lo), $[overloaded { "name" = "^", "is_infix" = true }] concat_str(">;\n", $[overloaded { "name" = "^", "is_infix" = true }] concat_str("    };\n", $[overloaded { "name" = "^", "is_infix" = true }] concat_str("  };\n", $[overloaded { "name" = "^", "is_infix" = true }] concat_str("  htif {\n", $[overloaded { "name" = "^", "is_infix" = true }] concat_str("    compatible = \"ucb,htif0\";\n", $[overloaded { "name" = "^", "is_infix" = true }] concat_str("  };\n", "};\n"))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
}

val generate_canonical_isa_string : unit -> string

$[complete]
function generate_canonical_isa_string () = generate_isa_string(Canonical_Lowercase)

val reset : unit -> unit

$[complete]
function reset () = {
    hart_state = HART_ACTIVE();
    reset_sys();
    reset_vmem();
    ext_reset()
}

val init_model : string -> unit

$[complete]
function init_model config_filename : string = {
    assert(config_is_valid(), $[overloaded { "name" = "^", "is_infix" = true }] concat_str(if $[overloaded { "name" = "==", "is_infix" = true }] eq_string(config_filename, "") then
      "Default config"
    else
      $[overloaded { "name" = "^", "is_infix" = true }] concat_str("Config in ", config_filename), " is invalid."));
    init_platform();
    reset()
}

val init_boot_requirements : unit -> unit

$[complete]
function init_boot_requirements () = {
    $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX(Regno(10), mhartid);
    $[overloaded { "name" = "X", "is_infix" = false }] $[setter] wX(Regno(11), to_bits_checked(sizeof(xlen), config platform.rom.base : int))
}

$[test]
val test_mstatus_sxl_uxl_reset_values : unit -> unit

$[complete]
function test_mstatus_sxl_uxl_reset_values () = {
    let mstatush_val : bits(32) = $[complete] match xlen {
      32 => read_CSR(0x310),
      64 => $[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(read_CSR(0x300), 63, 32),
      _ => internal_error("./unit_tests/test_mstatus.sail", 7, "unsupported xlen")
    };
    let expected_xl : bits(2) = $[complete] match xlen {
      32 => 0b00,
      64 => 0b10,
      _ => internal_error("./unit_tests/test_mstatus.sail", 15, "unsupported xlen")
    };
    assert($[overloaded { "name" = "==", "is_infix" = true }] eq_bits($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(mstatush_val, 3, 2), expected_xl), "./unit_tests/test_mstatus.sail:18.44-18.45");
    assert($[overloaded { "name" = "==", "is_infix" = true }] eq_bits($[overloaded { "name" = "vector_subrange", "is_infix" = false }] subrange_bits(mstatush_val, 1, 0), expected_xl), "./unit_tests/test_mstatus.sail:20.44-20.45")
}

val main : unit -> unit

$[complete]
function main () : unit = {
    try {
        init_model("");
        print_bits("PC = ", PC);
        sail_end_cycle();
        loop()
    } catch {
      Error_not_implemented(s) => print_string("Error: Not implemented: ", s),
      Error_internal_error(()) => print("Error: internal error")
    }
}

$[global]
val initialize_registers : unit -> unit

$[complete]
$[global]
function initialize_registers () = {
    rvfi_instruction = undefined;
    rvfi_inst_data = undefined;
    rvfi_pc_data = undefined;
    rvfi_int_data = undefined;
    rvfi_int_data_present = undefined;
    rvfi_mem_data = undefined;
    rvfi_mem_data_present = undefined;
    PC = undefined;
    nextPC = undefined;
    x1 = undefined;
    x2 = undefined;
    x3 = undefined;
    x4 = undefined;
    x5 = undefined;
    x6 = undefined;
    x7 = undefined;
    x8 = undefined;
    x9 = undefined;
    x10 = undefined;
    x11 = undefined;
    x12 = undefined;
    x13 = undefined;
    x14 = undefined;
    x15 = undefined;
    x16 = undefined;
    x17 = undefined;
    x18 = undefined;
    x19 = undefined;
    x20 = undefined;
    x21 = undefined;
    x22 = undefined;
    x23 = undefined;
    x24 = undefined;
    x25 = undefined;
    x26 = undefined;
    x27 = undefined;
    x28 = undefined;
    x29 = undefined;
    x30 = undefined;
    x31 = undefined;
    cur_privilege = undefined;
    cur_inst = undefined;
    mie = undefined;
    mip = undefined;
    medeleg = undefined;
    mideleg = undefined;
    mtvec = undefined;
    mcause = undefined;
    mepc = undefined;
    mtval = undefined;
    mscratch = undefined;
    scounteren = undefined;
    mcounteren = undefined;
    mcountinhibit = undefined;
    mcycle = undefined;
    mtime = undefined;
    minstret = undefined;
    minstret_increment = undefined;
    stvec = undefined;
    sscratch = undefined;
    sepc = undefined;
    scause = undefined;
    stval = undefined;
    tselect = undefined;
    float_result = undefined;
    float_fflags = undefined;
    pmpcfg_n = undefined;
    pmpaddr_n = undefined;
    f0 = undefined;
    f1 = undefined;
    f2 = undefined;
    f3 = undefined;
    f4 = undefined;
    f5 = undefined;
    f6 = undefined;
    f7 = undefined;
    f8 = undefined;
    f9 = undefined;
    f10 = undefined;
    f11 = undefined;
    f12 = undefined;
    f13 = undefined;
    f14 = undefined;
    f15 = undefined;
    f16 = undefined;
    f17 = undefined;
    f18 = undefined;
    f19 = undefined;
    f20 = undefined;
    f21 = undefined;
    f22 = undefined;
    f23 = undefined;
    f24 = undefined;
    f25 = undefined;
    f26 = undefined;
    f27 = undefined;
    f28 = undefined;
    f29 = undefined;
    f30 = undefined;
    f31 = undefined;
    fcsr = undefined;
    vr0 = undefined;
    vr1 = undefined;
    vr2 = undefined;
    vr3 = undefined;
    vr4 = undefined;
    vr5 = undefined;
    vr6 = undefined;
    vr7 = undefined;
    vr8 = undefined;
    vr9 = undefined;
    vr10 = undefined;
    vr11 = undefined;
    vr12 = undefined;
    vr13 = undefined;
    vr14 = undefined;
    vr15 = undefined;
    vr16 = undefined;
    vr17 = undefined;
    vr18 = undefined;
    vr19 = undefined;
    vr20 = undefined;
    vr21 = undefined;
    vr22 = undefined;
    vr23 = undefined;
    vr24 = undefined;
    vr25 = undefined;
    vr26 = undefined;
    vr27 = undefined;
    vr28 = undefined;
    vr29 = undefined;
    vr30 = undefined;
    vr31 = undefined;
    vstart = undefined;
    vl = undefined;
    vtype = undefined;
    vcsr = undefined;
    mcyclecfg = undefined;
    minstretcfg = undefined;
    mtimecmp = undefined;
    stimecmp = undefined;
    htif_tohost = undefined;
    htif_done = undefined;
    htif_exit_code = undefined;
    htif_cmd_write = undefined;
    htif_payload_writes = undefined;
    satp = undefined;
    mhpmevent = undefined;
    mhpmcounter = undefined
}
